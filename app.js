(function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, basedir, module) {
		return module = {
		  path: basedir,
		  exports: {},
		  require: function (path, base) {
	      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
	    }
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var p5_min = createCommonjsModule(function (module, exports) {
	/*! p5.js v1.1.9 July 22, 2020 */

	!function(e){module.exports=e();}(function(){return function o(i,s,l){function p(t,e){if(!s[t]){if(!i[t]){var r="function"==typeof commonjsRequire&&commonjsRequire;if(!e&&r)return r(t,!0);if(u)return u(t,!0);var n=new Error("Cannot find module '"+t+"'");throw n.code="MODULE_NOT_FOUND",n}var a=s[t]={exports:{}};i[t][0].call(a.exports,function(e){return p(i[t][1][e]||e)},a,a.exports,o,i,s,l);}return s[t].exports}for(var u="function"==typeof commonjsRequire&&commonjsRequire,e=0;e<l.length;e++)p(l[e]);return p}({1:[function(e,t,r){t.exports={p5:{alpha:{name:"alpha",params:[{name:"color",description:'<p><a href="#/p5.Color">p5.Color</a> object, color components,\n                                        or CSS color</p>\n',type:"p5.Color|Number[]|String"}],class:"p5",module:"Color"},blue:{name:"blue",params:[{name:"color",description:'<p><a href="#/p5.Color">p5.Color</a> object, color components,\n                                        or CSS color</p>\n',type:"p5.Color|Number[]|String"}],class:"p5",module:"Color"},brightness:{name:"brightness",params:[{name:"color",description:'<p><a href="#/p5.Color">p5.Color</a> object, color components,\n                                        or CSS color</p>\n',type:"p5.Color|Number[]|String"}],class:"p5",module:"Color"},color:{name:"color",class:"p5",module:"Color",overloads:[{params:[{name:"gray",description:"<p>number specifying value between white and black.</p>\n",type:"Number"},{name:"alpha",description:"<p>alpha value relative to current color range\n                                (default is 0-255)</p>\n",type:"Number",optional:!0}]},{params:[{name:"v1",description:"<p>red or hue value relative to\n                                the current color range</p>\n",type:"Number"},{name:"v2",description:"<p>green or saturation value\n                                relative to the current color range</p>\n",type:"Number"},{name:"v3",description:"<p>blue or brightness value\n                                relative to the current color range</p>\n",type:"Number"},{name:"alpha",description:"",type:"Number",optional:!0}]},{params:[{name:"value",description:"<p>a color string</p>\n",type:"String"}]},{params:[{name:"values",description:"<p>an array containing the red,green,blue &\n                                and alpha components of the color</p>\n",type:"Number[]"}]},{params:[{name:"color",description:"",type:"p5.Color"}]}]},green:{name:"green",params:[{name:"color",description:'<p><a href="#/p5.Color">p5.Color</a> object, color components,\n                                        or CSS color</p>\n',type:"p5.Color|Number[]|String"}],class:"p5",module:"Color"},hue:{name:"hue",params:[{name:"color",description:'<p><a href="#/p5.Color">p5.Color</a> object, color components,\n                                        or CSS color</p>\n',type:"p5.Color|Number[]|String"}],class:"p5",module:"Color"},lerpColor:{name:"lerpColor",params:[{name:"c1",description:"<p>interpolate from this color</p>\n",type:"p5.Color"},{name:"c2",description:"<p>interpolate to this color</p>\n",type:"p5.Color"},{name:"amt",description:"<p>number between 0 and 1</p>\n",type:"Number"}],class:"p5",module:"Color"},lightness:{name:"lightness",params:[{name:"color",description:'<p><a href="#/p5.Color">p5.Color</a> object, color components,\n                                        or CSS color</p>\n',type:"p5.Color|Number[]|String"}],class:"p5",module:"Color"},red:{name:"red",params:[{name:"color",description:'<p><a href="#/p5.Color">p5.Color</a> object, color components,\n                                        or CSS color</p>\n',type:"p5.Color|Number[]|String"}],class:"p5",module:"Color"},saturation:{name:"saturation",params:[{name:"color",description:'<p><a href="#/p5.Color">p5.Color</a> object, color components,\n                                        or CSS color</p>\n',type:"p5.Color|Number[]|String"}],class:"p5",module:"Color"},background:{name:"background",class:"p5",module:"Color",overloads:[{params:[{name:"color",description:'<p>any value created by the <a href="#/p5/color">color()</a> function</p>\n',type:"p5.Color"}],chainable:1},{params:[{name:"colorstring",description:"<p>color string, possible formats include: integer\n                        rgb() or rgba(), percentage rgb() or rgba(),\n                        3-digit hex, 6-digit hex</p>\n",type:"String"},{name:"a",description:"<p>opacity of the background relative to current\n                            color range (default is 0-255)</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"gray",description:"<p>specifies a value between white and black</p>\n",type:"Number"},{name:"a",description:"",type:"Number",optional:!0}],chainable:1},{params:[{name:"v1",description:"<p>red or hue value (depending on the current color\n                       mode)</p>\n",type:"Number"},{name:"v2",description:"<p>green or saturation value (depending on the current\n                       color mode)</p>\n",type:"Number"},{name:"v3",description:"<p>blue or brightness value (depending on the current\n                       color mode)</p>\n",type:"Number"},{name:"a",description:"",type:"Number",optional:!0}],chainable:1},{params:[{name:"values",description:"<p>an array containing the red, green, blue\n                                and alpha components of the color</p>\n",type:"Number[]"}],chainable:1},{params:[{name:"image",description:'<p>image created with <a href="#/p5/loadImage">loadImage()</a> or <a href="#/p5/createImage">createImage()</a>,\n                            to set as background\n                            (must be same size as the sketch window)</p>\n',type:"p5.Image"},{name:"a",description:"",type:"Number",optional:!0}],chainable:1}]},clear:{name:"clear",class:"p5",module:"Color"},colorMode:{name:"colorMode",class:"p5",module:"Color",overloads:[{params:[{name:"mode",description:"<p>either RGB, HSB or HSL, corresponding to\n                         Red/Green/Blue and Hue/Saturation/Brightness\n                         (or Lightness)</p>\n",type:"Constant"},{name:"max",description:"<p>range for all values</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"mode",description:"",type:"Constant"},{name:"max1",description:"<p>range for the red or hue depending on the\n                             current color mode</p>\n",type:"Number"},{name:"max2",description:"<p>range for the green or saturation depending\n                             on the current color mode</p>\n",type:"Number"},{name:"max3",description:"<p>range for the blue or brightness/lightness\n                             depending on the current color mode</p>\n",type:"Number"},{name:"maxA",description:"<p>range for the alpha</p>\n",type:"Number",optional:!0}],chainable:1}]},fill:{name:"fill",class:"p5",module:"Color",overloads:[{params:[{name:"v1",description:"<p>red or hue value relative to\n                                the current color range</p>\n",type:"Number"},{name:"v2",description:"<p>green or saturation value\n                                relative to the current color range</p>\n",type:"Number"},{name:"v3",description:"<p>blue or brightness value\n                                relative to the current color range</p>\n",type:"Number"},{name:"alpha",description:"",type:"Number",optional:!0}],chainable:1},{params:[{name:"value",description:"<p>a color string</p>\n",type:"String"}],chainable:1},{params:[{name:"gray",description:"<p>a gray value</p>\n",type:"Number"},{name:"alpha",description:"",type:"Number",optional:!0}],chainable:1},{params:[{name:"values",description:"<p>an array containing the red,green,blue &\n                                and alpha components of the color</p>\n",type:"Number[]"}],chainable:1},{params:[{name:"color",description:"<p>the fill color</p>\n",type:"p5.Color"}],chainable:1}]},noFill:{name:"noFill",class:"p5",module:"Color"},noStroke:{name:"noStroke",class:"p5",module:"Color"},stroke:{name:"stroke",class:"p5",module:"Color",overloads:[{params:[{name:"v1",description:"<p>red or hue value relative to\n                                the current color range</p>\n",type:"Number"},{name:"v2",description:"<p>green or saturation value\n                                relative to the current color range</p>\n",type:"Number"},{name:"v3",description:"<p>blue or brightness value\n                                relative to the current color range</p>\n",type:"Number"},{name:"alpha",description:"",type:"Number",optional:!0}],chainable:1},{params:[{name:"value",description:"<p>a color string</p>\n",type:"String"}],chainable:1},{params:[{name:"gray",description:"<p>a gray value</p>\n",type:"Number"},{name:"alpha",description:"",type:"Number",optional:!0}],chainable:1},{params:[{name:"values",description:"<p>an array containing the red,green,blue &\n                                and alpha components of the color</p>\n",type:"Number[]"}],chainable:1},{params:[{name:"color",description:"<p>the stroke color</p>\n",type:"p5.Color"}],chainable:1}]},erase:{name:"erase",params:[{name:"strengthFill",description:"<p>A number (0-255) for the strength of erasing for a shape's fill.\n                                       This will default to 255 when no argument is given, which\n                                       is full strength.</p>\n",type:"Number",optional:!0},{name:"strengthStroke",description:"<p>A number (0-255) for the strength of erasing for a shape's stroke.\n                                       This will default to 255 when no argument is given, which\n                                       is full strength.</p>\n",type:"Number",optional:!0}],class:"p5",module:"Color"},noErase:{name:"noErase",class:"p5",module:"Color"},arc:{name:"arc",params:[{name:"x",description:"<p>x-coordinate of the arc's ellipse</p>\n",type:"Number"},{name:"y",description:"<p>y-coordinate of the arc's ellipse</p>\n",type:"Number"},{name:"w",description:"<p>width of the arc's ellipse by default</p>\n",type:"Number"},{name:"h",description:"<p>height of the arc's ellipse by default</p>\n",type:"Number"},{name:"start",description:"<p>angle to start the arc, specified in radians</p>\n",type:"Number"},{name:"stop",description:"<p>angle to stop the arc, specified in radians</p>\n",type:"Number"},{name:"mode",description:"<p>optional parameter to determine the way of drawing\n                        the arc. either CHORD, PIE or OPEN</p>\n",type:"Constant",optional:!0},{name:"detail",description:"<p>optional parameter for WebGL mode only. This is to\n                        specify the number of vertices that makes up the\n                        perimeter of the arc. Default value is 25.</p>\n",type:"Number",optional:!0}],class:"p5",module:"Shape"},ellipse:{name:"ellipse",class:"p5",module:"Shape",overloads:[{params:[{name:"x",description:"<p>x-coordinate of the center of ellipse.</p>\n",type:"Number"},{name:"y",description:"<p>y-coordinate of the center of ellipse.</p>\n",type:"Number"},{name:"w",description:"<p>width of the ellipse.</p>\n",type:"Number"},{name:"h",description:"<p>height of the ellipse.</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"x",description:"",type:"Number"},{name:"y",description:"",type:"Number"},{name:"w",description:"",type:"Number"},{name:"h",description:"",type:"Number"},{name:"detail",description:"<p>number of radial sectors to draw (for WebGL mode)</p>\n",type:"Integer"}]}]},circle:{name:"circle",params:[{name:"x",description:"<p>x-coordinate of the centre of the circle.</p>\n",type:"Number"},{name:"y",description:"<p>y-coordinate of the centre of the circle.</p>\n",type:"Number"},{name:"d",description:"<p>diameter of the circle.</p>\n",type:"Number"}],class:"p5",module:"Shape"},line:{name:"line",class:"p5",module:"Shape",overloads:[{params:[{name:"x1",description:"<p>the x-coordinate of the first point</p>\n",type:"Number"},{name:"y1",description:"<p>the y-coordinate of the first point</p>\n",type:"Number"},{name:"x2",description:"<p>the x-coordinate of the second point</p>\n",type:"Number"},{name:"y2",description:"<p>the y-coordinate of the second point</p>\n",type:"Number"}],chainable:1},{params:[{name:"x1",description:"",type:"Number"},{name:"y1",description:"",type:"Number"},{name:"z1",description:"<p>the z-coordinate of the first point</p>\n",type:"Number"},{name:"x2",description:"",type:"Number"},{name:"y2",description:"",type:"Number"},{name:"z2",description:"<p>the z-coordinate of the second point</p>\n",type:"Number"}],chainable:1}]},point:{name:"point",class:"p5",module:"Shape",overloads:[{params:[{name:"x",description:"<p>the x-coordinate</p>\n",type:"Number"},{name:"y",description:"<p>the y-coordinate</p>\n",type:"Number"},{name:"z",description:"<p>the z-coordinate (for WebGL mode)</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"coordinate_vector",description:"<p>the coordinate vector</p>\n",type:"p5.Vector"}],chainable:1}]},quad:{name:"quad",class:"p5",module:"Shape",overloads:[{params:[{name:"x1",description:"<p>the x-coordinate of the first point</p>\n",type:"Number"},{name:"y1",description:"<p>the y-coordinate of the first point</p>\n",type:"Number"},{name:"x2",description:"<p>the x-coordinate of the second point</p>\n",type:"Number"},{name:"y2",description:"<p>the y-coordinate of the second point</p>\n",type:"Number"},{name:"x3",description:"<p>the x-coordinate of the third point</p>\n",type:"Number"},{name:"y3",description:"<p>the y-coordinate of the third point</p>\n",type:"Number"},{name:"x4",description:"<p>the x-coordinate of the fourth point</p>\n",type:"Number"},{name:"y4",description:"<p>the y-coordinate of the fourth point</p>\n",type:"Number"}],chainable:1},{params:[{name:"x1",description:"",type:"Number"},{name:"y1",description:"",type:"Number"},{name:"z1",description:"<p>the z-coordinate of the first point</p>\n",type:"Number"},{name:"x2",description:"",type:"Number"},{name:"y2",description:"",type:"Number"},{name:"z2",description:"<p>the z-coordinate of the second point</p>\n",type:"Number"},{name:"x3",description:"",type:"Number"},{name:"y3",description:"",type:"Number"},{name:"z3",description:"<p>the z-coordinate of the third point</p>\n",type:"Number"},{name:"x4",description:"",type:"Number"},{name:"y4",description:"",type:"Number"},{name:"z4",description:"<p>the z-coordinate of the fourth point</p>\n",type:"Number"}],chainable:1}]},rect:{name:"rect",class:"p5",module:"Shape",overloads:[{params:[{name:"x",description:"<p>x-coordinate of the rectangle.</p>\n",type:"Number"},{name:"y",description:"<p>y-coordinate of the rectangle.</p>\n",type:"Number"},{name:"w",description:"<p>width of the rectangle.</p>\n",type:"Number"},{name:"h",description:"<p>height of the rectangle.</p>\n",type:"Number",optional:!0},{name:"tl",description:"<p>optional radius of top-left corner.</p>\n",type:"Number",optional:!0},{name:"tr",description:"<p>optional radius of top-right corner.</p>\n",type:"Number",optional:!0},{name:"br",description:"<p>optional radius of bottom-right corner.</p>\n",type:"Number",optional:!0},{name:"bl",description:"<p>optional radius of bottom-left corner.</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"x",description:"",type:"Number"},{name:"y",description:"",type:"Number"},{name:"w",description:"",type:"Number"},{name:"h",description:"",type:"Number"},{name:"detailX",description:"<p>number of segments in the x-direction (for WebGL mode)</p>\n",type:"Integer",optional:!0},{name:"detailY",description:"<p>number of segments in the y-direction (for WebGL mode)</p>\n",type:"Integer",optional:!0}],chainable:1}]},square:{name:"square",params:[{name:"x",description:"<p>x-coordinate of the square.</p>\n",type:"Number"},{name:"y",description:"<p>y-coordinate of the square.</p>\n",type:"Number"},{name:"s",description:"<p>side size of the square.</p>\n",type:"Number"},{name:"tl",description:"<p>optional radius of top-left corner.</p>\n",type:"Number",optional:!0},{name:"tr",description:"<p>optional radius of top-right corner.</p>\n",type:"Number",optional:!0},{name:"br",description:"<p>optional radius of bottom-right corner.</p>\n",type:"Number",optional:!0},{name:"bl",description:"<p>optional radius of bottom-left corner.</p>\n",type:"Number",optional:!0}],class:"p5",module:"Shape"},triangle:{name:"triangle",params:[{name:"x1",description:"<p>x-coordinate of the first point</p>\n",type:"Number"},{name:"y1",description:"<p>y-coordinate of the first point</p>\n",type:"Number"},{name:"x2",description:"<p>x-coordinate of the second point</p>\n",type:"Number"},{name:"y2",description:"<p>y-coordinate of the second point</p>\n",type:"Number"},{name:"x3",description:"<p>x-coordinate of the third point</p>\n",type:"Number"},{name:"y3",description:"<p>y-coordinate of the third point</p>\n",type:"Number"}],class:"p5",module:"Shape"},ellipseMode:{name:"ellipseMode",params:[{name:"mode",description:"<p>either CENTER, RADIUS, CORNER, or CORNERS</p>\n",type:"Constant"}],class:"p5",module:"Shape"},noSmooth:{name:"noSmooth",class:"p5",module:"Shape"},rectMode:{name:"rectMode",params:[{name:"mode",description:"<p>either CORNER, CORNERS, CENTER, or RADIUS</p>\n",type:"Constant"}],class:"p5",module:"Shape"},smooth:{name:"smooth",class:"p5",module:"Shape"},strokeCap:{name:"strokeCap",params:[{name:"cap",description:"<p>either ROUND, SQUARE or PROJECT</p>\n",type:"Constant"}],class:"p5",module:"Shape"},strokeJoin:{name:"strokeJoin",params:[{name:"join",description:"<p>either MITER, BEVEL, ROUND</p>\n",type:"Constant"}],class:"p5",module:"Shape"},strokeWeight:{name:"strokeWeight",params:[{name:"weight",description:"<p>the weight of the stroke (in pixels)</p>\n",type:"Number"}],class:"p5",module:"Shape"},bezier:{name:"bezier",class:"p5",module:"Shape",overloads:[{params:[{name:"x1",description:"<p>x-coordinate for the first anchor point</p>\n",type:"Number"},{name:"y1",description:"<p>y-coordinate for the first anchor point</p>\n",type:"Number"},{name:"x2",description:"<p>x-coordinate for the first control point</p>\n",type:"Number"},{name:"y2",description:"<p>y-coordinate for the first control point</p>\n",type:"Number"},{name:"x3",description:"<p>x-coordinate for the second control point</p>\n",type:"Number"},{name:"y3",description:"<p>y-coordinate for the second control point</p>\n",type:"Number"},{name:"x4",description:"<p>x-coordinate for the second anchor point</p>\n",type:"Number"},{name:"y4",description:"<p>y-coordinate for the second anchor point</p>\n",type:"Number"}],chainable:1},{params:[{name:"x1",description:"",type:"Number"},{name:"y1",description:"",type:"Number"},{name:"z1",description:"<p>z-coordinate for the first anchor point</p>\n",type:"Number"},{name:"x2",description:"",type:"Number"},{name:"y2",description:"",type:"Number"},{name:"z2",description:"<p>z-coordinate for the first control point</p>\n",type:"Number"},{name:"x3",description:"",type:"Number"},{name:"y3",description:"",type:"Number"},{name:"z3",description:"<p>z-coordinate for the second control point</p>\n",type:"Number"},{name:"x4",description:"",type:"Number"},{name:"y4",description:"",type:"Number"},{name:"z4",description:"<p>z-coordinate for the second anchor point</p>\n",type:"Number"}],chainable:1}]},bezierDetail:{name:"bezierDetail",params:[{name:"detail",description:"<p>resolution of the curves</p>\n",type:"Number"}],class:"p5",module:"Shape"},bezierPoint:{name:"bezierPoint",params:[{name:"a",description:"<p>coordinate of first point on the curve</p>\n",type:"Number"},{name:"b",description:"<p>coordinate of first control point</p>\n",type:"Number"},{name:"c",description:"<p>coordinate of second control point</p>\n",type:"Number"},{name:"d",description:"<p>coordinate of second point on the curve</p>\n",type:"Number"},{name:"t",description:"<p>value between 0 and 1</p>\n",type:"Number"}],class:"p5",module:"Shape"},bezierTangent:{name:"bezierTangent",params:[{name:"a",description:"<p>coordinate of first point on the curve</p>\n",type:"Number"},{name:"b",description:"<p>coordinate of first control point</p>\n",type:"Number"},{name:"c",description:"<p>coordinate of second control point</p>\n",type:"Number"},{name:"d",description:"<p>coordinate of second point on the curve</p>\n",type:"Number"},{name:"t",description:"<p>value between 0 and 1</p>\n",type:"Number"}],class:"p5",module:"Shape"},curve:{name:"curve",class:"p5",module:"Shape",overloads:[{params:[{name:"x1",description:"<p>x-coordinate for the beginning control point</p>\n",type:"Number"},{name:"y1",description:"<p>y-coordinate for the beginning control point</p>\n",type:"Number"},{name:"x2",description:"<p>x-coordinate for the first point</p>\n",type:"Number"},{name:"y2",description:"<p>y-coordinate for the first point</p>\n",type:"Number"},{name:"x3",description:"<p>x-coordinate for the second point</p>\n",type:"Number"},{name:"y3",description:"<p>y-coordinate for the second point</p>\n",type:"Number"},{name:"x4",description:"<p>x-coordinate for the ending control point</p>\n",type:"Number"},{name:"y4",description:"<p>y-coordinate for the ending control point</p>\n",type:"Number"}],chainable:1},{params:[{name:"x1",description:"",type:"Number"},{name:"y1",description:"",type:"Number"},{name:"z1",description:"<p>z-coordinate for the beginning control point</p>\n",type:"Number"},{name:"x2",description:"",type:"Number"},{name:"y2",description:"",type:"Number"},{name:"z2",description:"<p>z-coordinate for the first point</p>\n",type:"Number"},{name:"x3",description:"",type:"Number"},{name:"y3",description:"",type:"Number"},{name:"z3",description:"<p>z-coordinate for the second point</p>\n",type:"Number"},{name:"x4",description:"",type:"Number"},{name:"y4",description:"",type:"Number"},{name:"z4",description:"<p>z-coordinate for the ending control point</p>\n",type:"Number"}],chainable:1}]},curveDetail:{name:"curveDetail",params:[{name:"resolution",description:"<p>resolution of the curves</p>\n",type:"Number"}],class:"p5",module:"Shape"},curveTightness:{name:"curveTightness",params:[{name:"amount",description:"<p>amount of deformation from the original vertices</p>\n",type:"Number"}],class:"p5",module:"Shape"},curvePoint:{name:"curvePoint",params:[{name:"a",description:"<p>coordinate of first control point of the curve</p>\n",type:"Number"},{name:"b",description:"<p>coordinate of first point</p>\n",type:"Number"},{name:"c",description:"<p>coordinate of second point</p>\n",type:"Number"},{name:"d",description:"<p>coordinate of second control point</p>\n",type:"Number"},{name:"t",description:"<p>value between 0 and 1</p>\n",type:"Number"}],class:"p5",module:"Shape"},curveTangent:{name:"curveTangent",params:[{name:"a",description:"<p>coordinate of first control point</p>\n",type:"Number"},{name:"b",description:"<p>coordinate of first point on the curve</p>\n",type:"Number"},{name:"c",description:"<p>coordinate of second point on the curve</p>\n",type:"Number"},{name:"d",description:"<p>coordinate of second conrol point</p>\n",type:"Number"},{name:"t",description:"<p>value between 0 and 1</p>\n",type:"Number"}],class:"p5",module:"Shape"},beginContour:{name:"beginContour",class:"p5",module:"Shape"},beginShape:{name:"beginShape",params:[{name:"kind",description:"<p>either POINTS, LINES, TRIANGLES, TRIANGLE_FAN\n                               TRIANGLE_STRIP, QUADS, QUAD_STRIP or TESS</p>\n",type:"Constant",optional:!0}],class:"p5",module:"Shape"},bezierVertex:{name:"bezierVertex",class:"p5",module:"Shape",overloads:[{params:[{name:"x2",description:"<p>x-coordinate for the first control point</p>\n",type:"Number"},{name:"y2",description:"<p>y-coordinate for the first control point</p>\n",type:"Number"},{name:"x3",description:"<p>x-coordinate for the second control point</p>\n",type:"Number"},{name:"y3",description:"<p>y-coordinate for the second control point</p>\n",type:"Number"},{name:"x4",description:"<p>x-coordinate for the anchor point</p>\n",type:"Number"},{name:"y4",description:"<p>y-coordinate for the anchor point</p>\n",type:"Number"}],chainable:1},{params:[{name:"x2",description:"",type:"Number"},{name:"y2",description:"",type:"Number"},{name:"z2",description:"<p>z-coordinate for the first control point (for WebGL mode)</p>\n",type:"Number"},{name:"x3",description:"",type:"Number"},{name:"y3",description:"",type:"Number"},{name:"z3",description:"<p>z-coordinate for the second control point (for WebGL mode)</p>\n",type:"Number"},{name:"x4",description:"",type:"Number"},{name:"y4",description:"",type:"Number"},{name:"z4",description:"<p>z-coordinate for the anchor point (for WebGL mode)</p>\n",type:"Number"}],chainable:1}]},curveVertex:{name:"curveVertex",class:"p5",module:"Shape",overloads:[{params:[{name:"x",description:"<p>x-coordinate of the vertex</p>\n",type:"Number"},{name:"y",description:"<p>y-coordinate of the vertex</p>\n",type:"Number"}],chainable:1},{params:[{name:"x",description:"",type:"Number"},{name:"y",description:"",type:"Number"},{name:"z",description:"<p>z-coordinate of the vertex (for WebGL mode)</p>\n",type:"Number",optional:!0}],chainable:1}]},endContour:{name:"endContour",class:"p5",module:"Shape"},endShape:{name:"endShape",params:[{name:"mode",description:"<p>use CLOSE to close the shape</p>\n",type:"Constant",optional:!0}],class:"p5",module:"Shape"},quadraticVertex:{name:"quadraticVertex",class:"p5",module:"Shape",overloads:[{params:[{name:"cx",description:"<p>x-coordinate for the control point</p>\n",type:"Number"},{name:"cy",description:"<p>y-coordinate for the control point</p>\n",type:"Number"},{name:"x3",description:"<p>x-coordinate for the anchor point</p>\n",type:"Number"},{name:"y3",description:"<p>y-coordinate for the anchor point</p>\n",type:"Number"}],chainable:1},{params:[{name:"cx",description:"",type:"Number"},{name:"cy",description:"",type:"Number"},{name:"cz",description:"<p>z-coordinate for the control point (for WebGL mode)</p>\n",type:"Number"},{name:"x3",description:"",type:"Number"},{name:"y3",description:"",type:"Number"},{name:"z3",description:"<p>z-coordinate for the anchor point (for WebGL mode)</p>\n",type:"Number"}],chainable:1}]},vertex:{name:"vertex",class:"p5",module:"Shape",overloads:[{params:[{name:"x",description:"<p>x-coordinate of the vertex</p>\n",type:"Number"},{name:"y",description:"<p>y-coordinate of the vertex</p>\n",type:"Number"}],chainable:1},{params:[{name:"x",description:"",type:"Number"},{name:"y",description:"",type:"Number"},{name:"z",description:"<p>z-coordinate of the vertex</p>\n",type:"Number"},{name:"u",description:"<p>the vertex's texture u-coordinate</p>\n",type:"Number",optional:!0},{name:"v",description:"<p>the vertex's texture v-coordinate</p>\n",type:"Number",optional:!0}],chainable:1}]},P2D:{name:"P2D",class:"p5",module:"Constants"},WEBGL:{name:"WEBGL",class:"p5",module:"Constants"},ARROW:{name:"ARROW",class:"p5",module:"Constants"},CROSS:{name:"CROSS",class:"p5",module:"Constants"},HAND:{name:"HAND",class:"p5",module:"Constants"},MOVE:{name:"MOVE",class:"p5",module:"Constants"},TEXT:{name:"TEXT",class:"p5",module:"Constants"},WAIT:{name:"WAIT",class:"p5",module:"Constants"},HALF_PI:{name:"HALF_PI",class:"p5",module:"Constants"},PI:{name:"PI",class:"p5",module:"Constants"},QUARTER_PI:{name:"QUARTER_PI",class:"p5",module:"Constants"},TAU:{name:"TAU",class:"p5",module:"Constants"},TWO_PI:{name:"TWO_PI",class:"p5",module:"Constants"},DEGREES:{name:"DEGREES",class:"p5",module:"Constants"},RADIANS:{name:"RADIANS",class:"p5",module:"Constants"},CORNER:{name:"CORNER",class:"p5",module:"Constants"},CORNERS:{name:"CORNERS",class:"p5",module:"Constants"},RADIUS:{name:"RADIUS",class:"p5",module:"Constants"},RIGHT:{name:"RIGHT",class:"p5",module:"Constants"},LEFT:{name:"LEFT",class:"p5",module:"Constants"},CENTER:{name:"CENTER",class:"p5",module:"Constants"},TOP:{name:"TOP",class:"p5",module:"Constants"},BOTTOM:{name:"BOTTOM",class:"p5",module:"Constants"},BASELINE:{name:"BASELINE",class:"p5",module:"Constants"},POINTS:{name:"POINTS",class:"p5",module:"Constants"},LINES:{name:"LINES",class:"p5",module:"Constants"},LINE_STRIP:{name:"LINE_STRIP",class:"p5",module:"Constants"},LINE_LOOP:{name:"LINE_LOOP",class:"p5",module:"Constants"},TRIANGLES:{name:"TRIANGLES",class:"p5",module:"Constants"},TRIANGLE_FAN:{name:"TRIANGLE_FAN",class:"p5",module:"Constants"},TRIANGLE_STRIP:{name:"TRIANGLE_STRIP",class:"p5",module:"Constants"},QUADS:{name:"QUADS",class:"p5",module:"Constants"},QUAD_STRIP:{name:"QUAD_STRIP",class:"p5",module:"Constants"},TESS:{name:"TESS",class:"p5",module:"Constants"},CLOSE:{name:"CLOSE",class:"p5",module:"Constants"},OPEN:{name:"OPEN",class:"p5",module:"Constants"},CHORD:{name:"CHORD",class:"p5",module:"Constants"},PIE:{name:"PIE",class:"p5",module:"Constants"},PROJECT:{name:"PROJECT",class:"p5",module:"Constants"},SQUARE:{name:"SQUARE",class:"p5",module:"Constants"},ROUND:{name:"ROUND",class:"p5",module:"Constants"},BEVEL:{name:"BEVEL",class:"p5",module:"Constants"},MITER:{name:"MITER",class:"p5",module:"Constants"},RGB:{name:"RGB",class:"p5",module:"Constants"},HSB:{name:"HSB",class:"p5",module:"Constants"},HSL:{name:"HSL",class:"p5",module:"Constants"},AUTO:{name:"AUTO",class:"p5",module:"Constants"},ALT:{name:"ALT",class:"p5",module:"Constants"},BACKSPACE:{name:"BACKSPACE",class:"p5",module:"Constants"},CONTROL:{name:"CONTROL",class:"p5",module:"Constants"},DELETE:{name:"DELETE",class:"p5",module:"Constants"},DOWN_ARROW:{name:"DOWN_ARROW",class:"p5",module:"Constants"},ENTER:{name:"ENTER",class:"p5",module:"Constants"},ESCAPE:{name:"ESCAPE",class:"p5",module:"Constants"},LEFT_ARROW:{name:"LEFT_ARROW",class:"p5",module:"Constants"},OPTION:{name:"OPTION",class:"p5",module:"Constants"},RETURN:{name:"RETURN",class:"p5",module:"Constants"},RIGHT_ARROW:{name:"RIGHT_ARROW",class:"p5",module:"Constants"},SHIFT:{name:"SHIFT",class:"p5",module:"Constants"},TAB:{name:"TAB",class:"p5",module:"Constants"},UP_ARROW:{name:"UP_ARROW",class:"p5",module:"Constants"},BLEND:{name:"BLEND",class:"p5",module:"Constants"},REMOVE:{name:"REMOVE",class:"p5",module:"Constants"},ADD:{name:"ADD",class:"p5",module:"Constants"},DARKEST:{name:"DARKEST",class:"p5",module:"Constants"},LIGHTEST:{name:"LIGHTEST",class:"p5",module:"Constants"},DIFFERENCE:{name:"DIFFERENCE",class:"p5",module:"Constants"},SUBTRACT:{name:"SUBTRACT",class:"p5",module:"Constants"},EXCLUSION:{name:"EXCLUSION",class:"p5",module:"Constants"},MULTIPLY:{name:"MULTIPLY",class:"p5",module:"Constants"},SCREEN:{name:"SCREEN",class:"p5",module:"Constants"},REPLACE:{name:"REPLACE",class:"p5",module:"Constants"},OVERLAY:{name:"OVERLAY",class:"p5",module:"Constants"},HARD_LIGHT:{name:"HARD_LIGHT",class:"p5",module:"Constants"},SOFT_LIGHT:{name:"SOFT_LIGHT",class:"p5",module:"Constants"},DODGE:{name:"DODGE",class:"p5",module:"Constants"},BURN:{name:"BURN",class:"p5",module:"Constants"},THRESHOLD:{name:"THRESHOLD",class:"p5",module:"Constants"},GRAY:{name:"GRAY",class:"p5",module:"Constants"},OPAQUE:{name:"OPAQUE",class:"p5",module:"Constants"},INVERT:{name:"INVERT",class:"p5",module:"Constants"},POSTERIZE:{name:"POSTERIZE",class:"p5",module:"Constants"},DILATE:{name:"DILATE",class:"p5",module:"Constants"},ERODE:{name:"ERODE",class:"p5",module:"Constants"},BLUR:{name:"BLUR",class:"p5",module:"Constants"},NORMAL:{name:"NORMAL",class:"p5",module:"Constants"},ITALIC:{name:"ITALIC",class:"p5",module:"Constants"},BOLD:{name:"BOLD",class:"p5",module:"Constants"},BOLDITALIC:{name:"BOLDITALIC",class:"p5",module:"Constants"},LINEAR:{name:"LINEAR",class:"p5",module:"Constants"},QUADRATIC:{name:"QUADRATIC",class:"p5",module:"Constants"},BEZIER:{name:"BEZIER",class:"p5",module:"Constants"},CURVE:{name:"CURVE",class:"p5",module:"Constants"},STROKE:{name:"STROKE",class:"p5",module:"Constants"},FILL:{name:"FILL",class:"p5",module:"Constants"},TEXTURE:{name:"TEXTURE",class:"p5",module:"Constants"},IMMEDIATE:{name:"IMMEDIATE",class:"p5",module:"Constants"},IMAGE:{name:"IMAGE",class:"p5",module:"Constants"},NEAREST:{name:"NEAREST",class:"p5",module:"Constants"},REPEAT:{name:"REPEAT",class:"p5",module:"Constants"},CLAMP:{name:"CLAMP",class:"p5",module:"Constants"},MIRROR:{name:"MIRROR",class:"p5",module:"Constants"},LANDSCAPE:{name:"LANDSCAPE",class:"p5",module:"Constants"},PORTRAIT:{name:"PORTRAIT",class:"p5",module:"Constants"},GRID:{name:"GRID",class:"p5",module:"Constants"},AXES:{name:"AXES",class:"p5",module:"Constants"},print:{name:"print",params:[{name:"contents",description:"<p>any combination of Number, String, Object, Boolean,\n                      Array to print</p>\n",type:"Any"}],class:"p5",module:"Environment"},frameCount:{name:"frameCount",class:"p5",module:"Environment"},deltaTime:{name:"deltaTime",class:"p5",module:"Environment"},focused:{name:"focused",class:"p5",module:"Environment"},cursor:{name:"cursor",params:[{name:"type",description:"<p>Built-In: either ARROW, CROSS, HAND, MOVE, TEXT and WAIT\n                              Native CSS properties: 'grab', 'progress', 'cell' etc.\n                              External: path for cursor's images\n                              (Allowed File extensions: .cur, .gif, .jpg, .jpeg, .png)\n                              For more information on Native CSS cursors and url visit:\n                              <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\">https://developer.mozilla.org/en-US/docs/Web/CSS/cursor</a></p>\n",type:"String|Constant"},{name:"x",description:"<p>the horizontal active spot of the cursor (must be less than 32)</p>\n",type:"Number",optional:!0},{name:"y",description:"<p>the vertical active spot of the cursor (must be less than 32)</p>\n",type:"Number",optional:!0}],class:"p5",module:"Environment"},frameRate:{name:"frameRate",class:"p5",module:"Environment",overloads:[{params:[{name:"fps",description:"<p>number of frames to be displayed every second</p>\n",type:"Number"}],chainable:1},{params:[]}]},noCursor:{name:"noCursor",class:"p5",module:"Environment"},displayWidth:{name:"displayWidth",class:"p5",module:"Environment"},displayHeight:{name:"displayHeight",class:"p5",module:"Environment"},windowWidth:{name:"windowWidth",class:"p5",module:"Environment"},windowHeight:{name:"windowHeight",class:"p5",module:"Environment"},windowResized:{name:"windowResized",class:"p5",module:"Environment"},width:{name:"width",class:"p5",module:"Environment"},height:{name:"height",class:"p5",module:"Environment"},fullscreen:{name:"fullscreen",params:[{name:"val",description:"<p>whether the sketch should be in fullscreen mode\nor not</p>\n",type:"Boolean",optional:!0}],class:"p5",module:"Environment"},pixelDensity:{name:"pixelDensity",class:"p5",module:"Environment",overloads:[{params:[{name:"val",description:"<p>whether or how much the sketch should scale</p>\n",type:"Number"}],chainable:1},{params:[]}]},displayDensity:{name:"displayDensity",class:"p5",module:"Environment"},getURL:{name:"getURL",class:"p5",module:"Environment"},getURLPath:{name:"getURLPath",class:"p5",module:"Environment"},getURLParams:{name:"getURLParams",class:"p5",module:"Environment"},preload:{name:"preload",class:"p5",module:"Structure"},setup:{name:"setup",class:"p5",module:"Structure"},draw:{name:"draw",class:"p5",module:"Structure"},remove:{name:"remove",class:"p5",module:"Structure"},disableFriendlyErrors:{name:"disableFriendlyErrors",class:"p5",module:"Structure"},let:{name:"let",class:"p5",module:"Foundation"},const:{name:"const",class:"p5",module:"Foundation"},"===":{name:"===",class:"p5",module:"Foundation"},">":{name:">",class:"p5",module:"Foundation"},">=":{name:">=",class:"p5",module:"Foundation"},"<":{name:"<",class:"p5",module:"Foundation"},"<=":{name:"<=",class:"p5",module:"Foundation"},"if-else":{name:"if-else",class:"p5",module:"Foundation"},function:{name:"function",class:"p5",module:"Foundation"},return:{name:"return",class:"p5",module:"Foundation"},boolean:{name:"boolean",params:[{name:"n",description:"<p>value to parse</p>\n",type:"String|Boolean|Number|Array"}],class:"p5",module:"Data"},string:{name:"string",class:"p5",module:"Foundation"},number:{name:"number",class:"p5",module:"Foundation"},object:{name:"object",class:"p5",module:"Foundation"},class:{name:"class",class:"p5",module:"Foundation"},for:{name:"for",class:"p5",module:"Foundation"},while:{name:"while",class:"p5",module:"Foundation"},createCanvas:{name:"createCanvas",params:[{name:"w",description:"<p>width of the canvas</p>\n",type:"Number"},{name:"h",description:"<p>height of the canvas</p>\n",type:"Number"},{name:"renderer",description:"<p>either P2D or WEBGL</p>\n",type:"Constant",optional:!0}],class:"p5",module:"Rendering"},resizeCanvas:{name:"resizeCanvas",params:[{name:"w",description:"<p>width of the canvas</p>\n",type:"Number"},{name:"h",description:"<p>height of the canvas</p>\n",type:"Number"},{name:"noRedraw",description:"<p>don't redraw the canvas immediately</p>\n",type:"Boolean",optional:!0}],class:"p5",module:"Rendering"},noCanvas:{name:"noCanvas",class:"p5",module:"Rendering"},createGraphics:{name:"createGraphics",params:[{name:"w",description:"<p>width of the offscreen graphics buffer</p>\n",type:"Number"},{name:"h",description:"<p>height of the offscreen graphics buffer</p>\n",type:"Number"},{name:"renderer",description:"<p>either P2D or WEBGL\n                              undefined defaults to p2d</p>\n",type:"Constant",optional:!0}],class:"p5",module:"Rendering"},blendMode:{name:"blendMode",params:[{name:"mode",description:"<p>blend mode to set for canvas.\n               either BLEND, DARKEST, LIGHTEST, DIFFERENCE, MULTIPLY,\n               EXCLUSION, SCREEN, REPLACE, OVERLAY, HARD_LIGHT,\n               SOFT_LIGHT, DODGE, BURN, ADD, REMOVE or SUBTRACT</p>\n",type:"Constant"}],class:"p5",module:"Rendering"},drawingContext:{name:"drawingContext",class:"p5",module:"Rendering"},noLoop:{name:"noLoop",class:"p5",module:"Structure"},loop:{name:"loop",class:"p5",module:"Structure"},isLooping:{name:"isLooping",class:"p5",module:"Structure"},push:{name:"push",class:"p5",module:"Structure"},pop:{name:"pop",class:"p5",module:"Structure"},redraw:{name:"redraw",params:[{name:"n",description:"<p>Redraw for n-times. The default value is 1.</p>\n",type:"Integer",optional:!0}],class:"p5",module:"Structure"},p5:{name:"p5",params:[{name:"sketch",description:"<p>a function containing a p5.js sketch</p>\n",type:"Object"},{name:"node",description:"<p>ID or pointer to HTML DOM node to contain sketch in</p>\n",type:"String|Object"}],class:"p5",module:"Structure"},applyMatrix:{name:"applyMatrix",params:[{name:"a",description:"<p>numbers which define the 2x3 matrix to be multiplied</p>\n",type:"Number"},{name:"b",description:"<p>numbers which define the 2x3 matrix to be multiplied</p>\n",type:"Number"},{name:"c",description:"<p>numbers which define the 2x3 matrix to be multiplied</p>\n",type:"Number"},{name:"d",description:"<p>numbers which define the 2x3 matrix to be multiplied</p>\n",type:"Number"},{name:"e",description:"<p>numbers which define the 2x3 matrix to be multiplied</p>\n",type:"Number"},{name:"f",description:"<p>numbers which define the 2x3 matrix to be multiplied</p>\n",type:"Number"}],class:"p5",module:"Transform"},resetMatrix:{name:"resetMatrix",class:"p5",module:"Transform"},rotate:{name:"rotate",params:[{name:"angle",description:"<p>the angle of rotation, specified in radians\n                       or degrees, depending on current angleMode</p>\n",type:"Number"},{name:"axis",description:"<p>(in 3d) the axis to rotate around</p>\n",type:"p5.Vector|Number[]",optional:!0}],class:"p5",module:"Transform"},rotateX:{name:"rotateX",params:[{name:"angle",description:"<p>the angle of rotation, specified in radians\n                       or degrees, depending on current angleMode</p>\n",type:"Number"}],class:"p5",module:"Transform"},rotateY:{name:"rotateY",params:[{name:"angle",description:"<p>the angle of rotation, specified in radians\n                       or degrees, depending on current angleMode</p>\n",type:"Number"}],class:"p5",module:"Transform"},rotateZ:{name:"rotateZ",params:[{name:"angle",description:"<p>the angle of rotation, specified in radians\n                       or degrees, depending on current angleMode</p>\n",type:"Number"}],class:"p5",module:"Transform"},scale:{name:"scale",class:"p5",module:"Transform",overloads:[{params:[{name:"s",description:"<p>percent to scale the object, or percentage to\n                     scale the object in the x-axis if multiple arguments\n                     are given</p>\n",type:"Number|p5.Vector|Number[]"},{name:"y",description:"<p>percent to scale the object in the y-axis</p>\n",type:"Number",optional:!0},{name:"z",description:"<p>percent to scale the object in the z-axis (webgl only)</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"scales",description:"<p>per-axis percents to scale the object</p>\n",type:"p5.Vector|Number[]"}],chainable:1}]},shearX:{name:"shearX",params:[{name:"angle",description:"<p>angle of shear specified in radians or degrees,\n                       depending on current angleMode</p>\n",type:"Number"}],class:"p5",module:"Transform"},shearY:{name:"shearY",params:[{name:"angle",description:"<p>angle of shear specified in radians or degrees,\n                       depending on current angleMode</p>\n",type:"Number"}],class:"p5",module:"Transform"},translate:{name:"translate",class:"p5",module:"Transform",overloads:[{params:[{name:"x",description:"<p>left/right translation</p>\n",type:"Number"},{name:"y",description:"<p>up/down translation</p>\n",type:"Number"},{name:"z",description:"<p>forward/backward translation (webgl only)</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"vector",description:"<p>the vector to translate by</p>\n",type:"p5.Vector"}],chainable:1}]},storeItem:{name:"storeItem",params:[{name:"key",description:"",type:"String"},{name:"value",description:"",type:"String|Number|Object|Boolean|p5.Color|p5.Vector"}],class:"p5",module:"Data"},getItem:{name:"getItem",params:[{name:"key",description:"<p>name that you wish to use to store in local storage</p>\n",type:"String"}],class:"p5",module:"Data"},clearStorage:{name:"clearStorage",class:"p5",module:"Data"},removeItem:{name:"removeItem",params:[{name:"key",description:"",type:"String"}],class:"p5",module:"Data"},createStringDict:{name:"createStringDict",class:"p5",module:"Data",overloads:[{params:[{name:"key",description:"",type:"String"},{name:"value",description:"",type:"String"}]},{params:[{name:"object",description:"<p>object</p>\n",type:"Object"}]}]},createNumberDict:{name:"createNumberDict",class:"p5",module:"Data",overloads:[{params:[{name:"key",description:"",type:"Number"},{name:"value",description:"",type:"Number"}]},{params:[{name:"object",description:"<p>object</p>\n",type:"Object"}]}]},select:{name:"select",params:[{name:"selectors",description:"<p>CSS selector string of element to search for</p>\n",type:"String"},{name:"container",description:'<p>CSS selector string, <a href="#/p5.Element">p5.Element</a>, or\n                                            HTML element to search within</p>\n',type:"String|p5.Element|HTMLElement",optional:!0}],class:"p5",module:"DOM"},selectAll:{name:"selectAll",params:[{name:"selectors",description:"<p>CSS selector string of elements to search for</p>\n",type:"String"},{name:"container",description:'<p>CSS selector string, <a href="#/p5.Element">p5.Element</a>\n                                            , or HTML element to search within</p>\n',type:"String|p5.Element|HTMLElement",optional:!0}],class:"p5",module:"DOM"},removeElements:{name:"removeElements",class:"p5",module:"DOM"},changed:{name:"changed",params:[{name:"fxn",description:"<p>function to be fired when the value of\n                               an element changes.\n                               if <code>false</code> is passed instead, the previously\n                               firing function will no longer fire.</p>\n",type:"Function|Boolean"}],class:"p5",module:"DOM"},input:{name:"input",params:[{name:"fxn",description:"<p>function to be fired when any user input is\n                               detected within the element.\n                               if <code>false</code> is passed instead, the previously\n                               firing function will no longer fire.</p>\n",type:"Function|Boolean"}],class:"p5",module:"DOM"},createDiv:{name:"createDiv",params:[{name:"html",description:"<p>inner HTML for element created</p>\n",type:"String",optional:!0}],class:"p5",module:"DOM"},createP:{name:"createP",params:[{name:"html",description:"<p>inner HTML for element created</p>\n",type:"String",optional:!0}],class:"p5",module:"DOM"},createSpan:{name:"createSpan",params:[{name:"html",description:"<p>inner HTML for element created</p>\n",type:"String",optional:!0}],class:"p5",module:"DOM"},createImg:{name:"createImg",class:"p5",module:"DOM",overloads:[{params:[{name:"src",description:"<p>src path or url for image</p>\n",type:"String"},{name:"alt",description:'<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Img#Attributes">alternate text</a> to be used if image does not load. You can use also an empty string (<code>""</code>) if that an image is not intended to be viewed.</p>\n',type:"String"}]},{params:[{name:"src",description:"",type:"String"},{name:"alt",description:"",type:"String"},{name:"crossOrigin",description:"<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes\">crossOrigin property</a> of the <code>img</code> element; use either 'anonymous' or 'use-credentials' to retrieve the image with cross-origin access (for later use with <code>canvas</code>. if an empty string(<code>\"\"</code>) is passed, CORS is not used</p>\n",type:"String"},{name:"successCallback",description:'<p>callback to be called once image data is loaded with the <a href="#/p5.Element">p5.Element</a> as argument</p>\n',type:"Function",optional:!0}]}]},createA:{name:"createA",params:[{name:"href",description:"<p>url of page to link to</p>\n",type:"String"},{name:"html",description:"<p>inner html of link element to display</p>\n",type:"String"},{name:"target",description:"<p>target where new link should open,\n                            could be _blank, _self, _parent, _top.</p>\n",type:"String",optional:!0}],class:"p5",module:"DOM"},createSlider:{name:"createSlider",params:[{name:"min",description:"<p>minimum value of the slider</p>\n",type:"Number"},{name:"max",description:"<p>maximum value of the slider</p>\n",type:"Number"},{name:"value",description:"<p>default value of the slider</p>\n",type:"Number",optional:!0},{name:"step",description:"<p>step size for each tick of the slider (if step is set to 0, the slider will move continuously from the minimum to the maximum value)</p>\n",type:"Number",optional:!0}],class:"p5",module:"DOM"},createButton:{name:"createButton",params:[{name:"label",description:"<p>label displayed on the button</p>\n",type:"String"},{name:"value",description:"<p>value of the button</p>\n",type:"String",optional:!0}],class:"p5",module:"DOM"},createCheckbox:{name:"createCheckbox",params:[{name:"label",description:"<p>label displayed after checkbox</p>\n",type:"String",optional:!0},{name:"value",description:"<p>value of the checkbox; checked is true, unchecked is false</p>\n",type:"Boolean",optional:!0}],class:"p5",module:"DOM"},createSelect:{name:"createSelect",class:"p5",module:"DOM",overloads:[{params:[{name:"multiple",description:"<p>true if dropdown should support multiple selections</p>\n",type:"Boolean",optional:!0}]},{params:[{name:"existing",description:"<p>DOM select element</p>\n",type:"Object"}]}]},createRadio:{name:"createRadio",class:"p5",module:"DOM",overloads:[{params:[{name:"containerElement",description:"<p>An container HTML Element either a div\nor span inside which all existing radio inputs will be considered as options.</p>\n",type:"Object"},{name:"name",description:"<p>A name parameter for each Input Element.</p>\n",type:"String",optional:!0}]},{params:[{name:"name",description:"",type:"String"}]},{params:[]}]},createColorPicker:{name:"createColorPicker",params:[{name:"value",description:"<p>default color of element</p>\n",type:"String|p5.Color",optional:!0}],class:"p5",module:"DOM"},createInput:{name:"createInput",class:"p5",module:"DOM",overloads:[{params:[{name:"value",description:"<p>default value of the input box</p>\n",type:"String"},{name:"type",description:"<p>type of text, ie text, password etc. Defaults to text.\n  Needs a value to be specified first.</p>\n",type:"String",optional:!0}]},{params:[{name:"value",description:"",type:"String",optional:!0}]}]},createFileInput:{name:"createFileInput",params:[{name:"callback",description:"<p>callback function for when a file is loaded</p>\n",type:"Function"},{name:"multiple",description:"<p>optional, to allow multiple files to be selected</p>\n",type:"Boolean",optional:!0}],class:"p5",module:"DOM"},createVideo:{name:"createVideo",params:[{name:"src",description:"<p>path to a video file, or array of paths for\n                            supporting different browsers</p>\n",type:"String|String[]"},{name:"callback",description:"<p>callback function to be called upon\n                            'canplaythrough' event fire, that is, when the\n                            browser can play the media, and estimates that\n                            enough data has been loaded to play the media\n                            up to its end without having to stop for\n                            further buffering of content</p>\n",type:"Function",optional:!0}],class:"p5",module:"DOM"},createAudio:{name:"createAudio",params:[{name:"src",description:"<p>path to an audio file, or array of paths\n                            for supporting different browsers</p>\n",type:"String|String[]",optional:!0},{name:"callback",description:"<p>callback function to be called upon\n                            'canplaythrough' event fire, that is, when the\n                            browser can play the media, and estimates that\n                            enough data has been loaded to play the media\n                            up to its end without having to stop for\n                            further buffering of content</p>\n",type:"Function",optional:!0}],class:"p5",module:"DOM"},VIDEO:{name:"VIDEO",class:"p5",module:"DOM"},AUDIO:{name:"AUDIO",class:"p5",module:"DOM"},createCapture:{name:"createCapture",params:[{name:"type",description:"<p>type of capture, either VIDEO or\n                                  AUDIO if none specified, default both,\n                                  or a Constraints object</p>\n",type:"String|Constant|Object"},{name:"callback",description:"<p>function to be called once\n                                  stream has loaded</p>\n",type:"Function",optional:!0}],class:"p5",module:"DOM"},createElement:{name:"createElement",params:[{name:"tag",description:"<p>tag for the new element</p>\n",type:"String"},{name:"content",description:"<p>html content to be inserted into the element</p>\n",type:"String",optional:!0}],class:"p5",module:"DOM"},deviceOrientation:{name:"deviceOrientation",class:"p5",module:"Events"},accelerationX:{name:"accelerationX",class:"p5",module:"Events"},accelerationY:{name:"accelerationY",class:"p5",module:"Events"},accelerationZ:{name:"accelerationZ",class:"p5",module:"Events"},pAccelerationX:{name:"pAccelerationX",class:"p5",module:"Events"},pAccelerationY:{name:"pAccelerationY",class:"p5",module:"Events"},pAccelerationZ:{name:"pAccelerationZ",class:"p5",module:"Events"},rotationX:{name:"rotationX",class:"p5",module:"Events"},rotationY:{name:"rotationY",class:"p5",module:"Events"},rotationZ:{name:"rotationZ",class:"p5",module:"Events"},pRotationX:{name:"pRotationX",class:"p5",module:"Events"},pRotationY:{name:"pRotationY",class:"p5",module:"Events"},pRotationZ:{name:"pRotationZ",class:"p5",module:"Events"},turnAxis:{name:"turnAxis",class:"p5",module:"Events"},setMoveThreshold:{name:"setMoveThreshold",params:[{name:"value",description:"<p>The threshold value</p>\n",type:"Number"}],class:"p5",module:"Events"},setShakeThreshold:{name:"setShakeThreshold",params:[{name:"value",description:"<p>The threshold value</p>\n",type:"Number"}],class:"p5",module:"Events"},deviceMoved:{name:"deviceMoved",class:"p5",module:"Events"},deviceTurned:{name:"deviceTurned",class:"p5",module:"Events"},deviceShaken:{name:"deviceShaken",class:"p5",module:"Events"},keyIsPressed:{name:"keyIsPressed",class:"p5",module:"Events"},key:{name:"key",class:"p5",module:"Events"},keyCode:{name:"keyCode",class:"p5",module:"Events"},keyPressed:{name:"keyPressed",class:"p5",module:"Events"},keyReleased:{name:"keyReleased",class:"p5",module:"Events"},keyTyped:{name:"keyTyped",class:"p5",module:"Events"},keyIsDown:{name:"keyIsDown",params:[{name:"code",description:"<p>The key to check for.</p>\n",type:"Number"}],class:"p5",module:"Events"},movedX:{name:"movedX",class:"p5",module:"Events"},movedY:{name:"movedY",class:"p5",module:"Events"},mouseX:{name:"mouseX",class:"p5",module:"Events"},mouseY:{name:"mouseY",class:"p5",module:"Events"},pmouseX:{name:"pmouseX",class:"p5",module:"Events"},pmouseY:{name:"pmouseY",class:"p5",module:"Events"},winMouseX:{name:"winMouseX",class:"p5",module:"Events"},winMouseY:{name:"winMouseY",class:"p5",module:"Events"},pwinMouseX:{name:"pwinMouseX",class:"p5",module:"Events"},pwinMouseY:{name:"pwinMouseY",class:"p5",module:"Events"},mouseButton:{name:"mouseButton",class:"p5",module:"Events"},mouseIsPressed:{name:"mouseIsPressed",class:"p5",module:"Events"},mouseMoved:{name:"mouseMoved",params:[{name:"event",description:"<p>optional MouseEvent callback argument.</p>\n",type:"Object",optional:!0}],class:"p5",module:"Events"},mouseDragged:{name:"mouseDragged",params:[{name:"event",description:"<p>optional MouseEvent callback argument.</p>\n",type:"Object",optional:!0}],class:"p5",module:"Events"},mousePressed:{name:"mousePressed",params:[{name:"event",description:"<p>optional MouseEvent callback argument.</p>\n",type:"Object",optional:!0}],class:"p5",module:"Events"},mouseReleased:{name:"mouseReleased",params:[{name:"event",description:"<p>optional MouseEvent callback argument.</p>\n",type:"Object",optional:!0}],class:"p5",module:"Events"},mouseClicked:{name:"mouseClicked",params:[{name:"event",description:"<p>optional MouseEvent callback argument.</p>\n",type:"Object",optional:!0}],class:"p5",module:"Events"},doubleClicked:{name:"doubleClicked",params:[{name:"event",description:"<p>optional MouseEvent callback argument.</p>\n",type:"Object",optional:!0}],class:"p5",module:"Events"},mouseWheel:{name:"mouseWheel",params:[{name:"event",description:"<p>optional WheelEvent callback argument.</p>\n",type:"Object",optional:!0}],class:"p5",module:"Events"},requestPointerLock:{name:"requestPointerLock",class:"p5",module:"Events"},exitPointerLock:{name:"exitPointerLock",class:"p5",module:"Events"},touches:{name:"touches",class:"p5",module:"Events"},touchStarted:{name:"touchStarted",params:[{name:"event",description:"<p>optional TouchEvent callback argument.</p>\n",type:"Object",optional:!0}],class:"p5",module:"Events"},touchMoved:{name:"touchMoved",params:[{name:"event",description:"<p>optional TouchEvent callback argument.</p>\n",type:"Object",optional:!0}],class:"p5",module:"Events"},touchEnded:{name:"touchEnded",params:[{name:"event",description:"<p>optional TouchEvent callback argument.</p>\n",type:"Object",optional:!0}],class:"p5",module:"Events"},createImage:{name:"createImage",params:[{name:"width",description:"<p>width in pixels</p>\n",type:"Integer"},{name:"height",description:"<p>height in pixels</p>\n",type:"Integer"}],class:"p5",module:"Image"},saveCanvas:{name:"saveCanvas",class:"p5",module:"Image",overloads:[{params:[{name:"selectedCanvas",description:"<p>a variable\n                                representing a specific html5 canvas (optional)</p>\n",type:"p5.Element|HTMLCanvasElement"},{name:"filename",description:"",type:"String",optional:!0},{name:"extension",description:"<p>'jpg' or 'png'</p>\n",type:"String",optional:!0}]},{params:[{name:"filename",description:"",type:"String",optional:!0},{name:"extension",description:"",type:"String",optional:!0}]}]},saveFrames:{name:"saveFrames",params:[{name:"filename",description:"",type:"String"},{name:"extension",description:"<p>'jpg' or 'png'</p>\n",type:"String"},{name:"duration",description:"<p>Duration in seconds to save the frames for.</p>\n",type:"Number"},{name:"framerate",description:"<p>Framerate to save the frames in.</p>\n",type:"Number"},{name:"callback",description:"<p>A callback function that will be executed\n                                to handle the image data. This function\n                                should accept an array as argument. The\n                                array will contain the specified number of\n                                frames of objects. Each object has three\n                                properties: imageData - an\n                                image/octet-stream, filename and extension.</p>\n",type:"Function(Array)",optional:!0}],class:"p5",module:"Image"},loadImage:{name:"loadImage",params:[{name:"path",description:"<p>Path of the image to be loaded</p>\n",type:"String"},{name:"successCallback",description:'<p>Function to be called once\n                               the image is loaded. Will be passed the\n                               <a href="#/p5.Image">p5.Image</a>.</p>\n',type:"function(p5.Image)",optional:!0},{name:"failureCallback",description:"<p>called with event error if\n                               the image fails to load.</p>\n",type:"Function(Event)",optional:!0}],class:"p5",module:"Image"},image:{name:"image",class:"p5",module:"Image",overloads:[{params:[{name:"img",description:"<p>the image to display</p>\n",type:"p5.Image|p5.Element"},{name:"x",description:"<p>the x-coordinate of the top-left corner of the image</p>\n",type:"Number"},{name:"y",description:"<p>the y-coordinate of the top-left corner of the image</p>\n",type:"Number"},{name:"width",description:"<p>the width to draw the image</p>\n",type:"Number",optional:!0},{name:"height",description:"<p>the height to draw the image</p>\n",type:"Number",optional:!0}]},{params:[{name:"img",description:"",type:"p5.Image|p5.Element"},{name:"dx",description:"<p>the x-coordinate of the destination\n                          rectangle in which to draw the source image</p>\n",type:"Number"},{name:"dy",description:"<p>the y-coordinate of the destination\n                          rectangle in which to draw the source image</p>\n",type:"Number"},{name:"dWidth",description:"<p>the width of the destination rectangle</p>\n",type:"Number"},{name:"dHeight",description:"<p>the height of the destination rectangle</p>\n",type:"Number"},{name:"sx",description:"<p>the x-coordinate of the subsection of the source\nimage to draw into the destination rectangle</p>\n",type:"Number"},{name:"sy",description:"<p>the y-coordinate of the subsection of the source\nimage to draw into the destination rectangle</p>\n",type:"Number"},{name:"sWidth",description:"<p>the width of the subsection of the\n                          source image to draw into the destination\n                          rectangle</p>\n",type:"Number",optional:!0},{name:"sHeight",description:"<p>the height of the subsection of the\n                           source image to draw into the destination rectangle</p>\n",type:"Number",optional:!0}]}]},tint:{name:"tint",class:"p5",module:"Image",overloads:[{params:[{name:"v1",description:"<p>red or hue value relative to\n                                the current color range</p>\n",type:"Number"},{name:"v2",description:"<p>green or saturation value\n                                relative to the current color range</p>\n",type:"Number"},{name:"v3",description:"<p>blue or brightness value\n                                relative to the current color range</p>\n",type:"Number"},{name:"alpha",description:"",type:"Number",optional:!0}]},{params:[{name:"value",description:"<p>a color string</p>\n",type:"String"}]},{params:[{name:"gray",description:"<p>a gray value</p>\n",type:"Number"},{name:"alpha",description:"",type:"Number",optional:!0}]},{params:[{name:"values",description:"<p>an array containing the red,green,blue &\n                                and alpha components of the color</p>\n",type:"Number[]"}]},{params:[{name:"color",description:"<p>the tint color</p>\n",type:"p5.Color"}]}]},noTint:{name:"noTint",class:"p5",module:"Image"},imageMode:{name:"imageMode",params:[{name:"mode",description:"<p>either CORNER, CORNERS, or CENTER</p>\n",type:"Constant"}],class:"p5",module:"Image"},pixels:{name:"pixels",class:"p5",module:"Image"},blend:{name:"blend",class:"p5",module:"Image",overloads:[{params:[{name:"srcImage",description:"<p>source image</p>\n",type:"p5.Image"},{name:"sx",description:"<p>X coordinate of the source's upper left corner</p>\n",type:"Integer"},{name:"sy",description:"<p>Y coordinate of the source's upper left corner</p>\n",type:"Integer"},{name:"sw",description:"<p>source image width</p>\n",type:"Integer"},{name:"sh",description:"<p>source image height</p>\n",type:"Integer"},{name:"dx",description:"<p>X coordinate of the destination's upper left corner</p>\n",type:"Integer"},{name:"dy",description:"<p>Y coordinate of the destination's upper left corner</p>\n",type:"Integer"},{name:"dw",description:"<p>destination image width</p>\n",type:"Integer"},{name:"dh",description:"<p>destination image height</p>\n",type:"Integer"},{name:"blendMode",description:"<p>the blend mode. either\n    BLEND, DARKEST, LIGHTEST, DIFFERENCE,\n    MULTIPLY, EXCLUSION, SCREEN, REPLACE, OVERLAY, HARD_LIGHT,\n    SOFT_LIGHT, DODGE, BURN, ADD or NORMAL.</p>\n",type:"Constant"}]},{params:[{name:"sx",description:"",type:"Integer"},{name:"sy",description:"",type:"Integer"},{name:"sw",description:"",type:"Integer"},{name:"sh",description:"",type:"Integer"},{name:"dx",description:"",type:"Integer"},{name:"dy",description:"",type:"Integer"},{name:"dw",description:"",type:"Integer"},{name:"dh",description:"",type:"Integer"},{name:"blendMode",description:"",type:"Constant"}]}]},copy:{name:"copy",class:"p5",module:"Image",overloads:[{params:[{name:"srcImage",description:"<p>source image</p>\n",type:"p5.Image|p5.Element"},{name:"sx",description:"<p>X coordinate of the source's upper left corner</p>\n",type:"Integer"},{name:"sy",description:"<p>Y coordinate of the source's upper left corner</p>\n",type:"Integer"},{name:"sw",description:"<p>source image width</p>\n",type:"Integer"},{name:"sh",description:"<p>source image height</p>\n",type:"Integer"},{name:"dx",description:"<p>X coordinate of the destination's upper left corner</p>\n",type:"Integer"},{name:"dy",description:"<p>Y coordinate of the destination's upper left corner</p>\n",type:"Integer"},{name:"dw",description:"<p>destination image width</p>\n",type:"Integer"},{name:"dh",description:"<p>destination image height</p>\n",type:"Integer"}]},{params:[{name:"sx",description:"",type:"Integer"},{name:"sy",description:"",type:"Integer"},{name:"sw",description:"",type:"Integer"},{name:"sh",description:"",type:"Integer"},{name:"dx",description:"",type:"Integer"},{name:"dy",description:"",type:"Integer"},{name:"dw",description:"",type:"Integer"},{name:"dh",description:"",type:"Integer"}]}]},filter:{name:"filter",params:[{name:"filterType",description:"<p>either THRESHOLD, GRAY, OPAQUE, INVERT,\n                               POSTERIZE, BLUR, ERODE, DILATE or BLUR.\n                               See Filters.js for docs on\n                               each available filter</p>\n",type:"Constant"},{name:"filterParam",description:"<p>an optional parameter unique\n                               to each filter, see above</p>\n",type:"Number",optional:!0}],class:"p5",module:"Image"},get:{name:"get",class:"p5",module:"Image",overloads:[{params:[{name:"x",description:"<p>x-coordinate of the pixel</p>\n",type:"Number"},{name:"y",description:"<p>y-coordinate of the pixel</p>\n",type:"Number"},{name:"w",description:"<p>width</p>\n",type:"Number"},{name:"h",description:"<p>height</p>\n",type:"Number"}]},{params:[]},{params:[{name:"x",description:"",type:"Number"},{name:"y",description:"",type:"Number"}]}]},loadPixels:{name:"loadPixels",class:"p5",module:"Image"},set:{name:"set",params:[{name:"x",description:"<p>x-coordinate of the pixel</p>\n",type:"Number"},{name:"y",description:"<p>y-coordinate of the pixel</p>\n",type:"Number"},{name:"c",description:'<p>insert a grayscale value | a pixel array |\n                               a <a href="#/p5.Color">p5.Color</a> object | a <a href="#/p5.Image">p5.Image</a> to copy</p>\n',type:"Number|Number[]|Object"}],class:"p5",module:"Image"},updatePixels:{name:"updatePixels",params:[{name:"x",description:"<p>x-coordinate of the upper-left corner of region\n                        to update</p>\n",type:"Number",optional:!0},{name:"y",description:"<p>y-coordinate of the upper-left corner of region\n                        to update</p>\n",type:"Number",optional:!0},{name:"w",description:"<p>width of region to update</p>\n",type:"Number",optional:!0},{name:"h",description:"<p>height of region to update</p>\n",type:"Number",optional:!0}],class:"p5",module:"Image"},loadJSON:{name:"loadJSON",class:"p5",module:"IO",overloads:[{params:[{name:"path",description:"<p>name of the file or url to load</p>\n",type:"String"},{name:"jsonpOptions",description:"<p>options object for jsonp related settings</p>\n",type:"Object",optional:!0},{name:"datatype",description:'<p>"json" or "jsonp"</p>\n',type:"String",optional:!0},{name:"callback",description:'<p>function to be executed after\n                                   <a href="#/p5/loadJSON">loadJSON()</a> completes, data is passed\n                                   in as first argument</p>\n',type:"Function",optional:!0},{name:"errorCallback",description:"<p>function to be executed if\n                                   there is an error, response is passed\n                                   in as first argument</p>\n",type:"Function",optional:!0}]},{params:[{name:"path",description:"",type:"String"},{name:"datatype",description:"",type:"String"},{name:"callback",description:"",type:"Function",optional:!0},{name:"errorCallback",description:"",type:"Function",optional:!0}]},{params:[{name:"path",description:"",type:"String"},{name:"callback",description:"",type:"Function"},{name:"errorCallback",description:"",type:"Function",optional:!0}]}]},loadStrings:{name:"loadStrings",params:[{name:"filename",description:"<p>name of the file or url to load</p>\n",type:"String"},{name:"callback",description:'<p>function to be executed after <a href="#/p5/loadStrings">loadStrings()</a>\n                              completes, Array is passed in as first\n                              argument</p>\n',type:"Function",optional:!0},{name:"errorCallback",description:"<p>function to be executed if\n                              there is an error, response is passed\n                              in as first argument</p>\n",type:"Function",optional:!0}],class:"p5",module:"IO"},loadTable:{name:"loadTable",params:[{name:"filename",description:"<p>name of the file or URL to load</p>\n",type:"String"},{name:"extension",description:'<p>parse the table by comma-separated values "csv", semicolon-separated\n                                     values "ssv", or tab-separated values "tsv"</p>\n',type:"String",optional:!0},{name:"header",description:'<p>"header" to indicate table has header row</p>\n',type:"String",optional:!0},{name:"callback",description:'<p>function to be executed after\n                                     <a href="#/p5/loadTable">loadTable()</a> completes. On success, the\n                                     <a href="#/p5.Table">Table</a> object is passed in as the\n                                     first argument.</p>\n',type:"Function",optional:!0},{name:"errorCallback",description:"<p>function to be executed if\n                                     there is an error, response is passed\n                                     in as first argument</p>\n",type:"Function",optional:!0}],class:"p5",module:"IO"},loadXML:{name:"loadXML",params:[{name:"filename",description:"<p>name of the file or URL to load</p>\n",type:"String"},{name:"callback",description:'<p>function to be executed after <a href="#/p5/loadXML">loadXML()</a>\n                              completes, XML object is passed in as\n                              first argument</p>\n',type:"Function",optional:!0},{name:"errorCallback",description:"<p>function to be executed if\n                              there is an error, response is passed\n                              in as first argument</p>\n",type:"Function",optional:!0}],class:"p5",module:"IO"},loadBytes:{name:"loadBytes",params:[{name:"file",description:"<p>name of the file or URL to load</p>\n",type:"String"},{name:"callback",description:'<p>function to be executed after <a href="#/p5/loadBytes">loadBytes()</a>\n                                   completes</p>\n',type:"Function",optional:!0},{name:"errorCallback",description:"<p>function to be executed if there\n                                   is an error</p>\n",type:"Function",optional:!0}],class:"p5",module:"IO"},httpGet:{name:"httpGet",class:"p5",module:"IO",overloads:[{params:[{name:"path",description:"<p>name of the file or url to load</p>\n",type:"String"},{name:"datatype",description:'<p>"json", "jsonp", "binary", "arrayBuffer",\n                                   "xml", or "text"</p>\n',type:"String",optional:!0},{name:"data",description:"<p>param data passed sent with request</p>\n",type:"Object|Boolean",optional:!0},{name:"callback",description:'<p>function to be executed after\n                                   <a href="#/p5/httpGet">httpGet()</a> completes, data is passed in\n                                   as first argument</p>\n',type:"Function",optional:!0},{name:"errorCallback",description:"<p>function to be executed if\n                                   there is an error, response is passed\n                                   in as first argument</p>\n",type:"Function",optional:!0}]},{params:[{name:"path",description:"",type:"String"},{name:"data",description:"",type:"Object|Boolean"},{name:"callback",description:"",type:"Function",optional:!0},{name:"errorCallback",description:"",type:"Function",optional:!0}]},{params:[{name:"path",description:"",type:"String"},{name:"callback",description:"",type:"Function"},{name:"errorCallback",description:"",type:"Function",optional:!0}]}]},httpPost:{name:"httpPost",class:"p5",module:"IO",overloads:[{params:[{name:"path",description:"<p>name of the file or url to load</p>\n",type:"String"},{name:"datatype",description:'<p>"json", "jsonp", "xml", or "text".\n                                   If omitted, <a href="#/p5/httpPost">httpPost()</a> will guess.</p>\n',type:"String",optional:!0},{name:"data",description:"<p>param data passed sent with request</p>\n",type:"Object|Boolean",optional:!0},{name:"callback",description:'<p>function to be executed after\n                                   <a href="#/p5/httpPost">httpPost()</a> completes, data is passed in\n                                   as first argument</p>\n',type:"Function",optional:!0},{name:"errorCallback",description:"<p>function to be executed if\n                                   there is an error, response is passed\n                                   in as first argument</p>\n",type:"Function",optional:!0}]},{params:[{name:"path",description:"",type:"String"},{name:"data",description:"",type:"Object|Boolean"},{name:"callback",description:"",type:"Function",optional:!0},{name:"errorCallback",description:"",type:"Function",optional:!0}]},{params:[{name:"path",description:"",type:"String"},{name:"callback",description:"",type:"Function"},{name:"errorCallback",description:"",type:"Function",optional:!0}]}]},httpDo:{name:"httpDo",class:"p5",module:"IO",overloads:[{params:[{name:"path",description:"<p>name of the file or url to load</p>\n",type:"String"},{name:"method",description:'<p>either "GET", "POST", or "PUT",\n                                   defaults to "GET"</p>\n',type:"String",optional:!0},{name:"datatype",description:'<p>"json", "jsonp", "xml", or "text"</p>\n',type:"String",optional:!0},{name:"data",description:"<p>param data passed sent with request</p>\n",type:"Object",optional:!0},{name:"callback",description:'<p>function to be executed after\n                                   <a href="#/p5/httpGet">httpGet()</a> completes, data is passed in\n                                   as first argument</p>\n',type:"Function",optional:!0},{name:"errorCallback",description:"<p>function to be executed if\n                                   there is an error, response is passed\n                                   in as first argument</p>\n",type:"Function",optional:!0}]},{params:[{name:"path",description:"",type:"String"},{name:"options",description:'<p>Request object options as documented in the\n                                   "fetch" API\n<a href="https://developer.mozilla.org/en/docs/Web/API/Fetch_API">reference</a></p>\n',type:"Object"},{name:"callback",description:"",type:"Function",optional:!0},{name:"errorCallback",description:"",type:"Function",optional:!0}]}]},createWriter:{name:"createWriter",params:[{name:"name",description:"<p>name of the file to be created</p>\n",type:"String"},{name:"extension",description:"",type:"String",optional:!0}],class:"p5",module:"IO"},save:{name:"save",params:[{name:"objectOrFilename",description:"<p>If filename is provided, will\n                                           save canvas as an image with\n                                           either png or jpg extension\n                                           depending on the filename.\n                                           If object is provided, will\n                                           save depending on the object\n                                           and filename (see examples\n                                           above).</p>\n",type:"Object|String",optional:!0},{name:"filename",description:"<p>If an object is provided as the first\n                             parameter, then the second parameter\n                             indicates the filename,\n                             and should include an appropriate\n                             file extension (see examples above).</p>\n",type:"String",optional:!0},{name:"options",description:"<p>Additional options depend on\n                          filetype. For example, when saving JSON,\n                          <code>true</code> indicates that the\n                          output will be optimized for filesize,\n                          rather than readability.</p>\n",type:"Boolean|String",optional:!0}],class:"p5",module:"IO"},saveJSON:{name:"saveJSON",params:[{name:"json",description:"",type:"Array|Object"},{name:"filename",description:"",type:"String"},{name:"optimize",description:"<p>If true, removes line breaks\n                               and spaces from the output\n                               file to optimize filesize\n                               (but not readability).</p>\n",type:"Boolean",optional:!0}],class:"p5",module:"IO"},saveStrings:{name:"saveStrings",params:[{name:"list",description:"<p>string array to be written</p>\n",type:"String[]"},{name:"filename",description:"<p>filename for output</p>\n",type:"String"},{name:"extension",description:"<p>the filename's extension</p>\n",type:"String",optional:!0},{name:"isCRLF",description:"<p>if true, change line-break to CRLF</p>\n",type:"Boolean",optional:!0}],class:"p5",module:"IO"},saveTable:{name:"saveTable",params:[{name:"Table",description:'<p>the <a href="#/p5.Table">Table</a> object to save to a file</p>\n',type:"p5.Table"},{name:"filename",description:"<p>the filename to which the Table should be saved</p>\n",type:"String"},{name:"options",description:'<p>can be one of "tsv", "csv", or "html"</p>\n',type:"String",optional:!0}],class:"p5",module:"IO"},abs:{name:"abs",params:[{name:"n",description:"<p>number to compute</p>\n",type:"Number"}],class:"p5",module:"Math"},ceil:{name:"ceil",params:[{name:"n",description:"<p>number to round up</p>\n",type:"Number"}],class:"p5",module:"Math"},constrain:{name:"constrain",params:[{name:"n",description:"<p>number to constrain</p>\n",type:"Number"},{name:"low",description:"<p>minimum limit</p>\n",type:"Number"},{name:"high",description:"<p>maximum limit</p>\n",type:"Number"}],class:"p5",module:"Math"},dist:{name:"dist",class:"p5",module:"Math",overloads:[{params:[{name:"x1",description:"<p>x-coordinate of the first point</p>\n",type:"Number"},{name:"y1",description:"<p>y-coordinate of the first point</p>\n",type:"Number"},{name:"x2",description:"<p>x-coordinate of the second point</p>\n",type:"Number"},{name:"y2",description:"<p>y-coordinate of the second point</p>\n",type:"Number"}]},{params:[{name:"x1",description:"",type:"Number"},{name:"y1",description:"",type:"Number"},{name:"z1",description:"<p>z-coordinate of the first point</p>\n",type:"Number"},{name:"x2",description:"",type:"Number"},{name:"y2",description:"",type:"Number"},{name:"z2",description:"<p>z-coordinate of the second point</p>\n",type:"Number"}]}]},exp:{name:"exp",params:[{name:"n",description:"<p>exponent to raise</p>\n",type:"Number"}],class:"p5",module:"Math"},floor:{name:"floor",params:[{name:"n",description:"<p>number to round down</p>\n",type:"Number"}],class:"p5",module:"Math"},lerp:{name:"lerp",params:[{name:"start",description:"<p>first value</p>\n",type:"Number"},{name:"stop",description:"<p>second value</p>\n",type:"Number"},{name:"amt",description:"<p>number</p>\n",type:"Number"}],class:"p5",module:"Math"},log:{name:"log",params:[{name:"n",description:"<p>number greater than 0</p>\n",type:"Number"}],class:"p5",module:"Math"},mag:{name:"mag",params:[{name:"a",description:"<p>first value</p>\n",type:"Number"},{name:"b",description:"<p>second value</p>\n",type:"Number"}],class:"p5",module:"Math"},map:{name:"map",params:[{name:"value",description:"<p>the incoming value to be converted</p>\n",type:"Number"},{name:"start1",description:"<p>lower bound of the value's current range</p>\n",type:"Number"},{name:"stop1",description:"<p>upper bound of the value's current range</p>\n",type:"Number"},{name:"start2",description:"<p>lower bound of the value's target range</p>\n",type:"Number"},{name:"stop2",description:"<p>upper bound of the value's target range</p>\n",type:"Number"},{name:"withinBounds",description:"<p>constrain the value to the newly mapped range</p>\n",type:"Boolean",optional:!0}],class:"p5",module:"Math"},max:{name:"max",class:"p5",module:"Math",overloads:[{params:[{name:"n0",description:"<p>Number to compare</p>\n",type:"Number"},{name:"n1",description:"<p>Number to compare</p>\n",type:"Number"}]},{params:[{name:"nums",description:"<p>Numbers to compare</p>\n",type:"Number[]"}]}]},min:{name:"min",class:"p5",module:"Math",overloads:[{params:[{name:"n0",description:"<p>Number to compare</p>\n",type:"Number"},{name:"n1",description:"<p>Number to compare</p>\n",type:"Number"}]},{params:[{name:"nums",description:"<p>Numbers to compare</p>\n",type:"Number[]"}]}]},norm:{name:"norm",params:[{name:"value",description:"<p>incoming value to be normalized</p>\n",type:"Number"},{name:"start",description:"<p>lower bound of the value's current range</p>\n",type:"Number"},{name:"stop",description:"<p>upper bound of the value's current range</p>\n",type:"Number"}],class:"p5",module:"Math"},pow:{name:"pow",params:[{name:"n",description:"<p>base of the exponential expression</p>\n",type:"Number"},{name:"e",description:"<p>power by which to raise the base</p>\n",type:"Number"}],class:"p5",module:"Math"},round:{name:"round",params:[{name:"n",description:"<p>number to round</p>\n",type:"Number"},{name:"decimals",description:"<p>number of decimal places to round to, default is 0</p>\n",type:"Number",optional:!0}],class:"p5",module:"Math"},sq:{name:"sq",params:[{name:"n",description:"<p>number to square</p>\n",type:"Number"}],class:"p5",module:"Math"},sqrt:{name:"sqrt",params:[{name:"n",description:"<p>non-negative number to square root</p>\n",type:"Number"}],class:"p5",module:"Math"},fract:{name:"fract",params:[{name:"num",description:"<p>Number whose fractional part needs to be found out</p>\n",type:"Number"}],class:"p5",module:"Math"},createVector:{name:"createVector",params:[{name:"x",description:"<p>x component of the vector</p>\n",type:"Number",optional:!0},{name:"y",description:"<p>y component of the vector</p>\n",type:"Number",optional:!0},{name:"z",description:"<p>z component of the vector</p>\n",type:"Number",optional:!0}],class:"p5",module:"Math"},noise:{name:"noise",params:[{name:"x",description:"<p>x-coordinate in noise space</p>\n",type:"Number"},{name:"y",description:"<p>y-coordinate in noise space</p>\n",type:"Number",optional:!0},{name:"z",description:"<p>z-coordinate in noise space</p>\n",type:"Number",optional:!0}],class:"p5",module:"Math"},noiseDetail:{name:"noiseDetail",params:[{name:"lod",description:"<p>number of octaves to be used by the noise</p>\n",type:"Number"},{name:"falloff",description:"<p>falloff factor for each octave</p>\n",type:"Number"}],class:"p5",module:"Math"},noiseSeed:{name:"noiseSeed",params:[{name:"seed",description:"<p>the seed value</p>\n",type:"Number"}],class:"p5",module:"Math"},randomSeed:{name:"randomSeed",params:[{name:"seed",description:"<p>the seed value</p>\n",type:"Number"}],class:"p5",module:"Math"},random:{name:"random",class:"p5",module:"Math",overloads:[{params:[{name:"min",description:"<p>the lower bound (inclusive)</p>\n",type:"Number",optional:!0},{name:"max",description:"<p>the upper bound (exclusive)</p>\n",type:"Number",optional:!0}]},{params:[{name:"choices",description:"<p>the array to choose from</p>\n",type:"Array"}]}]},randomGaussian:{name:"randomGaussian",params:[{name:"mean",description:"<p>the mean</p>\n",type:"Number"},{name:"sd",description:"<p>the standard deviation</p>\n",type:"Number"}],class:"p5",module:"Math"},acos:{name:"acos",params:[{name:"value",description:"<p>the value whose arc cosine is to be returned</p>\n",type:"Number"}],class:"p5",module:"Math"},asin:{name:"asin",params:[{name:"value",description:"<p>the value whose arc sine is to be returned</p>\n",type:"Number"}],class:"p5",module:"Math"},atan:{name:"atan",params:[{name:"value",description:"<p>the value whose arc tangent is to be returned</p>\n",type:"Number"}],class:"p5",module:"Math"},atan2:{name:"atan2",params:[{name:"y",description:"<p>y-coordinate of the point</p>\n",type:"Number"},{name:"x",description:"<p>x-coordinate of the point</p>\n",type:"Number"}],class:"p5",module:"Math"},cos:{name:"cos",params:[{name:"angle",description:"<p>the angle</p>\n",type:"Number"}],class:"p5",module:"Math"},sin:{name:"sin",params:[{name:"angle",description:"<p>the angle</p>\n",type:"Number"}],class:"p5",module:"Math"},tan:{name:"tan",params:[{name:"angle",description:"<p>the angle</p>\n",type:"Number"}],class:"p5",module:"Math"},degrees:{name:"degrees",params:[{name:"radians",description:"<p>the radians value to convert to degrees</p>\n",type:"Number"}],class:"p5",module:"Math"},radians:{name:"radians",params:[{name:"degrees",description:"<p>the degree value to convert to radians</p>\n",type:"Number"}],class:"p5",module:"Math"},angleMode:{name:"angleMode",params:[{name:"mode",description:"<p>either RADIANS or DEGREES</p>\n",type:"Constant"}],class:"p5",module:"Math"},textAlign:{name:"textAlign",class:"p5",module:"Typography",overloads:[{params:[{name:"horizAlign",description:"<p>horizontal alignment, either LEFT,\n                           CENTER, or RIGHT</p>\n",type:"Constant"},{name:"vertAlign",description:"<p>vertical alignment, either TOP,\n                           BOTTOM, CENTER, or BASELINE</p>\n",type:"Constant",optional:!0}],chainable:1},{params:[]}]},textLeading:{name:"textLeading",class:"p5",module:"Typography",overloads:[{params:[{name:"leading",description:"<p>the size in pixels for spacing between lines</p>\n",type:"Number"}],chainable:1},{params:[]}]},textSize:{name:"textSize",class:"p5",module:"Typography",overloads:[{params:[{name:"theSize",description:"<p>the size of the letters in units of pixels</p>\n",type:"Number"}],chainable:1},{params:[]}]},textStyle:{name:"textStyle",class:"p5",module:"Typography",overloads:[{params:[{name:"theStyle",description:"<p>styling for text, either NORMAL,\n                           ITALIC, BOLD or BOLDITALIC</p>\n",type:"Constant"}],chainable:1},{params:[]}]},textWidth:{name:"textWidth",params:[{name:"theText",description:"<p>the String of characters to measure</p>\n",type:"String"}],class:"p5",module:"Typography"},textAscent:{name:"textAscent",class:"p5",module:"Typography"},textDescent:{name:"textDescent",class:"p5",module:"Typography"},loadFont:{name:"loadFont",params:[{name:"path",description:"<p>name of the file or url to load</p>\n",type:"String"},{name:"callback",description:'<p>function to be executed after\n                                   <a href="#/p5/loadFont">loadFont()</a> completes</p>\n',type:"Function",optional:!0},{name:"onError",description:"<p>function to be executed if\n                                   an error occurs</p>\n",type:"Function",optional:!0}],class:"p5",module:"Typography"},text:{name:"text",params:[{name:"str",description:"<p>the alphanumeric\n                                            symbols to be displayed</p>\n",type:"String|Object|Array|Number|Boolean"},{name:"x",description:"<p>x-coordinate of text</p>\n",type:"Number"},{name:"y",description:"<p>y-coordinate of text</p>\n",type:"Number"},{name:"x2",description:'<p>by default, the width of the text box,\n                    see <a href="#/p5/rectMode">rectMode()</a> for more info</p>\n',type:"Number",optional:!0},{name:"y2",description:'<p>by default, the height of the text box,\n                    see <a href="#/p5/rectMode">rectMode()</a> for more info</p>\n',type:"Number",optional:!0}],class:"p5",module:"Typography"},textFont:{name:"textFont",class:"p5",module:"Typography",overloads:[{params:[]},{params:[{name:"font",description:'<p>a font loaded via <a href="#/p5/loadFont">loadFont()</a>,\nor a String representing a <a href="https://mzl.la/2dOw8WD">web safe font</a>\n(a font that is generally available across all systems)</p>\n',type:"Object|String"},{name:"size",description:"<p>the font size to use</p>\n",type:"Number",optional:!0}],chainable:1}]},append:{name:"append",params:[{name:"array",description:"<p>Array to append</p>\n",type:"Array"},{name:"value",description:"<p>to be added to the Array</p>\n",type:"Any"}],class:"p5",module:"Data"},arrayCopy:{name:"arrayCopy",class:"p5",module:"Data",overloads:[{params:[{name:"src",description:"<p>the source Array</p>\n",type:"Array"},{name:"srcPosition",description:"<p>starting position in the source Array</p>\n",type:"Integer"},{name:"dst",description:"<p>the destination Array</p>\n",type:"Array"},{name:"dstPosition",description:"<p>starting position in the destination Array</p>\n",type:"Integer"},{name:"length",description:"<p>number of Array elements to be copied</p>\n",type:"Integer"}]},{params:[{name:"src",description:"",type:"Array"},{name:"dst",description:"",type:"Array"},{name:"length",description:"",type:"Integer",optional:!0}]}]},concat:{name:"concat",params:[{name:"a",description:"<p>first Array to concatenate</p>\n",type:"Array"},{name:"b",description:"<p>second Array to concatenate</p>\n",type:"Array"}],class:"p5",module:"Data"},reverse:{name:"reverse",params:[{name:"list",description:"<p>Array to reverse</p>\n",type:"Array"}],class:"p5",module:"Data"},shorten:{name:"shorten",params:[{name:"list",description:"<p>Array to shorten</p>\n",type:"Array"}],class:"p5",module:"Data"},shuffle:{name:"shuffle",params:[{name:"array",description:"<p>Array to shuffle</p>\n",type:"Array"},{name:"bool",description:"<p>modify passed array</p>\n",type:"Boolean",optional:!0}],class:"p5",module:"Data"},sort:{name:"sort",params:[{name:"list",description:"<p>Array to sort</p>\n",type:"Array"},{name:"count",description:"<p>number of elements to sort, starting from 0</p>\n",type:"Integer",optional:!0}],class:"p5",module:"Data"},splice:{name:"splice",params:[{name:"list",description:"<p>Array to splice into</p>\n",type:"Array"},{name:"value",description:"<p>value to be spliced in</p>\n",type:"Any"},{name:"position",description:"<p>in the array from which to insert data</p>\n",type:"Integer"}],class:"p5",module:"Data"},subset:{name:"subset",params:[{name:"list",description:"<p>Array to extract from</p>\n",type:"Array"},{name:"start",description:"<p>position to begin</p>\n",type:"Integer"},{name:"count",description:"<p>number of values to extract</p>\n",type:"Integer",optional:!0}],class:"p5",module:"Data"},float:{name:"float",params:[{name:"str",description:"<p>float string to parse</p>\n",type:"String"}],class:"p5",module:"Data"},int:{name:"int",class:"p5",module:"Data",overloads:[{params:[{name:"n",description:"<p>value to parse</p>\n",type:"String|Boolean|Number"},{name:"radix",description:"<p>the radix to convert to (default: 10)</p>\n",type:"Integer",optional:!0}]},{params:[{name:"ns",description:"<p>values to parse</p>\n",type:"Array"}]}]},str:{name:"str",params:[{name:"n",description:"<p>value to parse</p>\n",type:"String|Boolean|Number|Array"}],class:"p5",module:"Data"},byte:{name:"byte",class:"p5",module:"Data",overloads:[{params:[{name:"n",description:"<p>value to parse</p>\n",type:"String|Boolean|Number"}]},{params:[{name:"ns",description:"<p>values to parse</p>\n",type:"Array"}]}]},char:{name:"char",class:"p5",module:"Data",overloads:[{params:[{name:"n",description:"<p>value to parse</p>\n",type:"String|Number"}]},{params:[{name:"ns",description:"<p>values to parse</p>\n",type:"Array"}]}]},unchar:{name:"unchar",class:"p5",module:"Data",overloads:[{params:[{name:"n",description:"<p>value to parse</p>\n",type:"String"}]},{params:[{name:"ns",description:"<p>values to parse</p>\n",type:"Array"}]}]},hex:{name:"hex",class:"p5",module:"Data",overloads:[{params:[{name:"n",description:"<p>value to parse</p>\n",type:"Number"},{name:"digits",description:"",type:"Number",optional:!0}]},{params:[{name:"ns",description:"<p>array of values to parse</p>\n",type:"Number[]"},{name:"digits",description:"",type:"Number",optional:!0}]}]},unhex:{name:"unhex",class:"p5",module:"Data",overloads:[{params:[{name:"n",description:"<p>value to parse</p>\n",type:"String"}]},{params:[{name:"ns",description:"<p>values to parse</p>\n",type:"Array"}]}]},join:{name:"join",params:[{name:"list",description:"<p>array of Strings to be joined</p>\n",type:"Array"},{name:"separator",description:"<p>String to be placed between each item</p>\n",type:"String"}],class:"p5",module:"Data"},match:{name:"match",params:[{name:"str",description:"<p>the String to be searched</p>\n",type:"String"},{name:"regexp",description:"<p>the regexp to be used for matching</p>\n",type:"String"}],class:"p5",module:"Data"},matchAll:{name:"matchAll",params:[{name:"str",description:"<p>the String to be searched</p>\n",type:"String"},{name:"regexp",description:"<p>the regexp to be used for matching</p>\n",type:"String"}],class:"p5",module:"Data"},nf:{name:"nf",class:"p5",module:"Data",overloads:[{params:[{name:"num",description:"<p>the Number to format</p>\n",type:"Number|String"},{name:"left",description:"<p>number of digits to the left of the\n                               decimal point</p>\n",type:"Integer|String",optional:!0},{name:"right",description:"<p>number of digits to the right of the\n                               decimal point</p>\n",type:"Integer|String",optional:!0}]},{params:[{name:"nums",description:"<p>the Numbers to format</p>\n",type:"Array"},{name:"left",description:"",type:"Integer|String",optional:!0},{name:"right",description:"",type:"Integer|String",optional:!0}]}]},nfc:{name:"nfc",class:"p5",module:"Data",overloads:[{params:[{name:"num",description:"<p>the Number to format</p>\n",type:"Number|String"},{name:"right",description:"<p>number of digits to the right of the\n                                 decimal point</p>\n",type:"Integer|String",optional:!0}]},{params:[{name:"nums",description:"<p>the Numbers to format</p>\n",type:"Array"},{name:"right",description:"",type:"Integer|String",optional:!0}]}]},nfp:{name:"nfp",class:"p5",module:"Data",overloads:[{params:[{name:"num",description:"<p>the Number to format</p>\n",type:"Number"},{name:"left",description:"<p>number of digits to the left of the decimal\n                               point</p>\n",type:"Integer",optional:!0},{name:"right",description:"<p>number of digits to the right of the\n                               decimal point</p>\n",type:"Integer",optional:!0}]},{params:[{name:"nums",description:"<p>the Numbers to format</p>\n",type:"Number[]"},{name:"left",description:"",type:"Integer",optional:!0},{name:"right",description:"",type:"Integer",optional:!0}]}]},nfs:{name:"nfs",class:"p5",module:"Data",overloads:[{params:[{name:"num",description:"<p>the Number to format</p>\n",type:"Number"},{name:"left",description:"<p>number of digits to the left of the decimal\n                               point</p>\n",type:"Integer",optional:!0},{name:"right",description:"<p>number of digits to the right of the\n                               decimal point</p>\n",type:"Integer",optional:!0}]},{params:[{name:"nums",description:"<p>the Numbers to format</p>\n",type:"Array"},{name:"left",description:"",type:"Integer",optional:!0},{name:"right",description:"",type:"Integer",optional:!0}]}]},split:{name:"split",params:[{name:"value",description:"<p>the String to be split</p>\n",type:"String"},{name:"delim",description:"<p>the String used to separate the data</p>\n",type:"String"}],class:"p5",module:"Data"},splitTokens:{name:"splitTokens",params:[{name:"value",description:"<p>the String to be split</p>\n",type:"String"},{name:"delim",description:"<p>list of individual Strings that will be used as\n                         separators</p>\n",type:"String",optional:!0}],class:"p5",module:"Data"},trim:{name:"trim",class:"p5",module:"Data",overloads:[{params:[{name:"str",description:"<p>a String to be trimmed</p>\n",type:"String"}]},{params:[{name:"strs",description:"<p>an Array of Strings to be trimmed</p>\n",type:"Array"}]}]},day:{name:"day",class:"p5",module:"IO"},hour:{name:"hour",class:"p5",module:"IO"},minute:{name:"minute",class:"p5",module:"IO"},millis:{name:"millis",class:"p5",module:"IO"},month:{name:"month",class:"p5",module:"IO"},second:{name:"second",class:"p5",module:"IO"},year:{name:"year",class:"p5",module:"IO"},plane:{name:"plane",params:[{name:"width",description:"<p>width of the plane</p>\n",type:"Number",optional:!0},{name:"height",description:"<p>height of the plane</p>\n",type:"Number",optional:!0},{name:"detailX",description:"<p>Optional number of triangle\n                            subdivisions in x-dimension</p>\n",type:"Integer",optional:!0},{name:"detailY",description:"<p>Optional number of triangle\n                            subdivisions in y-dimension</p>\n",type:"Integer",optional:!0}],class:"p5",module:"Shape"},box:{name:"box",params:[{name:"width",description:"<p>width of the box</p>\n",type:"Number",optional:!0},{name:"Height",description:"<p>height of the box</p>\n",type:"Number",optional:!0},{name:"depth",description:"<p>depth of the box</p>\n",type:"Number",optional:!0},{name:"detailX",description:"<p>Optional number of triangle\n                           subdivisions in x-dimension</p>\n",type:"Integer",optional:!0},{name:"detailY",description:"<p>Optional number of triangle\n                           subdivisions in y-dimension</p>\n",type:"Integer",optional:!0}],class:"p5",module:"Shape"},sphere:{name:"sphere",params:[{name:"radius",description:"<p>radius of circle</p>\n",type:"Number",optional:!0},{name:"detailX",description:"<p>optional number of subdivisions in x-dimension</p>\n",type:"Integer",optional:!0},{name:"detailY",description:"<p>optional number of subdivisions in y-dimension</p>\n",type:"Integer",optional:!0}],class:"p5",module:"Shape"},cylinder:{name:"cylinder",params:[{name:"radius",description:"<p>radius of the surface</p>\n",type:"Number",optional:!0},{name:"height",description:"<p>height of the cylinder</p>\n",type:"Number",optional:!0},{name:"detailX",description:"<p>number of subdivisions in x-dimension;\n                              default is 24</p>\n",type:"Integer",optional:!0},{name:"detailY",description:"<p>number of subdivisions in y-dimension;\n                              default is 1</p>\n",type:"Integer",optional:!0},{name:"bottomCap",description:"<p>whether to draw the bottom of the cylinder</p>\n",type:"Boolean",optional:!0},{name:"topCap",description:"<p>whether to draw the top of the cylinder</p>\n",type:"Boolean",optional:!0}],class:"p5",module:"Shape"},cone:{name:"cone",params:[{name:"radius",description:"<p>radius of the bottom surface</p>\n",type:"Number",optional:!0},{name:"height",description:"<p>height of the cone</p>\n",type:"Number",optional:!0},{name:"detailX",description:"<p>number of segments,\n                            the more segments the smoother geometry\n                            default is 24</p>\n",type:"Integer",optional:!0},{name:"detailY",description:"<p>number of segments,\n                            the more segments the smoother geometry\n                            default is 1</p>\n",type:"Integer",optional:!0},{name:"cap",description:"<p>whether to draw the base of the cone</p>\n",type:"Boolean",optional:!0}],class:"p5",module:"Shape"},ellipsoid:{name:"ellipsoid",params:[{name:"radiusx",description:"<p>x-radius of ellipsoid</p>\n",type:"Number",optional:!0},{name:"radiusy",description:"<p>y-radius of ellipsoid</p>\n",type:"Number",optional:!0},{name:"radiusz",description:"<p>z-radius of ellipsoid</p>\n",type:"Number",optional:!0},{name:"detailX",description:"<p>number of segments,\n                                   the more segments the smoother geometry\n                                   default is 24. Avoid detail number above\n                                   150, it may crash the browser.</p>\n",type:"Integer",optional:!0},{name:"detailY",description:"<p>number of segments,\n                                   the more segments the smoother geometry\n                                   default is 16. Avoid detail number above\n                                   150, it may crash the browser.</p>\n",type:"Integer",optional:!0}],class:"p5",module:"Shape"},torus:{name:"torus",params:[{name:"radius",description:"<p>radius of the whole ring</p>\n",type:"Number",optional:!0},{name:"tubeRadius",description:"<p>radius of the tube</p>\n",type:"Number",optional:!0},{name:"detailX",description:"<p>number of segments in x-dimension,\n                               the more segments the smoother geometry\n                               default is 24</p>\n",type:"Integer",optional:!0},{name:"detailY",description:"<p>number of segments in y-dimension,\n                               the more segments the smoother geometry\n                               default is 16</p>\n",type:"Integer",optional:!0}],class:"p5",module:"Shape"},orbitControl:{name:"orbitControl",params:[{name:"sensitivityX",description:"<p>sensitivity to mouse movement along X axis</p>\n",type:"Number",optional:!0},{name:"sensitivityY",description:"<p>sensitivity to mouse movement along Y axis</p>\n",type:"Number",optional:!0},{name:"sensitivityZ",description:"<p>sensitivity to scroll movement along Z axis</p>\n",type:"Number",optional:!0}],class:"p5",module:"Lights, Camera"},debugMode:{name:"debugMode",class:"p5",module:"Lights, Camera",overloads:[{params:[]},{params:[{name:"mode",description:"<p>either GRID or AXES</p>\n",type:"Constant"}]},{params:[{name:"mode",description:"",type:"Constant"},{name:"gridSize",description:"<p>size of one side of the grid</p>\n",type:"Number",optional:!0},{name:"gridDivisions",description:"<p>number of divisions in the grid</p>\n",type:"Number",optional:!0},{name:"xOff",description:"<p>X axis offset from origin (0,0,0)</p>\n",type:"Number",optional:!0},{name:"yOff",description:"<p>Y axis offset from origin (0,0,0)</p>\n",type:"Number",optional:!0},{name:"zOff",description:"<p>Z axis offset from origin (0,0,0)</p>\n",type:"Number",optional:!0}]},{params:[{name:"mode",description:"",type:"Constant"},{name:"axesSize",description:"<p>size of axes icon</p>\n",type:"Number",optional:!0},{name:"xOff",description:"",type:"Number",optional:!0},{name:"yOff",description:"",type:"Number",optional:!0},{name:"zOff",description:"",type:"Number",optional:!0}]},{params:[{name:"gridSize",description:"",type:"Number",optional:!0},{name:"gridDivisions",description:"",type:"Number",optional:!0},{name:"gridXOff",description:"",type:"Number",optional:!0},{name:"gridYOff",description:"",type:"Number",optional:!0},{name:"gridZOff",description:"",type:"Number",optional:!0},{name:"axesSize",description:"",type:"Number",optional:!0},{name:"axesXOff",description:"",type:"Number",optional:!0},{name:"axesYOff",description:"",type:"Number",optional:!0},{name:"axesZOff",description:"",type:"Number",optional:!0}]}]},noDebugMode:{name:"noDebugMode",class:"p5",module:"Lights, Camera"},ambientLight:{name:"ambientLight",class:"p5",module:"Lights, Camera",overloads:[{params:[{name:"v1",description:"<p>red or hue value relative to\n                                the current color range</p>\n",type:"Number"},{name:"v2",description:"<p>green or saturation value\n                                relative to the current color range</p>\n",type:"Number"},{name:"v3",description:"<p>blue or brightness value\n                                relative to the current color range</p>\n",type:"Number"},{name:"alpha",description:"<p>the alpha value</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"value",description:"<p>a color string</p>\n",type:"String"}],chainable:1},{params:[{name:"gray",description:"<p>a gray value</p>\n",type:"Number"},{name:"alpha",description:"",type:"Number",optional:!0}],chainable:1},{params:[{name:"values",description:"<p>an array containing the red,green,blue &\n                                and alpha components of the color</p>\n",type:"Number[]"}],chainable:1},{params:[{name:"color",description:"<p>the ambient light color</p>\n",type:"p5.Color"}],chainable:1}]},specularColor:{name:"specularColor",class:"p5",module:"Lights, Camera",overloads:[{params:[{name:"v1",description:"<p>red or hue value relative to\n                                the current color range</p>\n",type:"Number"},{name:"v2",description:"<p>green or saturation value\n                                relative to the current color range</p>\n",type:"Number"},{name:"v3",description:"<p>blue or brightness value\n                                relative to the current color range</p>\n",type:"Number"}],chainable:1},{params:[{name:"value",description:"<p>a color string</p>\n",type:"String"}],chainable:1},{params:[{name:"gray",description:"<p>a gray value</p>\n",type:"Number"}],chainable:1},{params:[{name:"values",description:"<p>an array containing the red,green,blue &\n                                and alpha components of the color</p>\n",type:"Number[]"}],chainable:1},{params:[{name:"color",description:"<p>the ambient light color</p>\n",type:"p5.Color"}],chainable:1}]},directionalLight:{name:"directionalLight",class:"p5",module:"Lights, Camera",overloads:[{params:[{name:"v1",description:"<p>red or hue value (depending on the current\ncolor mode),</p>\n",type:"Number"},{name:"v2",description:"<p>green or saturation value</p>\n",type:"Number"},{name:"v3",description:"<p>blue or brightness value</p>\n",type:"Number"},{name:"position",description:"<p>the direction of the light</p>\n",type:"p5.Vector"}],chainable:1},{params:[{name:"color",description:'<p>color Array, CSS color string,\n                                            or <a href="#/p5.Color">p5.Color</a> value</p>\n',type:"Number[]|String|p5.Color"},{name:"x",description:"<p>x axis direction</p>\n",type:"Number"},{name:"y",description:"<p>y axis direction</p>\n",type:"Number"},{name:"z",description:"<p>z axis direction</p>\n",type:"Number"}],chainable:1},{params:[{name:"color",description:"",type:"Number[]|String|p5.Color"},{name:"position",description:"",type:"p5.Vector"}],chainable:1},{params:[{name:"v1",description:"",type:"Number"},{name:"v2",description:"",type:"Number"},{name:"v3",description:"",type:"Number"},{name:"x",description:"",type:"Number"},{name:"y",description:"",type:"Number"},{name:"z",description:"",type:"Number"}],chainable:1}]},pointLight:{name:"pointLight",class:"p5",module:"Lights, Camera",overloads:[{params:[{name:"v1",description:"<p>red or hue value (depending on the current\ncolor mode),</p>\n",type:"Number"},{name:"v2",description:"<p>green or saturation value</p>\n",type:"Number"},{name:"v3",description:"<p>blue or brightness value</p>\n",type:"Number"},{name:"x",description:"<p>x axis position</p>\n",type:"Number"},{name:"y",description:"<p>y axis position</p>\n",type:"Number"},{name:"z",description:"<p>z axis position</p>\n",type:"Number"}],chainable:1},{params:[{name:"v1",description:"",type:"Number"},{name:"v2",description:"",type:"Number"},{name:"v3",description:"",type:"Number"},{name:"position",description:"<p>the position of the light</p>\n",type:"p5.Vector"}],chainable:1},{params:[{name:"color",description:'<p>color Array, CSS color string,\nor <a href="#/p5.Color">p5.Color</a> value</p>\n',type:"Number[]|String|p5.Color"},{name:"x",description:"",type:"Number"},{name:"y",description:"",type:"Number"},{name:"z",description:"",type:"Number"}],chainable:1},{params:[{name:"color",description:"",type:"Number[]|String|p5.Color"},{name:"position",description:"",type:"p5.Vector"}],chainable:1}]},lights:{name:"lights",class:"p5",module:"Lights, Camera"},lightFalloff:{name:"lightFalloff",params:[{name:"constant",description:"<p>constant value for determining falloff</p>\n",type:"Number"},{name:"linear",description:"<p>linear value for determining falloff</p>\n",type:"Number"},{name:"quadratic",description:"<p>quadratic value for determining falloff</p>\n",type:"Number"}],class:"p5",module:"Lights, Camera"},spotLight:{name:"spotLight",class:"p5",module:"Lights, Camera",overloads:[{params:[{name:"v1",description:"<p>red or hue value (depending on the current\ncolor mode),</p>\n",type:"Number"},{name:"v2",description:"<p>green or saturation value</p>\n",type:"Number"},{name:"v3",description:"<p>blue or brightness value</p>\n",type:"Number"},{name:"x",description:"<p>x axis position</p>\n",type:"Number"},{name:"y",description:"<p>y axis position</p>\n",type:"Number"},{name:"z",description:"<p>z axis position</p>\n",type:"Number"},{name:"rx",description:"<p>x axis direction of light</p>\n",type:"Number"},{name:"ry",description:"<p>y axis direction of light</p>\n",type:"Number"},{name:"rz",description:"<p>z axis direction of light</p>\n",type:"Number"},{name:"angle",description:"<p>optional parameter for angle. Defaults to PI/3</p>\n",type:"Number",optional:!0},{name:"conc",description:"<p>optional parameter for concentration. Defaults to 100</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"color",description:'<p>color Array, CSS color string,\nor <a href="#/p5.Color">p5.Color</a> value</p>\n',type:"Number[]|String|p5.Color"},{name:"position",description:"<p>the position of the light</p>\n",type:"p5.Vector"},{name:"direction",description:"<p>the direction of the light</p>\n",type:"p5.Vector"},{name:"angle",description:"",type:"Number",optional:!0},{name:"conc",description:"",type:"Number",optional:!0}]},{params:[{name:"v1",description:"",type:"Number"},{name:"v2",description:"",type:"Number"},{name:"v3",description:"",type:"Number"},{name:"position",description:"",type:"p5.Vector"},{name:"direction",description:"",type:"p5.Vector"},{name:"angle",description:"",type:"Number",optional:!0},{name:"conc",description:"",type:"Number",optional:!0}]},{params:[{name:"color",description:"",type:"Number[]|String|p5.Color"},{name:"x",description:"",type:"Number"},{name:"y",description:"",type:"Number"},{name:"z",description:"",type:"Number"},{name:"direction",description:"",type:"p5.Vector"},{name:"angle",description:"",type:"Number",optional:!0},{name:"conc",description:"",type:"Number",optional:!0}]},{params:[{name:"color",description:"",type:"Number[]|String|p5.Color"},{name:"position",description:"",type:"p5.Vector"},{name:"rx",description:"",type:"Number"},{name:"ry",description:"",type:"Number"},{name:"rz",description:"",type:"Number"},{name:"angle",description:"",type:"Number",optional:!0},{name:"conc",description:"",type:"Number",optional:!0}]},{params:[{name:"v1",description:"",type:"Number"},{name:"v2",description:"",type:"Number"},{name:"v3",description:"",type:"Number"},{name:"x",description:"",type:"Number"},{name:"y",description:"",type:"Number"},{name:"z",description:"",type:"Number"},{name:"direction",description:"",type:"p5.Vector"},{name:"angle",description:"",type:"Number",optional:!0},{name:"conc",description:"",type:"Number",optional:!0}]},{params:[{name:"v1",description:"",type:"Number"},{name:"v2",description:"",type:"Number"},{name:"v3",description:"",type:"Number"},{name:"position",description:"",type:"p5.Vector"},{name:"rx",description:"",type:"Number"},{name:"ry",description:"",type:"Number"},{name:"rz",description:"",type:"Number"},{name:"angle",description:"",type:"Number",optional:!0},{name:"conc",description:"",type:"Number",optional:!0}]},{params:[{name:"color",description:"",type:"Number[]|String|p5.Color"},{name:"x",description:"",type:"Number"},{name:"y",description:"",type:"Number"},{name:"z",description:"",type:"Number"},{name:"rx",description:"",type:"Number"},{name:"ry",description:"",type:"Number"},{name:"rz",description:"",type:"Number"},{name:"angle",description:"",type:"Number",optional:!0},{name:"conc",description:"",type:"Number",optional:!0}]}]},noLights:{name:"noLights",class:"p5",module:"Lights, Camera"},loadModel:{name:"loadModel",class:"p5",module:"Shape",overloads:[{params:[{name:"path",description:"<p>Path of the model to be loaded</p>\n",type:"String"},{name:"normalize",description:"<p>If true, scale the model to a\n                                     standardized size when loading</p>\n",type:"Boolean"},{name:"successCallback",description:"<p>Function to be called\n                                    once the model is loaded. Will be passed\n                                    the 3D model object.</p>\n",type:"function(p5.Geometry)",optional:!0},{name:"failureCallback",description:"<p>called with event error if\n                                        the model fails to load.</p>\n",type:"Function(Event)",optional:!0},{name:"fileType",description:"<p>The file extension of the model\n                                     (<code>.stl</code>, <code>.obj</code>).</p>\n",type:"String",optional:!0}]},{params:[{name:"path",description:"",type:"String"},{name:"successCallback",description:"",type:"function(p5.Geometry)",optional:!0},{name:"failureCallback",description:"",type:"Function(Event)",optional:!0},{name:"fileType",description:"",type:"String",optional:!0}]}]},model:{name:"model",params:[{name:"model",description:"<p>Loaded 3d model to be rendered</p>\n",type:"p5.Geometry"}],class:"p5",module:"Shape"},loadShader:{name:"loadShader",params:[{name:"vertFilename",description:"<p>path to file containing vertex shader\nsource code</p>\n",type:"String"},{name:"fragFilename",description:"<p>path to file containing fragment shader\nsource code</p>\n",type:"String"},{name:"callback",description:"<p>callback to be executed after loadShader\ncompletes. On success, the Shader object is passed as the first argument.</p>\n",type:"Function",optional:!0},{name:"errorCallback",description:"<p>callback to be executed when an error\noccurs inside loadShader. On error, the error is passed as the first\nargument.</p>\n",type:"Function",optional:!0}],class:"p5",module:"Lights, Camera"},createShader:{name:"createShader",params:[{name:"vertSrc",description:"<p>source code for the vertex shader</p>\n",type:"String"},{name:"fragSrc",description:"<p>source code for the fragment shader</p>\n",type:"String"}],class:"p5",module:"Lights, Camera"},shader:{name:"shader",params:[{name:"s",description:'<p>the desired <a href="#/p5.Shader">p5.Shader</a> to use for rendering\nshapes.</p>\n',type:"p5.Shader",optional:!0}],class:"p5",module:"Lights, Camera"},resetShader:{name:"resetShader",class:"p5",module:"Lights, Camera"},normalMaterial:{name:"normalMaterial",class:"p5",module:"Lights, Camera"},texture:{name:"texture",params:[{name:"tex",description:"<p>2-dimensional graphics\n                   to render as texture</p>\n",type:"p5.Image|p5.MediaElement|p5.Graphics"}],class:"p5",module:"Lights, Camera"},textureMode:{name:"textureMode",params:[{name:"mode",description:"<p>either IMAGE or NORMAL</p>\n",type:"Constant"}],class:"p5",module:"Lights, Camera"},textureWrap:{name:"textureWrap",params:[{name:"wrapX",description:"<p>either CLAMP, REPEAT, or MIRROR</p>\n",type:"Constant"},{name:"wrapY",description:"<p>either CLAMP, REPEAT, or MIRROR</p>\n",type:"Constant",optional:!0}],class:"p5",module:"Lights, Camera"},ambientMaterial:{name:"ambientMaterial",class:"p5",module:"Lights, Camera",overloads:[{params:[{name:"v1",description:"<p>gray value, red or hue value\n                        (depending on the current color mode),</p>\n",type:"Number"},{name:"v2",description:"<p>green or saturation value</p>\n",type:"Number",optional:!0},{name:"v3",description:"<p>blue or brightness value</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"color",description:"<p>color, color Array, or CSS color string</p>\n",type:"Number[]|String|p5.Color"}],chainable:1}]},emissiveMaterial:{name:"emissiveMaterial",class:"p5",module:"Lights, Camera",overloads:[{params:[{name:"v1",description:"<p>gray value, red or hue value\n                        (depending on the current color mode),</p>\n",type:"Number"},{name:"v2",description:"<p>green or saturation value</p>\n",type:"Number",optional:!0},{name:"v3",description:"<p>blue or brightness value</p>\n",type:"Number",optional:!0},{name:"a",description:"<p>opacity</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"color",description:"<p>color, color Array, or CSS color string</p>\n",type:"Number[]|String|p5.Color"}],chainable:1}]},specularMaterial:{name:"specularMaterial",class:"p5",module:"Lights, Camera",overloads:[{params:[{name:"gray",description:"<p>number specifying value between white and black.</p>\n",type:"Number"},{name:"alpha",description:"<p>alpha value relative to current color range\n                                (default is 0-255)</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"v1",description:"<p>red or hue value relative to\n                                the current color range</p>\n",type:"Number"},{name:"v2",description:"<p>green or saturation value\n                                relative to the current color range</p>\n",type:"Number"},{name:"v3",description:"<p>blue or brightness value\n                                relative to the current color range</p>\n",type:"Number"},{name:"alpha",description:"",type:"Number",optional:!0}],chainable:1},{params:[{name:"color",description:"<p>color Array, or CSS color string</p>\n",type:"Number[]|String|p5.Color"}],chainable:1}]},shininess:{name:"shininess",params:[{name:"shine",description:"<p>Degree of Shininess.\n                      Defaults to 1.</p>\n",type:"Number"}],class:"p5",module:"Lights, Camera"},camera:{name:"camera",params:[{name:"x",description:"<p>camera position value on x axis</p>\n",type:"Number",optional:!0},{name:"y",description:"<p>camera position value on y axis</p>\n",type:"Number",optional:!0},{name:"z",description:"<p>camera position value on z axis</p>\n",type:"Number",optional:!0},{name:"centerX",description:"<p>x coordinate representing center of the sketch</p>\n",type:"Number",optional:!0},{name:"centerY",description:"<p>y coordinate representing center of the sketch</p>\n",type:"Number",optional:!0},{name:"centerZ",description:"<p>z coordinate representing center of the sketch</p>\n",type:"Number",optional:!0},{name:"upX",description:"<p>x component of direction 'up' from camera</p>\n",type:"Number",optional:!0},{name:"upY",description:"<p>y component of direction 'up' from camera</p>\n",type:"Number",optional:!0},{name:"upZ",description:"<p>z component of direction 'up' from camera</p>\n",type:"Number",optional:!0}],class:"p5",module:"Lights, Camera"},perspective:{name:"perspective",params:[{name:"fovy",description:'<p>camera frustum vertical field of view,\n                          from bottom to top of view, in <a href="#/p5/angleMode">angleMode</a> units</p>\n',type:"Number",optional:!0},{name:"aspect",description:"<p>camera frustum aspect ratio</p>\n",type:"Number",optional:!0},{name:"near",description:"<p>frustum near plane length</p>\n",type:"Number",optional:!0},{name:"far",description:"<p>frustum far plane length</p>\n",type:"Number",optional:!0}],class:"p5",module:"Lights, Camera"},ortho:{name:"ortho",params:[{name:"left",description:"<p>camera frustum left plane</p>\n",type:"Number",optional:!0},{name:"right",description:"<p>camera frustum right plane</p>\n",type:"Number",optional:!0},{name:"bottom",description:"<p>camera frustum bottom plane</p>\n",type:"Number",optional:!0},{name:"top",description:"<p>camera frustum top plane</p>\n",type:"Number",optional:!0},{name:"near",description:"<p>camera frustum near plane</p>\n",type:"Number",optional:!0},{name:"far",description:"<p>camera frustum far plane</p>\n",type:"Number",optional:!0}],class:"p5",module:"Lights, Camera"},frustum:{name:"frustum",params:[{name:"left",description:"<p>camera frustum left plane</p>\n",type:"Number",optional:!0},{name:"right",description:"<p>camera frustum right plane</p>\n",type:"Number",optional:!0},{name:"bottom",description:"<p>camera frustum bottom plane</p>\n",type:"Number",optional:!0},{name:"top",description:"<p>camera frustum top plane</p>\n",type:"Number",optional:!0},{name:"near",description:"<p>camera frustum near plane</p>\n",type:"Number",optional:!0},{name:"far",description:"<p>camera frustum far plane</p>\n",type:"Number",optional:!0}],class:"p5",module:"Lights, Camera"},createCamera:{name:"createCamera",class:"p5",module:"Lights, Camera"},setCamera:{name:"setCamera",params:[{name:"cam",description:"<p>p5.Camera object</p>\n",type:"p5.Camera"}],class:"p5",module:"Lights, Camera"},setAttributes:{name:"setAttributes",class:"p5",module:"Rendering",overloads:[{params:[{name:"key",description:"<p>Name of attribute</p>\n",type:"String"},{name:"value",description:"<p>New value of named attribute</p>\n",type:"Boolean"}]},{params:[{name:"obj",description:"<p>object with key-value pairs</p>\n",type:"Object"}]}]},sampleRate:{name:"sampleRate",class:"p5",module:"p5.sound"},freqToMidi:{name:"freqToMidi",params:[{name:"frequency",description:'<p>A freqeuncy, for example, the "A"\n                           above Middle C is 440Hz</p>\n',type:"Number"}],class:"p5",module:"p5.sound"},midiToFreq:{name:"midiToFreq",params:[{name:"midiNote",description:"<p>The number of a MIDI note</p>\n",type:"Number"}],class:"p5",module:"p5.sound"},soundFormats:{name:"soundFormats",params:[{name:"formats",description:"<p>i.e. 'mp3', 'wav', 'ogg'</p>\n",type:"String",optional:!0,multiple:!0}],class:"p5",module:"p5.sound"},getAudioContext:{name:"getAudioContext",class:"p5",module:"p5.sound"},userStartAudio:{params:[{name:"element(s)",description:"<p>This argument can be an Element,\n                              Selector String, NodeList, p5.Element,\n                              jQuery Element, or an Array of any of those.</p>\n",type:"Element|Array",optional:!0},{name:"callback",description:"<p>Callback to invoke when the AudioContext\n                              has started</p>\n",type:"Function",optional:!0}],name:"userStartAudio",class:"p5",module:"p5.sound"},loadSound:{name:"loadSound",params:[{name:"path",description:"<p>Path to the sound file, or an array with\n                                  paths to soundfiles in multiple formats\n                                  i.e. ['sound.ogg', 'sound.mp3'].\n                                  Alternately, accepts an object: either\n                                  from the HTML5 File API, or a p5.File.</p>\n",type:"String|Array"},{name:"successCallback",description:"<p>Name of a function to call once file loads</p>\n",type:"Function",optional:!0},{name:"errorCallback",description:"<p>Name of a function to call if there is\n                                    an error loading the file.</p>\n",type:"Function",optional:!0},{name:"whileLoading",description:"<p>Name of a function to call while file is loading.\n                               This function will receive the percentage loaded\n                               so far, from 0.0 to 1.0.</p>\n",type:"Function",optional:!0}],class:"p5",module:"p5.sound"},createConvolver:{name:"createConvolver",params:[{name:"path",description:"<p>path to a sound file</p>\n",type:"String"},{name:"callback",description:"<p>function to call if loading is successful.\n                              The object will be passed in as the argument\n                              to the callback function.</p>\n",type:"Function",optional:!0},{name:"errorCallback",description:"<p>function to call if loading is not successful.\n                              A custom error will be passed in as the argument\n                              to the callback function.</p>\n",type:"Function",optional:!0}],class:"p5",module:"p5.sound"},setBPM:{name:"setBPM",params:[{name:"BPM",description:"<p>Beats Per Minute</p>\n",type:"Number"},{name:"rampTime",description:"<p>Seconds from now</p>\n",type:"Number"}],class:"p5",module:"p5.sound"},saveSound:{name:"saveSound",params:[{name:"soundFile",description:"<p>p5.SoundFile that you wish to save</p>\n",type:"p5.SoundFile"},{name:"fileName",description:"<p>name of the resulting .wav file.</p>\n",type:"String"}],class:"p5",module:"p5.sound"}},"p5.Color":{toString:{name:"toString",params:[{name:"format",description:"<p>How the color string will be formatted.\nLeaving this empty formats the string as rgba(r, g, b, a).\n'#rgb' '#rgba' '#rrggbb' and '#rrggbbaa' format as hexadecimal color codes.\n'rgb' 'hsb' and 'hsl' return the color formatted in the specified color mode.\n'rgba' 'hsba' and 'hsla' are the same as above but with alpha channels.\n'rgb%' 'hsb%' 'hsl%' 'rgba%' 'hsba%' and 'hsla%' format as percentages.</p>\n",type:"String",optional:!0}],class:"p5.Color",module:"Color"},setRed:{name:"setRed",params:[{name:"red",description:"<p>the new red value</p>\n",type:"Number"}],class:"p5.Color",module:"Color"},setGreen:{name:"setGreen",params:[{name:"green",description:"<p>the new green value</p>\n",type:"Number"}],class:"p5.Color",module:"Color"},setBlue:{name:"setBlue",params:[{name:"blue",description:"<p>the new blue value</p>\n",type:"Number"}],class:"p5.Color",module:"Color"},setAlpha:{name:"setAlpha",params:[{name:"alpha",description:"<p>the new alpha value</p>\n",type:"Number"}],class:"p5.Color",module:"Color"}},"p5.Element":{elt:{name:"elt",class:"p5.Element",module:"DOM"},parent:{name:"parent",class:"p5.Element",module:"DOM",overloads:[{params:[{name:"parent",description:'<p>the ID, DOM node, or <a href="#/p5.Element">p5.Element</a>\n                         of desired parent element</p>\n',type:"String|p5.Element|Object"}],chainable:1},{params:[]}]},id:{name:"id",class:"p5.Element",module:"DOM",overloads:[{params:[{name:"id",description:"<p>ID of the element</p>\n",type:"String"}],chainable:1},{params:[]}]},class:{name:"class",class:"p5.Element",module:"DOM",overloads:[{params:[{name:"class",description:"<p>class to add</p>\n",type:"String"}],chainable:1},{params:[]}]},mousePressed:{name:"mousePressed",params:[{name:"fxn",description:"<p>function to be fired when mouse is\n                               pressed over the element.\n                               if <code>false</code> is passed instead, the previously\n                               firing function will no longer fire.</p>\n",type:"Function|Boolean"}],class:"p5.Element",module:"DOM"},doubleClicked:{name:"doubleClicked",params:[{name:"fxn",description:"<p>function to be fired when mouse is\n                               double clicked over the element.\n                               if <code>false</code> is passed instead, the previously\n                               firing function will no longer fire.</p>\n",type:"Function|Boolean"}],class:"p5.Element",module:"DOM"},mouseWheel:{name:"mouseWheel",params:[{name:"fxn",description:"<p>function to be fired when mouse is\n                               scrolled over the element.\n                               if <code>false</code> is passed instead, the previously\n                               firing function will no longer fire.</p>\n",type:"Function|Boolean"}],class:"p5.Element",module:"DOM"},mouseReleased:{name:"mouseReleased",params:[{name:"fxn",description:"<p>function to be fired when mouse is\n                               released over the element.\n                               if <code>false</code> is passed instead, the previously\n                               firing function will no longer fire.</p>\n",type:"Function|Boolean"}],class:"p5.Element",module:"DOM"},mouseClicked:{name:"mouseClicked",params:[{name:"fxn",description:"<p>function to be fired when mouse is\n                               clicked over the element.\n                               if <code>false</code> is passed instead, the previously\n                               firing function will no longer fire.</p>\n",type:"Function|Boolean"}],class:"p5.Element",module:"DOM"},mouseMoved:{name:"mouseMoved",params:[{name:"fxn",description:"<p>function to be fired when a mouse moves\n                               over the element.\n                               if <code>false</code> is passed instead, the previously\n                               firing function will no longer fire.</p>\n",type:"Function|Boolean"}],class:"p5.Element",module:"DOM"},mouseOver:{name:"mouseOver",params:[{name:"fxn",description:"<p>function to be fired when a mouse moves\n                               onto the element.\n                               if <code>false</code> is passed instead, the previously\n                               firing function will no longer fire.</p>\n",type:"Function|Boolean"}],class:"p5.Element",module:"DOM"},mouseOut:{name:"mouseOut",params:[{name:"fxn",description:"<p>function to be fired when a mouse\n                               moves off of an element.\n                               if <code>false</code> is passed instead, the previously\n                               firing function will no longer fire.</p>\n",type:"Function|Boolean"}],class:"p5.Element",module:"DOM"},touchStarted:{name:"touchStarted",params:[{name:"fxn",description:"<p>function to be fired when a touch\n                               starts over the element.\n                               if <code>false</code> is passed instead, the previously\n                               firing function will no longer fire.</p>\n",type:"Function|Boolean"}],class:"p5.Element",module:"DOM"},touchMoved:{name:"touchMoved",params:[{name:"fxn",description:"<p>function to be fired when a touch moves over\n                               the element.\n                               if <code>false</code> is passed instead, the previously\n                               firing function will no longer fire.</p>\n",type:"Function|Boolean"}],class:"p5.Element",module:"DOM"},touchEnded:{name:"touchEnded",params:[{name:"fxn",description:"<p>function to be fired when a touch ends\n                               over the element.\n                               if <code>false</code> is passed instead, the previously\n                               firing function will no longer fire.</p>\n",type:"Function|Boolean"}],class:"p5.Element",module:"DOM"},dragOver:{name:"dragOver",params:[{name:"fxn",description:"<p>function to be fired when a file is\n                               dragged over the element.\n                               if <code>false</code> is passed instead, the previously\n                               firing function will no longer fire.</p>\n",type:"Function|Boolean"}],class:"p5.Element",module:"DOM"},dragLeave:{name:"dragLeave",params:[{name:"fxn",description:"<p>function to be fired when a file is\n                               dragged off the element.\n                               if <code>false</code> is passed instead, the previously\n                               firing function will no longer fire.</p>\n",type:"Function|Boolean"}],class:"p5.Element",module:"DOM"},addClass:{name:"addClass",params:[{name:"class",description:"<p>name of class to add</p>\n",type:"String"}],class:"p5.Element",module:"DOM"},removeClass:{name:"removeClass",params:[{name:"class",description:"<p>name of class to remove</p>\n",type:"String"}],class:"p5.Element",module:"DOM"},hasClass:{name:"hasClass",params:[{name:"c",description:"<p>class name of class to check</p>\n",type:"String"}],class:"p5.Element",module:"DOM"},toggleClass:{name:"toggleClass",params:[{name:"c",description:"<p>class name to toggle</p>\n",type:"String"}],class:"p5.Element",module:"DOM"},child:{name:"child",class:"p5.Element",module:"DOM",overloads:[{params:[]},{params:[{name:"child",description:'<p>the ID, DOM node, or <a href="#/p5.Element">p5.Element</a>\n                        to add to the current element</p>\n',type:"String|p5.Element",optional:!0}],chainable:1}]},center:{name:"center",params:[{name:"align",description:"<p>passing 'vertical', 'horizontal' aligns element accordingly</p>\n",type:"String",optional:!0}],class:"p5.Element",module:"DOM"},html:{name:"html",class:"p5.Element",module:"DOM",overloads:[{params:[]},{params:[{name:"html",description:"<p>the HTML to be placed inside the element</p>\n",type:"String",optional:!0},{name:"append",description:"<p>whether to append HTML to existing</p>\n",type:"Boolean",optional:!0}],chainable:1}]},position:{name:"position",class:"p5.Element",module:"DOM",overloads:[{params:[]},{params:[{name:"x",description:"<p>x-position relative to upper left of window (optional)</p>\n",type:"Number",optional:!0},{name:"y",description:"<p>y-position relative to upper left of window (optional)</p>\n",type:"Number",optional:!0},{name:"positionType",description:"<p>it can be static, fixed, relative, sticky, initial or inherit (optional)</p>\n",type:"String"}],chainable:1}]},style:{name:"style",class:"p5.Element",module:"DOM",overloads:[{params:[{name:"property",description:"<p>property to be set</p>\n",type:"String"}]},{params:[{name:"property",description:"",type:"String"},{name:"value",description:"<p>value to assign to property</p>\n",type:"String|p5.Color"}],chainable:1}]},attribute:{name:"attribute",class:"p5.Element",module:"DOM",overloads:[{params:[]},{params:[{name:"attr",description:"<p>attribute to set</p>\n",type:"String"},{name:"value",description:"<p>value to assign to attribute</p>\n",type:"String"}],chainable:1}]},removeAttribute:{name:"removeAttribute",params:[{name:"attr",description:"<p>attribute to remove</p>\n",type:"String"}],class:"p5.Element",module:"DOM"},value:{name:"value",class:"p5.Element",module:"DOM",overloads:[{params:[]},{params:[{name:"value",description:"",type:"String|Number"}],chainable:1}]},show:{name:"show",class:"p5.Element",module:"DOM"},hide:{name:"hide",class:"p5.Element",module:"DOM"},size:{name:"size",class:"p5.Element",module:"DOM",overloads:[{params:[]},{params:[{name:"w",description:"<p>width of the element, either AUTO, or a number</p>\n",type:"Number|Constant"},{name:"h",description:"<p>height of the element, either AUTO, or a number</p>\n",type:"Number|Constant",optional:!0}],chainable:1}]},remove:{name:"remove",class:"p5.Element",module:"DOM"},drop:{name:"drop",params:[{name:"callback",description:"<p>callback to receive loaded file, called for each file dropped.</p>\n",type:"Function"},{name:"fxn",description:"<p>callback triggered once when files are dropped with the drop event.</p>\n",type:"Function",optional:!0}],class:"p5.Element",module:"DOM"}},"p5.Graphics":{reset:{name:"reset",class:"p5.Graphics",module:"Rendering"},remove:{name:"remove",class:"p5.Graphics",module:"Rendering"}},JSON:{stringify:{name:"stringify",params:[{name:"object",description:"<p>:Javascript object that you would like to convert to JSON</p>\n",type:"Object"}],class:"JSON",module:"Foundation"}},console:{log:{name:"log",params:[{name:"message",description:"<p>:Message that you would like to print to the console</p>\n",type:"String|Expression|Object"}],class:"console",module:"Foundation"}},"p5.TypedDict":{size:{name:"size",class:"p5.TypedDict",module:"Data"},hasKey:{name:"hasKey",params:[{name:"key",description:"<p>that you want to look up</p>\n",type:"Number|String"}],class:"p5.TypedDict",module:"Data"},get:{name:"get",params:[{name:"the",description:"<p>key you want to access</p>\n",type:"Number|String"}],class:"p5.TypedDict",module:"Data"},set:{name:"set",params:[{name:"key",description:"",type:"Number|String"},{name:"value",description:"",type:"Number|String"}],class:"p5.TypedDict",module:"Data"},create:{name:"create",class:"p5.TypedDict",module:"Data",overloads:[{params:[{name:"key",description:"",type:"Number|String"},{name:"value",description:"",type:"Number|String"}]},{params:[{name:"obj",description:"<p>key/value pair</p>\n",type:"Object"}]}]},clear:{name:"clear",class:"p5.TypedDict",module:"Data"},remove:{name:"remove",params:[{name:"key",description:"<p>for the pair to remove</p>\n",type:"Number|String"}],class:"p5.TypedDict",module:"Data"},print:{name:"print",class:"p5.TypedDict",module:"Data"},saveTable:{name:"saveTable",class:"p5.TypedDict",module:"Data"},saveJSON:{name:"saveJSON",class:"p5.TypedDict",module:"Data"}},"p5.NumberDict":{add:{name:"add",params:[{name:"Key",description:"<p>for the value you wish to add to</p>\n",type:"Number"},{name:"Number",description:"<p>to add to the value</p>\n",type:"Number"}],class:"p5.NumberDict",module:"Data"},sub:{name:"sub",params:[{name:"Key",description:"<p>for the value you wish to subtract from</p>\n",type:"Number"},{name:"Number",description:"<p>to subtract from the value</p>\n",type:"Number"}],class:"p5.NumberDict",module:"Data"},mult:{name:"mult",params:[{name:"Key",description:"<p>for value you wish to multiply</p>\n",type:"Number"},{name:"Amount",description:"<p>to multiply the value by</p>\n",type:"Number"}],class:"p5.NumberDict",module:"Data"},div:{name:"div",params:[{name:"Key",description:"<p>for value you wish to divide</p>\n",type:"Number"},{name:"Amount",description:"<p>to divide the value by</p>\n",type:"Number"}],class:"p5.NumberDict",module:"Data"},minValue:{name:"minValue",class:"p5.NumberDict",module:"Data"},maxValue:{name:"maxValue",class:"p5.NumberDict",module:"Data"},minKey:{name:"minKey",class:"p5.NumberDict",module:"Data"},maxKey:{name:"maxKey",class:"p5.NumberDict",module:"Data"}},"p5.MediaElement":{src:{name:"src",class:"p5.MediaElement",module:"DOM"},play:{name:"play",class:"p5.MediaElement",module:"DOM"},stop:{name:"stop",class:"p5.MediaElement",module:"DOM"},pause:{name:"pause",class:"p5.MediaElement",module:"DOM"},loop:{name:"loop",class:"p5.MediaElement",module:"DOM"},noLoop:{name:"noLoop",class:"p5.MediaElement",module:"DOM"},autoplay:{name:"autoplay",params:[{name:"shouldAutoplay",description:"<p>whether the element should autoplay</p>\n",type:"Boolean"}],class:"p5.MediaElement",module:"DOM"},volume:{name:"volume",class:"p5.MediaElement",module:"DOM",overloads:[{params:[]},{params:[{name:"val",description:"<p>volume between 0.0 and 1.0</p>\n",type:"Number"}],chainable:1}]},speed:{name:"speed",class:"p5.MediaElement",module:"DOM",overloads:[{params:[]},{params:[{name:"speed",description:"<p>speed multiplier for element playback</p>\n",type:"Number"}],chainable:1}]},time:{name:"time",class:"p5.MediaElement",module:"DOM",overloads:[{params:[]},{params:[{name:"time",description:"<p>time to jump to (in seconds)</p>\n",type:"Number"}],chainable:1}]},duration:{name:"duration",class:"p5.MediaElement",module:"DOM"},onended:{name:"onended",params:[{name:"callback",description:"<p>function to call when the\n                            soundfile has ended. The\n                            media element will be passed\n                            in as the argument to the\n                            callback.</p>\n",type:"Function"}],class:"p5.MediaElement",module:"DOM"},connect:{name:"connect",params:[{name:"audioNode",description:"<p>AudioNode from the Web Audio API,\nor an object from the p5.sound library</p>\n",type:"AudioNode|Object"}],class:"p5.MediaElement",module:"DOM"},disconnect:{name:"disconnect",class:"p5.MediaElement",module:"DOM"},showControls:{name:"showControls",class:"p5.MediaElement",module:"DOM"},hideControls:{name:"hideControls",class:"p5.MediaElement",module:"DOM"},addCue:{name:"addCue",params:[{name:"time",description:"<p>Time in seconds, relative to this media\n                            element's playback. For example, to trigger\n                            an event every time playback reaches two\n                            seconds, pass in the number 2. This will be\n                            passed as the first parameter to\n                            the callback function.</p>\n",type:"Number"},{name:"callback",description:"<p>Name of a function that will be\n                            called at the given time. The callback will\n                            receive time and (optionally) param as its\n                            two parameters.</p>\n",type:"Function"},{name:"value",description:"<p>An object to be passed as the\n                            second parameter to the\n                            callback function.</p>\n",type:"Object",optional:!0}],class:"p5.MediaElement",module:"DOM"},removeCue:{name:"removeCue",params:[{name:"id",description:"<p>ID of the cue, as returned by addCue</p>\n",type:"Number"}],class:"p5.MediaElement",module:"DOM"},clearCues:{name:"clearCues",params:[{name:"id",description:"<p>ID of the cue, as returned by addCue</p>\n",type:"Number"}],class:"p5.MediaElement",module:"DOM"}},"p5.File":{file:{name:"file",class:"p5.File",module:"DOM"},type:{name:"type",class:"p5.File",module:"DOM"},subtype:{name:"subtype",class:"p5.File",module:"DOM"},name:{name:"name",class:"p5.File",module:"DOM"},size:{name:"size",class:"p5.File",module:"DOM"},data:{name:"data",class:"p5.File",module:"DOM"}},"p5.Image":{width:{name:"width",class:"p5.Image",module:"Image"},height:{name:"height",class:"p5.Image",module:"Image"},pixels:{name:"pixels",class:"p5.Image",module:"Image"},loadPixels:{name:"loadPixels",class:"p5.Image",module:"Image"},updatePixels:{name:"updatePixels",class:"p5.Image",module:"Image",overloads:[{params:[{name:"x",description:"<p>x-offset of the target update area for the\n                             underlying canvas</p>\n",type:"Integer"},{name:"y",description:"<p>y-offset of the target update area for the\n                             underlying canvas</p>\n",type:"Integer"},{name:"w",description:"<p>height of the target update area for the\n                             underlying canvas</p>\n",type:"Integer"},{name:"h",description:"<p>height of the target update area for the\n                             underlying canvas</p>\n",type:"Integer"}]},{params:[]}]},get:{name:"get",class:"p5.Image",module:"Image",overloads:[{params:[{name:"x",description:"<p>x-coordinate of the pixel</p>\n",type:"Number"},{name:"y",description:"<p>y-coordinate of the pixel</p>\n",type:"Number"},{name:"w",description:"<p>width</p>\n",type:"Number"},{name:"h",description:"<p>height</p>\n",type:"Number"}]},{params:[]},{params:[{name:"x",description:"",type:"Number"},{name:"y",description:"",type:"Number"}]}]},set:{name:"set",params:[{name:"x",description:"<p>x-coordinate of the pixel</p>\n",type:"Number"},{name:"y",description:"<p>y-coordinate of the pixel</p>\n",type:"Number"},{name:"a",description:'<p>grayscale value | pixel array |\n                               a <a href="#/p5.Color">p5.Color</a> | image to copy</p>\n',type:"Number|Number[]|Object"}],class:"p5.Image",module:"Image"},resize:{name:"resize",params:[{name:"width",description:"<p>the resized image width</p>\n",type:"Number"},{name:"height",description:"<p>the resized image height</p>\n",type:"Number"}],class:"p5.Image",module:"Image"},copy:{name:"copy",class:"p5.Image",module:"Image",overloads:[{params:[{name:"srcImage",description:"<p>source image</p>\n",type:"p5.Image|p5.Element"},{name:"sx",description:"<p>X coordinate of the source's upper left corner</p>\n",type:"Integer"},{name:"sy",description:"<p>Y coordinate of the source's upper left corner</p>\n",type:"Integer"},{name:"sw",description:"<p>source image width</p>\n",type:"Integer"},{name:"sh",description:"<p>source image height</p>\n",type:"Integer"},{name:"dx",description:"<p>X coordinate of the destination's upper left corner</p>\n",type:"Integer"},{name:"dy",description:"<p>Y coordinate of the destination's upper left corner</p>\n",type:"Integer"},{name:"dw",description:"<p>destination image width</p>\n",type:"Integer"},{name:"dh",description:"<p>destination image height</p>\n",type:"Integer"}]},{params:[{name:"sx",description:"",type:"Integer"},{name:"sy",description:"",type:"Integer"},{name:"sw",description:"",type:"Integer"},{name:"sh",description:"",type:"Integer"},{name:"dx",description:"",type:"Integer"},{name:"dy",description:"",type:"Integer"},{name:"dw",description:"",type:"Integer"},{name:"dh",description:"",type:"Integer"}]}]},mask:{name:"mask",params:[{name:"srcImage",description:"<p>source image</p>\n",type:"p5.Image"}],class:"p5.Image",module:"Image"},filter:{name:"filter",params:[{name:"filterType",description:"<p>either THRESHOLD, GRAY, OPAQUE, INVERT,\n                               POSTERIZE, BLUR, ERODE, DILATE or BLUR.\n                               See Filters.js for docs on\n                               each available filter</p>\n",type:"Constant"},{name:"filterParam",description:"<p>an optional parameter unique\n                               to each filter, see above</p>\n",type:"Number",optional:!0}],class:"p5.Image",module:"Image"},blend:{name:"blend",class:"p5.Image",module:"Image",overloads:[{params:[{name:"srcImage",description:"<p>source image</p>\n",type:"p5.Image"},{name:"sx",description:"<p>X coordinate of the source's upper left corner</p>\n",type:"Integer"},{name:"sy",description:"<p>Y coordinate of the source's upper left corner</p>\n",type:"Integer"},{name:"sw",description:"<p>source image width</p>\n",type:"Integer"},{name:"sh",description:"<p>source image height</p>\n",type:"Integer"},{name:"dx",description:"<p>X coordinate of the destination's upper left corner</p>\n",type:"Integer"},{name:"dy",description:"<p>Y coordinate of the destination's upper left corner</p>\n",type:"Integer"},{name:"dw",description:"<p>destination image width</p>\n",type:"Integer"},{name:"dh",description:"<p>destination image height</p>\n",type:"Integer"},{name:"blendMode",description:'<p>the blend mode. either\n    BLEND, DARKEST, LIGHTEST, DIFFERENCE,\n    MULTIPLY, EXCLUSION, SCREEN, REPLACE, OVERLAY, HARD_LIGHT,\n    SOFT_LIGHT, DODGE, BURN, ADD or NORMAL.</p>\n<p>Available blend modes are: normal | multiply | screen | overlay |\n           darken | lighten | color-dodge | color-burn | hard-light |\n           soft-light | difference | exclusion | hue | saturation |\n           color | luminosity</p>\n<p><a href="http://blogs.adobe.com/webplatform/2013/01/28/blending-features-in-canvas/">http://blogs.adobe.com/webplatform/2013/01/28/blending-features-in-canvas/</a></p>\n',type:"Constant"}]},{params:[{name:"sx",description:"",type:"Integer"},{name:"sy",description:"",type:"Integer"},{name:"sw",description:"",type:"Integer"},{name:"sh",description:"",type:"Integer"},{name:"dx",description:"",type:"Integer"},{name:"dy",description:"",type:"Integer"},{name:"dw",description:"",type:"Integer"},{name:"dh",description:"",type:"Integer"},{name:"blendMode",description:"",type:"Constant"}]}]},save:{name:"save",params:[{name:"filename",description:"<p>give your file a name</p>\n",type:"String"},{name:"extension",description:"<p>'png' or 'jpg'</p>\n",type:"String"}],class:"p5.Image",module:"Image"},reset:{name:"reset",class:"p5.Image",module:"Image"},getCurrentFrame:{name:"getCurrentFrame",class:"p5.Image",module:"Image"},setFrame:{name:"setFrame",params:[{name:"index",description:"<p>the index for the frame that should be displayed</p>\n",type:"Number"}],class:"p5.Image",module:"Image"},numFrames:{name:"numFrames",class:"p5.Image",module:"Image"},play:{name:"play",class:"p5.Image",module:"Image"},pause:{name:"pause",class:"p5.Image",module:"Image"},delay:{name:"delay",params:[{name:"d",description:"<p>the amount in milliseconds to delay between switching frames</p>\n",type:"Number"},{name:"index",description:"<p>the index of the frame that should have the new delay value {optional}</p>\n",type:"Number",optional:!0}],class:"p5.Image",module:"Image"}},"p5.PrintWriter":{write:{name:"write",params:[{name:"data",description:"<p>all data to be written by the PrintWriter</p>\n",type:"Array"}],class:"p5.PrintWriter",module:"IO"},print:{name:"print",params:[{name:"data",description:"<p>all data to be printed by the PrintWriter</p>\n",type:"Array"}],class:"p5.PrintWriter",module:"IO"},clear:{name:"clear",class:"p5.PrintWriter",module:"IO"},close:{name:"close",class:"p5.PrintWriter",module:"IO"}},"p5.Table":{columns:{name:"columns",class:"p5.Table",module:"IO"},rows:{name:"rows",class:"p5.Table",module:"IO"},addRow:{name:"addRow",params:[{name:"row",description:"<p>row to be added to the table</p>\n",type:"p5.TableRow",optional:!0}],class:"p5.Table",module:"IO"},removeRow:{name:"removeRow",params:[{name:"id",description:"<p>ID number of the row to remove</p>\n",type:"Integer"}],class:"p5.Table",module:"IO"},getRow:{name:"getRow",params:[{name:"rowID",description:"<p>ID number of the row to get</p>\n",type:"Integer"}],class:"p5.Table",module:"IO"},getRows:{name:"getRows",class:"p5.Table",module:"IO"},findRow:{name:"findRow",params:[{name:"value",description:"<p>The value to match</p>\n",type:"String"},{name:"column",description:"<p>ID number or title of the\n                               column to search</p>\n",type:"Integer|String"}],class:"p5.Table",module:"IO"},findRows:{name:"findRows",params:[{name:"value",description:"<p>The value to match</p>\n",type:"String"},{name:"column",description:"<p>ID number or title of the\n                               column to search</p>\n",type:"Integer|String"}],class:"p5.Table",module:"IO"},matchRow:{name:"matchRow",params:[{name:"regexp",description:"<p>The regular expression to match</p>\n",type:"String|RegExp"},{name:"column",description:"<p>The column ID (number) or\n                                 title (string)</p>\n",type:"String|Integer"}],class:"p5.Table",module:"IO"},matchRows:{name:"matchRows",params:[{name:"regexp",description:"<p>The regular expression to match</p>\n",type:"String"},{name:"column",description:"<p>The column ID (number) or\n                                 title (string)</p>\n",type:"String|Integer",optional:!0}],class:"p5.Table",module:"IO"},getColumn:{name:"getColumn",params:[{name:"column",description:"<p>String or Number of the column to return</p>\n",type:"String|Number"}],class:"p5.Table",module:"IO"},clearRows:{name:"clearRows",class:"p5.Table",module:"IO"},addColumn:{name:"addColumn",params:[{name:"title",description:"<p>title of the given column</p>\n",type:"String",optional:!0}],class:"p5.Table",module:"IO"},getColumnCount:{name:"getColumnCount",class:"p5.Table",module:"IO"},getRowCount:{name:"getRowCount",class:"p5.Table",module:"IO"},removeTokens:{name:"removeTokens",params:[{name:"chars",description:"<p>String listing characters to be removed</p>\n",type:"String"},{name:"column",description:"<p>Column ID (number)\n                                 or name (string)</p>\n",type:"String|Integer",optional:!0}],class:"p5.Table",module:"IO"},trim:{name:"trim",params:[{name:"column",description:"<p>Column ID (number)\n                                 or name (string)</p>\n",type:"String|Integer",optional:!0}],class:"p5.Table",module:"IO"},removeColumn:{name:"removeColumn",params:[{name:"column",description:"<p>columnName (string) or ID (number)</p>\n",type:"String|Integer"}],class:"p5.Table",module:"IO"},set:{name:"set",params:[{name:"row",description:"<p>row ID</p>\n",type:"Integer"},{name:"column",description:"<p>column ID (Number)\n                              or title (String)</p>\n",type:"String|Integer"},{name:"value",description:"<p>value to assign</p>\n",type:"String|Number"}],class:"p5.Table",module:"IO"},setNum:{name:"setNum",params:[{name:"row",description:"<p>row ID</p>\n",type:"Integer"},{name:"column",description:"<p>column ID (Number)\n                              or title (String)</p>\n",type:"String|Integer"},{name:"value",description:"<p>value to assign</p>\n",type:"Number"}],class:"p5.Table",module:"IO"},setString:{name:"setString",params:[{name:"row",description:"<p>row ID</p>\n",type:"Integer"},{name:"column",description:"<p>column ID (Number)\n                              or title (String)</p>\n",type:"String|Integer"},{name:"value",description:"<p>value to assign</p>\n",type:"String"}],class:"p5.Table",module:"IO"},get:{name:"get",params:[{name:"row",description:"<p>row ID</p>\n",type:"Integer"},{name:"column",description:"<p>columnName (string) or\n                                  ID (number)</p>\n",type:"String|Integer"}],class:"p5.Table",module:"IO"},getNum:{name:"getNum",params:[{name:"row",description:"<p>row ID</p>\n",type:"Integer"},{name:"column",description:"<p>columnName (string) or\n                                  ID (number)</p>\n",type:"String|Integer"}],class:"p5.Table",module:"IO"},getString:{name:"getString",params:[{name:"row",description:"<p>row ID</p>\n",type:"Integer"},{name:"column",description:"<p>columnName (string) or\n                                  ID (number)</p>\n",type:"String|Integer"}],class:"p5.Table",module:"IO"},getObject:{name:"getObject",params:[{name:"headerColumn",description:"<p>Name of the column which should be used to\n                             title each row object (optional)</p>\n",type:"String",optional:!0}],class:"p5.Table",module:"IO"},getArray:{name:"getArray",class:"p5.Table",module:"IO"}},"p5.TableRow":{set:{name:"set",params:[{name:"column",description:"<p>Column ID (Number)\n                              or Title (String)</p>\n",type:"String|Integer"},{name:"value",description:"<p>The value to be stored</p>\n",type:"String|Number"}],class:"p5.TableRow",module:"IO"},setNum:{name:"setNum",params:[{name:"column",description:"<p>Column ID (Number)\n                              or Title (String)</p>\n",type:"String|Integer"},{name:"value",description:"<p>The value to be stored\n                              as a Float</p>\n",type:"Number|String"}],class:"p5.TableRow",module:"IO"},setString:{name:"setString",params:[{name:"column",description:"<p>Column ID (Number)\n                              or Title (String)</p>\n",type:"String|Integer"},{name:"value",description:"<p>The value to be stored\n                              as a String</p>\n",type:"String|Number|Boolean|Object"}],class:"p5.TableRow",module:"IO"},get:{name:"get",params:[{name:"column",description:"<p>columnName (string) or\n                                 ID (number)</p>\n",type:"String|Integer"}],class:"p5.TableRow",module:"IO"},getNum:{name:"getNum",params:[{name:"column",description:"<p>columnName (string) or\n                                 ID (number)</p>\n",type:"String|Integer"}],class:"p5.TableRow",module:"IO"},getString:{name:"getString",params:[{name:"column",description:"<p>columnName (string) or\n                                 ID (number)</p>\n",type:"String|Integer"}],class:"p5.TableRow",module:"IO"}},"p5.XML":{getParent:{name:"getParent",class:"p5.XML",module:"IO"},getName:{name:"getName",class:"p5.XML",module:"IO"},setName:{name:"setName",params:[{name:"the",description:"<p>new name of the node</p>\n",type:"String"}],class:"p5.XML",module:"IO"},hasChildren:{name:"hasChildren",class:"p5.XML",module:"IO"},listChildren:{name:"listChildren",class:"p5.XML",module:"IO"},getChildren:{name:"getChildren",params:[{name:"name",description:"<p>element name</p>\n",type:"String",optional:!0}],class:"p5.XML",module:"IO"},getChild:{name:"getChild",params:[{name:"name",description:"<p>element name or index</p>\n",type:"String|Integer"}],class:"p5.XML",module:"IO"},addChild:{name:"addChild",params:[{name:"node",description:'<p>a <a href="#/p5.XML">p5.XML</a> Object which will be the child to be added</p>\n',type:"p5.XML"}],class:"p5.XML",module:"IO"},removeChild:{name:"removeChild",params:[{name:"name",description:"<p>element name or index</p>\n",type:"String|Integer"}],class:"p5.XML",module:"IO"},getAttributeCount:{name:"getAttributeCount",class:"p5.XML",module:"IO"},listAttributes:{name:"listAttributes",class:"p5.XML",module:"IO"},hasAttribute:{name:"hasAttribute",params:[{name:"the",description:"<p>attribute to be checked</p>\n",type:"String"}],class:"p5.XML",module:"IO"},getNum:{name:"getNum",params:[{name:"name",description:"<p>the non-null full name of the attribute</p>\n",type:"String"},{name:"defaultValue",description:"<p>the default value of the attribute</p>\n",type:"Number",optional:!0}],class:"p5.XML",module:"IO"},getString:{name:"getString",params:[{name:"name",description:"<p>the non-null full name of the attribute</p>\n",type:"String"},{name:"defaultValue",description:"<p>the default value of the attribute</p>\n",type:"Number",optional:!0}],class:"p5.XML",module:"IO"},setAttribute:{name:"setAttribute",params:[{name:"name",description:"<p>the full name of the attribute</p>\n",type:"String"},{name:"value",description:"<p>the value of the attribute</p>\n",type:"Number|String|Boolean"}],class:"p5.XML",module:"IO"},getContent:{name:"getContent",params:[{name:"defaultValue",description:"<p>value returned if no content is found</p>\n",type:"String",optional:!0}],class:"p5.XML",module:"IO"},setContent:{name:"setContent",params:[{name:"text",description:"<p>the new content</p>\n",type:"String"}],class:"p5.XML",module:"IO"},serialize:{name:"serialize",class:"p5.XML",module:"IO"}},"p5.Vector":{x:{name:"x",class:"p5.Vector",module:"Math"},y:{name:"y",class:"p5.Vector",module:"Math"},z:{name:"z",class:"p5.Vector",module:"Math"},toString:{name:"toString",class:"p5.Vector",module:"Math"},set:{name:"set",class:"p5.Vector",module:"Math",overloads:[{params:[{name:"x",description:"<p>the x component of the vector</p>\n",type:"Number",optional:!0},{name:"y",description:"<p>the y component of the vector</p>\n",type:"Number",optional:!0},{name:"z",description:"<p>the z component of the vector</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"value",description:"<p>the vector to set</p>\n",type:"p5.Vector|Number[]"}],chainable:1}]},copy:{name:"copy",class:"p5.Vector",module:"Math"},add:{name:"add",class:"p5.Vector",module:"Math",overloads:[{params:[{name:"x",description:"<p>the x component of the vector to be added</p>\n",type:"Number"},{name:"y",description:"<p>the y component of the vector to be added</p>\n",type:"Number",optional:!0},{name:"z",description:"<p>the z component of the vector to be added</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"value",description:"<p>the vector to add</p>\n",type:"p5.Vector|Number[]"}],chainable:1},{params:[{name:"v1",description:'<p>a <a href="#/p5.Vector">p5.Vector</a> to add</p>\n',type:"p5.Vector"},{name:"v2",description:'<p>a <a href="#/p5.Vector">p5.Vector</a> to add</p>\n',type:"p5.Vector"},{name:"target",description:"<p>the vector to receive the result (Optional)</p>\n",type:"p5.Vector",optional:!0}],static:1}]},rem:{name:"rem",class:"p5.Vector",module:"Math",overloads:[{params:[{name:"x",description:"<p>the x component of divisor vector</p>\n",type:"Number"},{name:"y",description:"<p>the y component of divisor vector</p>\n",type:"Number"},{name:"z",description:"<p>the z component of divisor vector</p>\n",type:"Number"}],chainable:1},{params:[{name:"value",description:"<p>divisor vector</p>\n",type:"p5.Vector | Number[]"}],chainable:1},{params:[{name:"v1",description:'<p>dividend <a href="#/p5.Vector">p5.Vector</a></p>\n',type:"p5.Vector"},{name:"v2",description:'<p>divisor <a href="#/p5.Vector">p5.Vector</a></p>\n',type:"p5.Vector"}],static:1},{params:[{name:"v1",description:"",type:"p5.Vector"},{name:"v2",description:"",type:"p5.Vector"}],static:1}]},sub:{name:"sub",class:"p5.Vector",module:"Math",overloads:[{params:[{name:"x",description:"<p>the x component of the vector to subtract</p>\n",type:"Number"},{name:"y",description:"<p>the y component of the vector to subtract</p>\n",type:"Number",optional:!0},{name:"z",description:"<p>the z component of the vector to subtract</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"value",description:"<p>the vector to subtract</p>\n",type:"p5.Vector|Number[]"}],chainable:1},{params:[{name:"v1",description:'<p>a <a href="#/p5.Vector">p5.Vector</a> to subtract from</p>\n',type:"p5.Vector"},{name:"v2",description:'<p>a <a href="#/p5.Vector">p5.Vector</a> to subtract</p>\n',type:"p5.Vector"},{name:"target",description:"<p>the vector to receive the result (Optional)</p>\n",type:"p5.Vector",optional:!0}],static:1}]},mult:{name:"mult",class:"p5.Vector",module:"Math",overloads:[{params:[{name:"n",description:"<p>The number to multiply with the vector</p>\n",type:"Number"}],chainable:1},{params:[{name:"x",description:"<p>The number to multiply with the x component of the vector</p>\n",type:"Number"},{name:"y",description:"<p>The number to multiply with the y component of the vector</p>\n",type:"Number"},{name:"z",description:"<p>The number to multiply with the z component of the vector</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"arr",description:"<p>The array to multiply with the components of the vector</p>\n",type:"Number[]"}],chainable:1},{params:[{name:"v",description:"<p>The vector to multiply with the components of the original vector</p>\n",type:"p5.Vector"}],chainable:1},{params:[{name:"x",description:"",type:"Number"},{name:"y",description:"",type:"Number"},{name:"z",description:"",type:"Number",optional:!0}],static:1},{params:[{name:"v",description:"",type:"p5.Vector"},{name:"n",description:"",type:"Number"},{name:"target",description:"<p>the vector to receive the result (Optional)</p>\n",type:"p5.Vector",optional:!0}],static:1},{params:[{name:"v0",description:"",type:"p5.Vector"},{name:"v1",description:"",type:"p5.Vector"},{name:"target",description:"",type:"p5.Vector",optional:!0}],static:1},{params:[{name:"v0",description:"",type:"p5.Vector"},{name:"arr",description:"",type:"Number[]"},{name:"target",description:"",type:"p5.Vector",optional:!0}],static:1}]},div:{name:"div",class:"p5.Vector",module:"Math",overloads:[{params:[{name:"n",description:"<p>The number to divide the vector by</p>\n",type:"Number"}],chainable:1},{params:[{name:"x",description:"<p>The number to divide with the x component of the vector</p>\n",type:"Number"},{name:"y",description:"<p>The number to divide with the y component of the vector</p>\n",type:"Number"},{name:"z",description:"<p>The number to divide with the z component of the vector</p>\n",type:"Number",optional:!0}],chainable:1},{params:[{name:"arr",description:"<p>The array to divide the components of the vector by</p>\n",type:"Number[]"}],chainable:1},{params:[{name:"v",description:"<p>The vector to divide the components of the original vector by</p>\n",type:"p5.Vector"}],chainable:1},{params:[{name:"x",description:"",type:"Number"},{name:"y",description:"",type:"Number"},{name:"z",description:"",type:"Number",optional:!0}],static:1},{params:[{name:"v",description:"",type:"p5.Vector"},{name:"n",description:"",type:"Number"},{name:"target",description:"<p>the vector to receive the result (Optional)</p>\n",type:"p5.Vector",optional:!0}],static:1},{params:[{name:"v0",description:"",type:"p5.Vector"},{name:"v1",description:"",type:"p5.Vector"},{name:"target",description:"",type:"p5.Vector",optional:!0}],static:1},{params:[{name:"v0",description:"",type:"p5.Vector"},{name:"arr",description:"",type:"Number[]"},{name:"target",description:"",type:"p5.Vector",optional:!0}],static:1}]},mag:{name:"mag",class:"p5.Vector",module:"Math",overloads:[{params:[]},{params:[{name:"vecT",description:"<p>the vector to return the magnitude of</p>\n",type:"p5.Vector"}],static:1}]},magSq:{name:"magSq",class:"p5.Vector",module:"Math"},dot:{name:"dot",class:"p5.Vector",module:"Math",overloads:[{params:[{name:"x",description:"<p>x component of the vector</p>\n",type:"Number"},{name:"y",description:"<p>y component of the vector</p>\n",type:"Number",optional:!0},{name:"z",description:"<p>z component of the vector</p>\n",type:"Number",optional:!0}]},{params:[{name:"value",description:'<p>value component of the vector or a <a href="#/p5.Vector">p5.Vector</a></p>\n',type:"p5.Vector"}]},{params:[{name:"v1",description:'<p>the first <a href="#/p5.Vector">p5.Vector</a></p>\n',type:"p5.Vector"},{name:"v2",description:'<p>the second <a href="#/p5.Vector">p5.Vector</a></p>\n',type:"p5.Vector"}],static:1}]},cross:{name:"cross",class:"p5.Vector",module:"Math",overloads:[{params:[{name:"v",description:'<p><a href="#/p5.Vector">p5.Vector</a> to be crossed</p>\n',type:"p5.Vector"}]},{params:[{name:"v1",description:'<p>the first <a href="#/p5.Vector">p5.Vector</a></p>\n',type:"p5.Vector"},{name:"v2",description:'<p>the second <a href="#/p5.Vector">p5.Vector</a></p>\n',type:"p5.Vector"}],static:1}]},dist:{name:"dist",class:"p5.Vector",module:"Math",overloads:[{params:[{name:"v",description:'<p>the x, y, and z coordinates of a <a href="#/p5.Vector">p5.Vector</a></p>\n',type:"p5.Vector"}]},{params:[{name:"v1",description:'<p>the first <a href="#/p5.Vector">p5.Vector</a></p>\n',type:"p5.Vector"},{name:"v2",description:'<p>the second <a href="#/p5.Vector">p5.Vector</a></p>\n',type:"p5.Vector"}],static:1}]},normalize:{name:"normalize",class:"p5.Vector",module:"Math"},limit:{name:"limit",params:[{name:"max",description:"<p>the maximum magnitude for the vector</p>\n",type:"Number"}],class:"p5.Vector",module:"Math"},setMag:{name:"setMag",params:[{name:"len",description:"<p>the new length for this vector</p>\n",type:"Number"}],class:"p5.Vector",module:"Math"},heading:{name:"heading",class:"p5.Vector",module:"Math"},rotate:{name:"rotate",params:[{name:"angle",description:"<p>the angle of rotation</p>\n",type:"Number"}],class:"p5.Vector",module:"Math"},angleBetween:{name:"angleBetween",params:[{name:"value",description:'<p>the x, y, and z components of a <a href="#/p5.Vector">p5.Vector</a></p>\n',type:"p5.Vector"}],class:"p5.Vector",module:"Math"},lerp:{name:"lerp",class:"p5.Vector",module:"Math",overloads:[{params:[{name:"x",description:"<p>the x component</p>\n",type:"Number"},{name:"y",description:"<p>the y component</p>\n",type:"Number"},{name:"z",description:"<p>the z component</p>\n",type:"Number"},{name:"amt",description:"<p>the amount of interpolation; some value between 0.0\n                        (old vector) and 1.0 (new vector). 0.9 is very near\n                        the new vector. 0.5 is halfway in between.</p>\n",type:"Number"}],chainable:1},{params:[{name:"v",description:'<p>the <a href="#/p5.Vector">p5.Vector</a> to lerp to</p>\n',type:"p5.Vector"},{name:"amt",description:"",type:"Number"}],chainable:1},{params:[{name:"v1",description:"",type:"p5.Vector"},{name:"v2",description:"",type:"p5.Vector"},{name:"amt",description:"",type:"Number"},{name:"target",description:"<p>the vector to receive the result (Optional)</p>\n",type:"p5.Vector",optional:!0}],static:1}]},reflect:{name:"reflect",params:[{name:"surfaceNormal",description:'<p>the <a href="#/p5.Vector">p5.Vector</a> to reflect about, will be normalized by this method</p>\n',type:"p5.Vector"}],class:"p5.Vector",module:"Math"},array:{name:"array",class:"p5.Vector",module:"Math"},equals:{name:"equals",class:"p5.Vector",module:"Math",overloads:[{params:[{name:"x",description:"<p>the x component of the vector</p>\n",type:"Number",optional:!0},{name:"y",description:"<p>the y component of the vector</p>\n",type:"Number",optional:!0},{name:"z",description:"<p>the z component of the vector</p>\n",type:"Number",optional:!0}]},{params:[{name:"value",description:"<p>the vector to compare</p>\n",type:"p5.Vector|Array"}]}]},fromAngle:{name:"fromAngle",params:[{name:"angle",description:'<p>the desired angle, in radians (unaffected by <a href="#/p5/angleMode">angleMode</a>)</p>\n',type:"Number"},{name:"length",description:"<p>the length of the new vector (defaults to 1)</p>\n",type:"Number",optional:!0}],class:"p5.Vector",module:"Math"},fromAngles:{name:"fromAngles",params:[{name:"theta",description:"<p>the polar angle, in radians (zero is up)</p>\n",type:"Number"},{name:"phi",description:"<p>the azimuthal angle, in radians\n                              (zero is out of the screen)</p>\n",type:"Number"},{name:"length",description:"<p>the length of the new vector (defaults to 1)</p>\n",type:"Number",optional:!0}],class:"p5.Vector",module:"Math"},random2D:{name:"random2D",class:"p5.Vector",module:"Math"},random3D:{name:"random3D",class:"p5.Vector",module:"Math"}},"p5.Font":{font:{name:"font",class:"p5.Font",module:"Typography"},textBounds:{name:"textBounds",params:[{name:"line",description:"<p>a line of text</p>\n",type:"String"},{name:"x",description:"<p>x-position</p>\n",type:"Number"},{name:"y",description:"<p>y-position</p>\n",type:"Number"},{name:"fontSize",description:"<p>font size to use (optional) Default is 12.</p>\n",type:"Number",optional:!0},{name:"options",description:"<p>opentype options (optional)\n                           opentype fonts contains alignment and baseline options.\n                           Default is 'LEFT' and 'alphabetic'</p>\n",type:"Object",optional:!0}],class:"p5.Font",module:"Typography"},textToPoints:{name:"textToPoints",params:[{name:"txt",description:"<p>a line of text</p>\n",type:"String"},{name:"x",description:"<p>x-position</p>\n",type:"Number"},{name:"y",description:"<p>y-position</p>\n",type:"Number"},{name:"fontSize",description:"<p>font size to use (optional)</p>\n",type:"Number"},{name:"options",description:"<p>an (optional) object that can contain:</p>\n<p><br>sampleFactor - the ratio of path-length to number of samples\n(default=.1); higher values yield more points and are therefore\nmore precise</p>\n<p><br>simplifyThreshold - if set to a non-zero value, collinear points will be\nbe removed from the polygon; the value represents the threshold angle to use\nwhen determining whether two edges are collinear</p>\n",type:"Object",optional:!0}],class:"p5.Font",module:"Typography"}},"p5.Camera":{perspective:{name:"perspective",class:"p5.Camera",module:"Lights, Camera"},ortho:{name:"ortho",class:"p5.Camera",module:"Lights, Camera"},frustum:{name:"frustum",class:"p5.Camera",module:"Lights, Camera"},pan:{name:"pan",params:[{name:"angle",description:'<p>amount to rotate camera in current\n<a href="#/p5/angleMode">angleMode</a> units.\nGreater than 0 values rotate counterclockwise (to the left).</p>\n',type:"Number"}],class:"p5.Camera",module:"Lights, Camera"},tilt:{name:"tilt",params:[{name:"angle",description:'<p>amount to rotate camera in current\n<a href="#/p5/angleMode">angleMode</a> units.\nGreater than 0 values rotate counterclockwise (to the left).</p>\n',type:"Number"}],class:"p5.Camera",module:"Lights, Camera"},lookAt:{name:"lookAt",params:[{name:"x",description:"<p>x position of a point in world space</p>\n",type:"Number"},{name:"y",description:"<p>y position of a point in world space</p>\n",type:"Number"},{name:"z",description:"<p>z position of a point in world space</p>\n",type:"Number"}],class:"p5.Camera",module:"Lights, Camera"},camera:{name:"camera",class:"p5.Camera",module:"Lights, Camera"},move:{name:"move",params:[{name:"x",description:"<p>amount to move along camera's left-right axis</p>\n",type:"Number"},{name:"y",description:"<p>amount to move along camera's up-down axis</p>\n",type:"Number"},{name:"z",description:"<p>amount to move along camera's forward-backward axis</p>\n",type:"Number"}],class:"p5.Camera",module:"Lights, Camera"},setPosition:{name:"setPosition",params:[{name:"x",description:"<p>x position of a point in world space</p>\n",type:"Number"},{name:"y",description:"<p>y position of a point in world space</p>\n",type:"Number"},{name:"z",description:"<p>z position of a point in world space</p>\n",type:"Number"}],class:"p5.Camera",module:"Lights, Camera"}},"p5.Geometry":{computeFaces:{name:"computeFaces",class:"p5.Geometry",module:"Lights, Camera"},computeNormals:{name:"computeNormals",class:"p5.Geometry",module:"Lights, Camera"},averageNormals:{name:"averageNormals",class:"p5.Geometry",module:"Lights, Camera"},averagePoleNormals:{name:"averagePoleNormals",class:"p5.Geometry",module:"Lights, Camera"},normalize:{name:"normalize",class:"p5.Geometry",module:"Lights, Camera"}},"p5.Shader":{setUniform:{name:"setUniform",params:[{name:"uniformName",description:"<p>the name of the uniform in the\nshader program</p>\n",type:"String"},{name:"data",description:"<p>the data to be associated\nwith that uniform; type varies (could be a single numerical value, array,\nmatrix, or texture / sampler reference)</p>\n",type:"Object|Number|Boolean|Number[]"}],class:"p5.Shader",module:"Lights, Camera"}},"p5.sound":{getMasterVolume:{name:"getMasterVolume",class:"p5.sound",module:"p5.sound"},masterVolume:{name:"masterVolume",params:[{name:"volume",description:"<p>Volume (amplitude) between 0.0\n                                   and 1.0 or modulating signal/oscillator</p>\n",type:"Number|Object"},{name:"rampTime",description:"<p>Fade for t seconds</p>\n",type:"Number",optional:!0},{name:"timeFromNow",description:"<p>Schedule this event to happen at\n                               t seconds in the future</p>\n",type:"Number",optional:!0}],class:"p5.sound",module:"p5.sound"},soundOut:{name:"soundOut",class:"p5.sound",module:"p5.sound"}},"p5.Effect":{amp:{name:"amp",params:[{name:"vol",description:"<p>amplitude between 0 and 1.0</p>\n",type:"Number",optional:!0},{name:"rampTime",description:"<p>create a fade that lasts until rampTime</p>\n",type:"Number",optional:!0},{name:"tFromNow",description:"<p>schedule this event to happen in tFromNow seconds</p>\n",type:"Number",optional:!0}],class:"p5.Effect",module:"p5.sound"},chain:{name:"chain",params:[{name:"arguments",description:"<p>Chain together multiple sound objects</p>\n",type:"Object",optional:!0}],class:"p5.Effect",module:"p5.sound"},drywet:{name:"drywet",params:[{name:"fade",description:"<p>The desired drywet value (0 - 1.0)</p>\n",type:"Number",optional:!0}],class:"p5.Effect",module:"p5.sound"},connect:{name:"connect",params:[{name:"unit",description:"",type:"Object"}],class:"p5.Effect",module:"p5.sound"},disconnect:{name:"disconnect",class:"p5.Effect",module:"p5.sound"}},"p5.Filter":{biquadFilter:{name:"biquadFilter",class:"p5.Filter",module:"p5.sound"},process:{name:"process",params:[{name:"Signal",description:"<p>An object that outputs audio</p>\n",type:"Object"},{name:"freq",description:"<p>Frequency in Hz, from 10 to 22050</p>\n",type:"Number",optional:!0},{name:"res",description:"<p>Resonance/Width of the filter frequency\n                      from 0.001 to 1000</p>\n",type:"Number",optional:!0}],class:"p5.Filter",module:"p5.sound"},set:{name:"set",params:[{name:"freq",description:"<p>Frequency in Hz, from 10 to 22050</p>\n",type:"Number",optional:!0},{name:"res",description:"<p>Resonance (Q) from 0.001 to 1000</p>\n",type:"Number",optional:!0},{name:"timeFromNow",description:"<p>schedule this event to happen\n                              seconds from now</p>\n",type:"Number",optional:!0}],class:"p5.Filter",module:"p5.sound"},freq:{name:"freq",params:[{name:"freq",description:"<p>Filter Frequency</p>\n",type:"Number"},{name:"timeFromNow",description:"<p>schedule this event to happen\n                              seconds from now</p>\n",type:"Number",optional:!0}],class:"p5.Filter",module:"p5.sound"},res:{name:"res",params:[{name:"res",description:"<p>Resonance/Width of filter freq\n                     from 0.001 to 1000</p>\n",type:"Number"},{name:"timeFromNow",description:"<p>schedule this event to happen\n                              seconds from now</p>\n",type:"Number",optional:!0}],class:"p5.Filter",module:"p5.sound"},gain:{name:"gain",params:[{name:"gain",description:"",type:"Number"}],class:"p5.Filter",module:"p5.sound"},toggle:{name:"toggle",class:"p5.Filter",module:"p5.sound"},setType:{name:"setType",params:[{name:"t",description:"",type:"String"}],class:"p5.Filter",module:"p5.sound"}},"p5.Oscillator":{start:{name:"start",params:[{name:"time",description:"<p>startTime in seconds from now.</p>\n",type:"Number",optional:!0},{name:"frequency",description:"<p>frequency in Hz.</p>\n",type:"Number",optional:!0}],class:"p5.Oscillator",module:"p5.sound"},stop:{name:"stop",params:[{name:"secondsFromNow",description:"<p>Time, in seconds from now.</p>\n",type:"Number"}],class:"p5.Oscillator",module:"p5.sound"},amp:{name:"amp",params:[{name:"vol",description:"<p>between 0 and 1.0\n                            or a modulating signal/oscillator</p>\n",type:"Number|Object"},{name:"rampTime",description:"<p>create a fade that lasts rampTime</p>\n",type:"Number",optional:!0},{name:"timeFromNow",description:"<p>schedule this event to happen\n                              seconds from now</p>\n",type:"Number",optional:!0}],class:"p5.Oscillator",module:"p5.sound"},freq:{name:"freq",params:[{name:"Frequency",description:"<p>Frequency in Hz\n                                      or modulating signal/oscillator</p>\n",type:"Number|Object"},{name:"rampTime",description:"<p>Ramp time (in seconds)</p>\n",type:"Number",optional:!0},{name:"timeFromNow",description:"<p>Schedule this event to happen\n                                 at x seconds from now</p>\n",type:"Number",optional:!0}],class:"p5.Oscillator",module:"p5.sound"},setType:{name:"setType",params:[{name:"type",description:"<p>'sine', 'triangle', 'sawtooth' or 'square'.</p>\n",type:"String"}],class:"p5.Oscillator",module:"p5.sound"},connect:{name:"connect",params:[{name:"unit",description:"<p>A p5.sound or Web Audio object</p>\n",type:"Object"}],class:"p5.Oscillator",module:"p5.sound"},disconnect:{name:"disconnect",class:"p5.Oscillator",module:"p5.sound"},pan:{name:"pan",params:[{name:"panning",description:"<p>Number between -1 and 1</p>\n",type:"Number"},{name:"timeFromNow",description:"<p>schedule this event to happen\n                              seconds from now</p>\n",type:"Number"}],class:"p5.Oscillator",module:"p5.sound"},phase:{name:"phase",params:[{name:"phase",description:"<p>float between 0.0 and 1.0</p>\n",type:"Number"}],class:"p5.Oscillator",module:"p5.sound"},add:{name:"add",params:[{name:"number",description:"<p>Constant number to add</p>\n",type:"Number"}],class:"p5.Oscillator",module:"p5.sound"},mult:{name:"mult",params:[{name:"number",description:"<p>Constant number to multiply</p>\n",type:"Number"}],class:"p5.Oscillator",module:"p5.sound"},scale:{name:"scale",params:[{name:"inMin",description:"<p>input range minumum</p>\n",type:"Number"},{name:"inMax",description:"<p>input range maximum</p>\n",type:"Number"},{name:"outMin",description:"<p>input range minumum</p>\n",type:"Number"},{name:"outMax",description:"<p>input range maximum</p>\n",type:"Number"}],class:"p5.Oscillator",module:"p5.sound"}},"p5.MonoSynth":{play:{name:"play",params:[{name:"note",description:'<p>the note you want to play, specified as a\n                               frequency in Hertz (Number) or as a midi\n                               value in Note/Octave format ("C4", "Eb3"...etc")\n                               See <a href = "https://github.com/Tonejs/Tone.js/wiki/Instruments">\n                               Tone</a>. Defaults to 440 hz.</p>\n',type:"String | Number"},{name:"velocity",description:"<p>velocity of the note to play (ranging from 0 to 1)</p>\n",type:"Number",optional:!0},{name:"secondsFromNow",description:"<p>time from now (in seconds) at which to play</p>\n",type:"Number",optional:!0},{name:"sustainTime",description:"<p>time to sustain before releasing the envelope. Defaults to 0.15 seconds.</p>\n",type:"Number",optional:!0}],class:"p5.MonoSynth",module:"p5.sound"},triggerAttack:{params:[{name:"note",description:'<p>the note you want to play, specified as a\n                               frequency in Hertz (Number) or as a midi\n                               value in Note/Octave format ("C4", "Eb3"...etc")\n                               See <a href = "https://github.com/Tonejs/Tone.js/wiki/Instruments">\n                               Tone</a>. Defaults to 440 hz</p>\n',type:"String | Number"},{name:"velocity",description:"<p>velocity of the note to play (ranging from 0 to 1)</p>\n",type:"Number",optional:!0},{name:"secondsFromNow",description:"<p>time from now (in seconds) at which to play</p>\n",type:"Number",optional:!0}],name:"triggerAttack",class:"p5.MonoSynth",module:"p5.sound"},triggerRelease:{params:[{name:"secondsFromNow",description:"<p>time to trigger the release</p>\n",type:"Number"}],name:"triggerRelease",class:"p5.MonoSynth",module:"p5.sound"},setADSR:{name:"setADSR",params:[{name:"attackTime",description:"<p>Time (in seconds before envelope\n                              reaches Attack Level</p>\n",type:"Number"},{name:"decayTime",description:"<p>Time (in seconds) before envelope\n                              reaches Decay/Sustain Level</p>\n",type:"Number",optional:!0},{name:"susRatio",description:"<p>Ratio between attackLevel and releaseLevel, on a scale from 0 to 1,\n                              where 1.0 = attackLevel, 0.0 = releaseLevel.\n                              The susRatio determines the decayLevel and the level at which the\n                              sustain portion of the envelope will sustain.\n                              For example, if attackLevel is 0.4, releaseLevel is 0,\n                              and susAmt is 0.5, the decayLevel would be 0.2. If attackLevel is\n                              increased to 1.0 (using <code>setRange</code>),\n                              then decayLevel would increase proportionally, to become 0.5.</p>\n",type:"Number",optional:!0},{name:"releaseTime",description:"<p>Time in seconds from now (defaults to 0)</p>\n",type:"Number",optional:!0}],class:"p5.MonoSynth",module:"p5.sound"},attack:{name:"attack",class:"p5.MonoSynth",module:"p5.sound"},decay:{name:"decay",class:"p5.MonoSynth",module:"p5.sound"},sustain:{name:"sustain",class:"p5.MonoSynth",module:"p5.sound"},release:{name:"release",class:"p5.MonoSynth",module:"p5.sound"},amp:{name:"amp",params:[{name:"vol",description:"<p>desired volume</p>\n",type:"Number"},{name:"rampTime",description:"<p>Time to reach new volume</p>\n",type:"Number",optional:!0}],class:"p5.MonoSynth",module:"p5.sound"},connect:{name:"connect",params:[{name:"unit",description:"<p>A p5.sound or Web Audio object</p>\n",type:"Object"}],class:"p5.MonoSynth",module:"p5.sound"},disconnect:{name:"disconnect",class:"p5.MonoSynth",module:"p5.sound"},dispose:{name:"dispose",class:"p5.MonoSynth",module:"p5.sound"}},"p5.AudioVoice":{connect:{name:"connect",params:[{name:"unit",description:"",type:"Object"}],class:"p5.AudioVoice",module:"p5.sound"},disconnect:{name:"disconnect",class:"p5.AudioVoice",module:"p5.sound"}},"p5.PolySynth":{notes:{name:"notes",class:"p5.PolySynth",module:"p5.sound"},polyvalue:{name:"polyvalue",class:"p5.PolySynth",module:"p5.sound"},AudioVoice:{name:"AudioVoice",class:"p5.PolySynth",module:"p5.sound"},play:{name:"play",params:[{name:"note",description:"<p>midi note to play (ranging from 0 to 127 - 60 being a middle C)</p>\n",type:"Number",optional:!0},{name:"velocity",description:"<p>velocity of the note to play (ranging from 0 to 1)</p>\n",type:"Number",optional:!0},{name:"secondsFromNow",description:"<p>time from now (in seconds) at which to play</p>\n",type:"Number",optional:!0},{name:"sustainTime",description:"<p>time to sustain before releasing the envelope</p>\n",type:"Number",optional:!0}],class:"p5.PolySynth",module:"p5.sound"},noteADSR:{name:"noteADSR",params:[{name:"note",description:"<p>Midi note on which ADSR should be set.</p>\n",type:"Number",optional:!0},{name:"attackTime",description:"<p>Time (in seconds before envelope\n                              reaches Attack Level</p>\n",type:"Number",optional:!0},{name:"decayTime",description:"<p>Time (in seconds) before envelope\n                              reaches Decay/Sustain Level</p>\n",type:"Number",optional:!0},{name:"susRatio",description:"<p>Ratio between attackLevel and releaseLevel, on a scale from 0 to 1,\n                              where 1.0 = attackLevel, 0.0 = releaseLevel.\n                              The susRatio determines the decayLevel and the level at which the\n                              sustain portion of the envelope will sustain.\n                              For example, if attackLevel is 0.4, releaseLevel is 0,\n                              and susAmt is 0.5, the decayLevel would be 0.2. If attackLevel is\n                              increased to 1.0 (using <code>setRange</code>),\n                              then decayLevel would increase proportionally, to become 0.5.</p>\n",type:"Number",optional:!0},{name:"releaseTime",description:"<p>Time in seconds from now (defaults to 0)</p>\n",type:"Number",optional:!0}],class:"p5.PolySynth",module:"p5.sound"},setADSR:{name:"setADSR",params:[{name:"attackTime",description:"<p>Time (in seconds before envelope\n                               reaches Attack Level</p>\n",type:"Number",optional:!0},{name:"decayTime",description:"<p>Time (in seconds) before envelope\n                               reaches Decay/Sustain Level</p>\n",type:"Number",optional:!0},{name:"susRatio",description:"<p>Ratio between attackLevel and releaseLevel, on a scale from 0 to 1,\n                               where 1.0 = attackLevel, 0.0 = releaseLevel.\n                               The susRatio determines the decayLevel and the level at which the\n                               sustain portion of the envelope will sustain.\n                               For example, if attackLevel is 0.4, releaseLevel is 0,\n                               and susAmt is 0.5, the decayLevel would be 0.2. If attackLevel is\n                               increased to 1.0 (using <code>setRange</code>),\n                               then decayLevel would increase proportionally, to become 0.5.</p>\n",type:"Number",optional:!0},{name:"releaseTime",description:"<p>Time in seconds from now (defaults to 0)</p>\n",type:"Number",optional:!0}],class:"p5.PolySynth",module:"p5.sound"},noteAttack:{name:"noteAttack",params:[{name:"note",description:"<p>midi note on which attack should be triggered.</p>\n",type:"Number",optional:!0},{name:"velocity",description:"<p>velocity of the note to play (ranging from 0 to 1)/</p>\n",type:"Number",optional:!0},{name:"secondsFromNow",description:"<p>time from now (in seconds)</p>\n",type:"Number",optional:!0}],class:"p5.PolySynth",module:"p5.sound"},noteRelease:{name:"noteRelease",params:[{name:"note",description:"<p>midi note on which attack should be triggered.\n                                  If no value is provided, all notes will be released.</p>\n",type:"Number",optional:!0},{name:"secondsFromNow",description:"<p>time to trigger the release</p>\n",type:"Number",optional:!0}],class:"p5.PolySynth",module:"p5.sound"},connect:{name:"connect",params:[{name:"unit",description:"<p>A p5.sound or Web Audio object</p>\n",type:"Object"}],class:"p5.PolySynth",module:"p5.sound"},disconnect:{name:"disconnect",class:"p5.PolySynth",module:"p5.sound"},dispose:{name:"dispose",class:"p5.PolySynth",module:"p5.sound"}},"p5.SoundFile":{isLoaded:{name:"isLoaded",class:"p5.SoundFile",module:"p5.sound"},play:{name:"play",params:[{name:"startTime",description:"<p>(optional) schedule playback to start (in seconds from now).</p>\n",type:"Number",optional:!0},{name:"rate",description:"<p>(optional) playback rate</p>\n",type:"Number",optional:!0},{name:"amp",description:"<p>(optional) amplitude (volume)\n                                    of playback</p>\n",type:"Number",optional:!0},{name:"cueStart",description:"<p>(optional) cue start time in seconds</p>\n",type:"Number",optional:!0},{name:"duration",description:"<p>(optional) duration of playback in seconds</p>\n",type:"Number",optional:!0}],class:"p5.SoundFile",module:"p5.sound"},playMode:{name:"playMode",params:[{name:"str",description:"<p>'restart' or 'sustain' or 'untilDone'</p>\n",type:"String"}],class:"p5.SoundFile",module:"p5.sound"},pause:{name:"pause",params:[{name:"startTime",description:"<p>(optional) schedule event to occur\n                             seconds from now</p>\n",type:"Number",optional:!0}],class:"p5.SoundFile",module:"p5.sound"},loop:{name:"loop",params:[{name:"startTime",description:"<p>(optional) schedule event to occur\n                            seconds from now</p>\n",type:"Number",optional:!0},{name:"rate",description:"<p>(optional) playback rate</p>\n",type:"Number",optional:!0},{name:"amp",description:"<p>(optional) playback volume</p>\n",type:"Number",optional:!0},{name:"cueLoopStart",description:"<p>(optional) startTime in seconds</p>\n",type:"Number",optional:!0},{name:"duration",description:"<p>(optional) loop duration in seconds</p>\n",type:"Number",optional:!0}],class:"p5.SoundFile",module:"p5.sound"},setLoop:{name:"setLoop",params:[{name:"Boolean",description:"<p>set looping to true or false</p>\n",type:"Boolean"}],class:"p5.SoundFile",module:"p5.sound"},isLooping:{name:"isLooping",class:"p5.SoundFile",module:"p5.sound"},isPlaying:{name:"isPlaying",class:"p5.SoundFile",module:"p5.sound"},isPaused:{name:"isPaused",class:"p5.SoundFile",module:"p5.sound"},stop:{name:"stop",params:[{name:"startTime",description:"<p>(optional) schedule event to occur\n                            in seconds from now</p>\n",type:"Number",optional:!0}],class:"p5.SoundFile",module:"p5.sound"},setVolume:{name:"setVolume",params:[{name:"volume",description:"<p>Volume (amplitude) between 0.0\n                                   and 1.0 or modulating signal/oscillator</p>\n",type:"Number|Object"},{name:"rampTime",description:"<p>Fade for t seconds</p>\n",type:"Number",optional:!0},{name:"timeFromNow",description:"<p>Schedule this event to happen at\n                               t seconds in the future</p>\n",type:"Number",optional:!0}],class:"p5.SoundFile",module:"p5.sound"},pan:{name:"pan",params:[{name:"panValue",description:"<p>Set the stereo panner</p>\n",type:"Number",optional:!0},{name:"timeFromNow",description:"<p>schedule this event to happen\n                                seconds from now</p>\n",type:"Number",optional:!0}],class:"p5.SoundFile",module:"p5.sound"},getPan:{name:"getPan",class:"p5.SoundFile",module:"p5.sound"},rate:{name:"rate",params:[{name:"playbackRate",description:"<p>Set the playback rate. 1.0 is normal,\n                                   .5 is half-speed, 2.0 is twice as fast.\n                                   Values less than zero play backwards.</p>\n",type:"Number",optional:!0}],class:"p5.SoundFile",module:"p5.sound"},duration:{name:"duration",class:"p5.SoundFile",module:"p5.sound"},currentTime:{name:"currentTime",class:"p5.SoundFile",module:"p5.sound"},jump:{name:"jump",params:[{name:"cueTime",description:"<p>cueTime of the soundFile in seconds.</p>\n",type:"Number"},{name:"duration",description:"<p>duration in seconds.</p>\n",type:"Number"}],class:"p5.SoundFile",module:"p5.sound"},channels:{name:"channels",class:"p5.SoundFile",module:"p5.sound"},sampleRate:{name:"sampleRate",class:"p5.SoundFile",module:"p5.sound"},frames:{name:"frames",class:"p5.SoundFile",module:"p5.sound"},getPeaks:{name:"getPeaks",params:[{name:"length",description:"<p>length is the size of the returned array.\n                         Larger length results in more precision.\n                         Defaults to 5*width of the browser window.</p>\n",type:"Number",optional:!0}],class:"p5.SoundFile",module:"p5.sound"},reverseBuffer:{name:"reverseBuffer",class:"p5.SoundFile",module:"p5.sound"},onended:{name:"onended",params:[{name:"callback",description:"<p>function to call when the\n                            soundfile has ended.</p>\n",type:"Function"}],class:"p5.SoundFile",module:"p5.sound"},connect:{name:"connect",params:[{name:"object",description:"<p>Audio object that accepts an input</p>\n",type:"Object",optional:!0}],class:"p5.SoundFile",module:"p5.sound"},disconnect:{name:"disconnect",class:"p5.SoundFile",module:"p5.sound"},setPath:{name:"setPath",params:[{name:"path",description:"<p>path to audio file</p>\n",type:"String"},{name:"callback",description:"<p>Callback</p>\n",type:"Function"}],class:"p5.SoundFile",module:"p5.sound"},setBuffer:{name:"setBuffer",params:[{name:"buf",description:"<p>Array of Float32 Array(s). 2 Float32 Arrays\n                   will create a stereo source. 1 will create\n                   a mono source.</p>\n",type:"Array"}],class:"p5.SoundFile",module:"p5.sound"},processPeaks:{name:"processPeaks",params:[{name:"callback",description:"<p>a function to call once this data is returned</p>\n",type:"Function"},{name:"initThreshold",description:"<p>initial threshold defaults to 0.9</p>\n",type:"Number",optional:!0},{name:"minThreshold",description:"<p>minimum threshold defaults to 0.22</p>\n",type:"Number",optional:!0},{name:"minPeaks",description:"<p>minimum number of peaks defaults to 200</p>\n",type:"Number",optional:!0}],class:"p5.SoundFile",module:"p5.sound"},addCue:{name:"addCue",params:[{name:"time",description:"<p>Time in seconds, relative to this media\n                           element's playback. For example, to trigger\n                           an event every time playback reaches two\n                           seconds, pass in the number 2. This will be\n                           passed as the first parameter to\n                           the callback function.</p>\n",type:"Number"},{name:"callback",description:"<p>Name of a function that will be\n                           called at the given time. The callback will\n                           receive time and (optionally) param as its\n                           two parameters.</p>\n",type:"Function"},{name:"value",description:"<p>An object to be passed as the\n                           second parameter to the\n                           callback function.</p>\n",type:"Object",optional:!0}],class:"p5.SoundFile",module:"p5.sound"},removeCue:{name:"removeCue",params:[{name:"id",description:"<p>ID of the cue, as returned by addCue</p>\n",type:"Number"}],class:"p5.SoundFile",module:"p5.sound"},clearCues:{name:"clearCues",class:"p5.SoundFile",module:"p5.sound"},save:{name:"save",params:[{name:"fileName",description:"<p>name of the resulting .wav file.</p>\n",type:"String",optional:!0}],class:"p5.SoundFile",module:"p5.sound"},getBlob:{name:"getBlob",class:"p5.SoundFile",module:"p5.sound"}},"p5.Amplitude":{setInput:{name:"setInput",params:[{name:"snd",description:"<p>set the sound source\n                                     (optional, defaults to\n                                     master output)</p>\n",type:"SoundObject|undefined",optional:!0},{name:"smoothing",description:"<p>a range between 0.0 and 1.0\n                                      to smooth amplitude readings</p>\n",type:"Number|undefined",optional:!0}],class:"p5.Amplitude",module:"p5.sound"},getLevel:{name:"getLevel",params:[{name:"channel",description:"<p>Optionally return only channel 0 (left) or 1 (right)</p>\n",type:"Number",optional:!0}],class:"p5.Amplitude",module:"p5.sound"},toggleNormalize:{name:"toggleNormalize",params:[{name:"boolean",description:"<p>set normalize to true (1) or false (0)</p>\n",type:"Boolean",optional:!0}],class:"p5.Amplitude",module:"p5.sound"},smooth:{name:"smooth",params:[{name:"set",description:"<p>smoothing from 0.0 <= 1</p>\n",type:"Number"}],class:"p5.Amplitude",module:"p5.sound"}},"p5.FFT":{setInput:{name:"setInput",params:[{name:"source",description:"<p>p5.sound object (or web audio API source node)</p>\n",type:"Object",optional:!0}],class:"p5.FFT",module:"p5.sound"},waveform:{name:"waveform",params:[{name:"bins",description:"<p>Must be a power of two between\n                          16 and 1024. Defaults to 1024.</p>\n",type:"Number",optional:!0},{name:"precision",description:"<p>If any value is provided, will return results\n                            in a Float32 Array which is more precise\n                            than a regular array.</p>\n",type:"String",optional:!0}],class:"p5.FFT",module:"p5.sound"},analyze:{name:"analyze",params:[{name:"bins",description:"<p>Must be a power of two between\n                           16 and 1024. Defaults to 1024.</p>\n",type:"Number",optional:!0},{name:"scale",description:'<p>If "dB," returns decibel\n                           float measurements between\n                           -140 and 0 (max).\n                           Otherwise returns integers from 0-255.</p>\n',type:"Number",optional:!0}],class:"p5.FFT",module:"p5.sound"},getEnergy:{name:"getEnergy",params:[{name:"frequency1",description:'<p>Will return a value representing\n                              energy at this frequency. Alternately,\n                              the strings "bass", "lowMid" "mid",\n                              "highMid", and "treble" will return\n                              predefined frequency ranges.</p>\n',type:"Number|String"},{name:"frequency2",description:"<p>If a second frequency is given,\n                              will return average amount of\n                              energy that exists between the\n                              two frequencies.</p>\n",type:"Number",optional:!0}],class:"p5.FFT",module:"p5.sound"},getCentroid:{name:"getCentroid",class:"p5.FFT",module:"p5.sound"},smooth:{name:"smooth",params:[{name:"smoothing",description:"<p>0.0 < smoothing < 1.0.\n                             Defaults to 0.8.</p>\n",type:"Number"}],class:"p5.FFT",module:"p5.sound"},linAverages:{name:"linAverages",params:[{name:"N",description:"<p>Number of returned frequency groups</p>\n",type:"Number"}],class:"p5.FFT",module:"p5.sound"},logAverages:{name:"logAverages",params:[{name:"octaveBands",description:"<p>Array of Octave Bands objects for grouping</p>\n",type:"Array"}],class:"p5.FFT",module:"p5.sound"},getOctaveBands:{name:"getOctaveBands",params:[{name:"N",description:"<p>Specifies the 1/N type of generated octave bands</p>\n",type:"Number"},{name:"fCtr0",description:"<p>Minimum central frequency for the lowest band</p>\n",type:"Number"}],class:"p5.FFT",module:"p5.sound"}},"p5.Signal":{fade:{name:"fade",params:[{name:"value",description:"<p>Value to set this signal</p>\n",type:"Number"},{name:"secondsFromNow",description:"<p>Length of fade, in seconds from now</p>\n",type:"Number",optional:!0}],class:"p5.Signal",module:"p5.sound"},setInput:{name:"setInput",params:[{name:"input",description:"",type:"Object"}],class:"p5.Signal",module:"p5.sound"},add:{name:"add",params:[{name:"number",description:"",type:"Number"}],class:"p5.Signal",module:"p5.sound"},mult:{name:"mult",params:[{name:"number",description:"<p>to multiply</p>\n",type:"Number"}],class:"p5.Signal",module:"p5.sound"},scale:{name:"scale",params:[{name:"number",description:"<p>to multiply</p>\n",type:"Number"},{name:"inMin",description:"<p>input range minumum</p>\n",type:"Number"},{name:"inMax",description:"<p>input range maximum</p>\n",type:"Number"},{name:"outMin",description:"<p>input range minumum</p>\n",type:"Number"},{name:"outMax",description:"<p>input range maximum</p>\n",type:"Number"}],class:"p5.Signal",module:"p5.sound"}},"p5.Envelope":{attackTime:{name:"attackTime",class:"p5.Envelope",module:"p5.sound"},attackLevel:{name:"attackLevel",class:"p5.Envelope",module:"p5.sound"},decayTime:{name:"decayTime",class:"p5.Envelope",module:"p5.sound"},decayLevel:{name:"decayLevel",class:"p5.Envelope",module:"p5.sound"},releaseTime:{name:"releaseTime",class:"p5.Envelope",module:"p5.sound"},releaseLevel:{name:"releaseLevel",class:"p5.Envelope",module:"p5.sound"},set:{name:"set",params:[{name:"attackTime",description:"<p>Time (in seconds) before level\n                               reaches attackLevel</p>\n",type:"Number"},{name:"attackLevel",description:"<p>Typically an amplitude between\n                               0.0 and 1.0</p>\n",type:"Number"},{name:"decayTime",description:"<p>Time</p>\n",type:"Number"},{name:"decayLevel",description:"<p>Amplitude (In a standard ADSR envelope,\n                               decayLevel = sustainLevel)</p>\n",type:"Number"},{name:"releaseTime",description:"<p>Release Time (in seconds)</p>\n",type:"Number"},{name:"releaseLevel",description:"<p>Amplitude</p>\n",type:"Number"}],class:"p5.Envelope",module:"p5.sound"},setADSR:{name:"setADSR",params:[{name:"attackTime",description:"<p>Time (in seconds before envelope\n                              reaches Attack Level</p>\n",type:"Number"},{name:"decayTime",description:"<p>Time (in seconds) before envelope\n                              reaches Decay/Sustain Level</p>\n",type:"Number",optional:!0},{name:"susRatio",description:"<p>Ratio between attackLevel and releaseLevel, on a scale from 0 to 1,\n                              where 1.0 = attackLevel, 0.0 = releaseLevel.\n                              The susRatio determines the decayLevel and the level at which the\n                              sustain portion of the envelope will sustain.\n                              For example, if attackLevel is 0.4, releaseLevel is 0,\n                              and susAmt is 0.5, the decayLevel would be 0.2. If attackLevel is\n                              increased to 1.0 (using <code>setRange</code>),\n                              then decayLevel would increase proportionally, to become 0.5.</p>\n",type:"Number",optional:!0},{name:"releaseTime",description:"<p>Time in seconds from now (defaults to 0)</p>\n",type:"Number",optional:!0}],class:"p5.Envelope",module:"p5.sound"},setRange:{name:"setRange",params:[{name:"aLevel",description:"<p>attack level (defaults to 1)</p>\n",type:"Number"},{name:"rLevel",description:"<p>release level (defaults to 0)</p>\n",type:"Number"}],class:"p5.Envelope",module:"p5.sound"},setInput:{name:"setInput",params:[{name:"inputs",description:"<p>A p5.sound object or\n                              Web Audio Param.</p>\n",type:"Object",optional:!0,multiple:!0}],class:"p5.Envelope",module:"p5.sound"},setExp:{name:"setExp",params:[{name:"isExp",description:"<p>true is exponential, false is linear</p>\n",type:"Boolean"}],class:"p5.Envelope",module:"p5.sound"},play:{name:"play",params:[{name:"unit",description:"<p>A p5.sound object or\n                              Web Audio Param.</p>\n",type:"Object"},{name:"startTime",description:"<p>time from now (in seconds) at which to play</p>\n",type:"Number",optional:!0},{name:"sustainTime",description:"<p>time to sustain before releasing the envelope</p>\n",type:"Number",optional:!0}],class:"p5.Envelope",module:"p5.sound"},triggerAttack:{name:"triggerAttack",params:[{name:"unit",description:"<p>p5.sound Object or Web Audio Param</p>\n",type:"Object"},{name:"secondsFromNow",description:"<p>time from now (in seconds)</p>\n",type:"Number"}],class:"p5.Envelope",module:"p5.sound"},triggerRelease:{name:"triggerRelease",params:[{name:"unit",description:"<p>p5.sound Object or Web Audio Param</p>\n",type:"Object"},{name:"secondsFromNow",description:"<p>time to trigger the release</p>\n",type:"Number"}],class:"p5.Envelope",module:"p5.sound"},ramp:{name:"ramp",params:[{name:"unit",description:"<p>p5.sound Object or Web Audio Param</p>\n",type:"Object"},{name:"secondsFromNow",description:"<p>When to trigger the ramp</p>\n",type:"Number"},{name:"v",description:"<p>Target value</p>\n",type:"Number"},{name:"v2",description:"<p>Second target value (optional)</p>\n",type:"Number",optional:!0}],class:"p5.Envelope",module:"p5.sound"},add:{name:"add",params:[{name:"number",description:"<p>Constant number to add</p>\n",type:"Number"}],class:"p5.Envelope",module:"p5.sound"},mult:{name:"mult",params:[{name:"number",description:"<p>Constant number to multiply</p>\n",type:"Number"}],class:"p5.Envelope",module:"p5.sound"},scale:{name:"scale",params:[{name:"inMin",description:"<p>input range minumum</p>\n",type:"Number"},{name:"inMax",description:"<p>input range maximum</p>\n",type:"Number"},{name:"outMin",description:"<p>input range minumum</p>\n",type:"Number"},{name:"outMax",description:"<p>input range maximum</p>\n",type:"Number"}],class:"p5.Envelope",module:"p5.sound"}},"p5.Pulse":{width:{name:"width",params:[{name:"width",description:"<p>Width between the pulses (0 to 1.0,\n                       defaults to 0)</p>\n",type:"Number",optional:!0}],class:"p5.Pulse",module:"p5.sound"}},"p5.Noise":{setType:{name:"setType",params:[{name:"type",description:"<p>'white', 'pink' or 'brown'</p>\n",type:"String",optional:!0}],class:"p5.Noise",module:"p5.sound"}},"p5.AudioIn":{input:{name:"input",class:"p5.AudioIn",module:"p5.sound"},output:{name:"output",class:"p5.AudioIn",module:"p5.sound"},stream:{name:"stream",class:"p5.AudioIn",module:"p5.sound"},mediaStream:{name:"mediaStream",class:"p5.AudioIn",module:"p5.sound"},currentSource:{name:"currentSource",class:"p5.AudioIn",module:"p5.sound"},enabled:{name:"enabled",class:"p5.AudioIn",module:"p5.sound"},amplitude:{name:"amplitude",class:"p5.AudioIn",module:"p5.sound"},start:{name:"start",params:[{name:"successCallback",description:"<p>Name of a function to call on\n                                  success.</p>\n",type:"Function",optional:!0},{name:"errorCallback",description:"<p>Name of a function to call if\n                                  there was an error. For example,\n                                  some browsers do not support\n                                  getUserMedia.</p>\n",type:"Function",optional:!0}],class:"p5.AudioIn",module:"p5.sound"},stop:{name:"stop",class:"p5.AudioIn",module:"p5.sound"},connect:{name:"connect",params:[{name:"unit",description:"<p>An object that accepts audio input,\n                        such as an FFT</p>\n",type:"Object",optional:!0}],class:"p5.AudioIn",module:"p5.sound"},disconnect:{name:"disconnect",class:"p5.AudioIn",module:"p5.sound"},getLevel:{name:"getLevel",params:[{name:"smoothing",description:"<p>Smoothing is 0.0 by default.\n                             Smooths values based on previous values.</p>\n",type:"Number",optional:!0}],class:"p5.AudioIn",module:"p5.sound"},amp:{name:"amp",params:[{name:"vol",description:"<p>between 0 and 1.0</p>\n",type:"Number"},{name:"time",description:"<p>ramp time (optional)</p>\n",type:"Number",optional:!0}],class:"p5.AudioIn",module:"p5.sound"},getSources:{name:"getSources",params:[{name:"successCallback",description:"<p>This callback function handles the sources when they\n                                     have been enumerated. The callback function\n                                     receives the deviceList array as its only argument</p>\n",type:"Function",optional:!0},{name:"errorCallback",description:"<p>This optional callback receives the error\n                                   message as its argument.</p>\n",type:"Function",optional:!0}],class:"p5.AudioIn",module:"p5.sound"},setSource:{name:"setSource",params:[{name:"num",description:"<p>position of input source in the array</p>\n",type:"Number"}],class:"p5.AudioIn",module:"p5.sound"}},"p5.EQ":{bands:{name:"bands",class:"p5.EQ",module:"p5.sound"},process:{name:"process",params:[{name:"src",description:"<p>Audio source</p>\n",type:"Object"}],class:"p5.EQ",module:"p5.sound"}},"p5.Panner3D":{panner:{name:"panner",class:"p5.Panner3D",module:"p5.sound"},process:{name:"process",params:[{name:"src",description:"<p>Input source</p>\n",type:"Object"}],class:"p5.Panner3D",module:"p5.sound"},set:{name:"set",params:[{name:"xVal",description:"",type:"Number"},{name:"yVal",description:"",type:"Number"},{name:"zVal",description:"",type:"Number"},{name:"time",description:"",type:"Number"}],class:"p5.Panner3D",module:"p5.sound"},positionX:{name:"positionX",class:"p5.Panner3D",module:"p5.sound"},positionY:{name:"positionY",class:"p5.Panner3D",module:"p5.sound"},positionZ:{name:"positionZ",class:"p5.Panner3D",module:"p5.sound"},orient:{name:"orient",params:[{name:"xVal",description:"",type:"Number"},{name:"yVal",description:"",type:"Number"},{name:"zVal",description:"",type:"Number"},{name:"time",description:"",type:"Number"}],class:"p5.Panner3D",module:"p5.sound"},orientX:{name:"orientX",class:"p5.Panner3D",module:"p5.sound"},orientY:{name:"orientY",class:"p5.Panner3D",module:"p5.sound"},orientZ:{name:"orientZ",class:"p5.Panner3D",module:"p5.sound"},setFalloff:{name:"setFalloff",params:[{name:"maxDistance",description:"",type:"Number",optional:!0},{name:"rolloffFactor",description:"",type:"Number",optional:!0}],class:"p5.Panner3D",module:"p5.sound"},maxDist:{name:"maxDist",params:[{name:"maxDistance",description:"",type:"Number"}],class:"p5.Panner3D",module:"p5.sound"},rollof:{name:"rollof",params:[{name:"rolloffFactor",description:"",type:"Number"}],class:"p5.Panner3D",module:"p5.sound"}},"p5.Delay":{leftDelay:{name:"leftDelay",class:"p5.Delay",module:"p5.sound"},rightDelay:{name:"rightDelay",class:"p5.Delay",module:"p5.sound"},process:{name:"process",params:[{name:"Signal",description:"<p>An object that outputs audio</p>\n",type:"Object"},{name:"delayTime",description:"<p>Time (in seconds) of the delay/echo.\n                             Some browsers limit delayTime to\n                             1 second.</p>\n",type:"Number",optional:!0},{name:"feedback",description:"<p>sends the delay back through itself\n                             in a loop that decreases in volume\n                             each time.</p>\n",type:"Number",optional:!0},{name:"lowPass",description:"<p>Cutoff frequency. Only frequencies\n                             below the lowPass will be part of the\n                             delay.</p>\n",type:"Number",optional:!0}],class:"p5.Delay",module:"p5.sound"},delayTime:{name:"delayTime",params:[{name:"delayTime",description:"<p>Time (in seconds) of the delay</p>\n",type:"Number"}],class:"p5.Delay",module:"p5.sound"},feedback:{name:"feedback",params:[{name:"feedback",description:"<p>0.0 to 1.0, or an object such as an\n                                Oscillator that can be used to\n                                modulate this param</p>\n",type:"Number|Object"}],class:"p5.Delay",module:"p5.sound"},filter:{name:"filter",params:[{name:"cutoffFreq",description:"<p>A lowpass filter will cut off any\n                            frequencies higher than the filter frequency.</p>\n",type:"Number|Object"},{name:"res",description:"<p>Resonance of the filter frequency\n                            cutoff, or an object (i.e. a p5.Oscillator)\n                            that can be used to modulate this parameter.\n                            High numbers (i.e. 15) will produce a resonance,\n                            low numbers (i.e. .2) will produce a slope.</p>\n",type:"Number|Object"}],class:"p5.Delay",module:"p5.sound"},setType:{name:"setType",params:[{name:"type",description:"<p>'pingPong' (1) or 'default' (0)</p>\n",type:"String|Number"}],class:"p5.Delay",module:"p5.sound"},amp:{name:"amp",params:[{name:"volume",description:"<p>amplitude between 0 and 1.0</p>\n",type:"Number"},{name:"rampTime",description:"<p>create a fade that lasts rampTime</p>\n",type:"Number",optional:!0},{name:"timeFromNow",description:"<p>schedule this event to happen\n                              seconds from now</p>\n",type:"Number",optional:!0}],class:"p5.Delay",module:"p5.sound"},connect:{name:"connect",params:[{name:"unit",description:"",type:"Object"}],class:"p5.Delay",module:"p5.sound"},disconnect:{name:"disconnect",class:"p5.Delay",module:"p5.sound"}},"p5.Reverb":{process:{name:"process",params:[{name:"src",description:"<p>p5.sound / Web Audio object with a sound\n                         output.</p>\n",type:"Object"},{name:"seconds",description:"<p>Duration of the reverb, in seconds.\n                         Min: 0, Max: 10. Defaults to 3.</p>\n",type:"Number",optional:!0},{name:"decayRate",description:"<p>Percentage of decay with each echo.\n                          Min: 0, Max: 100. Defaults to 2.</p>\n",type:"Number",optional:!0},{name:"reverse",description:"<p>Play the reverb backwards or forwards.</p>\n",type:"Boolean",optional:!0}],class:"p5.Reverb",module:"p5.sound"},set:{name:"set",params:[{name:"seconds",description:"<p>Duration of the reverb, in seconds.\n                         Min: 0, Max: 10. Defaults to 3.</p>\n",type:"Number",optional:!0},{name:"decayRate",description:"<p>Percentage of decay with each echo.\n                          Min: 0, Max: 100. Defaults to 2.</p>\n",type:"Number",optional:!0},{name:"reverse",description:"<p>Play the reverb backwards or forwards.</p>\n",type:"Boolean",optional:!0}],class:"p5.Reverb",module:"p5.sound"},amp:{name:"amp",params:[{name:"volume",description:"<p>amplitude between 0 and 1.0</p>\n",type:"Number"},{name:"rampTime",description:"<p>create a fade that lasts rampTime</p>\n",type:"Number",optional:!0},{name:"timeFromNow",description:"<p>schedule this event to happen\n                              seconds from now</p>\n",type:"Number",optional:!0}],class:"p5.Reverb",module:"p5.sound"},connect:{name:"connect",params:[{name:"unit",description:"",type:"Object"}],class:"p5.Reverb",module:"p5.sound"},disconnect:{name:"disconnect",class:"p5.Reverb",module:"p5.sound"}},"p5.Convolver":{convolverNode:{name:"convolverNode",class:"p5.Convolver",module:"p5.sound"},process:{name:"process",params:[{name:"src",description:"<p>p5.sound / Web Audio object with a sound\n                         output.</p>\n",type:"Object"}],class:"p5.Convolver",module:"p5.sound"},impulses:{name:"impulses",class:"p5.Convolver",module:"p5.sound"},addImpulse:{name:"addImpulse",params:[{name:"path",description:"<p>path to a sound file</p>\n",type:"String"},{name:"callback",description:"<p>function (optional)</p>\n",type:"Function"},{name:"errorCallback",description:"<p>function (optional)</p>\n",type:"Function"}],class:"p5.Convolver",module:"p5.sound"},resetImpulse:{name:"resetImpulse",params:[{name:"path",description:"<p>path to a sound file</p>\n",type:"String"},{name:"callback",description:"<p>function (optional)</p>\n",type:"Function"},{name:"errorCallback",description:"<p>function (optional)</p>\n",type:"Function"}],class:"p5.Convolver",module:"p5.sound"},toggleImpulse:{name:"toggleImpulse",params:[{name:"id",description:"<p>Identify the impulse by its original filename\n                          (String), or by its position in the\n                          <code>.impulses</code> Array (Number).</p>\n",type:"String|Number"}],class:"p5.Convolver",module:"p5.sound"}},"p5.Phrase":{sequence:{name:"sequence",class:"p5.Phrase",module:"p5.sound"}},"p5.Part":{setBPM:{name:"setBPM",params:[{name:"BPM",description:"<p>Beats Per Minute</p>\n",type:"Number"},{name:"rampTime",description:"<p>Seconds from now</p>\n",type:"Number",optional:!0}],class:"p5.Part",module:"p5.sound"},getBPM:{name:"getBPM",class:"p5.Part",module:"p5.sound"},start:{name:"start",params:[{name:"time",description:"<p>seconds from now</p>\n",type:"Number",optional:!0}],class:"p5.Part",module:"p5.sound"},loop:{name:"loop",params:[{name:"time",description:"<p>seconds from now</p>\n",type:"Number",optional:!0}],class:"p5.Part",module:"p5.sound"},noLoop:{name:"noLoop",class:"p5.Part",module:"p5.sound"},stop:{name:"stop",params:[{name:"time",description:"<p>seconds from now</p>\n",type:"Number",optional:!0}],class:"p5.Part",module:"p5.sound"},pause:{name:"pause",params:[{name:"time",description:"<p>seconds from now</p>\n",type:"Number"}],class:"p5.Part",module:"p5.sound"},addPhrase:{name:"addPhrase",params:[{name:"phrase",description:"<p>reference to a p5.Phrase</p>\n",type:"p5.Phrase"}],class:"p5.Part",module:"p5.sound"},removePhrase:{name:"removePhrase",params:[{name:"phraseName",description:"",type:"String"}],class:"p5.Part",module:"p5.sound"},getPhrase:{name:"getPhrase",params:[{name:"phraseName",description:"",type:"String"}],class:"p5.Part",module:"p5.sound"},replaceSequence:{name:"replaceSequence",params:[{name:"phraseName",description:"",type:"String"},{name:"sequence",description:"<p>Array of values to pass into the callback\n                          at each step of the phrase.</p>\n",type:"Array"}],class:"p5.Part",module:"p5.sound"},onStep:{name:"onStep",params:[{name:"callback",description:"<p>The name of the callback\n                            you want to fire\n                            on every beat/tatum.</p>\n",type:"Function"}],class:"p5.Part",module:"p5.sound"}},"p5.Score":{start:{name:"start",class:"p5.Score",module:"p5.sound"},stop:{name:"stop",class:"p5.Score",module:"p5.sound"},pause:{name:"pause",class:"p5.Score",module:"p5.sound"},loop:{name:"loop",class:"p5.Score",module:"p5.sound"},noLoop:{name:"noLoop",class:"p5.Score",module:"p5.sound"},setBPM:{name:"setBPM",params:[{name:"BPM",description:"<p>Beats Per Minute</p>\n",type:"Number"},{name:"rampTime",description:"<p>Seconds from now</p>\n",type:"Number"}],class:"p5.Score",module:"p5.sound"}},"p5.SoundLoop":{musicalTimeMode:{name:"musicalTimeMode",class:"p5.SoundLoop",module:"p5.sound"},maxIterations:{name:"maxIterations",class:"p5.SoundLoop",module:"p5.sound"},start:{name:"start",params:[{name:"timeFromNow",description:"<p>schedule a starting time</p>\n",type:"Number",optional:!0}],class:"p5.SoundLoop",module:"p5.sound"},stop:{name:"stop",params:[{name:"timeFromNow",description:"<p>schedule a stopping time</p>\n",type:"Number",optional:!0}],class:"p5.SoundLoop",module:"p5.sound"},pause:{name:"pause",params:[{name:"timeFromNow",description:"<p>schedule a pausing time</p>\n",type:"Number",optional:!0}],class:"p5.SoundLoop",module:"p5.sound"},syncedStart:{name:"syncedStart",params:[{name:"otherLoop",description:"<p>a p5.SoundLoop to sync with</p>\n",type:"Object"},{name:"timeFromNow",description:"<p>Start the loops in sync after timeFromNow seconds</p>\n",type:"Number",optional:!0}],class:"p5.SoundLoop",module:"p5.sound"},bpm:{name:"bpm",class:"p5.SoundLoop",module:"p5.sound"},timeSignature:{name:"timeSignature",class:"p5.SoundLoop",module:"p5.sound"},interval:{name:"interval",class:"p5.SoundLoop",module:"p5.sound"},iterations:{name:"iterations",class:"p5.SoundLoop",module:"p5.sound"}},"p5.Compressor":{compressor:{name:"compressor",class:"p5.Compressor",module:"p5.sound"},process:{name:"process",params:[{name:"src",description:"<p>Sound source to be connected</p>\n",type:"Object"},{name:"attack",description:"<p>The amount of time (in seconds) to reduce the gain by 10dB,\n                           default = .003, range 0 - 1</p>\n",type:"Number",optional:!0},{name:"knee",description:'<p>A decibel value representing the range above the\n                           threshold where the curve smoothly transitions to the "ratio" portion.\n                           default = 30, range 0 - 40</p>\n',type:"Number",optional:!0},{name:"ratio",description:"<p>The amount of dB change in input for a 1 dB change in output\n                           default = 12, range 1 - 20</p>\n",type:"Number",optional:!0},{name:"threshold",description:"<p>The decibel value above which the compression will start taking effect\n                           default = -24, range -100 - 0</p>\n",type:"Number",optional:!0},{name:"release",description:"<p>The amount of time (in seconds) to increase the gain by 10dB\n                           default = .25, range 0 - 1</p>\n",type:"Number",optional:!0}],class:"p5.Compressor",module:"p5.sound"},set:{name:"set",params:[{name:"attack",description:"<p>The amount of time (in seconds) to reduce the gain by 10dB,\n                           default = .003, range 0 - 1</p>\n",type:"Number"},{name:"knee",description:'<p>A decibel value representing the range above the\n                           threshold where the curve smoothly transitions to the "ratio" portion.\n                           default = 30, range 0 - 40</p>\n',type:"Number"},{name:"ratio",description:"<p>The amount of dB change in input for a 1 dB change in output\n                           default = 12, range 1 - 20</p>\n",type:"Number"},{name:"threshold",description:"<p>The decibel value above which the compression will start taking effect\n                           default = -24, range -100 - 0</p>\n",type:"Number"},{name:"release",description:"<p>The amount of time (in seconds) to increase the gain by 10dB\n                           default = .25, range 0 - 1</p>\n",type:"Number"}],class:"p5.Compressor",module:"p5.sound"},attack:{name:"attack",params:[{name:"attack",description:"<p>Attack is the amount of time (in seconds) to reduce the gain by 10dB,\n                         default = .003, range 0 - 1</p>\n",type:"Number",optional:!0},{name:"time",description:"<p>Assign time value to schedule the change in value</p>\n",type:"Number",optional:!0}],class:"p5.Compressor",module:"p5.sound"},knee:{name:"knee",params:[{name:"knee",description:'<p>A decibel value representing the range above the\n                       threshold where the curve smoothly transitions to the "ratio" portion.\n                       default = 30, range 0 - 40</p>\n',type:"Number",optional:!0},{name:"time",description:"<p>Assign time value to schedule the change in value</p>\n",type:"Number",optional:!0}],class:"p5.Compressor",module:"p5.sound"},ratio:{name:"ratio",params:[{name:"ratio",description:"<p>The amount of dB change in input for a 1 dB change in output\n                           default = 12, range 1 - 20</p>\n",type:"Number",optional:!0},{name:"time",description:"<p>Assign time value to schedule the change in value</p>\n",type:"Number",optional:!0}],class:"p5.Compressor",module:"p5.sound"},threshold:{name:"threshold",params:[{name:"threshold",description:"<p>The decibel value above which the compression will start taking effect\n                           default = -24, range -100 - 0</p>\n",type:"Number"},{name:"time",description:"<p>Assign time value to schedule the change in value</p>\n",type:"Number",optional:!0}],class:"p5.Compressor",module:"p5.sound"},release:{name:"release",params:[{name:"release",description:"<p>The amount of time (in seconds) to increase the gain by 10dB\n                           default = .25, range 0 - 1</p>\n",type:"Number"},{name:"time",description:"<p>Assign time value to schedule the change in value</p>\n",type:"Number",optional:!0}],class:"p5.Compressor",module:"p5.sound"},reduction:{name:"reduction",class:"p5.Compressor",module:"p5.sound"}},"p5.SoundRecorder":{setInput:{name:"setInput",params:[{name:"unit",description:"<p>p5.sound object or a web audio unit\n                       that outputs sound</p>\n",type:"Object",optional:!0}],class:"p5.SoundRecorder",module:"p5.sound"},record:{name:"record",params:[{name:"soundFile",description:"<p>p5.SoundFile</p>\n",type:"p5.SoundFile"},{name:"duration",description:"<p>Time (in seconds)</p>\n",type:"Number",optional:!0},{name:"callback",description:"<p>The name of a function that will be\n                              called once the recording completes</p>\n",type:"Function",optional:!0}],class:"p5.SoundRecorder",module:"p5.sound"},stop:{name:"stop",class:"p5.SoundRecorder",module:"p5.sound"}},"p5.PeakDetect":{isDetected:{name:"isDetected",class:"p5.PeakDetect",module:"p5.sound"},update:{name:"update",params:[{name:"fftObject",description:"<p>A p5.FFT object</p>\n",type:"p5.FFT"}],class:"p5.PeakDetect",module:"p5.sound"},onPeak:{name:"onPeak",params:[{name:"callback",description:"<p>Name of a function that will\n                            be called when a peak is\n                            detected.</p>\n",type:"Function"},{name:"val",description:"<p>Optional value to pass\n                            into the function when\n                            a peak is detected.</p>\n",type:"Object",optional:!0}],class:"p5.PeakDetect",module:"p5.sound"}},"p5.Gain":{setInput:{name:"setInput",params:[{name:"src",description:"<p>p5.sound / Web Audio object with a sound\n                         output.</p>\n",type:"Object"}],class:"p5.Gain",module:"p5.sound"},connect:{name:"connect",params:[{name:"unit",description:"",type:"Object"}],class:"p5.Gain",module:"p5.sound"},disconnect:{name:"disconnect",class:"p5.Gain",module:"p5.sound"},amp:{name:"amp",params:[{name:"volume",description:"<p>amplitude between 0 and 1.0</p>\n",type:"Number"},{name:"rampTime",description:"<p>create a fade that lasts rampTime</p>\n",type:"Number",optional:!0},{name:"timeFromNow",description:"<p>schedule this event to happen\n                              seconds from now</p>\n",type:"Number",optional:!0}],class:"p5.Gain",module:"p5.sound"}},"p5.Distortion":{WaveShaperNode:{name:"WaveShaperNode",class:"p5.Distortion",module:"p5.sound"},process:{name:"process",params:[{name:"amount",description:"<p>Unbounded distortion amount.\n                               Normal values range from 0-1.</p>\n",type:"Number",optional:!0,optdefault:"0.25"},{name:"oversample",description:"<p>'none', '2x', or '4x'.</p>\n",type:"String",optional:!0,optdefault:"'none'"}],class:"p5.Distortion",module:"p5.sound"},set:{name:"set",params:[{name:"amount",description:"<p>Unbounded distortion amount.\n                               Normal values range from 0-1.</p>\n",type:"Number",optional:!0,optdefault:"0.25"},{name:"oversample",description:"<p>'none', '2x', or '4x'.</p>\n",type:"String",optional:!0,optdefault:"'none'"}],class:"p5.Distortion",module:"p5.sound"},getAmount:{name:"getAmount",class:"p5.Distortion",module:"p5.sound"},getOversample:{name:"getOversample",class:"p5.Distortion",module:"p5.sound"}}};},{}],2:[function(e,t,r){r.byteLength=function(e){var t=c(e),r=t[0],n=t[1];return 3*(r+n)/4-n},r.toByteArray=function(e){var t,r,n=c(e),a=n[0],o=n[1],i=new u(function(e,t){return 3*(e+t)/4-t}(a,o)),s=0,l=0<o?a-4:a;for(r=0;r<l;r+=4)t=p[e.charCodeAt(r)]<<18|p[e.charCodeAt(r+1)]<<12|p[e.charCodeAt(r+2)]<<6|p[e.charCodeAt(r+3)],i[s++]=t>>16&255,i[s++]=t>>8&255,i[s++]=255&t;2===o&&(t=p[e.charCodeAt(r)]<<2|p[e.charCodeAt(r+1)]>>4,i[s++]=255&t);1===o&&(t=p[e.charCodeAt(r)]<<10|p[e.charCodeAt(r+1)]<<4|p[e.charCodeAt(r+2)]>>2,i[s++]=t>>8&255,i[s++]=255&t);return i},r.fromByteArray=function(e){for(var t,r=e.length,n=r%3,a=[],o=0,i=r-n;o<i;o+=16383)a.push(l(e,o,i<o+16383?i:o+16383));1==n?(t=e[r-1],a.push(s[t>>2]+s[t<<4&63]+"==")):2==n&&(t=(e[r-2]<<8)+e[r-1],a.push(s[t>>10]+s[t>>4&63]+s[t<<2&63]+"="));return a.join("")};for(var s=[],p=[],u="undefined"!=typeof Uint8Array?Uint8Array:Array,n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=0,o=n.length;a<o;++a)s[a]=n[a],p[n.charCodeAt(a)]=a;function c(e){var t=e.length;if(0<t%4)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");return -1===r&&(r=t),[r,r===t?0:4-r%4]}function l(e,t,r){for(var n,a,o=[],i=t;i<r;i+=3)n=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(255&e[i+2]),o.push(s[(a=n)>>18&63]+s[a>>12&63]+s[a>>6&63]+s[63&a]);return o.join("")}p["-".charCodeAt(0)]=62,p["_".charCodeAt(0)]=63;},{}],3:[function(e,t,r){},{}],4:[function(e,t,r){arguments[4][3][0].apply(r,arguments);},{dup:3}],5:[function(F,e,U){(function(c){var n=F("base64-js"),o=F("ieee754"),e="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;U.Buffer=c,U.SlowBuffer=function(e){+e!=e&&(e=0);return c.alloc(+e)},U.INSPECT_MAX_BYTES=50;var r=2147483647;function i(e){if(r<e)throw new RangeError('The value "'+e+'" is invalid for option "size"');var t=new Uint8Array(e);return Object.setPrototypeOf(t,c.prototype),t}function c(e,t,r){if("number"!=typeof e)return a(e,t,r);if("string"==typeof t)throw new TypeError('The "string" argument must be of type string. Received type number');return l(e)}function a(e,t,r){if("string"==typeof e)return function(e,t){"string"==typeof t&&""!==t||(t="utf8");if(!c.isEncoding(t))throw new TypeError("Unknown encoding: "+t);var r=0|d(e,t),n=i(r),a=n.write(e,t);a!==r&&(n=n.slice(0,a));return n}(e,t);if(ArrayBuffer.isView(e))return p(e);if(null==e)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(D(e,ArrayBuffer)||e&&D(e.buffer,ArrayBuffer))return function(e,t,r){if(t<0||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(r||0))throw new RangeError('"length" is outside of buffer bounds');var n;n=void 0===t&&void 0===r?new Uint8Array(e):void 0===r?new Uint8Array(e,t):new Uint8Array(e,t,r);return Object.setPrototypeOf(n,c.prototype),n}(e,t,r);if("number"==typeof e)throw new TypeError('The "value" argument must not be of type number. Received type number');var n=e.valueOf&&e.valueOf();if(null!=n&&n!==e)return c.from(n,t,r);var a=function(e){if(c.isBuffer(e)){var t=0|u(e.length),r=i(t);return 0===r.length||e.copy(r,0,0,t),r}if(void 0!==e.length)return "number"!=typeof e.length||A(e.length)?i(0):p(e);if("Buffer"===e.type&&Array.isArray(e.data))return p(e.data)}(e);if(a)return a;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return c.from(e[Symbol.toPrimitive]("string"),t,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function s(e){if("number"!=typeof e)throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function l(e){return s(e),i(e<0?0:0|u(e))}function p(e){for(var t=e.length<0?0:0|u(e.length),r=i(t),n=0;n<t;n+=1)r[n]=255&e[n];return r}function u(e){if(r<=e)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+r.toString(16)+" bytes");return 0|e}function d(e,t){if(c.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||D(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);var r=e.length,n=2<arguments.length&&!0===arguments[2];if(!n&&0===r)return 0;for(var a=!1;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return I(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return P(e).length;default:if(a)return n?-1:I(e).length;t=(""+t).toLowerCase(),a=!0;}}function h(e,t,r){var n=e[t];e[t]=e[r],e[r]=n;}function m(e,t,r,n,a){if(0===e.length)return -1;if("string"==typeof r?(n=r,r=0):2147483647<r?r=2147483647:r<-2147483648&&(r=-2147483648),A(r=+r)&&(r=a?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(a)return -1;r=e.length-1;}else if(r<0){if(!a)return -1;r=0;}if("string"==typeof t&&(t=c.from(t,n)),c.isBuffer(t))return 0===t.length?-1:f(e,t,r,n,a);if("number"==typeof t)return t&=255,"function"==typeof Uint8Array.prototype.indexOf?a?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):f(e,[t],r,n,a);throw new TypeError("val must be string, number or Buffer")}function f(e,t,r,n,a){var o,i=1,s=e.length,l=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return -1;s/=i=2,l/=2,r/=2;}function p(e,t){return 1===i?e[t]:e.readUInt16BE(t*i)}if(a){var u=-1;for(o=r;o<s;o++)if(p(e,o)===p(t,-1===u?0:o-u)){if(-1===u&&(u=o),o-u+1===l)return u*i}else -1!==u&&(o-=o-u),u=-1;}else for(s<r+l&&(r=s-l),o=r;0<=o;o--){for(var c=!0,d=0;d<l;d++)if(p(e,o+d)!==p(t,d)){c=!1;break}if(c)return o}return -1}function y(e,t,r,n){r=Number(r)||0;var a=e.length-r;n?a<(n=Number(n))&&(n=a):n=a;var o=t.length;o/2<n&&(n=o/2);for(var i=0;i<n;++i){var s=parseInt(t.substr(2*i,2),16);if(A(s))return i;e[r+i]=s;}return i}function g(e,t,r,n){return R(function(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}(t),e,r,n)}function v(e,t,r,n){return R(function(e,t){for(var r,n,a,o=[],i=0;i<e.length&&!((t-=2)<0);++i)r=e.charCodeAt(i),n=r>>8,a=r%256,o.push(a),o.push(n);return o}(t,e.length-r),e,r,n)}function b(e,t,r){return 0===t&&r===e.length?n.fromByteArray(e):n.fromByteArray(e.slice(t,r))}function _(e,t,r){r=Math.min(e.length,r);for(var n=[],a=t;a<r;){var o,i,s,l,p=e[a],u=null,c=239<p?4:223<p?3:191<p?2:1;if(a+c<=r)switch(c){case 1:p<128&&(u=p);break;case 2:128==(192&(o=e[a+1]))&&127<(l=(31&p)<<6|63&o)&&(u=l);break;case 3:o=e[a+1],i=e[a+2],128==(192&o)&&128==(192&i)&&2047<(l=(15&p)<<12|(63&o)<<6|63&i)&&(l<55296||57343<l)&&(u=l);break;case 4:o=e[a+1],i=e[a+2],s=e[a+3],128==(192&o)&&128==(192&i)&&128==(192&s)&&65535<(l=(15&p)<<18|(63&o)<<12|(63&i)<<6|63&s)&&l<1114112&&(u=l);}null===u?(u=65533,c=1):65535<u&&(u-=65536,n.push(u>>>10&1023|55296),u=56320|1023&u),n.push(u),a+=c;}return function(e){var t=e.length;if(t<=x)return String.fromCharCode.apply(String,e);var r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=x));return r}(n)}U.kMaxLength=r,(c.TYPED_ARRAY_SUPPORT=function(){try{var e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),42===e.foo()}catch(e){return !1}}())||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(c.prototype,"parent",{enumerable:!0,get:function(){if(c.isBuffer(this))return this.buffer}}),Object.defineProperty(c.prototype,"offset",{enumerable:!0,get:function(){if(c.isBuffer(this))return this.byteOffset}}),"undefined"!=typeof Symbol&&null!=Symbol.species&&c[Symbol.species]===c&&Object.defineProperty(c,Symbol.species,{value:null,configurable:!0,enumerable:!1,writable:!1}),c.poolSize=8192,c.from=function(e,t,r){return a(e,t,r)},Object.setPrototypeOf(c.prototype,Uint8Array.prototype),Object.setPrototypeOf(c,Uint8Array),c.alloc=function(e,t,r){return a=t,o=r,s(n=e),n<=0?i(n):void 0!==a?"string"==typeof o?i(n).fill(a,o):i(n).fill(a):i(n);var n,a,o;},c.allocUnsafe=function(e){return l(e)},c.allocUnsafeSlow=function(e){return l(e)},c.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==c.prototype},c.compare=function(e,t){if(D(e,Uint8Array)&&(e=c.from(e,e.offset,e.byteLength)),D(t,Uint8Array)&&(t=c.from(t,t.offset,t.byteLength)),!c.isBuffer(e)||!c.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;for(var r=e.length,n=t.length,a=0,o=Math.min(r,n);a<o;++a)if(e[a]!==t[a]){r=e[a],n=t[a];break}return r<n?-1:n<r?1:0},c.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return !0;default:return !1}},c.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return c.alloc(0);var r;if(void 0===t)for(r=t=0;r<e.length;++r)t+=e[r].length;var n=c.allocUnsafe(t),a=0;for(r=0;r<e.length;++r){var o=e[r];if(D(o,Uint8Array)&&(o=c.from(o)),!c.isBuffer(o))throw new TypeError('"list" argument must be an Array of Buffers');o.copy(n,a),a+=o.length;}return n},c.byteLength=d,c.prototype._isBuffer=!0,c.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)h(this,t,t+1);return this},c.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)h(this,t,t+3),h(this,t+1,t+2);return this},c.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)h(this,t,t+7),h(this,t+1,t+6),h(this,t+2,t+5),h(this,t+3,t+4);return this},c.prototype.toLocaleString=c.prototype.toString=function(){var e=this.length;return 0===e?"":0===arguments.length?_(this,0,e):function(e,t,r){var n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return "";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return "";if((r>>>=0)<=(t>>>=0))return "";for(e=e||"utf8";;)switch(e){case"hex":return M(this,t,r);case"utf8":case"utf-8":return _(this,t,r);case"ascii":return S(this,t,r);case"latin1":case"binary":return w(this,t,r);case"base64":return b(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return E(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0;}}.apply(this,arguments)},c.prototype.equals=function(e){if(!c.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===c.compare(this,e)},c.prototype.inspect=function(){var e="",t=U.INSPECT_MAX_BYTES;return e=this.toString("hex",0,t).replace(/(.{2})/g,"$1 ").trim(),this.length>t&&(e+=" ... "),"<Buffer "+e+">"},e&&(c.prototype[e]=c.prototype.inspect),c.prototype.compare=function(e,t,r,n,a){if(D(e,Uint8Array)&&(e=c.from(e,e.offset,e.byteLength)),!c.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===a&&(a=this.length),t<0||r>e.length||n<0||a>this.length)throw new RangeError("out of range index");if(a<=n&&r<=t)return 0;if(a<=n)return -1;if(r<=t)return 1;if(this===e)return 0;for(var o=(a>>>=0)-(n>>>=0),i=(r>>>=0)-(t>>>=0),s=Math.min(o,i),l=this.slice(n,a),p=e.slice(t,r),u=0;u<s;++u)if(l[u]!==p[u]){o=l[u],i=p[u];break}return o<i?-1:i<o?1:0},c.prototype.includes=function(e,t,r){return -1!==this.indexOf(e,t,r)},c.prototype.indexOf=function(e,t,r){return m(this,e,t,r,!0)},c.prototype.lastIndexOf=function(e,t,r){return m(this,e,t,r,!1)},c.prototype.write=function(e,t,r,n){if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else {if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t>>>=0,isFinite(r)?(r>>>=0,void 0===n&&(n="utf8")):(n=r,r=void 0);}var a=this.length-t;if((void 0===r||a<r)&&(r=a),0<e.length&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n=n||"utf8";for(var o,i,s,l,p,u,c=!1;;)switch(n){case"hex":return y(this,e,t,r);case"utf8":case"utf-8":return p=t,u=r,R(I(e,(l=this).length-p),l,p,u);case"ascii":return g(this,e,t,r);case"latin1":case"binary":return g(this,e,t,r);case"base64":return o=this,i=t,s=r,R(P(e),o,i,s);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return v(this,e,t,r);default:if(c)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),c=!0;}},c.prototype.toJSON=function(){return {type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var x=4096;function S(e,t,r){var n="";r=Math.min(e.length,r);for(var a=t;a<r;++a)n+=String.fromCharCode(127&e[a]);return n}function w(e,t,r){var n="";r=Math.min(e.length,r);for(var a=t;a<r;++a)n+=String.fromCharCode(e[a]);return n}function M(e,t,r){var n=e.length;(!t||t<0)&&(t=0),(!r||r<0||n<r)&&(r=n);for(var a="",o=t;o<r;++o)a+=k[e[o]];return a}function E(e,t,r){for(var n=e.slice(t,r),a="",o=0;o<n.length;o+=2)a+=String.fromCharCode(n[o]+256*n[o+1]);return a}function T(e,t,r){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(r<e+t)throw new RangeError("Trying to access beyond buffer length")}function C(e,t,r,n,a,o){if(!c.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(a<t||t<o)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}function N(e,t,r,n){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function O(e,t,r,n,a){return t=+t,r>>>=0,a||N(e,0,r,4),o.write(e,t,r,n,23,4),r+4}function L(e,t,r,n,a){return t=+t,r>>>=0,a||N(e,0,r,8),o.write(e,t,r,n,52,8),r+8}c.prototype.slice=function(e,t){var r=this.length;(e=~~e)<0?(e+=r)<0&&(e=0):r<e&&(e=r),(t=void 0===t?r:~~t)<0?(t+=r)<0&&(t=0):r<t&&(t=r),t<e&&(t=e);var n=this.subarray(e,t);return Object.setPrototypeOf(n,c.prototype),n},c.prototype.readUIntLE=function(e,t,r){e>>>=0,t>>>=0,r||T(e,t,this.length);for(var n=this[e],a=1,o=0;++o<t&&(a*=256);)n+=this[e+o]*a;return n},c.prototype.readUIntBE=function(e,t,r){e>>>=0,t>>>=0,r||T(e,t,this.length);for(var n=this[e+--t],a=1;0<t&&(a*=256);)n+=this[e+--t]*a;return n},c.prototype.readUInt8=function(e,t){return e>>>=0,t||T(e,1,this.length),this[e]},c.prototype.readUInt16LE=function(e,t){return e>>>=0,t||T(e,2,this.length),this[e]|this[e+1]<<8},c.prototype.readUInt16BE=function(e,t){return e>>>=0,t||T(e,2,this.length),this[e]<<8|this[e+1]},c.prototype.readUInt32LE=function(e,t){return e>>>=0,t||T(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},c.prototype.readUInt32BE=function(e,t){return e>>>=0,t||T(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},c.prototype.readIntLE=function(e,t,r){e>>>=0,t>>>=0,r||T(e,t,this.length);for(var n=this[e],a=1,o=0;++o<t&&(a*=256);)n+=this[e+o]*a;return (a*=128)<=n&&(n-=Math.pow(2,8*t)),n},c.prototype.readIntBE=function(e,t,r){e>>>=0,t>>>=0,r||T(e,t,this.length);for(var n=t,a=1,o=this[e+--n];0<n&&(a*=256);)o+=this[e+--n]*a;return (a*=128)<=o&&(o-=Math.pow(2,8*t)),o},c.prototype.readInt8=function(e,t){return e>>>=0,t||T(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},c.prototype.readInt16LE=function(e,t){e>>>=0,t||T(e,2,this.length);var r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},c.prototype.readInt16BE=function(e,t){e>>>=0,t||T(e,2,this.length);var r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},c.prototype.readInt32LE=function(e,t){return e>>>=0,t||T(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},c.prototype.readInt32BE=function(e,t){return e>>>=0,t||T(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},c.prototype.readFloatLE=function(e,t){return e>>>=0,t||T(e,4,this.length),o.read(this,e,!0,23,4)},c.prototype.readFloatBE=function(e,t){return e>>>=0,t||T(e,4,this.length),o.read(this,e,!1,23,4)},c.prototype.readDoubleLE=function(e,t){return e>>>=0,t||T(e,8,this.length),o.read(this,e,!0,52,8)},c.prototype.readDoubleBE=function(e,t){return e>>>=0,t||T(e,8,this.length),o.read(this,e,!1,52,8)},c.prototype.writeUIntLE=function(e,t,r,n){e=+e,t>>>=0,r>>>=0,n||C(this,e,t,r,Math.pow(2,8*r)-1,0);var a=1,o=0;for(this[t]=255&e;++o<r&&(a*=256);)this[t+o]=e/a&255;return t+r},c.prototype.writeUIntBE=function(e,t,r,n){e=+e,t>>>=0,r>>>=0,n||C(this,e,t,r,Math.pow(2,8*r)-1,0);var a=r-1,o=1;for(this[t+a]=255&e;0<=--a&&(o*=256);)this[t+a]=e/o&255;return t+r},c.prototype.writeUInt8=function(e,t,r){return e=+e,t>>>=0,r||C(this,e,t,1,255,0),this[t]=255&e,t+1},c.prototype.writeUInt16LE=function(e,t,r){return e=+e,t>>>=0,r||C(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},c.prototype.writeUInt16BE=function(e,t,r){return e=+e,t>>>=0,r||C(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},c.prototype.writeUInt32LE=function(e,t,r){return e=+e,t>>>=0,r||C(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},c.prototype.writeUInt32BE=function(e,t,r){return e=+e,t>>>=0,r||C(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},c.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t>>>=0,!n){var a=Math.pow(2,8*r-1);C(this,e,t,r,a-1,-a);}var o=0,i=1,s=0;for(this[t]=255&e;++o<r&&(i*=256);)e<0&&0===s&&0!==this[t+o-1]&&(s=1),this[t+o]=(e/i>>0)-s&255;return t+r},c.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t>>>=0,!n){var a=Math.pow(2,8*r-1);C(this,e,t,r,a-1,-a);}var o=r-1,i=1,s=0;for(this[t+o]=255&e;0<=--o&&(i*=256);)e<0&&0===s&&0!==this[t+o+1]&&(s=1),this[t+o]=(e/i>>0)-s&255;return t+r},c.prototype.writeInt8=function(e,t,r){return e=+e,t>>>=0,r||C(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=255&e,t+1},c.prototype.writeInt16LE=function(e,t,r){return e=+e,t>>>=0,r||C(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},c.prototype.writeInt16BE=function(e,t,r){return e=+e,t>>>=0,r||C(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},c.prototype.writeInt32LE=function(e,t,r){return e=+e,t>>>=0,r||C(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},c.prototype.writeInt32BE=function(e,t,r){return e=+e,t>>>=0,r||C(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},c.prototype.writeFloatLE=function(e,t,r){return O(this,e,t,!0,r)},c.prototype.writeFloatBE=function(e,t,r){return O(this,e,t,!1,r)},c.prototype.writeDoubleLE=function(e,t,r){return L(this,e,t,!0,r)},c.prototype.writeDoubleBE=function(e,t,r){return L(this,e,t,!1,r)},c.prototype.copy=function(e,t,r,n){if(!c.isBuffer(e))throw new TypeError("argument should be a Buffer");if(r=r||0,n||0===n||(n=this.length),t>=e.length&&(t=e.length),t=t||0,0<n&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);var a=n-r;if(this===e&&"function"==typeof Uint8Array.prototype.copyWithin)this.copyWithin(t,r,n);else if(this===e&&r<t&&t<n)for(var o=a-1;0<=o;--o)e[o+t]=this[o+r];else Uint8Array.prototype.set.call(e,this.subarray(r,n),t);return a},c.prototype.fill=function(e,t,r,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!c.isEncoding(n))throw new TypeError("Unknown encoding: "+n);if(1===e.length){var a=e.charCodeAt(0);("utf8"===n&&a<128||"latin1"===n)&&(e=a);}}else "number"==typeof e?e&=255:"boolean"==typeof e&&(e=Number(e));if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;var o;if(t>>>=0,r=void 0===r?this.length:r>>>0,"number"==typeof(e=e||0))for(o=t;o<r;++o)this[o]=e;else {var i=c.isBuffer(e)?e:c.from(e,n),s=i.length;if(0===s)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(o=0;o<r-t;++o)this[o+t]=i[o%s];}return this};var t=/[^+/0-9A-Za-z-_]/g;function I(e,t){var r;t=t||1/0;for(var n=e.length,a=null,o=[],i=0;i<n;++i){if(55295<(r=e.charCodeAt(i))&&r<57344){if(!a){if(56319<r){-1<(t-=3)&&o.push(239,191,189);continue}if(i+1===n){-1<(t-=3)&&o.push(239,191,189);continue}a=r;continue}if(r<56320){-1<(t-=3)&&o.push(239,191,189),a=r;continue}r=65536+(a-55296<<10|r-56320);}else a&&-1<(t-=3)&&o.push(239,191,189);if(a=null,r<128){if(--t<0)break;o.push(r);}else if(r<2048){if((t-=2)<0)break;o.push(r>>6|192,63&r|128);}else if(r<65536){if((t-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128);}else {if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128);}}return o}function P(e){return n.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(t,"")).length<2)return "";for(;e.length%4!=0;)e+="=";return e}(e))}function R(e,t,r,n){for(var a=0;a<n&&!(a+r>=t.length||a>=e.length);++a)t[a+r]=e[a];return a}function D(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}function A(e){return e!=e}var k=function(){for(var e="0123456789abcdef",t=new Array(256),r=0;r<16;++r)for(var n=16*r,a=0;a<16;++a)t[n+a]=e[r]+e[a];return t}();}).call(this,F("buffer").Buffer);},{"base64-js":2,buffer:5,ieee754:10}],6:[function(e,t,r){t.exports=e("./").polyfill();},{"./":7}],7:[function(z,r,n){(function(j,V){var e,t;e=this,t=function(){function l(e){return "function"==typeof e}var r=Array.isArray?Array.isArray:function(e){return "[object Array]"===Object.prototype.toString.call(e)},n=0,t=void 0,a=void 0,i=function(e,t){d[n]=e,d[n+1]=t,2===(n+=2)&&(a?a(h):v());};var e="undefined"!=typeof window?window:void 0,o=e||{},s=o.MutationObserver||o.WebKitMutationObserver,p="undefined"==typeof self&&void 0!==j&&"[object process]"==={}.toString.call(j),u="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel;function c(){var e=setTimeout;return function(){return e(h,1)}}var d=new Array(1e3);function h(){for(var e=0;e<n;e+=2){(0, d[e])(d[e+1]),d[e]=void 0,d[e+1]=void 0;}n=0;}var m,f,y,g,v=void 0;function b(e,t){var r=this,n=new this.constructor(S);void 0===n[x]&&k(n);var a=r._state;if(a){var o=arguments[a-1];i(function(){return D(a,n,o,r._result)});}else P(r,n,e,t);return n}function _(e){if(e&&"object"==typeof e&&e.constructor===this)return e;var t=new this(S);return N(t,e),t}v=p?function(){return j.nextTick(h)}:s?(f=0,y=new s(h),g=document.createTextNode(""),y.observe(g,{characterData:!0}),function(){g.data=f=++f%2;}):u?((m=new MessageChannel).port1.onmessage=h,function(){return m.port2.postMessage(0)}):void 0===e&&"function"==typeof z?function(){try{var e=Function("return this")().require("vertx");return void 0!==(t=e.runOnLoop||e.runOnContext)?function(){t(h);}:c()}catch(e){return c()}}():c();var x=Math.random().toString(36).substring(2);function S(){}var w=void 0,M=1,E=2;function T(e,n,a){i(function(t){var r=!1,e=function(e,t,r,n){try{e.call(t,r,n);}catch(e){return e}}(a,n,function(e){r||(r=!0,n!==e?N(t,e):L(t,e));},function(e){r||(r=!0,I(t,e));},t._label);!r&&e&&(r=!0,I(t,e));},e);}function C(e,t,r){var n,a;t.constructor===e.constructor&&r===b&&t.constructor.resolve===_?(n=e,(a=t)._state===M?L(n,a._result):a._state===E?I(n,a._result):P(a,void 0,function(e){return N(n,e)},function(e){return I(n,e)})):void 0===r?L(e,t):l(r)?T(e,t,r):L(e,t);}function N(t,e){if(t===e)I(t,new TypeError("You cannot resolve a promise with itself"));else if(a=typeof(n=e),null===n||"object"!=a&&"function"!=a)L(t,e);else {var r=void 0;try{r=e.then;}catch(e){return void I(t,e)}C(t,e,r);}var n,a;}function O(e){e._onerror&&e._onerror(e._result),R(e);}function L(e,t){e._state===w&&(e._result=t,e._state=M,0!==e._subscribers.length&&i(R,e));}function I(e,t){e._state===w&&(e._state=E,e._result=t,i(O,e));}function P(e,t,r,n){var a=e._subscribers,o=a.length;e._onerror=null,a[o]=t,a[o+M]=r,a[o+E]=n,0===o&&e._state&&i(R,e);}function R(e){var t=e._subscribers,r=e._state;if(0!==t.length){for(var n=void 0,a=void 0,o=e._result,i=0;i<t.length;i+=3)n=t[i],a=t[i+r],n?D(r,n,a,o):a(o);e._subscribers.length=0;}}function D(e,t,r,n){var a=l(r),o=void 0,i=void 0,s=!0;if(a){try{o=r(n);}catch(e){s=!1,i=e;}if(t===o)return void I(t,new TypeError("A promises callback cannot return that same promise."))}else o=n;t._state!==w||(a&&s?N(t,o):!1===s?I(t,i):e===M?L(t,o):e===E&&I(t,o));}var A=0;function k(e){e[x]=A++,e._state=void 0,e._result=void 0,e._subscribers=[];}var F=(U.prototype._enumerate=function(e){for(var t=0;this._state===w&&t<e.length;t++)this._eachEntry(e[t],t);},U.prototype._eachEntry=function(t,e){var r=this._instanceConstructor,n=r.resolve;if(n===_){var a=void 0,o=void 0,i=!1;try{a=t.then;}catch(e){i=!0,o=e;}if(a===b&&t._state!==w)this._settledAt(t._state,e,t._result);else if("function"!=typeof a)this._remaining--,this._result[e]=t;else if(r===B){var s=new r(S);i?I(s,o):C(s,t,a),this._willSettleAt(s,e);}else this._willSettleAt(new r(function(e){return e(t)}),e);}else this._willSettleAt(n(t),e);},U.prototype._settledAt=function(e,t,r){var n=this.promise;n._state===w&&(this._remaining--,e===E?I(n,r):this._result[t]=r),0===this._remaining&&L(n,this._result);},U.prototype._willSettleAt=function(e,t){var r=this;P(e,void 0,function(e){return r._settledAt(M,t,e)},function(e){return r._settledAt(E,t,e)});},U);function U(e,t){this._instanceConstructor=e,this.promise=new e(S),this.promise[x]||k(this.promise),r(t)?(this.length=t.length,this._remaining=t.length,this._result=new Array(this.length),0===this.length?L(this.promise,this._result):(this.length=this.length||0,this._enumerate(t),0===this._remaining&&L(this.promise,this._result))):I(this.promise,new Error("Array Methods must be provided an Array"));}var B=(G.prototype.catch=function(e){return this.then(null,e)},G.prototype.finally=function(t){var r=this.constructor;return l(t)?this.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})}):this.then(t,t)},G);function G(e){this[x]=A++,this._result=this._state=void 0,this._subscribers=[],S!==e&&("function"!=typeof e&&function(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}(),this instanceof G?function(t,e){try{e(function(e){N(t,e);},function(e){I(t,e);});}catch(e){I(t,e);}}(this,e):function(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}());}return B.prototype.then=b,B.all=function(e){return new F(this,e).promise},B.race=function(a){var o=this;return r(a)?new o(function(e,t){for(var r=a.length,n=0;n<r;n++)o.resolve(a[n]).then(e,t);}):new o(function(e,t){return t(new TypeError("You must pass an array to race."))})},B.resolve=_,B.reject=function(e){var t=new this(S);return I(t,e),t},B._setScheduler=function(e){a=e;},B._setAsap=function(e){i=e;},B._asap=i,B.polyfill=function(){var e=void 0;if(void 0!==V)e=V;else if("undefined"!=typeof self)e=self;else try{e=Function("return this")();}catch(e){throw new Error("polyfill failed because global object is unavailable in this environment")}var t=e.Promise;if(t){var r=null;try{r=Object.prototype.toString.call(t.resolve());}catch(e){}if("[object Promise]"===r&&!t.cast)return}e.Promise=B;},B.Promise=B},"object"==typeof n&&void 0!==r?r.exports=t():e.ES6Promise=t();}).call(this,z("_process"),"undefined"!=typeof commonjsGlobal?commonjsGlobal:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{_process:15}],8:[function(e,n,a){!function(e,t){if(void 0!==a&&void 0!==n)t(a,n);else {var r={exports:{}};t(r.exports,r),e.fetchJsonp=r.exports;}}(this,function(e,t){var r=5e3,n="callback";function c(t){try{delete window[t];}catch(e){window[t]=void 0;}}function d(e){var t=document.getElementById(e);t&&document.getElementsByTagName("head")[0].removeChild(t);}t.exports=function(o){var i=arguments.length<=1||void 0===arguments[1]?{}:arguments[1],s=o,l=i.timeout||r,p=i.jsonpCallback||n,u=void 0;return new Promise(function(t,e){var r=i.jsonpCallbackFunction||"jsonp_"+Date.now()+"_"+Math.ceil(1e5*Math.random()),n=p+"_"+r;window[r]=function(e){t({ok:!0,json:function(){return Promise.resolve(e)}}),u&&clearTimeout(u),d(n),c(r);},s+=-1===s.indexOf("?")?"?":"&";var a=document.createElement("script");a.setAttribute("src",""+s+p+"="+r),i.charset&&a.setAttribute("charset",i.charset),a.id=n,document.getElementsByTagName("head")[0].appendChild(a),u=setTimeout(function(){e(new Error("JSONP request to "+o+" timed out")),c(r),d(n),window[r]=function(){c(r);};},l),a.onerror=function(){e(new Error("JSONP request to "+o+" failed")),c(r),d(n),u&&clearTimeout(u);};})};});},{}],9:[function(e,t,r){var n=n||function(s){if(!(void 0===s||"undefined"!=typeof navigator&&/MSIE [1-9]\./.test(navigator.userAgent))){var e=s.document,l=function(){return s.URL||s.webkitURL||s},p=e.createElementNS("http://www.w3.org/1999/xhtml","a"),u="download"in p,c=/constructor/i.test(s.HTMLElement)||s.safari,d=/CriOS\/[\d]+/.test(navigator.userAgent),h=function(e){(s.setImmediate||s.setTimeout)(function(){throw e},0);},m=function(e){setTimeout(function(){"string"==typeof e?l().revokeObjectURL(e):e.remove();},4e4);},f=function(e){return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)?new Blob([String.fromCharCode(65279),e],{type:e.type}):e},n=function(e,r,t){t||(e=f(e));function n(){!function(e,t,r){for(var n=(t=[].concat(t)).length;n--;){var a=e["on"+t[n]];if("function"==typeof a)try{a.call(e,r||e);}catch(e){h(e);}}}(o,"writestart progress write writeend".split(" "));}var a,o=this,i="application/octet-stream"===e.type;if(o.readyState=o.INIT,u)return a=l().createObjectURL(e),void setTimeout(function(){var e,t;p.href=a,p.download=r,e=p,t=new MouseEvent("click"),e.dispatchEvent(t),n(),m(a),o.readyState=o.DONE;});!function(){if((d||i&&c)&&s.FileReader){var t=new FileReader;return t.onloadend=function(){var e=d?t.result:t.result.replace(/^data:[^;]*;/,"data:attachment/file;");s.open(e,"_blank")||(s.location.href=e),e=void 0,o.readyState=o.DONE,n();},t.readAsDataURL(e),o.readyState=o.INIT}(a=a||l().createObjectURL(e),i)?s.location.href=a:s.open(a,"_blank")||(s.location.href=a);o.readyState=o.DONE,n(),m(a);}();},t=n.prototype;return "undefined"!=typeof navigator&&navigator.msSaveOrOpenBlob?function(e,t,r){return t=t||e.name||"download",r||(e=f(e)),navigator.msSaveOrOpenBlob(e,t)}:(t.abort=function(){},t.readyState=t.INIT=0,t.WRITING=1,t.DONE=2,t.error=t.onwritestart=t.onprogress=t.onwrite=t.onabort=t.onerror=t.onwriteend=null,function(e,t,r){return new n(e,t||e.name||"download",r)})}}("undefined"!=typeof self&&self||"undefined"!=typeof window&&window||this.content);void 0!==t&&t.exports&&(t.exports.saveAs=n);},{}],10:[function(e,t,r){r.read=function(e,t,r,n,a){var o,i,s=8*a-n-1,l=(1<<s)-1,p=l>>1,u=-7,c=r?a-1:0,d=r?-1:1,h=e[t+c];for(c+=d,o=h&(1<<-u)-1,h>>=-u,u+=s;0<u;o=256*o+e[t+c],c+=d,u-=8);for(i=o&(1<<-u)-1,o>>=-u,u+=n;0<u;i=256*i+e[t+c],c+=d,u-=8);if(0===o)o=1-p;else {if(o===l)return i?NaN:1/0*(h?-1:1);i+=Math.pow(2,n),o-=p;}return (h?-1:1)*i*Math.pow(2,o-n)},r.write=function(e,t,r,n,a,o){var i,s,l,p=8*o-a-1,u=(1<<p)-1,c=u>>1,d=23===a?Math.pow(2,-24)-Math.pow(2,-77):0,h=n?0:o-1,m=n?1:-1,f=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,i=u):(i=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-i))<1&&(i--,l*=2),2<=(t+=1<=i+c?d/l:d*Math.pow(2,1-c))*l&&(i++,l/=2),u<=i+c?(s=0,i=u):1<=i+c?(s=(t*l-1)*Math.pow(2,a),i+=c):(s=t*Math.pow(2,c-1)*Math.pow(2,a),i=0));8<=a;e[r+h]=255&s,h+=m,s/=256,a-=8);for(i=i<<a|s,p+=a;0<p;e[r+h]=255&i,h+=m,i/=256,p-=8);e[r+h-m]|=128*f;};},{}],11:[function(e,t,r){var n;function y(e,t){return e.b===t.b&&e.a===t.a}function g(e,t){return e.b<t.b||e.b===t.b&&e.a<=t.a}function v(e,t,r){var n=t.b-e.b,a=r.b-t.b;return 0<n+a?n<a?t.a-e.a+n/(n+a)*(e.a-r.a):t.a-r.a+a/(n+a)*(r.a-e.a):0}function b(e,t,r){var n=t.b-e.b,a=r.b-t.b;return 0<n+a?(t.a-r.a)*n+(t.a-e.a)*a:0}function _(e,t){return e.a<t.a||e.a===t.a&&e.b<=t.b}function x(e,t,r){var n=t.a-e.a,a=r.a-t.a;return 0<n+a?n<a?t.b-e.b+n/(n+a)*(e.b-r.b):t.b-r.b+a/(n+a)*(r.b-e.b):0}function S(e,t,r){var n=t.a-e.a,a=r.a-t.a;return 0<n+a?(t.b-r.b)*n+(t.b-e.b)*a:0}function w(e,t,r,n){return (e=e<0?0:e)<=(r=r<0?0:r)?0===r?(t+n)/2:t+e/(e+r)*(n-t):n+r/(e+r)*(t-n)}function i(e){var t=o(e.b);return a(t,e.c),a(t.b,e.c),s(t,e.a),t}function M(e,t){var r=!1,n=!1;e!==t&&(t.a!==e.a&&(n=!0,f(t.a,e.a)),t.d!==e.d&&(r=!0,l(t.d,e.d)),h(t,e),n||(a(t,e.a),e.a.c=e),r||(s(t,e.d),e.d.a=e));}function c(e){var t=e.b,r=!1;e.d!==e.b.d&&(r=!0,l(e.d,e.b.d)),e.c===e?f(e.a,null):(e.b.d.a=J(e),e.a.c=e.c,h(e,J(e)),r||s(e,e.d)),t.c===t?(f(t.a,null),l(t.d,null)):(e.d.a=J(t),t.a.c=t.c,h(t,J(t))),m(e);}function E(e){var t=o(e),r=t.b;return h(t,e.e),t.a=e.b.a,a(r,t.a),t.d=r.d=e.d,t=t.b,h(e.b,J(e.b)),h(e.b,t),e.b.a=t.a,t.b.a.c=t.b,t.b.d=e.b.d,t.f=e.f,t.b.f=e.b.f,t}function d(e,t){var r=!1,n=o(e),a=n.b;return t.d!==e.d&&(r=!0,l(t.d,e.d)),h(n,e.e),h(a,t),n.a=e.b.a,a.a=t.a,n.d=a.d=e.d,e.d.a=a,r||s(n,e.d),n}function o(e){var t=new K,r=new K,n=e.b.h;return (((r.h=n).b.h=t).h=e).b.h=r,t.b=r,((t.c=t).e=r).b=t,(r.c=r).e=t}function h(e,t){var r=e.c,n=t.c;r.b.e=t,(n.b.e=e).c=n,t.c=r;}function a(e,t){var r=t.f,n=new ee(t,r);for(r.e=n,r=(t.f=n).c=e;r.a=n,(r=r.c)!==e;);}function s(e,t){var r=t.d,n=new Q(t,r);for(r.b=n,(t.d=n).a=e,n.c=t.c,r=e;r.d=n,(r=r.e)!==e;);}function m(e){var t=e.h;e=e.b.h,(t.b.h=e).b.h=t;}function f(e,t){for(var r=e.c,n=r;n.a=t,(n=n.c)!==r;);r=e.f,((n=e.e).f=r).e=n;}function l(e,t){for(var r=e.a,n=r;n.d=t,(n=n.e)!==r;);r=e.d,((n=e.b).d=r).b=n;}function T(e){var t=0;return Math.abs(e[1])>Math.abs(e[0])&&(t=1),Math.abs(e[2])>Math.abs(e[t])&&(t=2),t}var C=4e150;function N(e,t){e.f+=t.f,e.b.f+=t.b.f;}function p(e,t,r){return e=e.a,t=t.a,r=r.a,t.b.a===e?r.b.a===e?g(t.a,r.a)?b(r.b.a,t.a,r.a)<=0:0<=b(t.b.a,r.a,t.a):b(r.b.a,e,r.a)<=0:r.b.a===e?0<=b(t.b.a,e,t.a):(t=v(t.b.a,e,t.a),(e=v(r.b.a,e,r.a))<=t)}function O(e){e.a.i=null;var t=e.e;t.a.c=t.c,t.c.a=t.a,e.e=null;}function u(e,t){c(e.a),e.c=!1,(e.a=t).i=e;}function L(e){for(var t=e.a.a;(e=de(e)).a.a===t;);return e.c&&(u(e,t=d(ce(e).a.b,e.a.e)),e=de(e)),e}function I(e,t,r){var n=new ue;return n.a=r,n.e=W(e.f,t.e,n),r.i=n}function P(e,t){switch(e.s){case 100130:return 0!=(1&t);case 100131:return 0!==t;case 100132:return 0<t;case 100133:return t<0;case 100134:return 2<=t||t<=-2}return !1}function R(e){var t=e.a,r=t.d;r.c=e.d,r.a=t,O(e);}function D(e,t,r){for(t=(e=t).a;e!==r;){e.c=!1;var n=ce(e),a=n.a;if(a.a!==t.a){if(!n.c){R(e);break}u(n,a=d(t.c.b,a.b));}t.c!==a&&(M(J(a),a),M(t,a)),R(e),t=n.a,e=n;}return t}function A(e,t,r,n,a,o){for(var i=!0;I(e,t,r.b),(r=r.c)!==n;);for(null===a&&(a=ce(t).a.b.c);(r=(n=ce(t)).a.b).a===a.a;)r.c!==a&&(M(J(r),r),M(J(a),r)),n.f=t.f-r.f,n.d=P(e,n.f),t.b=!0,!i&&B(e,t)&&(N(r,a),O(t),c(a)),i=!1,t=n,a=r;t.b=!0,o&&j(e,t);}function k(e,t,r,n,a){var o=[t.g[0],t.g[1],t.g[2]];t.d=null,t.d=e.o&&e.o(o,r,n,e.c)||null,null===t.d&&(a?e.n||(Z(e,100156),e.n=!0):t.d=r[0]);}function F(e,t,r){var n=[null,null,null,null];n[0]=t.a.d,n[1]=r.a.d,k(e,t.a,n,[.5,.5,0,0],!1),M(t,r);}function U(e,t,r,n,a){var o=Math.abs(t.b-e.b)+Math.abs(t.a-e.a),i=Math.abs(r.b-e.b)+Math.abs(r.a-e.a),s=a+1;n[a]=.5*i/(o+i),n[s]=.5*o/(o+i),e.g[0]+=n[a]*t.g[0]+n[s]*r.g[0],e.g[1]+=n[a]*t.g[1]+n[s]*r.g[1],e.g[2]+=n[a]*t.g[2]+n[s]*r.g[2];}function B(e,t){var r=ce(t),n=t.a,a=r.a;if(g(n.a,a.a)){if(0<b(a.b.a,n.a,a.a))return !1;if(y(n.a,a.a)){if(n.a!==a.a){r=e.e;var o=n.a.h;if(0<=o){var i=(r=r.b).d,s=r.e,l=r.c,p=l[o];i[p]=i[r.a],(l[i[p]]=p)<=--r.a&&(p<=1?le(r,p):g(s[i[p>>1]],s[i[p]])?le(r,p):pe(r,p)),s[o]=null,l[o]=r.b,r.b=o;}else for(r.c[-(o+1)]=null;0<r.a&&null===r.c[r.d[r.a-1]];)--r.a;F(e,J(a),n);}}else E(a.b),M(n,J(a)),t.b=r.b=!0;}else {if(b(n.b.a,a.a,n.a)<0)return !1;de(t).b=t.b=!0,E(n.b),M(J(a),n);}return !0}function G(e,t){var r=ce(t),n=t.a,a=r.a,o=n.a,i=a.a,s=n.b.a,l=a.b.a,p=new ee;if(b(s,e.a,o),b(l,e.a,i),o===i||Math.min(o.a,s.a)>Math.max(i.a,l.a))return !1;if(g(o,i)){if(0<b(l,o,i))return !1}else if(b(s,i,o)<0)return !1;var u,c,d=s,h=o,m=l,f=i;if(g(d,h)||(u=d,d=h,h=u),g(m,f)||(u=m,m=f,f=u),g(d,m)||(u=d,d=m,m=u,u=h,h=f,f=u),g(m,h)?g(h,f)?((u=v(d,m,h))+(c=v(m,h,f))<0&&(u=-u,c=-c),p.b=w(u,m.b,c,h.b)):((u=b(d,m,h))+(c=-b(d,f,h))<0&&(u=-u,c=-c),p.b=w(u,m.b,c,f.b)):p.b=(m.b+h.b)/2,_(d,h)||(u=d,d=h,h=u),_(m,f)||(u=m,m=f,f=u),_(d,m)||(u=d,d=m,m=u,u=h,h=f,f=u),_(m,h)?_(h,f)?((u=x(d,m,h))+(c=x(m,h,f))<0&&(u=-u,c=-c),p.a=w(u,m.a,c,h.a)):((u=S(d,m,h))+(c=-S(d,f,h))<0&&(u=-u,c=-c),p.a=w(u,m.a,c,f.a)):p.a=(m.a+h.a)/2,g(p,e.a)&&(p.b=e.a.b,p.a=e.a.a),d=g(o,i)?o:i,g(d,p)&&(p.b=d.b,p.a=d.a),y(p,o)||y(p,i))return B(e,t),!1;if(!y(s,e.a)&&0<=b(s,e.a,p)||!y(l,e.a)&&b(l,e.a,p)<=0){if(l===e.a)return E(n.b),M(a.b,n),n=ce(t=L(t)).a,D(e,ce(t),r),A(e,t,J(n),n,n,!0),!0;if(s!==e.a)return 0<=b(s,e.a,p)&&(de(t).b=t.b=!0,E(n.b),n.a.b=e.a.b,n.a.a=e.a.a),b(l,e.a,p)<=0&&(t.b=r.b=!0,E(a.b),a.a.b=e.a.b,a.a.a=e.a.a),!1;for(E(a.b),M(n.e,J(a)),i=(o=r=t).a.b.a;(o=de(o)).a.b.a===i;);return o=ce(t=o).a.b.c,r.a=J(a),A(e,t,(a=D(e,r,null)).c,n.b.c,o,!0),!0}return E(n.b),E(a.b),M(J(a),n),n.a.b=p.b,n.a.a=p.a,n.a.h=re(e.e,n.a),n=n.a,a=[0,0,0,0],p=[o.d,s.d,i.d,l.d],n.g[0]=n.g[1]=n.g[2]=0,U(n,o,s,a,0),U(n,i,l,a,2),k(e,n,p,a,!0),de(t).b=t.b=r.b=!0,!1}function j(e,t){for(var r=ce(t);;){for(;r.b;)r=ce(t=r);if(!t.b&&(null===(t=de(r=t))||!t.b))break;t.b=!1;var n,a=t.a,o=r.a;if(n=a.b.a!==o.b.a)e:{var i=ce(n=t),s=n.a,l=i.a,p=void 0;if(g(s.b.a,l.b.a)){if(b(s.b.a,l.b.a,s.a)<0){n=!1;break e}de(n).b=n.b=!0,p=E(s),M(l.b,p),p.d.c=n.d;}else {if(0<b(l.b.a,s.b.a,l.a)){n=!1;break e}n.b=i.b=!0,p=E(l),M(s.e,l.b),p.b.d.c=n.d;}n=!0;}if(n&&(r.c?(O(r),c(o),o=(r=ce(t)).a):t.c&&(O(t),c(a),a=(t=de(r)).a)),a.a!==o.a)if(a.b.a===o.b.a||t.c||r.c||a.b.a!==e.a&&o.b.a!==e.a)B(e,t);else if(G(e,t))break;a.a===o.a&&a.b.a===o.b.a&&(N(o,a),O(t),c(a),t=de(r));}}function V(e,t){for(var r=(e.a=t).c;null===r.i;)if((r=r.c)===t.c){r=e;var n=t;(i=new ue).a=n.c.b;for(var a=(l=r.f).a;null!==(a=a.a).b&&!l.c(l.b,i,a.b););var o=ce(l=a.b),i=l.a;a=o.a;if(0===b(i.b.a,n,i.a))y((i=l.a).a,n)||y(i.b.a,n)||(E(i.b),l.c&&(c(i.c),l.c=!1),M(n.c,i),V(r,n));else {var s=g(a.b.a,i.b.a)?l:o;o=void 0;l.d||s.c?(o=s===l?d(n.c.b,i.e):d(a.b.c.b,n.c).b,s.c?u(s,o):((l=I(i=r,l,o)).f=de(l).f+l.a.f,l.d=P(i,l.f)),V(r,n)):A(r,l,n.c,n.c,null,!0);}return}if(l=(i=ce(r=L(r.i))).a,(i=D(e,i,null)).c===l){i=(l=i).c,a=ce(r),o=r.a,s=a.a;var l,p=!1;o.b.a!==s.b.a&&G(e,r),y(o.a,e.a)&&(M(J(i),o),i=ce(r=L(r)).a,D(e,ce(r),a),p=!0),y(s.a,e.a)&&(M(l,J(s)),l=D(e,a,null),p=!0),p?A(e,r,l.c,i,i,!0):(n=g(s.a,o.a)?J(s):o,A(e,r,n=d(l.c.b,n),n.c,n.c,!1),n.b.i.c=!0,j(e,r));}else A(e,r,i.c,l,l,!0);}function z(e,t){var r=new ue,n=i(e.b);n.a.b=C,n.a.a=t,n.b.a.b=-C,n.b.a.a=t,e.a=n.b.a,r.a=n,r.f=0,r.d=!1,r.c=!1,r.h=!0,r.b=!1,n=W(n=e.f,n.a,r),r.e=n;}function H(e){this.a=new X,this.b=e,this.c=p;}function W(e,t,r){for(;null!==(t=t.c).b&&!e.c(e.b,t.b,r););return e=new X(r,t.a,t),t.a.c=e,t.a=e}function X(e,t,r){this.b=e||null,this.a=t||this,this.c=r||this;}function q(){this.d=0,this.p=this.b=this.q=null,this.j=[0,0,0],this.s=100130,this.n=!1,this.o=this.a=this.e=this.f=null,this.m=!1,this.c=this.r=this.i=this.k=this.l=this.h=null;}function Y(e,t){if(e.d!==t)for(;e.d!==t;)if(e.d<t)switch(e.d){case 0:Z(e,100151),e.u(null);break;case 1:Z(e,100152),e.t();}else switch(e.d){case 2:Z(e,100154),e.v();break;case 1:Z(e,100153),e.w();}}function Z(e,t){e.p&&e.p(t,e.c);}function Q(e,t){this.b=e||this,this.d=t||this,this.a=null,this.c=!1;}function K(){(this.h=this).i=this.d=this.a=this.e=this.c=this.b=null,this.f=0;}function J(e){return e.b.e}function $(){this.c=new ee,this.a=new Q,this.b=new K,this.d=new K,this.b.b=this.d,this.d.b=this.b;}function ee(e,t){this.e=e||this,this.f=t||this,this.d=this.c=null,this.g=[0,0,0],this.h=this.a=this.b=0;}function te(){this.c=[],this.d=null,this.a=0,this.e=!1,this.b=new ae;}function re(e,t){if(e.e){var r,n=e.b,a=++n.a;return 2*a>n.f&&(n.f*=2,n.c=oe(n.c,n.f+1)),0===n.b?r=a:(r=n.b,n.b=n.c[n.b]),n.e[r]=t,n.c[r]=a,n.d[a]=r,n.h&&pe(n,a),r}return n=e.a++,e.c[n]=t,-(n+1)}function ne(e){if(0===e.a)return se(e.b);var t=e.c[e.d[e.a-1]];if(0!==e.b.a&&g(ie(e.b),t))return se(e.b);for(;--e.a,0<e.a&&null===e.c[e.d[e.a-1]];);return t}function ae(){this.d=oe([0],33),this.e=[null,null],this.c=[0,0],this.a=0,this.f=32,this.b=0,this.h=!1,this.d[1]=1;}function oe(e,t){for(var r=Array(t),n=0;n<e.length;n++)r[n]=e[n];for(;n<t;n++)r[n]=0;return r}function ie(e){return e.e[e.d[1]]}function se(e){var t=e.d,r=e.e,n=e.c,a=t[1],o=r[a];return 0<e.a&&(t[1]=t[e.a],n[t[1]]=1,r[a]=null,n[a]=e.b,e.b=a,0<--e.a&&le(e,1)),o}function le(e,t){for(var r=e.d,n=e.e,a=e.c,o=t,i=r[o];;){var s=o<<1;s<e.a&&g(n[r[s+1]],n[r[s]])&&(s+=1);var l=r[s];if(s>e.a||g(n[i],n[l])){a[r[o]=i]=o;break}a[r[o]=l]=o,o=s;}}function pe(e,t){for(var r=e.d,n=e.e,a=e.c,o=t,i=r[o];;){var s=o>>1,l=r[s];if(0==s||g(n[l],n[i])){a[r[o]=i]=o;break}a[r[o]=l]=o,o=s;}}function ue(){this.e=this.a=null,this.f=0,this.c=this.b=this.h=this.d=!1;}function ce(e){return e.e.c.b}function de(e){return e.e.a.b}(n=q.prototype).x=function(){Y(this,0);},n.B=function(e,t){switch(e){case 100142:return;case 100140:switch(t){case 100130:case 100131:case 100132:case 100133:case 100134:return void(this.s=t)}break;case 100141:return void(this.m=!!t);default:return void Z(this,100900)}Z(this,100901);},n.y=function(e){switch(e){case 100142:return 0;case 100140:return this.s;case 100141:return this.m;default:Z(this,100900);}return !1},n.A=function(e,t,r){this.j[0]=e,this.j[1]=t,this.j[2]=r;},n.z=function(e,t){var r=t||null;switch(e){case 100100:case 100106:this.h=r;break;case 100104:case 100110:this.l=r;break;case 100101:case 100107:this.k=r;break;case 100102:case 100108:this.i=r;break;case 100103:case 100109:this.p=r;break;case 100105:case 100111:this.o=r;break;case 100112:this.r=r;break;default:Z(this,100900);}},n.C=function(e,t){var r=!1,n=[0,0,0];Y(this,2);for(var a=0;a<3;++a){var o=e[a];o<-1e150&&(o=-1e150,r=!0),1e150<o&&(o=1e150,r=!0),n[a]=o;}r&&Z(this,100155),null===(r=this.q)?M(r=i(this.b),r.b):(E(r),r=r.e),r.a.d=t,r.a.g[0]=n[0],r.a.g[1]=n[1],r.a.g[2]=n[2],r.f=1,r.b.f=-1,this.q=r;},n.u=function(e){Y(this,0),this.d=1,this.b=new $,this.c=e;},n.t=function(){Y(this,1),this.d=2,this.q=null;},n.v=function(){Y(this,2),this.d=1;},n.w=function(){Y(this,1),this.d=0;var e,t,r=!1,n=[l=this.j[0],a=this.j[1],i=this.j[2]];if(0===l&&0===a&&0===i){for(var a=[-2e150,-2e150,-2e150],o=[2e150,2e150,2e150],i=[],s=[],l=(r=this.b.c).e;l!==r;l=l.e)for(var p=0;p<3;++p){var u=l.g[p];u<o[p]&&(o[p]=u,s[p]=l),u>a[p]&&(a[p]=u,i[p]=l);}if(l=0,a[1]-o[1]>a[0]-o[0]&&(l=1),a[2]-o[2]>a[l]-o[l]&&(l=2),o[l]>=a[l])n[0]=0,n[1]=0,n[2]=1;else {for(a=0,o=s[l],i=i[l],s=[0,0,0],o=[o.g[0]-i.g[0],o.g[1]-i.g[1],o.g[2]-i.g[2]],p=[0,0,0],l=r.e;l!==r;l=l.e)p[0]=l.g[0]-i.g[0],p[1]=l.g[1]-i.g[1],p[2]=l.g[2]-i.g[2],s[0]=o[1]*p[2]-o[2]*p[1],s[1]=o[2]*p[0]-o[0]*p[2],s[2]=o[0]*p[1]-o[1]*p[0],a<(u=s[0]*s[0]+s[1]*s[1]+s[2]*s[2])&&(a=u,n[0]=s[0],n[1]=s[1],n[2]=s[2]);a<=0&&(n[0]=n[1]=n[2]=0,n[T(o)]=1);}r=!0;}for(s=T(n),l=this.b.c,a=(s+1)%3,i=(s+2)%3,s=0<n[s]?1:-1,n=l.e;n!==l;n=n.e)n.b=n.g[a],n.a=s*n.g[i];if(r){for(n=0,l=(r=this.b.a).b;l!==r;l=l.b)if(!((a=l.a).f<=0))for(;n+=(a.a.b-a.b.a.b)*(a.a.a+a.b.a.a),(a=a.e)!==l.a;);if(n<0)for(r=(n=this.b.c).e;r!==n;r=r.e)r.a=-r.a;}for(this.n=!1,l=(n=this.b.b).h;l!==n;l=r)r=l.h,a=l.e,y(l.a,l.b.a)&&l.e.e!==l&&(F(this,a,l),c(l),a=(l=a).e),a.e===l&&(a!==l&&(a!==r&&a!==r.b||(r=r.h),c(a)),l!==r&&l!==r.b||(r=r.h),c(l));for(this.e=n=new te,l=(r=this.b.c).e;l!==r;l=l.e)l.h=re(n,l);for(!function(e){e.d=[];for(var t=0;t<e.a;t++)e.d[t]=t;e.d.sort(function(r){return function(e,t){return g(r[e],r[t])?1:-1}}(e.c)),e.e=!0,function(e){for(var t=e.a;1<=t;--t)le(e,t);e.h=!0;}(e.b);}(n),this.f=new H(this),z(this,-C),z(this,C);null!==(n=ne(this.e));){for(;;){e:if(l=this.e,0===l.a)r=ie(l.b);else if(r=l.c[l.d[l.a-1]],0!==l.b.a&&(l=ie(l.b),g(l,r))){r=l;break e}if(null===r||!y(r,n))break;r=ne(this.e),F(this,n.c,r.c);}V(this,n);}for(this.a=this.f.a.a.b.a.a,n=0;null!==(r=this.f.a.a.b);)r.h||++n,O(r);for(this.f=null,(n=this.e).b=null,n.d=null,this.e=n.c=null,l=(n=this.b).a.b;l!==n.a;l=r)r=l.b,(l=l.a).e.e===l&&(N(l.c,l),c(l));if(!this.n){if(n=this.b,this.m)for(l=n.b.h;l!==n.b;l=r)r=l.h,l.b.d.c!==l.d.c?l.f=l.d.c?1:-1:c(l);else for(l=n.a.b;l!==n.a;l=r)if(r=l.b,l.c){for(l=l.a;g(l.b.a,l.a);l=l.c.b);for(;g(l.a,l.b.a);l=l.e);for(a=l.c.b,i=void 0;l.e!==a;)if(g(l.b.a,a.a)){for(;a.e!==l&&(g((t=a.e).b.a,t.a)||b(a.a,a.b.a,a.e.b.a)<=0);)a=(i=d(a.e,a)).b;a=a.c.b;}else {for(;a.e!==l&&(g((e=l.c.b).a,e.b.a)||0<=b(l.b.a,l.a,l.c.b.a));)l=(i=d(l,l.c.b)).b;l=l.e;}for(;a.e.e!==l;)a=(i=d(a.e,a)).b;}if(this.h||this.i||this.k||this.l)if(this.m){for(r=(n=this.b).a.b;r!==n.a;r=r.b)if(r.c){for(this.h&&this.h(2,this.c),l=r.a;this.k&&this.k(l.a.d,this.c),(l=l.e)!==r.a;);this.i&&this.i(this.c);}}else {for(n=this.b,r=!!this.l,l=!1,a=-1,i=n.a.d;i!==n.a;i=i.d)if(i.c)for(l||(this.h&&this.h(4,this.c),l=!0),s=i.a;r&&(a!==(o=s.b.d.c?0:1)&&(a=o,this.l&&this.l(!!a,this.c))),this.k&&this.k(s.a.d,this.c),(s=s.e)!==i.a;);l&&this.i&&this.i(this.c);}if(this.r){for(l=(n=this.b).a.b;l!==n.a;l=r)if(r=l.b,!l.c){for(i=(a=l.a).e,s=void 0;i=(s=i).e,(s.d=null)===s.b.d&&(s.c===s?f(s.a,null):(s.a.c=s.c,h(s,J(s))),(o=s.b).c===o?f(o.a,null):(o.a.c=o.c,h(o,J(o))),m(s)),s!==a;);a=l.d,((l=l.b).d=a).b=l;}return this.r(this.b),void(this.c=this.b=null)}}this.b=this.c=null;},this.libtess={GluTesselator:q,windingRule:{GLU_TESS_WINDING_ODD:100130,GLU_TESS_WINDING_NONZERO:100131,GLU_TESS_WINDING_POSITIVE:100132,GLU_TESS_WINDING_NEGATIVE:100133,GLU_TESS_WINDING_ABS_GEQ_TWO:100134},primitiveType:{GL_LINE_LOOP:2,GL_TRIANGLES:4,GL_TRIANGLE_STRIP:5,GL_TRIANGLE_FAN:6},errorType:{GLU_TESS_MISSING_BEGIN_POLYGON:100151,GLU_TESS_MISSING_END_POLYGON:100153,GLU_TESS_MISSING_BEGIN_CONTOUR:100152,GLU_TESS_MISSING_END_CONTOUR:100154,GLU_TESS_COORD_TOO_LARGE:100155,GLU_TESS_NEED_COMBINE_CALLBACK:100156},gluEnum:{GLU_TESS_MESH:100112,GLU_TESS_TOLERANCE:100142,GLU_TESS_WINDING_RULE:100140,GLU_TESS_BOUNDARY_ONLY:100141,GLU_INVALID_ENUM:100900,GLU_INVALID_VALUE:100901,GLU_TESS_BEGIN:100100,GLU_TESS_VERTEX:100101,GLU_TESS_END:100102,GLU_TESS_ERROR:100103,GLU_TESS_EDGE_FLAG:100104,GLU_TESS_COMBINE:100105,GLU_TESS_BEGIN_DATA:100106,GLU_TESS_VERTEX_DATA:100107,GLU_TESS_END_DATA:100108,GLU_TESS_ERROR_DATA:100109,GLU_TESS_EDGE_FLAG_DATA:100110,GLU_TESS_COMBINE_DATA:100111}},q.prototype.gluDeleteTess=q.prototype.x,q.prototype.gluTessProperty=q.prototype.B,q.prototype.gluGetTessProperty=q.prototype.y,q.prototype.gluTessNormal=q.prototype.A,q.prototype.gluTessCallback=q.prototype.z,q.prototype.gluTessVertex=q.prototype.C,q.prototype.gluTessBeginPolygon=q.prototype.u,q.prototype.gluTessBeginContour=q.prototype.t,q.prototype.gluTessEndContour=q.prototype.v,q.prototype.gluTessEndPolygon=q.prototype.w,void 0!==t&&(t.exports=this.libtess);},{}],12:[function(e,t,r){function N(e,t,r,n){for(var a=e[t++],o=1<<a,i=1+o,s=1+i,l=a+1,p=(1<<l)-1,u=0,c=0,d=0,h=e[t++],m=new Int32Array(4096),f=null;;){for(;u<16&&0!==h;)c|=e[t++]<<u,u+=8,1===h?h=e[t++]:--h;if(u<l)break;var y=c&p;if(c>>=l,u-=l,y!=o){if(y==i)break;for(var g=y<s?y:f,v=0,b=g;o<b;)b=m[b]>>8,++v;var _=b;if(n<d+v+(g!==y?1:0))return void console.log("Warning, gif stream longer than expected.");r[d++]=_;var x=d+=v;for(g!==y&&(r[d++]=_),b=g;v--;)b=m[b],r[--x]=255&b,b>>=8;null!==f&&s<4096&&(m[s++]=f<<8|_,p+1<=s&&l<12&&(++l,p=p<<1|1)),f=y;}else s=1+i,p=(1<<(l=a+1))-1,f=null;}return d!==n&&console.log("Warning, gif stream shorter than expected."),r}try{r.GifWriter=function(g,e,t,r){var v=0,n=void 0===(r=void 0===r?{}:r).loop?null:r.loop,b=void 0===r.palette?null:r.palette;if(e<=0||t<=0||65535<e||65535<t)throw new Error("Width/Height invalid.");function _(e){var t=e.length;if(t<2||256<t||t&t-1)throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");return t}g[v++]=71,g[v++]=73,g[v++]=70,g[v++]=56,g[v++]=57,g[v++]=97;var a=0,o=0;if(null!==b){for(var i=_(b);i>>=1;)++a;if(i=1<<a,--a,void 0!==r.background){if(i<=(o=r.background))throw new Error("Background index out of range.");if(0===o)throw new Error("Background index explicitly passed as 0.")}}if(g[v++]=255&e,g[v++]=e>>8&255,g[v++]=255&t,g[v++]=t>>8&255,g[v++]=(null!==b?128:0)|a,g[v++]=o,g[v++]=0,null!==b)for(var s=0,l=b.length;s<l;++s){var p=b[s];g[v++]=p>>16&255,g[v++]=p>>8&255,g[v++]=255&p;}if(null!==n){if(n<0||65535<n)throw new Error("Loop count invalid.");g[v++]=33,g[v++]=255,g[v++]=11,g[v++]=78,g[v++]=69,g[v++]=84,g[v++]=83,g[v++]=67,g[v++]=65,g[v++]=80,g[v++]=69,g[v++]=50,g[v++]=46,g[v++]=48,g[v++]=3,g[v++]=1,g[v++]=255&n,g[v++]=n>>8&255,g[v++]=0;}var x=!1;this.addFrame=function(e,t,r,n,a,o){if(!0===x&&(--v,x=!1),o=void 0===o?{}:o,e<0||t<0||65535<e||65535<t)throw new Error("x/y invalid.");if(r<=0||n<=0||65535<r||65535<n)throw new Error("Width/Height invalid.");if(a.length<r*n)throw new Error("Not enough pixels for the frame size.");var i=!0,s=o.palette;if(null==s&&(i=!1,s=b),null==s)throw new Error("Must supply either a local or global palette.");for(var l=_(s),p=0;l>>=1;)++p;l=1<<p;var u=void 0===o.delay?0:o.delay,c=void 0===o.disposal?0:o.disposal;if(c<0||3<c)throw new Error("Disposal out of range.");var d=!1,h=0;if(void 0!==o.transparent&&null!==o.transparent&&(d=!0,(h=o.transparent)<0||l<=h))throw new Error("Transparent color index.");if(0===c&&!d&&0===u||(g[v++]=33,g[v++]=249,g[v++]=4,g[v++]=c<<2|(!0===d?1:0),g[v++]=255&u,g[v++]=u>>8&255,g[v++]=h,g[v++]=0),g[v++]=44,g[v++]=255&e,g[v++]=e>>8&255,g[v++]=255&t,g[v++]=t>>8&255,g[v++]=255&r,g[v++]=r>>8&255,g[v++]=255&n,g[v++]=n>>8&255,g[v++]=!0===i?128|p-1:0,!0===i)for(var m=0,f=s.length;m<f;++m){var y=s[m];g[v++]=y>>16&255,g[v++]=y>>8&255,g[v++]=255&y;}return v=function(t,r,e,n){t[r++]=e;var a=r++,o=1<<e,i=o-1,s=1+o,l=1+s,p=e+1,u=0,c=0;function d(e){for(;e<=u;)t[r++]=255&c,c>>=8,u-=8,r===a+256&&(t[a]=255,a=r++);}function h(e){c|=e<<u,u+=p,d(8);}var m=n[0]&i,f={};h(o);for(var y=1,g=n.length;y<g;++y){var v=n[y]&i,b=m<<8|v,_=f[b];if(void 0===_){for(c|=m<<u,u+=p;8<=u;)t[r++]=255&c,c>>=8,u-=8,r===a+256&&(t[a]=255,a=r++);4096===l?(h(o),l=1+s,p=e+1,f={}):(1<<p<=l&&++p,f[b]=l++),m=v;}else m=_;}h(m),h(s),d(1),a+1===r?t[a]=0:(t[a]=r-a-1,t[r++]=0);return r}(g,v,p<2?2:p,a)},this.end=function(){return !1===x&&(g[v++]=59,x=!0),v},this.getOutputBuffer=function(){return g},this.setOutputBuffer=function(e){g=e;},this.getOutputBufferPosition=function(){return v},this.setOutputBufferPosition=function(e){v=e;};},r.GifReader=function(x){var e=0;if(71!==x[e++]||73!==x[e++]||70!==x[e++]||56!==x[e++]||56!=(x[e++]+1&253)||97!==x[e++])throw new Error("Invalid GIF 87a/89a header.");var S=x[e++]|x[e++]<<8,t=x[e++]|x[e++]<<8,r=x[e++],n=r>>7,a=1<<1+(7&r);x[e++],x[e++];var o=null,i=null;n&&(o=e,e+=3*(i=a));var s=!0,l=[],p=0,u=null,c=0,d=null;for(this.width=S,this.height=t;s&&e<x.length;)switch(x[e++]){case 33:switch(x[e++]){case 255:if(11!==x[e]||78==x[e+1]&&69==x[e+2]&&84==x[e+3]&&83==x[e+4]&&67==x[e+5]&&65==x[e+6]&&80==x[e+7]&&69==x[e+8]&&50==x[e+9]&&46==x[e+10]&&48==x[e+11]&&3==x[e+12]&&1==x[e+13]&&0==x[e+16])e+=14,d=x[e++]|x[e++]<<8,e++;else for(e+=12;;){if(!(0<=(C=x[e++])))throw Error("Invalid block size");if(0===C)break;e+=C;}break;case 249:if(4!==x[e++]||0!==x[e+4])throw new Error("Invalid graphics extension block.");var h=x[e++];p=x[e++]|x[e++]<<8,u=x[e++],0==(1&h)&&(u=null),c=h>>2&7,e++;break;case 254:for(;;){if(!(0<=(C=x[e++])))throw Error("Invalid block size");if(0===C)break;e+=C;}break;default:throw new Error("Unknown graphic control label: 0x"+x[e-1].toString(16))}break;case 44:var m=x[e++]|x[e++]<<8,f=x[e++]|x[e++]<<8,y=x[e++]|x[e++]<<8,g=x[e++]|x[e++]<<8,v=x[e++],b=v>>6&1,_=1<<1+(7&v),w=o,M=i,E=!1;if(v>>7){E=!0;w=e,e+=3*(M=_);}var T=e;for(e++;;){var C;if(!(0<=(C=x[e++])))throw Error("Invalid block size");if(0===C)break;e+=C;}l.push({x:m,y:f,width:y,height:g,has_local_palette:E,palette_offset:w,palette_size:M,data_offset:T,data_length:e-T,transparent_index:u,interlaced:!!b,delay:p,disposal:c});break;case 59:s=!1;break;default:throw new Error("Unknown gif block: 0x"+x[e-1].toString(16))}this.numFrames=function(){return l.length},this.loopCount=function(){return d},this.frameInfo=function(e){if(e<0||e>=l.length)throw new Error("Frame index out of range.");return l[e]},this.decodeAndBlitFrameBGRA=function(e,t){var r=this.frameInfo(e),n=r.width*r.height,a=new Uint8Array(n);N(x,r.data_offset,a,n);var o=r.palette_offset,i=r.transparent_index;null===i&&(i=256);var s=r.width,l=S-s,p=s,u=4*(r.y*S+r.x),c=4*((r.y+r.height)*S+r.x),d=u,h=4*l;!0===r.interlaced&&(h+=4*S*7);for(var m=8,f=0,y=a.length;f<y;++f){var g=a[f];if(0===p&&(p=s,c<=(d+=h)&&(h=4*l+4*S*(m-1),d=u+(s+l)*(m<<1),m>>=1)),g===i)d+=4;else {var v=x[o+3*g],b=x[o+3*g+1],_=x[o+3*g+2];t[d++]=_,t[d++]=b,t[d++]=v,t[d++]=255;}--p;}},this.decodeAndBlitFrameRGBA=function(e,t){var r=this.frameInfo(e),n=r.width*r.height,a=new Uint8Array(n);N(x,r.data_offset,a,n);var o=r.palette_offset,i=r.transparent_index;null===i&&(i=256);var s=r.width,l=S-s,p=s,u=4*(r.y*S+r.x),c=4*((r.y+r.height)*S+r.x),d=u,h=4*l;!0===r.interlaced&&(h+=4*S*7);for(var m=8,f=0,y=a.length;f<y;++f){var g=a[f];if(0===p&&(p=s,c<=(d+=h)&&(h=4*l+4*S*(m-1),d=u+(s+l)*(m<<1),m>>=1)),g===i)d+=4;else {var v=x[o+3*g],b=x[o+3*g+1],_=x[o+3*g+2];t[d++]=v,t[d++]=b,t[d++]=_,t[d++]=255;}--p;}};};}catch(e){}},{}],13:[function(jr,t,r){(function(Gr){var e;e=this,function(E){function e(e){if(null==this)throw TypeError();var t=String(this),r=t.length,n=e?Number(e):0;if(n!=n&&(n=0),!(n<0||r<=n)){var a,o=t.charCodeAt(n);return 55296<=o&&o<=56319&&n+1<r&&56320<=(a=t.charCodeAt(n+1))&&a<=57343?1024*(o-55296)+a-56320+65536:o}}var t;String.prototype.codePointAt||((t=function(){try{var e={},t=Object.defineProperty,r=t(e,e,e)&&t;}catch(e){}return r}())?t(String.prototype,"codePointAt",{value:e,configurable:!0,writable:!0}):String.prototype.codePointAt=e);var l=0,o=-3;function r(){this.table=new Uint16Array(16),this.trans=new Uint16Array(288);}function i(e,t){this.source=e,this.sourceIndex=0,this.tag=0,this.bitcount=0,this.dest=t,this.destLen=0,this.ltree=new r,this.dtree=new r;}var s=new r,p=new r,u=new Uint8Array(30),c=new Uint16Array(30),d=new Uint8Array(30),h=new Uint16Array(30),m=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),f=new r,y=new Uint8Array(320);function n(e,t,r,n){var a,o;for(a=0;a<r;++a)e[a]=0;for(a=0;a<30-r;++a)e[a+r]=a/r|0;for(o=n,a=0;a<30;++a)t[a]=o,o+=1<<e[a];}var g=new Uint16Array(16);function v(e,t,r,n){var a,o;for(a=0;a<16;++a)e.table[a]=0;for(a=0;a<n;++a)e.table[t[r+a]]++;for(a=o=e.table[0]=0;a<16;++a)g[a]=o,o+=e.table[a];for(a=0;a<n;++a)t[r+a]&&(e.trans[g[t[r+a]]++]=a);}function b(e){e.bitcount--||(e.tag=e.source[e.sourceIndex++],e.bitcount=7);var t=1&e.tag;return e.tag>>>=1,t}function _(e,t,r){if(!t)return r;for(;e.bitcount<24;)e.tag|=e.source[e.sourceIndex++]<<e.bitcount,e.bitcount+=8;var n=e.tag&65535>>>16-t;return e.tag>>>=t,e.bitcount-=t,n+r}function x(e,t){for(;e.bitcount<24;)e.tag|=e.source[e.sourceIndex++]<<e.bitcount,e.bitcount+=8;for(var r=0,n=0,a=0,o=e.tag;n=2*n+(1&o),o>>>=1,++a,r+=t.table[a],0<=(n-=t.table[a]););return e.tag=o,e.bitcount-=a,t.trans[r+n]}function S(e,t,r){var n,a,o,i,s,l;for(n=_(e,5,257),a=_(e,5,1),o=_(e,4,4),i=0;i<19;++i)y[i]=0;for(i=0;i<o;++i){var p=_(e,3,0);y[m[i]]=p;}for(v(f,y,0,19),s=0;s<n+a;){var u=x(e,f);switch(u){case 16:var c=y[s-1];for(l=_(e,2,3);l;--l)y[s++]=c;break;case 17:for(l=_(e,3,3);l;--l)y[s++]=0;break;case 18:for(l=_(e,7,11);l;--l)y[s++]=0;break;default:y[s++]=u;}}v(t,y,0,n),v(r,y,n,a);}function w(e,t,r){for(;;){var n,a,o,i,s=x(e,t);if(256===s)return l;if(s<256)e.dest[e.destLen++]=s;else for(n=_(e,u[s-=257],c[s]),a=x(e,r),i=o=e.destLen-_(e,d[a],h[a]);i<o+n;++i)e.dest[e.destLen++]=e.dest[i];}}function M(e){for(var t,r;8<e.bitcount;)e.sourceIndex--,e.bitcount-=8;if((t=256*(t=e.source[e.sourceIndex+1])+e.source[e.sourceIndex])!==(65535&~(256*e.source[e.sourceIndex+3]+e.source[e.sourceIndex+2])))return o;for(e.sourceIndex+=4,r=t;r;--r)e.dest[e.destLen++]=e.source[e.sourceIndex++];return e.bitcount=0,l}!function(e,t){var r;for(r=0;r<7;++r)e.table[r]=0;for(e.table[7]=24,e.table[8]=152,e.table[9]=112,r=0;r<24;++r)e.trans[r]=256+r;for(r=0;r<144;++r)e.trans[24+r]=r;for(r=0;r<8;++r)e.trans[168+r]=280+r;for(r=0;r<112;++r)e.trans[176+r]=144+r;for(r=0;r<5;++r)t.table[r]=0;for(t.table[5]=32,r=0;r<32;++r)t.trans[r]=r;}(s,p),n(u,c,4,3),n(d,h,2,1),u[28]=0,c[28]=258;var a=function(e,t){var r,n,a=new i(e,t);do{switch(r=b(a),_(a,2,0)){case 0:n=M(a);break;case 1:n=w(a,s,p);break;case 2:S(a,a.ltree,a.dtree),n=w(a,a.ltree,a.dtree);break;default:n=o;}if(n!==l)throw new Error("Data error")}while(!r);return a.destLen<a.dest.length?"function"==typeof a.dest.slice?a.dest.slice(0,a.destLen):a.dest.subarray(0,a.destLen):a.dest};function T(e,t,r,n,a){return Math.pow(1-a,3)*e+3*Math.pow(1-a,2)*a*t+3*(1-a)*Math.pow(a,2)*r+Math.pow(a,3)*n}function C(){this.x1=Number.NaN,this.y1=Number.NaN,this.x2=Number.NaN,this.y2=Number.NaN;}function A(){this.commands=[],this.fill="black",this.stroke=null,this.strokeWidth=1;}function N(e){throw new Error(e)}function O(e,t){e||N(t);}C.prototype.isEmpty=function(){return isNaN(this.x1)||isNaN(this.y1)||isNaN(this.x2)||isNaN(this.y2)},C.prototype.addPoint=function(e,t){"number"==typeof e&&((isNaN(this.x1)||isNaN(this.x2))&&(this.x1=e,this.x2=e),e<this.x1&&(this.x1=e),e>this.x2&&(this.x2=e)),"number"==typeof t&&((isNaN(this.y1)||isNaN(this.y2))&&(this.y1=t,this.y2=t),t<this.y1&&(this.y1=t),t>this.y2&&(this.y2=t));},C.prototype.addX=function(e){this.addPoint(e,null);},C.prototype.addY=function(e){this.addPoint(null,e);},C.prototype.addBezier=function(e,t,r,n,a,o,i,s){var l=this,p=[e,t],u=[r,n],c=[a,o],d=[i,s];this.addPoint(e,t),this.addPoint(i,s);for(var h=0;h<=1;h++){var m=6*p[h]-12*u[h]+6*c[h],f=-3*p[h]+9*u[h]-9*c[h]+3*d[h],y=3*u[h]-3*p[h];if(0!=f){var g=Math.pow(m,2)-4*y*f;if(!(g<0)){var v=(-m+Math.sqrt(g))/(2*f);0<v&&v<1&&(0===h&&l.addX(T(p[h],u[h],c[h],d[h],v)),1===h&&l.addY(T(p[h],u[h],c[h],d[h],v)));var b=(-m-Math.sqrt(g))/(2*f);0<b&&b<1&&(0===h&&l.addX(T(p[h],u[h],c[h],d[h],b)),1===h&&l.addY(T(p[h],u[h],c[h],d[h],b)));}}else {if(0==m)continue;var _=-y/m;0<_&&_<1&&(0===h&&l.addX(T(p[h],u[h],c[h],d[h],_)),1===h&&l.addY(T(p[h],u[h],c[h],d[h],_)));}}},C.prototype.addQuad=function(e,t,r,n,a,o){var i=e+2/3*(r-e),s=t+2/3*(n-t),l=i+1/3*(a-e),p=s+1/3*(o-t);this.addBezier(e,t,i,s,l,p,a,o);},A.prototype.moveTo=function(e,t){this.commands.push({type:"M",x:e,y:t});},A.prototype.lineTo=function(e,t){this.commands.push({type:"L",x:e,y:t});},A.prototype.curveTo=A.prototype.bezierCurveTo=function(e,t,r,n,a,o){this.commands.push({type:"C",x1:e,y1:t,x2:r,y2:n,x:a,y:o});},A.prototype.quadTo=A.prototype.quadraticCurveTo=function(e,t,r,n){this.commands.push({type:"Q",x1:e,y1:t,x:r,y:n});},A.prototype.close=A.prototype.closePath=function(){this.commands.push({type:"Z"});},A.prototype.extend=function(e){if(e.commands)e=e.commands;else if(e instanceof C){var t=e;return this.moveTo(t.x1,t.y1),this.lineTo(t.x2,t.y1),this.lineTo(t.x2,t.y2),this.lineTo(t.x1,t.y2),void this.close()}Array.prototype.push.apply(this.commands,e);},A.prototype.getBoundingBox=function(){for(var e=new C,t=0,r=0,n=0,a=0,o=0;o<this.commands.length;o++){var i=this.commands[o];switch(i.type){case"M":e.addPoint(i.x,i.y),t=n=i.x,r=a=i.y;break;case"L":e.addPoint(i.x,i.y),n=i.x,a=i.y;break;case"Q":e.addQuad(n,a,i.x1,i.y1,i.x,i.y),n=i.x,a=i.y;break;case"C":e.addBezier(n,a,i.x1,i.y1,i.x2,i.y2,i.x,i.y),n=i.x,a=i.y;break;case"Z":n=t,a=r;break;default:throw new Error("Unexpected path command "+i.type)}}return e.isEmpty()&&e.addPoint(0,0),e},A.prototype.draw=function(e){e.beginPath();for(var t=0;t<this.commands.length;t+=1){var r=this.commands[t];"M"===r.type?e.moveTo(r.x,r.y):"L"===r.type?e.lineTo(r.x,r.y):"C"===r.type?e.bezierCurveTo(r.x1,r.y1,r.x2,r.y2,r.x,r.y):"Q"===r.type?e.quadraticCurveTo(r.x1,r.y1,r.x,r.y):"Z"===r.type&&e.closePath();}this.fill&&(e.fillStyle=this.fill,e.fill()),this.stroke&&(e.strokeStyle=this.stroke,e.lineWidth=this.strokeWidth,e.stroke());},A.prototype.toPathData=function(o){function e(){for(var e,t=arguments,r="",n=0;n<arguments.length;n+=1){var a=t[n];0<=a&&0<n&&(r+=" "),r+=(e=a,Math.round(e)===e?""+Math.round(e):e.toFixed(o));}return r}o=void 0!==o?o:2;for(var t="",r=0;r<this.commands.length;r+=1){var n=this.commands[r];"M"===n.type?t+="M"+e(n.x,n.y):"L"===n.type?t+="L"+e(n.x,n.y):"C"===n.type?t+="C"+e(n.x1,n.y1,n.x2,n.y2,n.x,n.y):"Q"===n.type?t+="Q"+e(n.x1,n.y1,n.x,n.y):"Z"===n.type&&(t+="Z");}return t},A.prototype.toSVG=function(e){var t='<path d="';return t+=this.toPathData(e),t+='"',this.fill&&"black"!==this.fill&&(null===this.fill?t+=' fill="none"':t+=' fill="'+this.fill+'"'),this.stroke&&(t+=' stroke="'+this.stroke+'" stroke-width="'+this.strokeWidth+'"'),t+="/>"},A.prototype.toDOMElement=function(e){var t=this.toPathData(e),r=document.createElementNS("http://www.w3.org/2000/svg","path");return r.setAttribute("d",t),r};var L={fail:N,argument:O,assert:O},I=2147483648,P={},R={},D={};function k(e){return function(){return e}}R.BYTE=function(e){return L.argument(0<=e&&e<=255,"Byte value should be between 0 and 255."),[e]},D.BYTE=k(1),R.CHAR=function(e){return [e.charCodeAt(0)]},D.CHAR=k(1),R.CHARARRAY=function(e){for(var t=[],r=0;r<e.length;r+=1)t[r]=e.charCodeAt(r);return t},D.CHARARRAY=function(e){return e.length},R.USHORT=function(e){return [e>>8&255,255&e]},D.USHORT=k(2),R.SHORT=function(e){return 32768<=e&&(e=-(65536-e)),[e>>8&255,255&e]},D.SHORT=k(2),R.UINT24=function(e){return [e>>16&255,e>>8&255,255&e]},D.UINT24=k(3),R.ULONG=function(e){return [e>>24&255,e>>16&255,e>>8&255,255&e]},D.ULONG=k(4),R.LONG=function(e){return I<=e&&(e=-(2*I-e)),[e>>24&255,e>>16&255,e>>8&255,255&e]},D.LONG=k(4),R.FIXED=R.ULONG,D.FIXED=D.ULONG,R.FWORD=R.SHORT,D.FWORD=D.SHORT,R.UFWORD=R.USHORT,D.UFWORD=D.USHORT,R.LONGDATETIME=function(e){return [0,0,0,0,e>>24&255,e>>16&255,e>>8&255,255&e]},D.LONGDATETIME=k(8),R.TAG=function(e){return L.argument(4===e.length,"Tag should be exactly 4 ASCII characters."),[e.charCodeAt(0),e.charCodeAt(1),e.charCodeAt(2),e.charCodeAt(3)]},D.TAG=k(4),R.Card8=R.BYTE,D.Card8=D.BYTE,R.Card16=R.USHORT,D.Card16=D.USHORT,R.OffSize=R.BYTE,D.OffSize=D.BYTE,R.SID=R.USHORT,D.SID=D.USHORT,R.NUMBER=function(e){return -107<=e&&e<=107?[e+139]:108<=e&&e<=1131?[247+((e-=108)>>8),255&e]:-1131<=e&&e<=-108?[251+((e=-e-108)>>8),255&e]:-32768<=e&&e<=32767?R.NUMBER16(e):R.NUMBER32(e)},D.NUMBER=function(e){return R.NUMBER(e).length},R.NUMBER16=function(e){return [28,e>>8&255,255&e]},D.NUMBER16=k(3),R.NUMBER32=function(e){return [29,e>>24&255,e>>16&255,e>>8&255,255&e]},D.NUMBER32=k(5),R.REAL=function(e){var t=e.toString(),r=/\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(t);if(r){var n=parseFloat("1e"+((r[2]?+r[2]:0)+r[1].length));t=(Math.round(e*n)/n).toString();}for(var a="",o=0,i=t.length;o<i;o+=1){var s=t[o];a+="e"===s?"-"===t[++o]?"c":"b":"."===s?"a":"-"===s?"e":s;}for(var l=[30],p=0,u=(a+=1&a.length?"f":"ff").length;p<u;p+=2)l.push(parseInt(a.substr(p,2),16));return l},D.REAL=function(e){return R.REAL(e).length},R.NAME=R.CHARARRAY,D.NAME=D.CHARARRAY,R.STRING=R.CHARARRAY,D.STRING=D.CHARARRAY,P.UTF8=function(e,t,r){for(var n=[],a=r,o=0;o<a;o++,t+=1)n[o]=e.getUint8(t);return String.fromCharCode.apply(null,n)},P.UTF16=function(e,t,r){for(var n=[],a=r/2,o=0;o<a;o++,t+=2)n[o]=e.getUint16(t);return String.fromCharCode.apply(null,n)},R.UTF16=function(e){for(var t=[],r=0;r<e.length;r+=1){var n=e.charCodeAt(r);t[t.length]=n>>8&255,t[t.length]=255&n;}return t},D.UTF16=function(e){return 2*e.length};var F={"x-mac-croatian":"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ","x-mac-cyrillic":"АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю","x-mac-gaelic":"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæøṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ","x-mac-greek":"Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ­","x-mac-icelandic":"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ","x-mac-inuit":"ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł","x-mac-ce":"ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ",macintosh:"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ","x-mac-romanian":"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ","x-mac-turkish":"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ"};P.MACSTRING=function(e,t,r,n){var a=F[n];if(void 0!==a){for(var o="",i=0;i<r;i++){var s=e.getUint8(t+i);o+=s<=127?String.fromCharCode(s):a[127&s];}return o}};var U,B="function"==typeof WeakMap&&new WeakMap;function G(e){return -128<=e&&e<=127}function j(e,t,r){for(var n=0,a=e.length;t<a&&n<64&&0===e[t];)++t,++n;return r.push(128|n-1),t}function V(e,t,r){for(var n=0,a=e.length,o=t;o<a&&n<64;){var i=e[o];if(!G(i))break;if(0===i&&o+1<a&&0===e[o+1])break;++o,++n;}r.push(n-1);for(var s=t;s<o;++s)r.push(e[s]+256&255);return o}function z(e,t,r){for(var n=0,a=e.length,o=t;o<a&&n<64;){var i=e[o];if(0===i)break;if(G(i)&&o+1<a&&G(e[o+1]))break;++o,++n;}r.push(64|n-1);for(var s=t;s<o;++s){var l=e[s];r.push(l+65536>>8&255,l+256&255);}return o}R.MACSTRING=function(e,t){var r=function(e){if(!U)for(var t in U={},F)U[t]=new String(t);var r=U[e];if(void 0!==r){if(B){var n=B.get(r);if(void 0!==n)return n}var a=F[e];if(void 0!==a){for(var o={},i=0;i<a.length;i++)o[a.charCodeAt(i)]=i+128;return B&&B.set(r,o),o}}}(t);if(void 0!==r){for(var n=[],a=0;a<e.length;a++){var o=e.charCodeAt(a);if(128<=o&&void 0===(o=r[o]))return;n[a]=o;}return n}},D.MACSTRING=function(e,t){var r=R.MACSTRING(e,t);return void 0!==r?r.length:0},R.VARDELTAS=function(e){for(var t=0,r=[];t<e.length;){var n=e[t];t=0===n?j(e,t,r):-128<=n&&n<=127?V(e,t,r):z(e,t,r);}return r},R.INDEX=function(e){for(var t=1,r=[t],n=[],a=0;a<e.length;a+=1){var o=R.OBJECT(e[a]);Array.prototype.push.apply(n,o),t+=o.length,r.push(t);}if(0===n.length)return [0,0];for(var i=[],s=1+Math.floor(Math.log(t)/Math.log(2))/8|0,l=[void 0,R.BYTE,R.USHORT,R.UINT24,R.ULONG][s],p=0;p<r.length;p+=1){var u=l(r[p]);Array.prototype.push.apply(i,u);}return Array.prototype.concat(R.Card16(e.length),R.OffSize(s),i,n)},D.INDEX=function(e){return R.INDEX(e).length},R.DICT=function(e){for(var t=[],r=Object.keys(e),n=r.length,a=0;a<n;a+=1){var o=parseInt(r[a],0),i=e[o];t=(t=t.concat(R.OPERAND(i.value,i.type))).concat(R.OPERATOR(o));}return t},D.DICT=function(e){return R.DICT(e).length},R.OPERATOR=function(e){return e<1200?[e]:[12,e-1200]},R.OPERAND=function(e,t){var r=[];if(Array.isArray(t))for(var n=0;n<t.length;n+=1)L.argument(e.length===t.length,"Not enough arguments given for type"+t),r=r.concat(R.OPERAND(e[n],t[n]));else if("SID"===t)r=r.concat(R.NUMBER(e));else if("offset"===t)r=r.concat(R.NUMBER32(e));else if("number"===t)r=r.concat(R.NUMBER(e));else {if("real"!==t)throw new Error("Unknown operand type "+t);r=r.concat(R.REAL(e));}return r},R.OP=R.BYTE,D.OP=D.BYTE;var H="function"==typeof WeakMap&&new WeakMap;function W(e,t,r){for(var n=0;n<t.length;n+=1){var a=t[n];this[a.name]=a.value;}if(this.tableName=e,this.fields=t,r)for(var o=Object.keys(r),i=0;i<o.length;i+=1){var s=o[i],l=r[s];void 0!==this[s]&&(this[s]=l);}}function X(e,t,r){void 0===r&&(r=t.length);var n=new Array(t.length+1);n[0]={name:e+"Count",type:"USHORT",value:r};for(var a=0;a<t.length;a++)n[a+1]={name:e+a,type:"USHORT",value:t[a]};return n}function q(e,t,r){var n=t.length,a=new Array(n+1);a[0]={name:e+"Count",type:"USHORT",value:n};for(var o=0;o<n;o++)a[o+1]={name:e+o,type:"TABLE",value:r(t[o],o)};return a}function Y(e,t,r){var n=t.length,a=[];a[0]={name:e+"Count",type:"USHORT",value:n};for(var o=0;o<n;o++)a=a.concat(r(t[o],o));return a}function Z(e){1===e.format?W.call(this,"coverageTable",[{name:"coverageFormat",type:"USHORT",value:1}].concat(X("glyph",e.glyphs))):L.assert(!1,"Can't create coverage table format 2 yet.");}function Q(e){W.call(this,"scriptListTable",Y("scriptRecord",e,function(e,t){var r=e.script,n=r.defaultLangSys;return L.assert(!!n,"Unable to write GSUB: script "+e.tag+" has no default language system."),[{name:"scriptTag"+t,type:"TAG",value:e.tag},{name:"script"+t,type:"TABLE",value:new W("scriptTable",[{name:"defaultLangSys",type:"TABLE",value:new W("defaultLangSys",[{name:"lookupOrder",type:"USHORT",value:0},{name:"reqFeatureIndex",type:"USHORT",value:n.reqFeatureIndex}].concat(X("featureIndex",n.featureIndexes)))}].concat(Y("langSys",r.langSysRecords,function(e,t){var r=e.langSys;return [{name:"langSysTag"+t,type:"TAG",value:e.tag},{name:"langSys"+t,type:"TABLE",value:new W("langSys",[{name:"lookupOrder",type:"USHORT",value:0},{name:"reqFeatureIndex",type:"USHORT",value:r.reqFeatureIndex}].concat(X("featureIndex",r.featureIndexes)))}]})))}]}));}function K(e){W.call(this,"featureListTable",Y("featureRecord",e,function(e,t){var r=e.feature;return [{name:"featureTag"+t,type:"TAG",value:e.tag},{name:"feature"+t,type:"TABLE",value:new W("featureTable",[{name:"featureParams",type:"USHORT",value:r.featureParams}].concat(X("lookupListIndex",r.lookupListIndexes)))}]}));}function J(e,r){W.call(this,"lookupListTable",q("lookup",e,function(e){var t=r[e.lookupType];return L.assert(!!t,"Unable to write GSUB lookup type "+e.lookupType+" tables."),new W("lookupTable",[{name:"lookupType",type:"USHORT",value:e.lookupType},{name:"lookupFlag",type:"USHORT",value:e.lookupFlag}].concat(q("subtable",e.subtables,t)))}));}R.CHARSTRING=function(e){if(H){var t=H.get(e);if(void 0!==t)return t}for(var r=[],n=e.length,a=0;a<n;a+=1){var o=e[a];r=r.concat(R[o.type](o.value));}return H&&H.set(e,r),r},D.CHARSTRING=function(e){return R.CHARSTRING(e).length},R.OBJECT=function(e){var t=R[e.type];return L.argument(void 0!==t,"No encoding function for type "+e.type),t(e.value)},D.OBJECT=function(e){var t=D[e.type];return L.argument(void 0!==t,"No sizeOf function for type "+e.type),t(e.value)},R.TABLE=function(e){for(var t=[],r=e.fields.length,n=[],a=[],o=0;o<r;o+=1){var i=e.fields[o],s=R[i.type];L.argument(void 0!==s,"No encoding function for field type "+i.type+" ("+i.name+")");var l=e[i.name];void 0===l&&(l=i.value);var p=s(l);"TABLE"===i.type?(a.push(t.length),t=t.concat([0,0]),n.push(p)):t=t.concat(p);}for(var u=0;u<n.length;u+=1){var c=a[u],d=t.length;L.argument(d<65536,"Table "+e.tableName+" too big."),t[c]=d>>8,t[c+1]=255&d,t=t.concat(n[u]);}return t},D.TABLE=function(e){for(var t=0,r=e.fields.length,n=0;n<r;n+=1){var a=e.fields[n],o=D[a.type];L.argument(void 0!==o,"No sizeOf function for field type "+a.type+" ("+a.name+")");var i=e[a.name];void 0===i&&(i=a.value),t+=o(i),"TABLE"===a.type&&(t+=2);}return t},R.RECORD=R.TABLE,D.RECORD=D.TABLE,R.LITERAL=function(e){return e},D.LITERAL=function(e){return e.length},W.prototype.encode=function(){return R.TABLE(this)},W.prototype.sizeOf=function(){return D.TABLE(this)};var $={Table:W,Record:W,Coverage:(Z.prototype=Object.create(W.prototype)).constructor=Z,ScriptList:(Q.prototype=Object.create(W.prototype)).constructor=Q,FeatureList:(K.prototype=Object.create(W.prototype)).constructor=K,LookupList:(J.prototype=Object.create(W.prototype)).constructor=J,ushortList:X,tableList:q,recordList:Y};function ee(e,t){return e.getUint8(t)}function te(e,t){return e.getUint16(t,!1)}function re(e,t){return e.getUint32(t,!1)}function ne(e,t){return e.getInt16(t,!1)+e.getUint16(t+2,!1)/65535}var ae={byte:1,uShort:2,short:2,uLong:4,fixed:4,longDateTime:8,tag:4};function oe(e,t){this.data=e,this.offset=t,this.relativeOffset=0;}oe.prototype.parseByte=function(){var e=this.data.getUint8(this.offset+this.relativeOffset);return this.relativeOffset+=1,e},oe.prototype.parseChar=function(){var e=this.data.getInt8(this.offset+this.relativeOffset);return this.relativeOffset+=1,e},oe.prototype.parseCard8=oe.prototype.parseByte,oe.prototype.parseCard16=oe.prototype.parseUShort=function(){var e=this.data.getUint16(this.offset+this.relativeOffset);return this.relativeOffset+=2,e},oe.prototype.parseSID=oe.prototype.parseUShort,oe.prototype.parseOffset16=oe.prototype.parseUShort,oe.prototype.parseShort=function(){var e=this.data.getInt16(this.offset+this.relativeOffset);return this.relativeOffset+=2,e},oe.prototype.parseF2Dot14=function(){var e=this.data.getInt16(this.offset+this.relativeOffset)/16384;return this.relativeOffset+=2,e},oe.prototype.parseOffset32=oe.prototype.parseULong=function(){var e=re(this.data,this.offset+this.relativeOffset);return this.relativeOffset+=4,e},oe.prototype.parseFixed=function(){var e=ne(this.data,this.offset+this.relativeOffset);return this.relativeOffset+=4,e},oe.prototype.parseString=function(e){var t=this.data,r=this.offset+this.relativeOffset,n="";this.relativeOffset+=e;for(var a=0;a<e;a++)n+=String.fromCharCode(t.getUint8(r+a));return n},oe.prototype.parseTag=function(){return this.parseString(4)},oe.prototype.parseLongDateTime=function(){var e=re(this.data,this.offset+this.relativeOffset+4);return e-=2082844800,this.relativeOffset+=8,e},oe.prototype.parseVersion=function(e){var t=te(this.data,this.offset+this.relativeOffset),r=te(this.data,this.offset+this.relativeOffset+2);return this.relativeOffset+=4,void 0===e&&(e=4096),t+r/e/10},oe.prototype.skip=function(e,t){void 0===t&&(t=1),this.relativeOffset+=ae[e]*t;},oe.prototype.parseULongList=function(e){void 0===e&&(e=this.parseULong());for(var t=new Array(e),r=this.data,n=this.offset+this.relativeOffset,a=0;a<e;a++)t[a]=r.getUint32(n),n+=4;return this.relativeOffset+=4*e,t},oe.prototype.parseOffset16List=oe.prototype.parseUShortList=function(e){void 0===e&&(e=this.parseUShort());for(var t=new Array(e),r=this.data,n=this.offset+this.relativeOffset,a=0;a<e;a++)t[a]=r.getUint16(n),n+=2;return this.relativeOffset+=2*e,t},oe.prototype.parseShortList=function(e){for(var t=new Array(e),r=this.data,n=this.offset+this.relativeOffset,a=0;a<e;a++)t[a]=r.getInt16(n),n+=2;return this.relativeOffset+=2*e,t},oe.prototype.parseByteList=function(e){for(var t=new Array(e),r=this.data,n=this.offset+this.relativeOffset,a=0;a<e;a++)t[a]=r.getUint8(n++);return this.relativeOffset+=e,t},oe.prototype.parseList=function(e,t){t||(t=e,e=this.parseUShort());for(var r=new Array(e),n=0;n<e;n++)r[n]=t.call(this);return r},oe.prototype.parseList32=function(e,t){t||(t=e,e=this.parseULong());for(var r=new Array(e),n=0;n<e;n++)r[n]=t.call(this);return r},oe.prototype.parseRecordList=function(e,t){t||(t=e,e=this.parseUShort());for(var r=new Array(e),n=Object.keys(t),a=0;a<e;a++){for(var o={},i=0;i<n.length;i++){var s=n[i],l=t[s];o[s]=l.call(this);}r[a]=o;}return r},oe.prototype.parseRecordList32=function(e,t){t||(t=e,e=this.parseULong());for(var r=new Array(e),n=Object.keys(t),a=0;a<e;a++){for(var o={},i=0;i<n.length;i++){var s=n[i],l=t[s];o[s]=l.call(this);}r[a]=o;}return r},oe.prototype.parseStruct=function(e){if("function"==typeof e)return e.call(this);for(var t=Object.keys(e),r={},n=0;n<t.length;n++){var a=t[n],o=e[a];r[a]=o.call(this);}return r},oe.prototype.parseValueRecord=function(e){if(void 0===e&&(e=this.parseUShort()),0!==e){var t={};return 1&e&&(t.xPlacement=this.parseShort()),2&e&&(t.yPlacement=this.parseShort()),4&e&&(t.xAdvance=this.parseShort()),8&e&&(t.yAdvance=this.parseShort()),16&e&&(t.xPlaDevice=void 0,this.parseShort()),32&e&&(t.yPlaDevice=void 0,this.parseShort()),64&e&&(t.xAdvDevice=void 0,this.parseShort()),128&e&&(t.yAdvDevice=void 0,this.parseShort()),t}},oe.prototype.parseValueRecordList=function(){for(var e=this.parseUShort(),t=this.parseUShort(),r=new Array(t),n=0;n<t;n++)r[n]=this.parseValueRecord(e);return r},oe.prototype.parsePointer=function(e){var t=this.parseOffset16();if(0<t)return new oe(this.data,this.offset+t).parseStruct(e)},oe.prototype.parsePointer32=function(e){var t=this.parseOffset32();if(0<t)return new oe(this.data,this.offset+t).parseStruct(e)},oe.prototype.parseListOfLists=function(e){for(var t=this,r=this.parseOffset16List(),n=r.length,a=this.relativeOffset,o=new Array(n),i=0;i<n;i++){var s=r[i];if(0!==s)if(t.relativeOffset=s,e){for(var l=t.parseOffset16List(),p=new Array(l.length),u=0;u<l.length;u++)t.relativeOffset=s+l[u],p[u]=e.call(t);o[i]=p;}else o[i]=t.parseUShortList();else o[i]=void 0;}return this.relativeOffset=a,o},oe.prototype.parseCoverage=function(){var e=this.offset+this.relativeOffset,t=this.parseUShort(),r=this.parseUShort();if(1===t)return {format:1,glyphs:this.parseUShortList(r)};if(2!==t)throw new Error("0x"+e.toString(16)+": Coverage format must be 1 or 2.");for(var n=new Array(r),a=0;a<r;a++)n[a]={start:this.parseUShort(),end:this.parseUShort(),index:this.parseUShort()};return {format:2,ranges:n}},oe.prototype.parseClassDef=function(){var e=this.offset+this.relativeOffset,t=this.parseUShort();if(1===t)return {format:1,startGlyph:this.parseUShort(),classes:this.parseUShortList()};if(2===t)return {format:2,ranges:this.parseRecordList({start:oe.uShort,end:oe.uShort,classId:oe.uShort})};throw new Error("0x"+e.toString(16)+": ClassDef format must be 1 or 2.")},oe.list=function(e,t){return function(){return this.parseList(e,t)}},oe.list32=function(e,t){return function(){return this.parseList32(e,t)}},oe.recordList=function(e,t){return function(){return this.parseRecordList(e,t)}},oe.recordList32=function(e,t){return function(){return this.parseRecordList32(e,t)}},oe.pointer=function(e){return function(){return this.parsePointer(e)}},oe.pointer32=function(e){return function(){return this.parsePointer32(e)}},oe.tag=oe.prototype.parseTag,oe.byte=oe.prototype.parseByte,oe.uShort=oe.offset16=oe.prototype.parseUShort,oe.uShortList=oe.prototype.parseUShortList,oe.uLong=oe.offset32=oe.prototype.parseULong,oe.uLongList=oe.prototype.parseULongList,oe.struct=oe.prototype.parseStruct,oe.coverage=oe.prototype.parseCoverage,oe.classDef=oe.prototype.parseClassDef;var ie={reserved:oe.uShort,reqFeatureIndex:oe.uShort,featureIndexes:oe.uShortList};oe.prototype.parseScriptList=function(){return this.parsePointer(oe.recordList({tag:oe.tag,script:oe.pointer({defaultLangSys:oe.pointer(ie),langSysRecords:oe.recordList({tag:oe.tag,langSys:oe.pointer(ie)})})}))||[]},oe.prototype.parseFeatureList=function(){return this.parsePointer(oe.recordList({tag:oe.tag,feature:oe.pointer({featureParams:oe.offset16,lookupListIndexes:oe.uShortList})}))||[]},oe.prototype.parseLookupList=function(n){return this.parsePointer(oe.list(oe.pointer(function(){var e=this.parseUShort();L.argument(1<=e&&e<=9,"GPOS/GSUB lookup type "+e+" unknown.");var t=this.parseUShort(),r=16&t;return {lookupType:e,lookupFlag:t,subtables:this.parseList(oe.pointer(n[e])),markFilteringSet:r?this.parseUShort():void 0}})))||[]},oe.prototype.parseFeatureVariationsList=function(){return this.parsePointer32(function(){var e=this.parseUShort(),t=this.parseUShort();return L.argument(1===e&&t<1,"GPOS/GSUB feature variations table unknown."),this.parseRecordList32({conditionSetOffset:oe.offset32,featureTableSubstitutionOffset:oe.offset32})})||[]};var se={getByte:ee,getCard8:ee,getUShort:te,getCard16:te,getShort:function(e,t){return e.getInt16(t,!1)},getULong:re,getFixed:ne,getTag:function(e,t){for(var r="",n=t;n<t+4;n+=1)r+=String.fromCharCode(e.getInt8(n));return r},getOffset:function(e,t,r){for(var n=0,a=0;a<r;a+=1)n<<=8,n+=e.getUint8(t+a);return n},getBytes:function(e,t,r){for(var n=[],a=t;a<r;a+=1)n.push(e.getUint8(a));return n},bytesToString:function(e){for(var t="",r=0;r<e.length;r+=1)t+=String.fromCharCode(e[r]);return t},Parser:oe};var le={parse:function(e,t){var r={};r.version=se.getUShort(e,t),L.argument(0===r.version,"cmap table version should be 0."),r.numTables=se.getUShort(e,t+2);for(var n=-1,a=r.numTables-1;0<=a;--a){var o=se.getUShort(e,t+4+8*a),i=se.getUShort(e,t+4+8*a+2);if(3===o&&(0===i||1===i||10===i)||0===o&&(0===i||1===i||2===i||3===i||4===i)){n=se.getULong(e,t+4+8*a+4);break}}if(-1===n)throw new Error("No valid cmap sub-tables found.");var s=new se.Parser(e,t+n);if(r.format=s.parseUShort(),12===r.format)!function(e,t){var r;t.parseUShort(),e.length=t.parseULong(),e.language=t.parseULong(),e.groupCount=r=t.parseULong(),e.glyphIndexMap={};for(var n=0;n<r;n+=1)for(var a=t.parseULong(),o=t.parseULong(),i=t.parseULong(),s=a;s<=o;s+=1)e.glyphIndexMap[s]=i,i++;}(r,s);else {if(4!==r.format)throw new Error("Only format 4 and 12 cmap tables are supported (found format "+r.format+").");!function(e,t,r,n,a){var o;e.length=t.parseUShort(),e.language=t.parseUShort(),e.segCount=o=t.parseUShort()>>1,t.skip("uShort",3),e.glyphIndexMap={};for(var i=new se.Parser(r,n+a+14),s=new se.Parser(r,n+a+16+2*o),l=new se.Parser(r,n+a+16+4*o),p=new se.Parser(r,n+a+16+6*o),u=n+a+16+8*o,c=0;c<o-1;c+=1)for(var d=void 0,h=i.parseUShort(),m=s.parseUShort(),f=l.parseShort(),y=p.parseUShort(),g=m;g<=h;g+=1)0!==y?(u=p.offset+p.relativeOffset-2,u+=y,u+=2*(g-m),0!==(d=se.getUShort(r,u))&&(d=d+f&65535)):d=g+f&65535,e.glyphIndexMap[g]=d;}(r,s,e,t,n);}return r},make:function(e){var t,r=!0;for(t=e.length-1;0<t;--t){if(65535<e.get(t).unicode){console.log("Adding CMAP format 12 (needed!)"),r=!1;break}}var n=[{name:"version",type:"USHORT",value:0},{name:"numTables",type:"USHORT",value:r?1:2},{name:"platformID",type:"USHORT",value:3},{name:"encodingID",type:"USHORT",value:1},{name:"offset",type:"ULONG",value:r?12:20}];r||(n=n.concat([{name:"cmap12PlatformID",type:"USHORT",value:3},{name:"cmap12EncodingID",type:"USHORT",value:10},{name:"cmap12Offset",type:"ULONG",value:0}])),n=n.concat([{name:"format",type:"USHORT",value:4},{name:"cmap4Length",type:"USHORT",value:0},{name:"language",type:"USHORT",value:0},{name:"segCountX2",type:"USHORT",value:0},{name:"searchRange",type:"USHORT",value:0},{name:"entrySelector",type:"USHORT",value:0},{name:"rangeShift",type:"USHORT",value:0}]);var a,o,i,s=new $.Table("cmap",n);for(s.segments=[],t=0;t<e.length;t+=1){for(var l=e.get(t),p=0;p<l.unicodes.length;p+=1)a=s,o=l.unicodes[p],i=t,a.segments.push({end:o,start:o,delta:-(o-i),offset:0,glyphIndex:i});s.segments=s.segments.sort(function(e,t){return e.start-t.start});}s.segments.push({end:65535,start:65535,delta:1,offset:0});var u=s.segments.length,c=0,d=[],h=[],m=[],f=[],y=[],g=[];for(t=0;t<u;t+=1){var v=s.segments[t];v.end<=65535&&v.start<=65535?(d=d.concat({name:"end_"+t,type:"USHORT",value:v.end}),h=h.concat({name:"start_"+t,type:"USHORT",value:v.start}),m=m.concat({name:"idDelta_"+t,type:"SHORT",value:v.delta}),f=f.concat({name:"idRangeOffset_"+t,type:"USHORT",value:v.offset}),void 0!==v.glyphId&&(y=y.concat({name:"glyph_"+t,type:"USHORT",value:v.glyphId}))):c+=1,r||void 0===v.glyphIndex||(g=(g=(g=g.concat({name:"cmap12Start_"+t,type:"ULONG",value:v.start})).concat({name:"cmap12End_"+t,type:"ULONG",value:v.end})).concat({name:"cmap12Glyph_"+t,type:"ULONG",value:v.glyphIndex}));}if(s.segCountX2=2*(u-c),s.searchRange=2*Math.pow(2,Math.floor(Math.log(u-c)/Math.log(2))),s.entrySelector=Math.log(s.searchRange/2)/Math.log(2),s.rangeShift=s.segCountX2-s.searchRange,s.fields=s.fields.concat(d),s.fields.push({name:"reservedPad",type:"USHORT",value:0}),s.fields=s.fields.concat(h),s.fields=s.fields.concat(m),s.fields=s.fields.concat(f),s.fields=s.fields.concat(y),s.cmap4Length=14+2*d.length+2+2*h.length+2*m.length+2*f.length+2*y.length,!r){var b=16+4*g.length;s.cmap12Offset=20+s.cmap4Length,s.fields=s.fields.concat([{name:"cmap12Format",type:"USHORT",value:12},{name:"cmap12Reserved",type:"USHORT",value:0},{name:"cmap12Length",type:"ULONG",value:b},{name:"cmap12Language",type:"ULONG",value:0},{name:"cmap12nGroups",type:"ULONG",value:g.length/3}]),s.fields=s.fields.concat(g);}return s}},pe=[".notdef","space","exclam","quotedbl","numbersign","dollar","percent","ampersand","quoteright","parenleft","parenright","asterisk","plus","comma","hyphen","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","at","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","bracketleft","backslash","bracketright","asciicircum","underscore","quoteleft","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","braceleft","bar","braceright","asciitilde","exclamdown","cent","sterling","fraction","yen","florin","section","currency","quotesingle","quotedblleft","guillemotleft","guilsinglleft","guilsinglright","fi","fl","endash","dagger","daggerdbl","periodcentered","paragraph","bullet","quotesinglbase","quotedblbase","quotedblright","guillemotright","ellipsis","perthousand","questiondown","grave","acute","circumflex","tilde","macron","breve","dotaccent","dieresis","ring","cedilla","hungarumlaut","ogonek","caron","emdash","AE","ordfeminine","Lslash","Oslash","OE","ordmasculine","ae","dotlessi","lslash","oslash","oe","germandbls","onesuperior","logicalnot","mu","trademark","Eth","onehalf","plusminus","Thorn","onequarter","divide","brokenbar","degree","thorn","threequarters","twosuperior","registered","minus","eth","multiply","threesuperior","copyright","Aacute","Acircumflex","Adieresis","Agrave","Aring","Atilde","Ccedilla","Eacute","Ecircumflex","Edieresis","Egrave","Iacute","Icircumflex","Idieresis","Igrave","Ntilde","Oacute","Ocircumflex","Odieresis","Ograve","Otilde","Scaron","Uacute","Ucircumflex","Udieresis","Ugrave","Yacute","Ydieresis","Zcaron","aacute","acircumflex","adieresis","agrave","aring","atilde","ccedilla","eacute","ecircumflex","edieresis","egrave","iacute","icircumflex","idieresis","igrave","ntilde","oacute","ocircumflex","odieresis","ograve","otilde","scaron","uacute","ucircumflex","udieresis","ugrave","yacute","ydieresis","zcaron","exclamsmall","Hungarumlautsmall","dollaroldstyle","dollarsuperior","ampersandsmall","Acutesmall","parenleftsuperior","parenrightsuperior","266 ff","onedotenleader","zerooldstyle","oneoldstyle","twooldstyle","threeoldstyle","fouroldstyle","fiveoldstyle","sixoldstyle","sevenoldstyle","eightoldstyle","nineoldstyle","commasuperior","threequartersemdash","periodsuperior","questionsmall","asuperior","bsuperior","centsuperior","dsuperior","esuperior","isuperior","lsuperior","msuperior","nsuperior","osuperior","rsuperior","ssuperior","tsuperior","ff","ffi","ffl","parenleftinferior","parenrightinferior","Circumflexsmall","hyphensuperior","Gravesmall","Asmall","Bsmall","Csmall","Dsmall","Esmall","Fsmall","Gsmall","Hsmall","Ismall","Jsmall","Ksmall","Lsmall","Msmall","Nsmall","Osmall","Psmall","Qsmall","Rsmall","Ssmall","Tsmall","Usmall","Vsmall","Wsmall","Xsmall","Ysmall","Zsmall","colonmonetary","onefitted","rupiah","Tildesmall","exclamdownsmall","centoldstyle","Lslashsmall","Scaronsmall","Zcaronsmall","Dieresissmall","Brevesmall","Caronsmall","Dotaccentsmall","Macronsmall","figuredash","hypheninferior","Ogoneksmall","Ringsmall","Cedillasmall","questiondownsmall","oneeighth","threeeighths","fiveeighths","seveneighths","onethird","twothirds","zerosuperior","foursuperior","fivesuperior","sixsuperior","sevensuperior","eightsuperior","ninesuperior","zeroinferior","oneinferior","twoinferior","threeinferior","fourinferior","fiveinferior","sixinferior","seveninferior","eightinferior","nineinferior","centinferior","dollarinferior","periodinferior","commainferior","Agravesmall","Aacutesmall","Acircumflexsmall","Atildesmall","Adieresissmall","Aringsmall","AEsmall","Ccedillasmall","Egravesmall","Eacutesmall","Ecircumflexsmall","Edieresissmall","Igravesmall","Iacutesmall","Icircumflexsmall","Idieresissmall","Ethsmall","Ntildesmall","Ogravesmall","Oacutesmall","Ocircumflexsmall","Otildesmall","Odieresissmall","OEsmall","Oslashsmall","Ugravesmall","Uacutesmall","Ucircumflexsmall","Udieresissmall","Yacutesmall","Thornsmall","Ydieresissmall","001.000","001.001","001.002","001.003","Black","Bold","Book","Light","Medium","Regular","Roman","Semibold"],ue=["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","space","exclam","quotedbl","numbersign","dollar","percent","ampersand","quoteright","parenleft","parenright","asterisk","plus","comma","hyphen","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","at","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","bracketleft","backslash","bracketright","asciicircum","underscore","quoteleft","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","braceleft","bar","braceright","asciitilde","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","exclamdown","cent","sterling","fraction","yen","florin","section","currency","quotesingle","quotedblleft","guillemotleft","guilsinglleft","guilsinglright","fi","fl","","endash","dagger","daggerdbl","periodcentered","","paragraph","bullet","quotesinglbase","quotedblbase","quotedblright","guillemotright","ellipsis","perthousand","","questiondown","","grave","acute","circumflex","tilde","macron","breve","dotaccent","dieresis","","ring","cedilla","","hungarumlaut","ogonek","caron","emdash","","","","","","","","","","","","","","","","","AE","","ordfeminine","","","","","Lslash","Oslash","OE","ordmasculine","","","","","","ae","","","","dotlessi","","","lslash","oslash","oe","germandbls"],ce=["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","space","exclamsmall","Hungarumlautsmall","","dollaroldstyle","dollarsuperior","ampersandsmall","Acutesmall","parenleftsuperior","parenrightsuperior","twodotenleader","onedotenleader","comma","hyphen","period","fraction","zerooldstyle","oneoldstyle","twooldstyle","threeoldstyle","fouroldstyle","fiveoldstyle","sixoldstyle","sevenoldstyle","eightoldstyle","nineoldstyle","colon","semicolon","commasuperior","threequartersemdash","periodsuperior","questionsmall","","asuperior","bsuperior","centsuperior","dsuperior","esuperior","","","isuperior","","","lsuperior","msuperior","nsuperior","osuperior","","","rsuperior","ssuperior","tsuperior","","ff","fi","fl","ffi","ffl","parenleftinferior","","parenrightinferior","Circumflexsmall","hyphensuperior","Gravesmall","Asmall","Bsmall","Csmall","Dsmall","Esmall","Fsmall","Gsmall","Hsmall","Ismall","Jsmall","Ksmall","Lsmall","Msmall","Nsmall","Osmall","Psmall","Qsmall","Rsmall","Ssmall","Tsmall","Usmall","Vsmall","Wsmall","Xsmall","Ysmall","Zsmall","colonmonetary","onefitted","rupiah","Tildesmall","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","exclamdownsmall","centoldstyle","Lslashsmall","","","Scaronsmall","Zcaronsmall","Dieresissmall","Brevesmall","Caronsmall","","Dotaccentsmall","","","Macronsmall","","","figuredash","hypheninferior","","","Ogoneksmall","Ringsmall","Cedillasmall","","","","onequarter","onehalf","threequarters","questiondownsmall","oneeighth","threeeighths","fiveeighths","seveneighths","onethird","twothirds","","","zerosuperior","onesuperior","twosuperior","threesuperior","foursuperior","fivesuperior","sixsuperior","sevensuperior","eightsuperior","ninesuperior","zeroinferior","oneinferior","twoinferior","threeinferior","fourinferior","fiveinferior","sixinferior","seveninferior","eightinferior","nineinferior","centinferior","dollarinferior","periodinferior","commainferior","Agravesmall","Aacutesmall","Acircumflexsmall","Atildesmall","Adieresissmall","Aringsmall","AEsmall","Ccedillasmall","Egravesmall","Eacutesmall","Ecircumflexsmall","Edieresissmall","Igravesmall","Iacutesmall","Icircumflexsmall","Idieresissmall","Ethsmall","Ntildesmall","Ogravesmall","Oacutesmall","Ocircumflexsmall","Otildesmall","Odieresissmall","OEsmall","Oslashsmall","Ugravesmall","Uacutesmall","Ucircumflexsmall","Udieresissmall","Yacutesmall","Thornsmall","Ydieresissmall"],de=[".notdef",".null","nonmarkingreturn","space","exclam","quotedbl","numbersign","dollar","percent","ampersand","quotesingle","parenleft","parenright","asterisk","plus","comma","hyphen","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","at","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","bracketleft","backslash","bracketright","asciicircum","underscore","grave","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","braceleft","bar","braceright","asciitilde","Adieresis","Aring","Ccedilla","Eacute","Ntilde","Odieresis","Udieresis","aacute","agrave","acircumflex","adieresis","atilde","aring","ccedilla","eacute","egrave","ecircumflex","edieresis","iacute","igrave","icircumflex","idieresis","ntilde","oacute","ograve","ocircumflex","odieresis","otilde","uacute","ugrave","ucircumflex","udieresis","dagger","degree","cent","sterling","section","bullet","paragraph","germandbls","registered","copyright","trademark","acute","dieresis","notequal","AE","Oslash","infinity","plusminus","lessequal","greaterequal","yen","mu","partialdiff","summation","product","pi","integral","ordfeminine","ordmasculine","Omega","ae","oslash","questiondown","exclamdown","logicalnot","radical","florin","approxequal","Delta","guillemotleft","guillemotright","ellipsis","nonbreakingspace","Agrave","Atilde","Otilde","OE","oe","endash","emdash","quotedblleft","quotedblright","quoteleft","quoteright","divide","lozenge","ydieresis","Ydieresis","fraction","currency","guilsinglleft","guilsinglright","fi","fl","daggerdbl","periodcentered","quotesinglbase","quotedblbase","perthousand","Acircumflex","Ecircumflex","Aacute","Edieresis","Egrave","Iacute","Icircumflex","Idieresis","Igrave","Oacute","Ocircumflex","apple","Ograve","Uacute","Ucircumflex","Ugrave","dotlessi","circumflex","tilde","macron","breve","dotaccent","ring","cedilla","hungarumlaut","ogonek","caron","Lslash","lslash","Scaron","scaron","Zcaron","zcaron","brokenbar","Eth","eth","Yacute","yacute","Thorn","thorn","minus","multiply","onesuperior","twosuperior","threesuperior","onehalf","onequarter","threequarters","franc","Gbreve","gbreve","Idotaccent","Scedilla","scedilla","Cacute","cacute","Ccaron","ccaron","dcroat"];function he(e){this.font=e;}function me(e){this.cmap=e;}function fe(e,t){this.encoding=e,this.charset=t;}function ye(e){switch(e.version){case 1:this.names=de.slice();break;case 2:this.names=new Array(e.numberOfGlyphs);for(var t=0;t<e.numberOfGlyphs;t++)e.glyphNameIndex[t]<de.length?this.names[t]=de[e.glyphNameIndex[t]]:this.names[t]=e.names[e.glyphNameIndex[t]-de.length];break;case 2.5:this.names=new Array(e.numberOfGlyphs);for(var r=0;r<e.numberOfGlyphs;r++)this.names[r]=de[r+e.glyphNameIndex[r]];break;case 3:default:this.names=[];}}he.prototype.charToGlyphIndex=function(e){var t=e.codePointAt(0),r=this.font.glyphs;if(r)for(var n=0;n<r.length;n+=1)for(var a=r.get(n),o=0;o<a.unicodes.length;o+=1)if(a.unicodes[o]===t)return n;return null},me.prototype.charToGlyphIndex=function(e){return this.cmap.glyphIndexMap[e.codePointAt(0)]||0},fe.prototype.charToGlyphIndex=function(e){var t=e.codePointAt(0),r=this.encoding[t];return this.charset.indexOf(r)},ye.prototype.nameToGlyphIndex=function(e){return this.names.indexOf(e)},ye.prototype.glyphIndexToName=function(e){return this.names[e]};var ge={line:function(e,t,r,n,a){e.beginPath(),e.moveTo(t,r),e.lineTo(n,a),e.stroke();}};function ve(e){this.bindConstructorValues(e);}function be(t,e,r){Object.defineProperty(t,e,{get:function(){return t.path,t[r]},set:function(e){t[r]=e;},enumerable:!0,configurable:!0});}function _e(e,t){if(this.font=e,this.glyphs={},Array.isArray(t))for(var r=0;r<t.length;r++)this.glyphs[r]=t[r];this.length=t&&t.length||0;}ve.prototype.bindConstructorValues=function(e){var t,r;this.index=e.index||0,this.name=e.name||null,this.unicode=e.unicode||void 0,this.unicodes=e.unicodes||void 0!==e.unicode?[e.unicode]:[],e.xMin&&(this.xMin=e.xMin),e.yMin&&(this.yMin=e.yMin),e.xMax&&(this.xMax=e.xMax),e.yMax&&(this.yMax=e.yMax),e.advanceWidth&&(this.advanceWidth=e.advanceWidth),Object.defineProperty(this,"path",(t=e.path,r=t||new A,{configurable:!0,get:function(){return "function"==typeof r&&(r=r()),r},set:function(e){r=e;}}));},ve.prototype.addUnicode=function(e){0===this.unicodes.length&&(this.unicode=e),this.unicodes.push(e);},ve.prototype.getBoundingBox=function(){return this.path.getBoundingBox()},ve.prototype.getPath=function(e,t,r,n,a){var o,i;e=void 0!==e?e:0,t=void 0!==t?t:0,r=void 0!==r?r:72;var s=(n=n||{}).xScale,l=n.yScale;if(n.hinting&&a&&a.hinting&&(i=this.path&&a.hinting.exec(this,r)),i)o=a.hinting.getCommands(i),e=Math.round(e),t=Math.round(t),s=l=1;else {o=this.path.commands;var p=1/this.path.unitsPerEm*r;void 0===s&&(s=p),void 0===l&&(l=p);}for(var u=new A,c=0;c<o.length;c+=1){var d=o[c];"M"===d.type?u.moveTo(e+d.x*s,t+-d.y*l):"L"===d.type?u.lineTo(e+d.x*s,t+-d.y*l):"Q"===d.type?u.quadraticCurveTo(e+d.x1*s,t+-d.y1*l,e+d.x*s,t+-d.y*l):"C"===d.type?u.curveTo(e+d.x1*s,t+-d.y1*l,e+d.x2*s,t+-d.y2*l,e+d.x*s,t+-d.y*l):"Z"===d.type&&u.closePath();}return u},ve.prototype.getContours=function(){if(void 0===this.points)return [];for(var e=[],t=[],r=0;r<this.points.length;r+=1){var n=this.points[r];t.push(n),n.lastPointOfContour&&(e.push(t),t=[]);}return L.argument(0===t.length,"There are still points left in the current contour."),e},ve.prototype.getMetrics=function(){for(var e=this.path.commands,t=[],r=[],n=0;n<e.length;n+=1){var a=e[n];"Z"!==a.type&&(t.push(a.x),r.push(a.y)),"Q"!==a.type&&"C"!==a.type||(t.push(a.x1),r.push(a.y1)),"C"===a.type&&(t.push(a.x2),r.push(a.y2));}var o={xMin:Math.min.apply(null,t),yMin:Math.min.apply(null,r),xMax:Math.max.apply(null,t),yMax:Math.max.apply(null,r),leftSideBearing:this.leftSideBearing};return isFinite(o.xMin)||(o.xMin=0),isFinite(o.xMax)||(o.xMax=this.advanceWidth),isFinite(o.yMin)||(o.yMin=0),isFinite(o.yMax)||(o.yMax=0),o.rightSideBearing=this.advanceWidth-o.leftSideBearing-(o.xMax-o.xMin),o},ve.prototype.draw=function(e,t,r,n,a){this.getPath(t,r,n,a).draw(e);},ve.prototype.drawPoints=function(i,e,t,r){function n(e,t,r,n){var a=2*Math.PI;i.beginPath();for(var o=0;o<e.length;o+=1)i.moveTo(t+e[o].x*n,r+e[o].y*n),i.arc(t+e[o].x*n,r+e[o].y*n,2,0,a,!1);i.closePath(),i.fill();}e=void 0!==e?e:0,t=void 0!==t?t:0,r=void 0!==r?r:24;for(var a=1/this.path.unitsPerEm*r,o=[],s=[],l=this.path,p=0;p<l.commands.length;p+=1){var u=l.commands[p];void 0!==u.x&&o.push({x:u.x,y:-u.y}),void 0!==u.x1&&s.push({x:u.x1,y:-u.y1}),void 0!==u.x2&&s.push({x:u.x2,y:-u.y2});}i.fillStyle="blue",n(o,e,t,a),i.fillStyle="red",n(s,e,t,a);},ve.prototype.drawMetrics=function(e,t,r,n){var a;t=void 0!==t?t:0,r=void 0!==r?r:0,n=void 0!==n?n:24,a=1/this.path.unitsPerEm*n,e.lineWidth=1,e.strokeStyle="black",ge.line(e,t,-1e4,t,1e4),ge.line(e,-1e4,r,1e4,r);var o=this.xMin||0,i=this.yMin||0,s=this.xMax||0,l=this.yMax||0,p=this.advanceWidth||0;e.strokeStyle="blue",ge.line(e,t+o*a,-1e4,t+o*a,1e4),ge.line(e,t+s*a,-1e4,t+s*a,1e4),ge.line(e,-1e4,r+-i*a,1e4,r+-i*a),ge.line(e,-1e4,r+-l*a,1e4,r+-l*a),e.strokeStyle="green",ge.line(e,t+p*a,-1e4,t+p*a,1e4);},_e.prototype.get=function(e){return "function"==typeof this.glyphs[e]&&(this.glyphs[e]=this.glyphs[e]()),this.glyphs[e]},_e.prototype.push=function(e,t){this.glyphs[e]=t,this.length++;};var xe={GlyphSet:_e,glyphLoader:function(e,t){return new ve({index:t,font:e})},ttfGlyphLoader:function(r,e,n,a,o,i){return function(){var t=new ve({index:e,font:r});return t.path=function(){n(t,a,o);var e=i(r.glyphs,t);return e.unitsPerEm=r.unitsPerEm,e},be(t,"xMin","_xMin"),be(t,"xMax","_xMax"),be(t,"yMin","_yMin"),be(t,"yMax","_yMax"),t}},cffGlyphLoader:function(r,e,n,a){return function(){var t=new ve({index:e,font:r});return t.path=function(){var e=n(r,t,a);return e.unitsPerEm=r.unitsPerEm,e},t}}};function Se(e,t){if(e===t)return !0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return !1;for(var r=0;r<e.length;r+=1)if(!Se(e[r],t[r]))return !1;return !0}return !1}function we(e){return e.length<1240?107:e.length<33900?1131:32768}function Me(e,t,r){var n,a,o=[],i=[],s=se.getCard16(e,t);if(0!==s){var l=se.getByte(e,t+2);n=t+(s+1)*l+2;for(var p=t+3,u=0;u<s+1;u+=1)o.push(se.getOffset(e,p,l)),p+=l;a=n+o[s];}else a=t+2;for(var c=0;c<o.length-1;c+=1){var d=se.getBytes(e,n+o[c],n+o[c+1]);r&&(d=r(d)),i.push(d);}return {objects:i,startOffset:t,endOffset:a}}function Ee(e,t){if(28===t)return e.parseByte()<<8|e.parseByte();if(29===t)return e.parseByte()<<24|e.parseByte()<<16|e.parseByte()<<8|e.parseByte();if(30===t)return function(e){for(var t="",r=["0","1","2","3","4","5","6","7","8","9",".","E","E-",null,"-"];;){var n=e.parseByte(),a=n>>4,o=15&n;if(15==a)break;if(t+=r[a],15==o)break;t+=r[o];}return parseFloat(t)}(e);if(32<=t&&t<=246)return t-139;if(247<=t&&t<=250)return 256*(t-247)+e.parseByte()+108;if(251<=t&&t<=254)return 256*-(t-251)-e.parseByte()-108;throw new Error("Invalid b0 "+t)}function Te(e,t,r){t=void 0!==t?t:0;var n=new se.Parser(e,t),a=[],o=[];for(r=void 0!==r?r:e.length;n.relativeOffset<r;){var i=n.parseByte();i<=21?(12===i&&(i=1200+n.parseByte()),a.push([i,o]),o=[]):o.push(Ee(n,i));}return function(e){for(var t={},r=0;r<e.length;r+=1){var n=e[r][0],a=e[r][1],o=void 0;if(o=1===a.length?a[0]:a,t.hasOwnProperty(n)&&!isNaN(t[n]))throw new Error("Object "+t+" already has key "+n);t[n]=o;}return t}(a)}function Ce(e,t){return t=t<=390?pe[t]:e[t-391]}function Ne(e,t,r){for(var n,a={},o=0;o<t.length;o+=1){var i=t[o];if(Array.isArray(i.type)){var s=[];s.length=i.type.length;for(var l=0;l<i.type.length;l++)void 0===(n=void 0!==e[i.op]?e[i.op][l]:void 0)&&(n=void 0!==i.value&&void 0!==i.value[l]?i.value[l]:null),"SID"===i.type[l]&&(n=Ce(r,n)),s[l]=n;a[i.name]=s;}else void 0===(n=e[i.op])&&(n=void 0!==i.value?i.value:null),"SID"===i.type&&(n=Ce(r,n)),a[i.name]=n;}return a}var Oe=[{name:"version",op:0,type:"SID"},{name:"notice",op:1,type:"SID"},{name:"copyright",op:1200,type:"SID"},{name:"fullName",op:2,type:"SID"},{name:"familyName",op:3,type:"SID"},{name:"weight",op:4,type:"SID"},{name:"isFixedPitch",op:1201,type:"number",value:0},{name:"italicAngle",op:1202,type:"number",value:0},{name:"underlinePosition",op:1203,type:"number",value:-100},{name:"underlineThickness",op:1204,type:"number",value:50},{name:"paintType",op:1205,type:"number",value:0},{name:"charstringType",op:1206,type:"number",value:2},{name:"fontMatrix",op:1207,type:["real","real","real","real","real","real"],value:[.001,0,0,.001,0,0]},{name:"uniqueId",op:13,type:"number"},{name:"fontBBox",op:5,type:["number","number","number","number"],value:[0,0,0,0]},{name:"strokeWidth",op:1208,type:"number",value:0},{name:"xuid",op:14,type:[],value:null},{name:"charset",op:15,type:"offset",value:0},{name:"encoding",op:16,type:"offset",value:0},{name:"charStrings",op:17,type:"offset",value:0},{name:"private",op:18,type:["number","offset"],value:[0,0]},{name:"ros",op:1230,type:["SID","SID","number"]},{name:"cidFontVersion",op:1231,type:"number",value:0},{name:"cidFontRevision",op:1232,type:"number",value:0},{name:"cidFontType",op:1233,type:"number",value:0},{name:"cidCount",op:1234,type:"number",value:8720},{name:"uidBase",op:1235,type:"number"},{name:"fdArray",op:1236,type:"offset"},{name:"fdSelect",op:1237,type:"offset"},{name:"fontName",op:1238,type:"SID"}],Le=[{name:"subrs",op:19,type:"offset",value:0},{name:"defaultWidthX",op:20,type:"number",value:0},{name:"nominalWidthX",op:21,type:"number",value:0}];function Ie(e,t,r,n){return Ne(Te(e,t,r),Le,n)}function Pe(e,t,r,n){for(var a,o,i=[],s=0;s<r.length;s+=1){var l=new DataView(new Uint8Array(r[s]).buffer),p=(o=n,Ne(Te(a=l,0,a.byteLength),Oe,o));p._subrs=[],p._subrsBias=0;var u=p.private[0],c=p.private[1];if(0!==u&&0!==c){var d=Ie(e,c+t,u,n);if(p._defaultWidthX=d.defaultWidthX,p._nominalWidthX=d.nominalWidthX,0!==d.subrs){var h=Me(e,c+d.subrs+t);p._subrs=h.objects,p._subrsBias=we(p._subrs);}p._privateDict=d;}i.push(p);}return i}function Re(y,g,e){var v,b,_,x,S,w,t,M,E=new A,T=[],C=0,N=!1,O=!1,L=0,I=0;if(y.isCIDFont){var r=y.tables.cff.topDict._fdSelect[g.index],n=y.tables.cff.topDict._fdArray[r];S=n._subrs,w=n._subrsBias,t=n._defaultWidthX,M=n._nominalWidthX;}else S=y.tables.cff.topDict._subrs,w=y.tables.cff.topDict._subrsBias,t=y.tables.cff.topDict._defaultWidthX,M=y.tables.cff.topDict._nominalWidthX;var P=t;function R(e,t){O&&E.closePath(),E.moveTo(e,t),O=!0;}function D(){T.length%2==0||N||(P=T.shift()+M),C+=T.length>>1,T.length=0,N=!0;}return function e(t){for(var r,n,a,o,i,s,l,p,u,c,d,h,m=0;m<t.length;){var f=t[m];switch(m+=1,f){case 1:case 3:D();break;case 4:1<T.length&&!N&&(P=T.shift()+M,N=!0),I+=T.pop(),R(L,I);break;case 5:for(;0<T.length;)L+=T.shift(),I+=T.shift(),E.lineTo(L,I);break;case 6:for(;0<T.length&&(L+=T.shift(),E.lineTo(L,I),0!==T.length);)I+=T.shift(),E.lineTo(L,I);break;case 7:for(;0<T.length&&(I+=T.shift(),E.lineTo(L,I),0!==T.length);)L+=T.shift(),E.lineTo(L,I);break;case 8:for(;0<T.length;)v=L+T.shift(),b=I+T.shift(),_=v+T.shift(),x=b+T.shift(),L=_+T.shift(),I=x+T.shift(),E.curveTo(v,b,_,x,L,I);break;case 10:i=T.pop()+w,(s=S[i])&&e(s);break;case 11:return;case 12:switch(f=t[m],m+=1,f){case 35:v=L+T.shift(),b=I+T.shift(),_=v+T.shift(),x=b+T.shift(),l=_+T.shift(),p=x+T.shift(),u=l+T.shift(),c=p+T.shift(),d=u+T.shift(),h=c+T.shift(),L=d+T.shift(),I=h+T.shift(),T.shift(),E.curveTo(v,b,_,x,l,p),E.curveTo(u,c,d,h,L,I);break;case 34:v=L+T.shift(),b=I,_=v+T.shift(),x=b+T.shift(),l=_+T.shift(),p=x,u=l+T.shift(),c=x,d=u+T.shift(),h=I,L=d+T.shift(),E.curveTo(v,b,_,x,l,p),E.curveTo(u,c,d,h,L,I);break;case 36:v=L+T.shift(),b=I+T.shift(),_=v+T.shift(),x=b+T.shift(),l=_+T.shift(),p=x,u=l+T.shift(),c=x,d=u+T.shift(),h=c+T.shift(),L=d+T.shift(),E.curveTo(v,b,_,x,l,p),E.curveTo(u,c,d,h,L,I);break;case 37:v=L+T.shift(),b=I+T.shift(),_=v+T.shift(),x=b+T.shift(),l=_+T.shift(),p=x+T.shift(),u=l+T.shift(),c=p+T.shift(),d=u+T.shift(),h=c+T.shift(),Math.abs(d-L)>Math.abs(h-I)?L=d+T.shift():I=h+T.shift(),E.curveTo(v,b,_,x,l,p),E.curveTo(u,c,d,h,L,I);break;default:console.log("Glyph "+g.index+": unknown operator 1200"+f),T.length=0;}break;case 14:0<T.length&&!N&&(P=T.shift()+M,N=!0),O&&(E.closePath(),O=!1);break;case 18:D();break;case 19:case 20:D(),m+=C+7>>3;break;case 21:2<T.length&&!N&&(P=T.shift()+M,N=!0),I+=T.pop(),R(L+=T.pop(),I);break;case 22:1<T.length&&!N&&(P=T.shift()+M,N=!0),R(L+=T.pop(),I);break;case 23:D();break;case 24:for(;2<T.length;)v=L+T.shift(),b=I+T.shift(),_=v+T.shift(),x=b+T.shift(),L=_+T.shift(),I=x+T.shift(),E.curveTo(v,b,_,x,L,I);L+=T.shift(),I+=T.shift(),E.lineTo(L,I);break;case 25:for(;6<T.length;)L+=T.shift(),I+=T.shift(),E.lineTo(L,I);v=L+T.shift(),b=I+T.shift(),_=v+T.shift(),x=b+T.shift(),L=_+T.shift(),I=x+T.shift(),E.curveTo(v,b,_,x,L,I);break;case 26:for(T.length%2&&(L+=T.shift());0<T.length;)v=L,b=I+T.shift(),_=v+T.shift(),x=b+T.shift(),L=_,I=x+T.shift(),E.curveTo(v,b,_,x,L,I);break;case 27:for(T.length%2&&(I+=T.shift());0<T.length;)v=L+T.shift(),b=I,_=v+T.shift(),x=b+T.shift(),L=_+T.shift(),I=x,E.curveTo(v,b,_,x,L,I);break;case 28:r=t[m],n=t[m+1],T.push((r<<24|n<<16)>>16),m+=2;break;case 29:i=T.pop()+y.gsubrsBias,(s=y.gsubrs[i])&&e(s);break;case 30:for(;0<T.length&&(v=L,b=I+T.shift(),_=v+T.shift(),x=b+T.shift(),L=_+T.shift(),I=x+(1===T.length?T.shift():0),E.curveTo(v,b,_,x,L,I),0!==T.length);)v=L+T.shift(),b=I,_=v+T.shift(),x=b+T.shift(),I=x+T.shift(),L=_+(1===T.length?T.shift():0),E.curveTo(v,b,_,x,L,I);break;case 31:for(;0<T.length&&(v=L+T.shift(),b=I,_=v+T.shift(),x=b+T.shift(),I=x+T.shift(),L=_+(1===T.length?T.shift():0),E.curveTo(v,b,_,x,L,I),0!==T.length);)v=L,b=I+T.shift(),_=v+T.shift(),x=b+T.shift(),L=_+T.shift(),I=x+(1===T.length?T.shift():0),E.curveTo(v,b,_,x,L,I);break;default:f<32?console.log("Glyph "+g.index+": unknown operator "+f):f<247?T.push(f-139):f<251?(r=t[m],m+=1,T.push(256*(f-247)+r+108)):f<255?(r=t[m],m+=1,T.push(256*-(f-251)-r-108)):(r=t[m],n=t[m+1],a=t[m+2],o=t[m+3],m+=4,T.push((r<<24|n<<16|a<<8|o)/65536));}}}(e),g.advanceWidth=P,E}function De(e,t){var r,n=pe.indexOf(e);return 0<=n&&(r=n),0<=(n=t.indexOf(e))?r=n+pe.length:(r=pe.length+t.length,t.push(e)),r}function Ae(e,t,r){for(var n={},a=0;a<e.length;a+=1){var o=e[a],i=t[o.name];void 0===i||Se(i,o.value)||("SID"===o.type&&(i=De(i,r)),n[o.op]={name:o.name,type:o.type,value:i});}return n}function ke(e,t){var r=new $.Record("Top DICT",[{name:"dict",type:"DICT",value:{}}]);return r.dict=Ae(Oe,e,t),r}function Fe(e){var t=new $.Record("Top DICT INDEX",[{name:"topDicts",type:"INDEX",value:[]}]);return t.topDicts=[{name:"topDict_0",type:"TABLE",value:e}],t}function Ue(e){var t=[],r=e.path;t.push({name:"width",type:"NUMBER",value:e.advanceWidth});for(var n=0,a=0,o=0;o<r.commands.length;o+=1){var i=void 0,s=void 0,l=r.commands[o];if("Q"===l.type){l={type:"C",x:l.x,y:l.y,x1:1/3*n+2/3*l.x1,y1:1/3*a+2/3*l.y1,x2:1/3*l.x+2/3*l.x1,y2:1/3*l.y+2/3*l.y1};}if("M"===l.type)i=Math.round(l.x-n),s=Math.round(l.y-a),t.push({name:"dx",type:"NUMBER",value:i}),t.push({name:"dy",type:"NUMBER",value:s}),t.push({name:"rmoveto",type:"OP",value:21}),n=Math.round(l.x),a=Math.round(l.y);else if("L"===l.type)i=Math.round(l.x-n),s=Math.round(l.y-a),t.push({name:"dx",type:"NUMBER",value:i}),t.push({name:"dy",type:"NUMBER",value:s}),t.push({name:"rlineto",type:"OP",value:5}),n=Math.round(l.x),a=Math.round(l.y);else if("C"===l.type){var p=Math.round(l.x1-n),u=Math.round(l.y1-a),c=Math.round(l.x2-l.x1),d=Math.round(l.y2-l.y1);i=Math.round(l.x-l.x2),s=Math.round(l.y-l.y2),t.push({name:"dx1",type:"NUMBER",value:p}),t.push({name:"dy1",type:"NUMBER",value:u}),t.push({name:"dx2",type:"NUMBER",value:c}),t.push({name:"dy2",type:"NUMBER",value:d}),t.push({name:"dx",type:"NUMBER",value:i}),t.push({name:"dy",type:"NUMBER",value:s}),t.push({name:"rrcurveto",type:"OP",value:8}),n=Math.round(l.x),a=Math.round(l.y);}}return t.push({name:"endchar",type:"OP",value:14}),t}var Be={parse:function(e,t,r){r.tables.cff={};var n,a,o,i=Me(e,(n=e,a=t,(o={}).formatMajor=se.getCard8(n,a),o.formatMinor=se.getCard8(n,a+1),o.size=se.getCard8(n,a+2),o.offsetSize=se.getCard8(n,a+3),o.startOffset=a,o.endOffset=a+4,o).endOffset,se.bytesToString),s=Me(e,i.endOffset),l=Me(e,s.endOffset,se.bytesToString),p=Me(e,l.endOffset);r.gsubrs=p.objects,r.gsubrsBias=we(r.gsubrs);var u=Pe(e,t,s.objects,l.objects);if(1!==u.length)throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = "+u.length);var c=u[0];if((r.tables.cff.topDict=c)._privateDict&&(r.defaultWidthX=c._privateDict.defaultWidthX,r.nominalWidthX=c._privateDict.nominalWidthX),void 0!==c.ros[0]&&void 0!==c.ros[1]&&(r.isCIDFont=!0),r.isCIDFont){var d=c.fdArray,h=c.fdSelect;if(0===d||0===h)throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing");var m=Pe(e,t,Me(e,d+=t).objects,l.objects);c._fdArray=m,h+=t,c._fdSelect=function(e,t,r,n){var a,o=[],i=new se.Parser(e,t),s=i.parseCard8();if(0===s)for(var l=0;l<r;l++){if(n<=(a=i.parseCard8()))throw new Error("CFF table CID Font FDSelect has bad FD index value "+a+" (FD count "+n+")");o.push(a);}else {if(3!==s)throw new Error("CFF Table CID Font FDSelect table has unsupported format "+s);var p,u=i.parseCard16(),c=i.parseCard16();if(0!==c)throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID "+c);for(var d=0;d<u;d++){if(a=i.parseCard8(),p=i.parseCard16(),n<=a)throw new Error("CFF table CID Font FDSelect has bad FD index value "+a+" (FD count "+n+")");if(r<p)throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID "+p);for(;c<p;c++)o.push(a);c=p;}if(p!==r)throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID "+p)}return o}(e,h,r.numGlyphs,m.length);}var f=t+c.private[1],y=Ie(e,f,c.private[0],l.objects);if(r.defaultWidthX=y.defaultWidthX,r.nominalWidthX=y.nominalWidthX,0!==y.subrs){var g=Me(e,f+y.subrs);r.subrs=g.objects,r.subrsBias=we(r.subrs);}else r.subrs=[],r.subrsBias=0;var v=Me(e,t+c.charStrings);r.nGlyphs=v.objects.length;var b=function(e,t,r,n){var a,o,i=new se.Parser(e,t);--r;var s=[".notdef"],l=i.parseCard8();if(0===l)for(var p=0;p<r;p+=1)a=i.parseSID(),s.push(Ce(n,a));else if(1===l)for(;s.length<=r;){a=i.parseSID(),o=i.parseCard8();for(var u=0;u<=o;u+=1)s.push(Ce(n,a)),a+=1;}else {if(2!==l)throw new Error("Unknown charset format "+l);for(;s.length<=r;){a=i.parseSID(),o=i.parseCard16();for(var c=0;c<=o;c+=1)s.push(Ce(n,a)),a+=1;}}return s}(e,t+c.charset,r.nGlyphs,l.objects);0===c.encoding?r.cffEncoding=new fe(ue,b):1===c.encoding?r.cffEncoding=new fe(ce,b):r.cffEncoding=function(e,t,r){var n,a={},o=new se.Parser(e,t),i=o.parseCard8();if(0===i)for(var s=o.parseCard8(),l=0;l<s;l+=1)a[n=o.parseCard8()]=l;else {if(1!==i)throw new Error("Unknown encoding format "+i);var p=o.parseCard8();n=1;for(var u=0;u<p;u+=1)for(var c=o.parseCard8(),d=o.parseCard8(),h=c;h<=c+d;h+=1)a[h]=n,n+=1;}return new fe(a,r)}(e,t+c.encoding,b),r.encoding=r.encoding||r.cffEncoding,r.glyphs=new xe.GlyphSet(r);for(var _=0;_<r.nGlyphs;_+=1){var x=v.objects[_];r.glyphs.push(_,xe.cffGlyphLoader(r,_,Re,x));}},make:function(e,t){for(var r,n=new $.Table("CFF ",[{name:"header",type:"RECORD"},{name:"nameIndex",type:"RECORD"},{name:"topDictIndex",type:"RECORD"},{name:"stringIndex",type:"RECORD"},{name:"globalSubrIndex",type:"RECORD"},{name:"charsets",type:"RECORD"},{name:"charStringsIndex",type:"RECORD"},{name:"privateDict",type:"RECORD"}]),a=1/t.unitsPerEm,o={version:t.version,fullName:t.fullName,familyName:t.familyName,weight:t.weightName,fontBBox:t.fontBBox||[0,0,0,0],fontMatrix:[a,0,0,a,0,0],charset:999,encoding:0,charStrings:999,private:[0,999]},i=[],s=1;s<e.length;s+=1)r=e.get(s),i.push(r.name);var l=[];n.header=new $.Record("Header",[{name:"major",type:"Card8",value:1},{name:"minor",type:"Card8",value:0},{name:"hdrSize",type:"Card8",value:4},{name:"major",type:"Card8",value:1}]),n.nameIndex=function(e){var t=new $.Record("Name INDEX",[{name:"names",type:"INDEX",value:[]}]);t.names=[];for(var r=0;r<e.length;r+=1)t.names.push({name:"name_"+r,type:"NAME",value:e[r]});return t}([t.postScriptName]);var p,u,c,d=ke(o,l);n.topDictIndex=Fe(d),n.globalSubrIndex=new $.Record("Global Subr INDEX",[{name:"subrs",type:"INDEX",value:[]}]),n.charsets=function(e,t){for(var r=new $.Record("Charsets",[{name:"format",type:"Card8",value:0}]),n=0;n<e.length;n+=1){var a=De(e[n],t);r.fields.push({name:"glyph_"+n,type:"SID",value:a});}return r}(i,l),n.charStringsIndex=function(e){for(var t=new $.Record("CharStrings INDEX",[{name:"charStrings",type:"INDEX",value:[]}]),r=0;r<e.length;r+=1){var n=e.get(r),a=Ue(n);t.charStrings.push({name:n.name,type:"CHARSTRING",value:a});}return t}(e),n.privateDict=(p={},u=l,(c=new $.Record("Private DICT",[{name:"dict",type:"DICT",value:{}}])).dict=Ae(Le,p,u),c),n.stringIndex=function(e){var t=new $.Record("String INDEX",[{name:"strings",type:"INDEX",value:[]}]);t.strings=[];for(var r=0;r<e.length;r+=1)t.strings.push({name:"string_"+r,type:"STRING",value:e[r]});return t}(l);var h=n.header.sizeOf()+n.nameIndex.sizeOf()+n.topDictIndex.sizeOf()+n.stringIndex.sizeOf()+n.globalSubrIndex.sizeOf();return o.charset=h,o.encoding=0,o.charStrings=o.charset+n.charsets.sizeOf(),o.private[1]=o.charStrings+n.charStringsIndex.sizeOf(),d=ke(o,l),n.topDictIndex=Fe(d),n}};var Ge={parse:function(e,t){var r={},n=new se.Parser(e,t);return r.version=n.parseVersion(),r.fontRevision=Math.round(1e3*n.parseFixed())/1e3,r.checkSumAdjustment=n.parseULong(),r.magicNumber=n.parseULong(),L.argument(1594834165===r.magicNumber,"Font header has wrong magic number."),r.flags=n.parseUShort(),r.unitsPerEm=n.parseUShort(),r.created=n.parseLongDateTime(),r.modified=n.parseLongDateTime(),r.xMin=n.parseShort(),r.yMin=n.parseShort(),r.xMax=n.parseShort(),r.yMax=n.parseShort(),r.macStyle=n.parseUShort(),r.lowestRecPPEM=n.parseUShort(),r.fontDirectionHint=n.parseShort(),r.indexToLocFormat=n.parseShort(),r.glyphDataFormat=n.parseShort(),r},make:function(e){var t=Math.round((new Date).getTime()/1e3)+2082844800,r=t;return e.createdTimestamp&&(r=e.createdTimestamp+2082844800),new $.Table("head",[{name:"version",type:"FIXED",value:65536},{name:"fontRevision",type:"FIXED",value:65536},{name:"checkSumAdjustment",type:"ULONG",value:0},{name:"magicNumber",type:"ULONG",value:1594834165},{name:"flags",type:"USHORT",value:0},{name:"unitsPerEm",type:"USHORT",value:1e3},{name:"created",type:"LONGDATETIME",value:r},{name:"modified",type:"LONGDATETIME",value:t},{name:"xMin",type:"SHORT",value:0},{name:"yMin",type:"SHORT",value:0},{name:"xMax",type:"SHORT",value:0},{name:"yMax",type:"SHORT",value:0},{name:"macStyle",type:"USHORT",value:0},{name:"lowestRecPPEM",type:"USHORT",value:0},{name:"fontDirectionHint",type:"SHORT",value:2},{name:"indexToLocFormat",type:"SHORT",value:0},{name:"glyphDataFormat",type:"SHORT",value:0}],e)}};var je={parse:function(e,t){var r={},n=new se.Parser(e,t);return r.version=n.parseVersion(),r.ascender=n.parseShort(),r.descender=n.parseShort(),r.lineGap=n.parseShort(),r.advanceWidthMax=n.parseUShort(),r.minLeftSideBearing=n.parseShort(),r.minRightSideBearing=n.parseShort(),r.xMaxExtent=n.parseShort(),r.caretSlopeRise=n.parseShort(),r.caretSlopeRun=n.parseShort(),r.caretOffset=n.parseShort(),n.relativeOffset+=8,r.metricDataFormat=n.parseShort(),r.numberOfHMetrics=n.parseUShort(),r},make:function(e){return new $.Table("hhea",[{name:"version",type:"FIXED",value:65536},{name:"ascender",type:"FWORD",value:0},{name:"descender",type:"FWORD",value:0},{name:"lineGap",type:"FWORD",value:0},{name:"advanceWidthMax",type:"UFWORD",value:0},{name:"minLeftSideBearing",type:"FWORD",value:0},{name:"minRightSideBearing",type:"FWORD",value:0},{name:"xMaxExtent",type:"FWORD",value:0},{name:"caretSlopeRise",type:"SHORT",value:1},{name:"caretSlopeRun",type:"SHORT",value:0},{name:"caretOffset",type:"SHORT",value:0},{name:"reserved1",type:"SHORT",value:0},{name:"reserved2",type:"SHORT",value:0},{name:"reserved3",type:"SHORT",value:0},{name:"reserved4",type:"SHORT",value:0},{name:"metricDataFormat",type:"SHORT",value:0},{name:"numberOfHMetrics",type:"USHORT",value:0}],e)}};var Ve={parse:function(e,t,r,n,a){for(var o,i,s=new se.Parser(e,t),l=0;l<n;l+=1){l<r&&(o=s.parseUShort(),i=s.parseShort());var p=a.get(l);p.advanceWidth=o,p.leftSideBearing=i;}},make:function(e){for(var t=new $.Table("hmtx",[]),r=0;r<e.length;r+=1){var n=e.get(r),a=n.advanceWidth||0,o=n.leftSideBearing||0;t.fields.push({name:"advanceWidth_"+r,type:"USHORT",value:a}),t.fields.push({name:"leftSideBearing_"+r,type:"SHORT",value:o});}return t}};var ze={make:function(e){for(var t=new $.Table("ltag",[{name:"version",type:"ULONG",value:1},{name:"flags",type:"ULONG",value:0},{name:"numTags",type:"ULONG",value:e.length}]),r="",n=12+4*e.length,a=0;a<e.length;++a){var o=r.indexOf(e[a]);o<0&&(o=r.length,r+=e[a]),t.fields.push({name:"offset "+a,type:"USHORT",value:n+o}),t.fields.push({name:"length "+a,type:"USHORT",value:e[a].length});}return t.fields.push({name:"stringPool",type:"CHARARRAY",value:r}),t},parse:function(e,t){var r=new se.Parser(e,t),n=r.parseULong();L.argument(1===n,"Unsupported ltag table version."),r.skip("uLong",1);for(var a=r.parseULong(),o=[],i=0;i<a;i++){for(var s="",l=t+r.parseUShort(),p=r.parseUShort(),u=l;u<l+p;++u)s+=String.fromCharCode(e.getInt8(u));o.push(s);}return o}};var He={parse:function(e,t){var r={},n=new se.Parser(e,t);return r.version=n.parseVersion(),r.numGlyphs=n.parseUShort(),1===r.version&&(r.maxPoints=n.parseUShort(),r.maxContours=n.parseUShort(),r.maxCompositePoints=n.parseUShort(),r.maxCompositeContours=n.parseUShort(),r.maxZones=n.parseUShort(),r.maxTwilightPoints=n.parseUShort(),r.maxStorage=n.parseUShort(),r.maxFunctionDefs=n.parseUShort(),r.maxInstructionDefs=n.parseUShort(),r.maxStackElements=n.parseUShort(),r.maxSizeOfInstructions=n.parseUShort(),r.maxComponentElements=n.parseUShort(),r.maxComponentDepth=n.parseUShort()),r},make:function(e){return new $.Table("maxp",[{name:"version",type:"FIXED",value:20480},{name:"numGlyphs",type:"USHORT",value:e}])}},We=["copyright","fontFamily","fontSubfamily","uniqueID","fullName","version","postScriptName","trademark","manufacturer","designer","description","manufacturerURL","designerURL","license","licenseURL","reserved","preferredFamily","preferredSubfamily","compatibleFullName","sampleText","postScriptFindFontName","wwsFamily","wwsSubfamily"],Xe={0:"en",1:"fr",2:"de",3:"it",4:"nl",5:"sv",6:"es",7:"da",8:"pt",9:"no",10:"he",11:"ja",12:"ar",13:"fi",14:"el",15:"is",16:"mt",17:"tr",18:"hr",19:"zh-Hant",20:"ur",21:"hi",22:"th",23:"ko",24:"lt",25:"pl",26:"hu",27:"es",28:"lv",29:"se",30:"fo",31:"fa",32:"ru",33:"zh",34:"nl-BE",35:"ga",36:"sq",37:"ro",38:"cz",39:"sk",40:"si",41:"yi",42:"sr",43:"mk",44:"bg",45:"uk",46:"be",47:"uz",48:"kk",49:"az-Cyrl",50:"az-Arab",51:"hy",52:"ka",53:"mo",54:"ky",55:"tg",56:"tk",57:"mn-CN",58:"mn",59:"ps",60:"ks",61:"ku",62:"sd",63:"bo",64:"ne",65:"sa",66:"mr",67:"bn",68:"as",69:"gu",70:"pa",71:"or",72:"ml",73:"kn",74:"ta",75:"te",76:"si",77:"my",78:"km",79:"lo",80:"vi",81:"id",82:"tl",83:"ms",84:"ms-Arab",85:"am",86:"ti",87:"om",88:"so",89:"sw",90:"rw",91:"rn",92:"ny",93:"mg",94:"eo",128:"cy",129:"eu",130:"ca",131:"la",132:"qu",133:"gn",134:"ay",135:"tt",136:"ug",137:"dz",138:"jv",139:"su",140:"gl",141:"af",142:"br",143:"iu",144:"gd",145:"gv",146:"ga",147:"to",148:"el-polyton",149:"kl",150:"az",151:"nn"},qe={0:0,1:0,2:0,3:0,4:0,5:0,6:0,7:0,8:0,9:0,10:5,11:1,12:4,13:0,14:6,15:0,16:0,17:0,18:0,19:2,20:4,21:9,22:21,23:3,24:29,25:29,26:29,27:29,28:29,29:0,30:0,31:4,32:7,33:25,34:0,35:0,36:0,37:0,38:29,39:29,40:0,41:5,42:7,43:7,44:7,45:7,46:7,47:7,48:7,49:7,50:4,51:24,52:23,53:7,54:7,55:7,56:7,57:27,58:7,59:4,60:4,61:4,62:4,63:26,64:9,65:9,66:9,67:13,68:13,69:11,70:10,71:12,72:17,73:16,74:14,75:15,76:18,77:19,78:20,79:22,80:30,81:0,82:0,83:0,84:4,85:28,86:28,87:28,88:0,89:0,90:0,91:0,92:0,93:0,94:0,128:0,129:0,130:0,131:0,132:0,133:0,134:0,135:7,136:4,137:26,138:0,139:0,140:0,141:0,142:0,143:28,144:0,145:0,146:0,147:0,148:6,149:0,150:0,151:0},Ye={1078:"af",1052:"sq",1156:"gsw",1118:"am",5121:"ar-DZ",15361:"ar-BH",3073:"ar",2049:"ar-IQ",11265:"ar-JO",13313:"ar-KW",12289:"ar-LB",4097:"ar-LY",6145:"ary",8193:"ar-OM",16385:"ar-QA",1025:"ar-SA",10241:"ar-SY",7169:"aeb",14337:"ar-AE",9217:"ar-YE",1067:"hy",1101:"as",2092:"az-Cyrl",1068:"az",1133:"ba",1069:"eu",1059:"be",2117:"bn",1093:"bn-IN",8218:"bs-Cyrl",5146:"bs",1150:"br",1026:"bg",1027:"ca",3076:"zh-HK",5124:"zh-MO",2052:"zh",4100:"zh-SG",1028:"zh-TW",1155:"co",1050:"hr",4122:"hr-BA",1029:"cs",1030:"da",1164:"prs",1125:"dv",2067:"nl-BE",1043:"nl",3081:"en-AU",10249:"en-BZ",4105:"en-CA",9225:"en-029",16393:"en-IN",6153:"en-IE",8201:"en-JM",17417:"en-MY",5129:"en-NZ",13321:"en-PH",18441:"en-SG",7177:"en-ZA",11273:"en-TT",2057:"en-GB",1033:"en",12297:"en-ZW",1061:"et",1080:"fo",1124:"fil",1035:"fi",2060:"fr-BE",3084:"fr-CA",1036:"fr",5132:"fr-LU",6156:"fr-MC",4108:"fr-CH",1122:"fy",1110:"gl",1079:"ka",3079:"de-AT",1031:"de",5127:"de-LI",4103:"de-LU",2055:"de-CH",1032:"el",1135:"kl",1095:"gu",1128:"ha",1037:"he",1081:"hi",1038:"hu",1039:"is",1136:"ig",1057:"id",1117:"iu",2141:"iu-Latn",2108:"ga",1076:"xh",1077:"zu",1040:"it",2064:"it-CH",1041:"ja",1099:"kn",1087:"kk",1107:"km",1158:"quc",1159:"rw",1089:"sw",1111:"kok",1042:"ko",1088:"ky",1108:"lo",1062:"lv",1063:"lt",2094:"dsb",1134:"lb",1071:"mk",2110:"ms-BN",1086:"ms",1100:"ml",1082:"mt",1153:"mi",1146:"arn",1102:"mr",1148:"moh",1104:"mn",2128:"mn-CN",1121:"ne",1044:"nb",2068:"nn",1154:"oc",1096:"or",1123:"ps",1045:"pl",1046:"pt",2070:"pt-PT",1094:"pa",1131:"qu-BO",2155:"qu-EC",3179:"qu",1048:"ro",1047:"rm",1049:"ru",9275:"smn",4155:"smj-NO",5179:"smj",3131:"se-FI",1083:"se",2107:"se-SE",8251:"sms",6203:"sma-NO",7227:"sms",1103:"sa",7194:"sr-Cyrl-BA",3098:"sr",6170:"sr-Latn-BA",2074:"sr-Latn",1132:"nso",1074:"tn",1115:"si",1051:"sk",1060:"sl",11274:"es-AR",16394:"es-BO",13322:"es-CL",9226:"es-CO",5130:"es-CR",7178:"es-DO",12298:"es-EC",17418:"es-SV",4106:"es-GT",18442:"es-HN",2058:"es-MX",19466:"es-NI",6154:"es-PA",15370:"es-PY",10250:"es-PE",20490:"es-PR",3082:"es",1034:"es",21514:"es-US",14346:"es-UY",8202:"es-VE",2077:"sv-FI",1053:"sv",1114:"syr",1064:"tg",2143:"tzm",1097:"ta",1092:"tt",1098:"te",1054:"th",1105:"bo",1055:"tr",1090:"tk",1152:"ug",1058:"uk",1070:"hsb",1056:"ur",2115:"uz-Cyrl",1091:"uz",1066:"vi",1106:"cy",1160:"wo",1157:"sah",1144:"ii",1130:"yo"};function Ze(e,t,r){switch(e){case 0:if(65535===t)return "und";if(r)return r[t];break;case 1:return Xe[t];case 3:return Ye[t]}}var Qe="utf-16",Ke={0:"macintosh",1:"x-mac-japanese",2:"x-mac-chinesetrad",3:"x-mac-korean",6:"x-mac-greek",7:"x-mac-cyrillic",9:"x-mac-devanagai",10:"x-mac-gurmukhi",11:"x-mac-gujarati",12:"x-mac-oriya",13:"x-mac-bengali",14:"x-mac-tamil",15:"x-mac-telugu",16:"x-mac-kannada",17:"x-mac-malayalam",18:"x-mac-sinhalese",19:"x-mac-burmese",20:"x-mac-khmer",21:"x-mac-thai",22:"x-mac-lao",23:"x-mac-georgian",24:"x-mac-armenian",25:"x-mac-chinesesimp",26:"x-mac-tibetan",27:"x-mac-mongolian",28:"x-mac-ethiopic",29:"x-mac-ce",30:"x-mac-vietnamese",31:"x-mac-extarabic"},Je={15:"x-mac-icelandic",17:"x-mac-turkish",18:"x-mac-croatian",24:"x-mac-ce",25:"x-mac-ce",26:"x-mac-ce",27:"x-mac-ce",28:"x-mac-ce",30:"x-mac-icelandic",37:"x-mac-romanian",38:"x-mac-ce",39:"x-mac-ce",40:"x-mac-ce",143:"x-mac-inuit",146:"x-mac-gaelic"};function $e(e,t,r){switch(e){case 0:return Qe;case 1:return Je[r]||Ke[t];case 3:if(1===t||10===t)return Qe}}function et(e){var t={};for(var r in e)t[e[r]]=parseInt(r);return t}function tt(e,t,r,n,a,o){return new $.Record("NameRecord",[{name:"platformID",type:"USHORT",value:e},{name:"encodingID",type:"USHORT",value:t},{name:"languageID",type:"USHORT",value:r},{name:"nameID",type:"USHORT",value:n},{name:"length",type:"USHORT",value:a},{name:"offset",type:"USHORT",value:o}])}function rt(e,t){var r=function(e,t){var r=e.length,n=t.length-r+1;e:for(var a=0;a<n;a++)for(;a<n;a++){for(var o=0;o<r;o++)if(t[a+o]!==e[o])continue e;return a}return -1}(e,t);if(r<0){r=t.length;for(var n=0,a=e.length;n<a;++n)t.push(e[n]);}return r}var nt={parse:function(e,t,r){for(var n={},a=new se.Parser(e,t),o=a.parseUShort(),i=a.parseUShort(),s=a.offset+a.parseUShort(),l=0;l<i;l++){var p=a.parseUShort(),u=a.parseUShort(),c=a.parseUShort(),d=a.parseUShort(),h=We[d]||d,m=a.parseUShort(),f=a.parseUShort(),y=Ze(p,c,r),g=$e(p,u,c);if(void 0!==g&&void 0!==y){var v=void 0;if(v=g===Qe?P.UTF16(e,s+f,m):P.MACSTRING(e,s+f,m,g)){var b=n[h];void 0===b&&(b=n[h]={}),b[y]=v;}}}return 1===o&&a.parseUShort(),n},make:function(e,t){var r,n=[],a={},o=et(We);for(var i in e){var s=o[i];if(void 0===s&&(s=i),r=parseInt(s),isNaN(r))throw new Error('Name table entry "'+i+'" does not exist, see nameTableNames for complete list.');a[r]=e[i],n.push(r);}for(var l=et(Xe),p=et(Ye),u=[],c=[],d=0;d<n.length;d++){var h=a[r=n[d]];for(var m in h){var f=h[m],y=1,g=l[m],v=qe[g],b=$e(y,v,g),_=R.MACSTRING(f,b);void 0===_&&(y=0,(g=t.indexOf(m))<0&&(g=t.length,t.push(m)),v=4,_=R.UTF16(f));var x=rt(_,c);u.push(tt(y,v,g,r,_.length,x));var S=p[m];if(void 0!==S){var w=R.UTF16(f),M=rt(w,c);u.push(tt(3,1,S,r,w.length,M));}}}u.sort(function(e,t){return e.platformID-t.platformID||e.encodingID-t.encodingID||e.languageID-t.languageID||e.nameID-t.nameID});for(var E=new $.Table("name",[{name:"format",type:"USHORT",value:0},{name:"count",type:"USHORT",value:u.length},{name:"stringOffset",type:"USHORT",value:6+12*u.length}]),T=0;T<u.length;T++)E.fields.push({name:"record_"+T,type:"RECORD",value:u[T]});return E.fields.push({name:"strings",type:"LITERAL",value:c}),E}},at=[{begin:0,end:127},{begin:128,end:255},{begin:256,end:383},{begin:384,end:591},{begin:592,end:687},{begin:688,end:767},{begin:768,end:879},{begin:880,end:1023},{begin:11392,end:11519},{begin:1024,end:1279},{begin:1328,end:1423},{begin:1424,end:1535},{begin:42240,end:42559},{begin:1536,end:1791},{begin:1984,end:2047},{begin:2304,end:2431},{begin:2432,end:2559},{begin:2560,end:2687},{begin:2688,end:2815},{begin:2816,end:2943},{begin:2944,end:3071},{begin:3072,end:3199},{begin:3200,end:3327},{begin:3328,end:3455},{begin:3584,end:3711},{begin:3712,end:3839},{begin:4256,end:4351},{begin:6912,end:7039},{begin:4352,end:4607},{begin:7680,end:7935},{begin:7936,end:8191},{begin:8192,end:8303},{begin:8304,end:8351},{begin:8352,end:8399},{begin:8400,end:8447},{begin:8448,end:8527},{begin:8528,end:8591},{begin:8592,end:8703},{begin:8704,end:8959},{begin:8960,end:9215},{begin:9216,end:9279},{begin:9280,end:9311},{begin:9312,end:9471},{begin:9472,end:9599},{begin:9600,end:9631},{begin:9632,end:9727},{begin:9728,end:9983},{begin:9984,end:10175},{begin:12288,end:12351},{begin:12352,end:12447},{begin:12448,end:12543},{begin:12544,end:12591},{begin:12592,end:12687},{begin:43072,end:43135},{begin:12800,end:13055},{begin:13056,end:13311},{begin:44032,end:55215},{begin:55296,end:57343},{begin:67840,end:67871},{begin:19968,end:40959},{begin:57344,end:63743},{begin:12736,end:12783},{begin:64256,end:64335},{begin:64336,end:65023},{begin:65056,end:65071},{begin:65040,end:65055},{begin:65104,end:65135},{begin:65136,end:65279},{begin:65280,end:65519},{begin:65520,end:65535},{begin:3840,end:4095},{begin:1792,end:1871},{begin:1920,end:1983},{begin:3456,end:3583},{begin:4096,end:4255},{begin:4608,end:4991},{begin:5024,end:5119},{begin:5120,end:5759},{begin:5760,end:5791},{begin:5792,end:5887},{begin:6016,end:6143},{begin:6144,end:6319},{begin:10240,end:10495},{begin:40960,end:42127},{begin:5888,end:5919},{begin:66304,end:66351},{begin:66352,end:66383},{begin:66560,end:66639},{begin:118784,end:119039},{begin:119808,end:120831},{begin:1044480,end:1048573},{begin:65024,end:65039},{begin:917504,end:917631},{begin:6400,end:6479},{begin:6480,end:6527},{begin:6528,end:6623},{begin:6656,end:6687},{begin:11264,end:11359},{begin:11568,end:11647},{begin:19904,end:19967},{begin:43008,end:43055},{begin:65536,end:65663},{begin:65856,end:65935},{begin:66432,end:66463},{begin:66464,end:66527},{begin:66640,end:66687},{begin:66688,end:66735},{begin:67584,end:67647},{begin:68096,end:68191},{begin:119552,end:119647},{begin:73728,end:74751},{begin:119648,end:119679},{begin:7040,end:7103},{begin:7168,end:7247},{begin:7248,end:7295},{begin:43136,end:43231},{begin:43264,end:43311},{begin:43312,end:43359},{begin:43520,end:43615},{begin:65936,end:65999},{begin:66e3,end:66047},{begin:66208,end:66271},{begin:127024,end:127135}];var ot={parse:function(e,t){var r={},n=new se.Parser(e,t);r.version=n.parseUShort(),r.xAvgCharWidth=n.parseShort(),r.usWeightClass=n.parseUShort(),r.usWidthClass=n.parseUShort(),r.fsType=n.parseUShort(),r.ySubscriptXSize=n.parseShort(),r.ySubscriptYSize=n.parseShort(),r.ySubscriptXOffset=n.parseShort(),r.ySubscriptYOffset=n.parseShort(),r.ySuperscriptXSize=n.parseShort(),r.ySuperscriptYSize=n.parseShort(),r.ySuperscriptXOffset=n.parseShort(),r.ySuperscriptYOffset=n.parseShort(),r.yStrikeoutSize=n.parseShort(),r.yStrikeoutPosition=n.parseShort(),r.sFamilyClass=n.parseShort(),r.panose=[];for(var a=0;a<10;a++)r.panose[a]=n.parseByte();return r.ulUnicodeRange1=n.parseULong(),r.ulUnicodeRange2=n.parseULong(),r.ulUnicodeRange3=n.parseULong(),r.ulUnicodeRange4=n.parseULong(),r.achVendID=String.fromCharCode(n.parseByte(),n.parseByte(),n.parseByte(),n.parseByte()),r.fsSelection=n.parseUShort(),r.usFirstCharIndex=n.parseUShort(),r.usLastCharIndex=n.parseUShort(),r.sTypoAscender=n.parseShort(),r.sTypoDescender=n.parseShort(),r.sTypoLineGap=n.parseShort(),r.usWinAscent=n.parseUShort(),r.usWinDescent=n.parseUShort(),1<=r.version&&(r.ulCodePageRange1=n.parseULong(),r.ulCodePageRange2=n.parseULong()),2<=r.version&&(r.sxHeight=n.parseShort(),r.sCapHeight=n.parseShort(),r.usDefaultChar=n.parseUShort(),r.usBreakChar=n.parseUShort(),r.usMaxContent=n.parseUShort()),r},make:function(e){return new $.Table("OS/2",[{name:"version",type:"USHORT",value:3},{name:"xAvgCharWidth",type:"SHORT",value:0},{name:"usWeightClass",type:"USHORT",value:0},{name:"usWidthClass",type:"USHORT",value:0},{name:"fsType",type:"USHORT",value:0},{name:"ySubscriptXSize",type:"SHORT",value:650},{name:"ySubscriptYSize",type:"SHORT",value:699},{name:"ySubscriptXOffset",type:"SHORT",value:0},{name:"ySubscriptYOffset",type:"SHORT",value:140},{name:"ySuperscriptXSize",type:"SHORT",value:650},{name:"ySuperscriptYSize",type:"SHORT",value:699},{name:"ySuperscriptXOffset",type:"SHORT",value:0},{name:"ySuperscriptYOffset",type:"SHORT",value:479},{name:"yStrikeoutSize",type:"SHORT",value:49},{name:"yStrikeoutPosition",type:"SHORT",value:258},{name:"sFamilyClass",type:"SHORT",value:0},{name:"bFamilyType",type:"BYTE",value:0},{name:"bSerifStyle",type:"BYTE",value:0},{name:"bWeight",type:"BYTE",value:0},{name:"bProportion",type:"BYTE",value:0},{name:"bContrast",type:"BYTE",value:0},{name:"bStrokeVariation",type:"BYTE",value:0},{name:"bArmStyle",type:"BYTE",value:0},{name:"bLetterform",type:"BYTE",value:0},{name:"bMidline",type:"BYTE",value:0},{name:"bXHeight",type:"BYTE",value:0},{name:"ulUnicodeRange1",type:"ULONG",value:0},{name:"ulUnicodeRange2",type:"ULONG",value:0},{name:"ulUnicodeRange3",type:"ULONG",value:0},{name:"ulUnicodeRange4",type:"ULONG",value:0},{name:"achVendID",type:"CHARARRAY",value:"XXXX"},{name:"fsSelection",type:"USHORT",value:0},{name:"usFirstCharIndex",type:"USHORT",value:0},{name:"usLastCharIndex",type:"USHORT",value:0},{name:"sTypoAscender",type:"SHORT",value:0},{name:"sTypoDescender",type:"SHORT",value:0},{name:"sTypoLineGap",type:"SHORT",value:0},{name:"usWinAscent",type:"USHORT",value:0},{name:"usWinDescent",type:"USHORT",value:0},{name:"ulCodePageRange1",type:"ULONG",value:0},{name:"ulCodePageRange2",type:"ULONG",value:0},{name:"sxHeight",type:"SHORT",value:0},{name:"sCapHeight",type:"SHORT",value:0},{name:"usDefaultChar",type:"USHORT",value:0},{name:"usBreakChar",type:"USHORT",value:0},{name:"usMaxContext",type:"USHORT",value:0}],e)},unicodeRanges:at,getUnicodeRange:function(e){for(var t=0;t<at.length;t+=1){var r=at[t];if(e>=r.begin&&e<r.end)return t}return -1}};var it={parse:function(e,t){var r={},n=new se.Parser(e,t);switch(r.version=n.parseVersion(),r.italicAngle=n.parseFixed(),r.underlinePosition=n.parseShort(),r.underlineThickness=n.parseShort(),r.isFixedPitch=n.parseULong(),r.minMemType42=n.parseULong(),r.maxMemType42=n.parseULong(),r.minMemType1=n.parseULong(),r.maxMemType1=n.parseULong(),r.version){case 1:r.names=de.slice();break;case 2:r.numberOfGlyphs=n.parseUShort(),r.glyphNameIndex=new Array(r.numberOfGlyphs);for(var a=0;a<r.numberOfGlyphs;a++)r.glyphNameIndex[a]=n.parseUShort();r.names=[];for(var o=0;o<r.numberOfGlyphs;o++)if(r.glyphNameIndex[o]>=de.length){var i=n.parseChar();r.names.push(n.parseString(i));}break;case 2.5:r.numberOfGlyphs=n.parseUShort(),r.offset=new Array(r.numberOfGlyphs);for(var s=0;s<r.numberOfGlyphs;s++)r.offset[s]=n.parseChar();}return r},make:function(){return new $.Table("post",[{name:"version",type:"FIXED",value:196608},{name:"italicAngle",type:"FIXED",value:0},{name:"underlinePosition",type:"FWORD",value:0},{name:"underlineThickness",type:"FWORD",value:0},{name:"isFixedPitch",type:"ULONG",value:0},{name:"minMemType42",type:"ULONG",value:0},{name:"maxMemType42",type:"ULONG",value:0},{name:"minMemType1",type:"ULONG",value:0},{name:"maxMemType1",type:"ULONG",value:0}])}},st=new Array(9);st[1]=function(){var e=this.offset+this.relativeOffset,t=this.parseUShort();return 1===t?{substFormat:1,coverage:this.parsePointer(oe.coverage),deltaGlyphId:this.parseUShort()}:2===t?{substFormat:2,coverage:this.parsePointer(oe.coverage),substitute:this.parseOffset16List()}:void L.assert(!1,"0x"+e.toString(16)+": lookup type 1 format must be 1 or 2.")},st[2]=function(){var e=this.parseUShort();return L.argument(1===e,"GSUB Multiple Substitution Subtable identifier-format must be 1"),{substFormat:e,coverage:this.parsePointer(oe.coverage),sequences:this.parseListOfLists()}},st[3]=function(){var e=this.parseUShort();return L.argument(1===e,"GSUB Alternate Substitution Subtable identifier-format must be 1"),{substFormat:e,coverage:this.parsePointer(oe.coverage),alternateSets:this.parseListOfLists()}},st[4]=function(){var e=this.parseUShort();return L.argument(1===e,"GSUB ligature table identifier-format must be 1"),{substFormat:e,coverage:this.parsePointer(oe.coverage),ligatureSets:this.parseListOfLists(function(){return {ligGlyph:this.parseUShort(),components:this.parseUShortList(this.parseUShort()-1)}})}};var lt={sequenceIndex:oe.uShort,lookupListIndex:oe.uShort};st[5]=function(){var e=this.offset+this.relativeOffset,t=this.parseUShort();if(1===t)return {substFormat:t,coverage:this.parsePointer(oe.coverage),ruleSets:this.parseListOfLists(function(){var e=this.parseUShort(),t=this.parseUShort();return {input:this.parseUShortList(e-1),lookupRecords:this.parseRecordList(t,lt)}})};if(2===t)return {substFormat:t,coverage:this.parsePointer(oe.coverage),classDef:this.parsePointer(oe.classDef),classSets:this.parseListOfLists(function(){var e=this.parseUShort(),t=this.parseUShort();return {classes:this.parseUShortList(e-1),lookupRecords:this.parseRecordList(t,lt)}})};if(3===t){var r=this.parseUShort(),n=this.parseUShort();return {substFormat:t,coverages:this.parseList(r,oe.pointer(oe.coverage)),lookupRecords:this.parseRecordList(n,lt)}}L.assert(!1,"0x"+e.toString(16)+": lookup type 5 format must be 1, 2 or 3.");},st[6]=function(){var e=this.offset+this.relativeOffset,t=this.parseUShort();return 1===t?{substFormat:1,coverage:this.parsePointer(oe.coverage),chainRuleSets:this.parseListOfLists(function(){return {backtrack:this.parseUShortList(),input:this.parseUShortList(this.parseShort()-1),lookahead:this.parseUShortList(),lookupRecords:this.parseRecordList(lt)}})}:2===t?{substFormat:2,coverage:this.parsePointer(oe.coverage),backtrackClassDef:this.parsePointer(oe.classDef),inputClassDef:this.parsePointer(oe.classDef),lookaheadClassDef:this.parsePointer(oe.classDef),chainClassSet:this.parseListOfLists(function(){return {backtrack:this.parseUShortList(),input:this.parseUShortList(this.parseShort()-1),lookahead:this.parseUShortList(),lookupRecords:this.parseRecordList(lt)}})}:3===t?{substFormat:3,backtrackCoverage:this.parseList(oe.pointer(oe.coverage)),inputCoverage:this.parseList(oe.pointer(oe.coverage)),lookaheadCoverage:this.parseList(oe.pointer(oe.coverage)),lookupRecords:this.parseRecordList(lt)}:void L.assert(!1,"0x"+e.toString(16)+": lookup type 6 format must be 1, 2 or 3.")},st[7]=function(){var e=this.parseUShort();L.argument(1===e,"GSUB Extension Substitution subtable identifier-format must be 1");var t=this.parseUShort(),r=new oe(this.data,this.offset+this.parseULong());return {substFormat:1,lookupType:t,extension:st[t].call(r)}},st[8]=function(){var e=this.parseUShort();return L.argument(1===e,"GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"),{substFormat:e,coverage:this.parsePointer(oe.coverage),backtrackCoverage:this.parseList(oe.pointer(oe.coverage)),lookaheadCoverage:this.parseList(oe.pointer(oe.coverage)),substitutes:this.parseUShortList()}};var pt=new Array(9);pt[1]=function(e){return 1===e.substFormat?new $.Table("substitutionTable",[{name:"substFormat",type:"USHORT",value:1},{name:"coverage",type:"TABLE",value:new $.Coverage(e.coverage)},{name:"deltaGlyphID",type:"USHORT",value:e.deltaGlyphId}]):new $.Table("substitutionTable",[{name:"substFormat",type:"USHORT",value:2},{name:"coverage",type:"TABLE",value:new $.Coverage(e.coverage)}].concat($.ushortList("substitute",e.substitute)))},pt[3]=function(e){return L.assert(1===e.substFormat,"Lookup type 3 substFormat must be 1."),new $.Table("substitutionTable",[{name:"substFormat",type:"USHORT",value:1},{name:"coverage",type:"TABLE",value:new $.Coverage(e.coverage)}].concat($.tableList("altSet",e.alternateSets,function(e){return new $.Table("alternateSetTable",$.ushortList("alternate",e))})))},pt[4]=function(e){return L.assert(1===e.substFormat,"Lookup type 4 substFormat must be 1."),new $.Table("substitutionTable",[{name:"substFormat",type:"USHORT",value:1},{name:"coverage",type:"TABLE",value:new $.Coverage(e.coverage)}].concat($.tableList("ligSet",e.ligatureSets,function(e){return new $.Table("ligatureSetTable",$.tableList("ligature",e,function(e){return new $.Table("ligatureTable",[{name:"ligGlyph",type:"USHORT",value:e.ligGlyph}].concat($.ushortList("component",e.components,e.components.length+1)))}))})))};var ut={parse:function(e,t){var r=new oe(e,t=t||0),n=r.parseVersion(1);return L.argument(1===n||1.1===n,"Unsupported GSUB table version."),1===n?{version:n,scripts:r.parseScriptList(),features:r.parseFeatureList(),lookups:r.parseLookupList(st)}:{version:n,scripts:r.parseScriptList(),features:r.parseFeatureList(),lookups:r.parseLookupList(st),variations:r.parseFeatureVariationsList()}},make:function(e){return new $.Table("GSUB",[{name:"version",type:"ULONG",value:65536},{name:"scripts",type:"TABLE",value:new $.ScriptList(e.scripts)},{name:"features",type:"TABLE",value:new $.FeatureList(e.features)},{name:"lookups",type:"TABLE",value:new $.LookupList(e.lookups,pt)}])}};var ct={parse:function(e,t){var r=new se.Parser(e,t),n=r.parseULong();L.argument(1===n,"Unsupported META table version."),r.parseULong(),r.parseULong();for(var a=r.parseULong(),o={},i=0;i<a;i++){var s=r.parseTag(),l=r.parseULong(),p=r.parseULong(),u=P.UTF8(e,t+l,p);o[s]=u;}return o},make:function(e){var t=Object.keys(e).length,r="",n=16+12*t,a=new $.Table("meta",[{name:"version",type:"ULONG",value:1},{name:"flags",type:"ULONG",value:0},{name:"offset",type:"ULONG",value:n},{name:"numTags",type:"ULONG",value:t}]);for(var o in e){var i=r.length;r+=e[o],a.fields.push({name:"tag "+o,type:"TAG",value:o}),a.fields.push({name:"offset "+o,type:"ULONG",value:n+i}),a.fields.push({name:"length "+o,type:"ULONG",value:e[o].length});}return a.fields.push({name:"stringPool",type:"CHARARRAY",value:r}),a}};function dt(e){return Math.log(e)/Math.log(2)|0}function ht(e){for(;e.length%4!=0;)e.push(0);for(var t=0,r=0;r<e.length;r+=4)t+=(e[r]<<24)+(e[r+1]<<16)+(e[r+2]<<8)+e[r+3];return t%=Math.pow(2,32)}function mt(e,t,r,n){return new $.Record("Table Record",[{name:"tag",type:"TAG",value:void 0!==e?e:""},{name:"checkSum",type:"ULONG",value:void 0!==t?t:0},{name:"offset",type:"ULONG",value:void 0!==r?r:0},{name:"length",type:"ULONG",value:void 0!==n?n:0}])}function ft(e){var t=new $.Table("sfnt",[{name:"version",type:"TAG",value:"OTTO"},{name:"numTables",type:"USHORT",value:0},{name:"searchRange",type:"USHORT",value:0},{name:"entrySelector",type:"USHORT",value:0},{name:"rangeShift",type:"USHORT",value:0}]);t.tables=e,t.numTables=e.length;var r=Math.pow(2,dt(t.numTables));t.searchRange=16*r,t.entrySelector=dt(r),t.rangeShift=16*t.numTables-t.searchRange;for(var n=[],a=[],o=t.sizeOf()+mt().sizeOf()*t.numTables;o%4!=0;)o+=1,a.push({name:"padding",type:"BYTE",value:0});for(var i=0;i<e.length;i+=1){var s=e[i];L.argument(4===s.tableName.length,"Table name"+s.tableName+" is invalid.");var l=s.sizeOf(),p=mt(s.tableName,ht(s.encode()),o,l);for(n.push({name:p.tag+" Table Record",type:"RECORD",value:p}),a.push({name:s.tableName+" table",type:"RECORD",value:s}),o+=l,L.argument(!isNaN(o),"Something went wrong calculating the offset.");o%4!=0;)o+=1,a.push({name:"padding",type:"BYTE",value:0});}return n.sort(function(e,t){return e.value.tag>t.value.tag?1:-1}),t.fields=t.fields.concat(n),t.fields=t.fields.concat(a),t}function yt(e,t,r){for(var n=0;n<t.length;n+=1){var a=e.charToGlyphIndex(t[n]);if(0<a)return e.glyphs.get(a).getMetrics()}return r}var gt={make:ft,fontToTable:function(e){for(var t,r=[],n=[],a=[],o=[],i=[],s=[],l=[],p=0,u=0,c=0,d=0,h=0,m=0;m<e.glyphs.length;m+=1){var f=e.glyphs.get(m),y=0|f.unicode;if(isNaN(f.advanceWidth))throw new Error("Glyph "+f.name+" ("+m+"): advanceWidth is not a number.");(y<t||void 0===t)&&0<y&&(t=y),p<y&&(p=y);var g=ot.getUnicodeRange(y);if(g<32)u|=1<<g;else if(g<64)c|=1<<g-32;else if(g<96)d|=1<<g-64;else {if(!(g<123))throw new Error("Unicode ranges bits > 123 are reserved for internal usage");h|=1<<g-96;}if(".notdef"!==f.name){var v=f.getMetrics();r.push(v.xMin),n.push(v.yMin),a.push(v.xMax),o.push(v.yMax),s.push(v.leftSideBearing),l.push(v.rightSideBearing),i.push(f.advanceWidth);}}var b={xMin:Math.min.apply(null,r),yMin:Math.min.apply(null,n),xMax:Math.max.apply(null,a),yMax:Math.max.apply(null,o),advanceWidthMax:Math.max.apply(null,i),advanceWidthAvg:function(e){for(var t=0,r=0;r<e.length;r+=1)t+=e[r];return t/e.length}(i),minLeftSideBearing:Math.min.apply(null,s),maxLeftSideBearing:Math.max.apply(null,s),minRightSideBearing:Math.min.apply(null,l)};b.ascender=e.ascender,b.descender=e.descender;var _=Ge.make({flags:3,unitsPerEm:e.unitsPerEm,xMin:b.xMin,yMin:b.yMin,xMax:b.xMax,yMax:b.yMax,lowestRecPPEM:3,createdTimestamp:e.createdTimestamp}),x=je.make({ascender:b.ascender,descender:b.descender,advanceWidthMax:b.advanceWidthMax,minLeftSideBearing:b.minLeftSideBearing,minRightSideBearing:b.minRightSideBearing,xMaxExtent:b.maxLeftSideBearing+(b.xMax-b.xMin),numberOfHMetrics:e.glyphs.length}),S=He.make(e.glyphs.length),w=ot.make({xAvgCharWidth:Math.round(b.advanceWidthAvg),usWeightClass:e.tables.os2.usWeightClass,usWidthClass:e.tables.os2.usWidthClass,usFirstCharIndex:t,usLastCharIndex:p,ulUnicodeRange1:u,ulUnicodeRange2:c,ulUnicodeRange3:d,ulUnicodeRange4:h,fsSelection:e.tables.os2.fsSelection,sTypoAscender:b.ascender,sTypoDescender:b.descender,sTypoLineGap:0,usWinAscent:b.yMax,usWinDescent:Math.abs(b.yMin),ulCodePageRange1:1,sxHeight:yt(e,"xyvw",{yMax:Math.round(b.ascender/2)}).yMax,sCapHeight:yt(e,"HIKLEFJMNTZBDPRAGOQSUVWXY",b).yMax,usDefaultChar:e.hasChar(" ")?32:0,usBreakChar:e.hasChar(" ")?32:0}),M=Ve.make(e.glyphs),E=le.make(e.glyphs),T=e.getEnglishName("fontFamily"),C=e.getEnglishName("fontSubfamily"),N=T+" "+C,O=e.getEnglishName("postScriptName");O=O||T.replace(/\s/g,"")+"-"+C;var L={};for(var I in e.names)L[I]=e.names[I];L.uniqueID||(L.uniqueID={en:e.getEnglishName("manufacturer")+":"+N}),L.postScriptName||(L.postScriptName={en:O}),L.preferredFamily||(L.preferredFamily=e.names.fontFamily),L.preferredSubfamily||(L.preferredSubfamily=e.names.fontSubfamily);var P=[],R=nt.make(L,P),D=0<P.length?ze.make(P):void 0,A=it.make(),k=Be.make(e.glyphs,{version:e.getEnglishName("version"),fullName:N,familyName:T,weightName:C,postScriptName:O,unitsPerEm:e.unitsPerEm,fontBBox:[0,b.yMin,b.ascender,b.advanceWidthMax]}),F=e.metas&&0<Object.keys(e.metas).length?ct.make(e.metas):void 0,U=[_,x,S,w,R,E,A,k,M];D&&U.push(D),e.tables.gsub&&U.push(ut.make(e.tables.gsub)),F&&U.push(F);for(var B=ft(U),G=ht(B.encode()),j=B.fields,V=!1,z=0;z<j.length;z+=1)if("head table"===j[z].name){j[z].value.checkSumAdjustment=2981146554-G,V=!0;break}if(!V)throw new Error("Could not find head table with checkSum to adjust.");return B},computeCheckSum:ht};function vt(e,t){for(var r=0,n=e.length-1;r<=n;){var a=r+n>>>1,o=e[a].tag;if(o===t)return a;o<t?r=1+a:n=a-1;}return -r-1}function bt(e,t){for(var r=0,n=e.length-1;r<=n;){var a=r+n>>>1,o=e[a];if(o===t)return a;o<t?r=1+a:n=a-1;}return -r-1}function _t(e,t){for(var r,n=0,a=e.length-1;n<=a;){var o=n+a>>>1,i=(r=e[o]).start;if(i===t)return r;i<t?n=1+o:a=o-1;}if(0<n)return t>(r=e[n-1]).end?0:r}function xt(e,t){this.font=e,this.tableName=t;}function St(e){xt.call(this,e,"gpos");}function wt(e){xt.call(this,e,"gsub");}function Mt(e,t){var r=e.length;if(r!==t.length)return !1;for(var n=0;n<r;n++)if(e[n]!==t[n])return !1;return !0}function Et(e,t,r){for(var n=e.subtables,a=0;a<n.length;a++){var o=n[a];if(o.substFormat===t)return o}if(r)return n.push(r),r}function Tt(e){for(var t=new ArrayBuffer(e.length),r=new Uint8Array(t),n=0;n<e.length;++n)r[n]=e[n];return t}function Ct(e,t){if(!e)throw t}function Nt(e,t,r,n,a){var o;return o=0<(t&n)?(o=e.parseByte(),0==(t&a)&&(o=-o),r+o):0<(t&a)?r:r+e.parseShort()}function Ot(e,t,r){var n,a,o=new se.Parser(t,r);if(e.numberOfContours=o.parseShort(),e._xMin=o.parseShort(),e._yMin=o.parseShort(),e._xMax=o.parseShort(),e._yMax=o.parseShort(),0<e.numberOfContours){for(var i=e.endPointIndices=[],s=0;s<e.numberOfContours;s+=1)i.push(o.parseUShort());e.instructionLength=o.parseUShort(),e.instructions=[];for(var l=0;l<e.instructionLength;l+=1)e.instructions.push(o.parseByte());var p=i[i.length-1]+1;n=[];for(var u=0;u<p;u+=1)if(a=o.parseByte(),n.push(a),0<(8&a))for(var c=o.parseByte(),d=0;d<c;d+=1)n.push(a),u+=1;if(L.argument(n.length===p,"Bad flags."),0<i.length){var h,m=[];if(0<p){for(var f=0;f<p;f+=1)a=n[f],(h={}).onCurve=!!(1&a),h.lastPointOfContour=0<=i.indexOf(f),m.push(h);for(var y=0,g=0;g<p;g+=1)a=n[g],(h=m[g]).x=Nt(o,a,y,2,16),y=h.x;for(var v=0,b=0;b<p;b+=1)a=n[b],(h=m[b]).y=Nt(o,a,v,4,32),v=h.y;}e.points=m;}else e.points=[];}else if(0===e.numberOfContours)e.points=[];else {e.isComposite=!0,e.points=[],e.components=[];for(var _=!0;_;){n=o.parseUShort();var x={glyphIndex:o.parseUShort(),xScale:1,scale01:0,scale10:0,yScale:1,dx:0,dy:0};0<(1&n)?0<(2&n)?(x.dx=o.parseShort(),x.dy=o.parseShort()):x.matchedPoints=[o.parseUShort(),o.parseUShort()]:0<(2&n)?(x.dx=o.parseChar(),x.dy=o.parseChar()):x.matchedPoints=[o.parseByte(),o.parseByte()],0<(8&n)?x.xScale=x.yScale=o.parseF2Dot14():0<(64&n)?(x.xScale=o.parseF2Dot14(),x.yScale=o.parseF2Dot14()):0<(128&n)&&(x.xScale=o.parseF2Dot14(),x.scale01=o.parseF2Dot14(),x.scale10=o.parseF2Dot14(),x.yScale=o.parseF2Dot14()),e.components.push(x),_=!!(32&n);}if(256&n){e.instructionLength=o.parseUShort(),e.instructions=[];for(var S=0;S<e.instructionLength;S+=1)e.instructions.push(o.parseByte());}}}function Lt(e,t){for(var r=[],n=0;n<e.length;n+=1){var a=e[n],o={x:t.xScale*a.x+t.scale01*a.y+t.dx,y:t.scale10*a.x+t.yScale*a.y+t.dy,onCurve:a.onCurve,lastPointOfContour:a.lastPointOfContour};r.push(o);}return r}function It(e){var t=new A;if(!e)return t;for(var r=function(e){for(var t=[],r=[],n=0;n<e.length;n+=1){var a=e[n];r.push(a),a.lastPointOfContour&&(t.push(r),r=[]);}return L.argument(0===r.length,"There are still points left in the current contour."),t}(e),n=0;n<r.length;++n){var a=r[n],o=null,i=a[a.length-1],s=a[0];if(i.onCurve)t.moveTo(i.x,i.y);else if(s.onCurve)t.moveTo(s.x,s.y);else {var l={x:.5*(i.x+s.x),y:.5*(i.y+s.y)};t.moveTo(l.x,l.y);}for(var p=0;p<a.length;++p)if(o=i,i=s,s=a[(p+1)%a.length],i.onCurve)t.lineTo(i.x,i.y);else {var u=s;o.onCurve||{x:.5*(i.x+o.x),y:.5*(i.y+o.y)},s.onCurve||(u={x:.5*(i.x+s.x),y:.5*(i.y+s.y)}),t.quadraticCurveTo(i.x,i.y,u.x,u.y);}t.closePath();}return t}function Pt(e,t){if(t.isComposite)for(var r=0;r<t.components.length;r+=1){var n=t.components[r],a=e.get(n.glyphIndex);if(a.getPath(),a.points){var o=void 0;if(void 0===n.matchedPoints)o=Lt(a.points,n);else {if(n.matchedPoints[0]>t.points.length-1||n.matchedPoints[1]>a.points.length-1)throw Error("Matched points out of range in "+t.name);var i=t.points[n.matchedPoints[0]],s=a.points[n.matchedPoints[1]],l={xScale:n.xScale,scale01:n.scale01,scale10:n.scale10,yScale:n.yScale,dx:0,dy:0};s=Lt([s],l)[0],l.dx=i.x-s.x,l.dy=i.y-s.y,o=Lt(a.points,l);}t.points=t.points.concat(o);}}return It(t.points)}(St.prototype=xt.prototype={searchTag:vt,binSearch:bt,getTable:function(e){var t=this.font.tables[this.tableName];return !t&&e&&(t=this.font.tables[this.tableName]=this.createDefaultTable()),t},getScriptNames:function(){var e=this.getTable();return e?e.scripts.map(function(e){return e.tag}):[]},getDefaultScriptName:function(){var e=this.getTable();if(e){for(var t=!1,r=0;r<e.scripts.length;r++){var n=e.scripts[r].tag;if("DFLT"===n)return n;"latn"===n&&(t=!0);}return t?"latn":void 0}},getScriptTable:function(e,t){var r=this.getTable(t);if(r){e=e||"DFLT";var n=r.scripts,a=vt(r.scripts,e);if(0<=a)return n[a].script;if(t){var o={tag:e,script:{defaultLangSys:{reserved:0,reqFeatureIndex:65535,featureIndexes:[]},langSysRecords:[]}};return n.splice(-1-a,0,o),o.script}}},getLangSysTable:function(e,t,r){var n=this.getScriptTable(e,r);if(n){if(!t||"dflt"===t||"DFLT"===t)return n.defaultLangSys;var a=vt(n.langSysRecords,t);if(0<=a)return n.langSysRecords[a].langSys;if(r){var o={tag:t,langSys:{reserved:0,reqFeatureIndex:65535,featureIndexes:[]}};return n.langSysRecords.splice(-1-a,0,o),o.langSys}}},getFeatureTable:function(e,t,r,n){var a=this.getLangSysTable(e,t,n);if(a){for(var o,i=a.featureIndexes,s=this.font.tables[this.tableName].features,l=0;l<i.length;l++)if((o=s[i[l]]).tag===r)return o.feature;if(n){var p=s.length;return L.assert(0===p||r>=s[p-1].tag,"Features must be added in alphabetical order."),o={tag:r,feature:{params:0,lookupListIndexes:[]}},s.push(o),i.push(p),o.feature}}},getLookupTables:function(e,t,r,n,a){var o=this.getFeatureTable(e,t,r,a),i=[];if(o){for(var s,l=o.lookupListIndexes,p=this.font.tables[this.tableName].lookups,u=0;u<l.length;u++)(s=p[l[u]]).lookupType===n&&i.push(s);if(0===i.length&&a){s={lookupType:n,lookupFlag:0,subtables:[],markFilteringSet:void 0};var c=p.length;return p.push(s),l.push(c),[s]}}return i},getGlyphClass:function(e,t){switch(e.format){case 1:return e.startGlyph<=t&&t<e.startGlyph+e.classes.length?e.classes[t-e.startGlyph]:0;case 2:var r=_t(e.ranges,t);return r?r.classId:0}},getCoverageIndex:function(e,t){switch(e.format){case 1:var r=bt(e.glyphs,t);return 0<=r?r:-1;case 2:var n=_t(e.ranges,t);return n?n.index+t-n.start:-1}},expandCoverage:function(e){if(1===e.format)return e.glyphs;for(var t=[],r=e.ranges,n=0;n<r.length;n++)for(var a=r[n],o=a.start,i=a.end,s=o;s<=i;s++)t.push(s);return t}}).init=function(){var e=this.getDefaultScriptName();this.defaultKerningTables=this.getKerningTables(e);},St.prototype.getKerningValue=function(e,t,r){for(var n=0;n<e.length;n++)for(var a=e[n].subtables,o=0;o<a.length;o++){var i=a[o],s=this.getCoverageIndex(i.coverage,t);if(!(s<0))switch(i.posFormat){case 1:for(var l=i.pairSets[s],p=0;p<l.length;p++){var u=l[p];if(u.secondGlyph===r)return u.value1&&u.value1.xAdvance||0}break;case 2:var c=this.getGlyphClass(i.classDef1,t),d=this.getGlyphClass(i.classDef2,r),h=i.classRecords[c][d];return h.value1&&h.value1.xAdvance||0}}return 0},St.prototype.getKerningTables=function(e,t){if(this.font.tables.gpos)return this.getLookupTables(e,t,"kern",2)},(wt.prototype=xt.prototype).createDefaultTable=function(){return {version:1,scripts:[{tag:"DFLT",script:{defaultLangSys:{reserved:0,reqFeatureIndex:65535,featureIndexes:[]},langSysRecords:[]}}],features:[],lookups:[]}},wt.prototype.getSingle=function(e,t,r){for(var n=[],a=this.getLookupTables(t,r,e,1),o=0;o<a.length;o++)for(var i=a[o].subtables,s=0;s<i.length;s++){var l=i[s],p=this.expandCoverage(l.coverage),u=void 0;if(1===l.substFormat){var c=l.deltaGlyphId;for(u=0;u<p.length;u++){var d=p[u];n.push({sub:d,by:d+c});}}else {var h=l.substitute;for(u=0;u<p.length;u++)n.push({sub:p[u],by:h[u]});}}return n},wt.prototype.getAlternates=function(e,t,r){for(var n=[],a=this.getLookupTables(t,r,e,3),o=0;o<a.length;o++)for(var i=a[o].subtables,s=0;s<i.length;s++)for(var l=i[s],p=this.expandCoverage(l.coverage),u=l.alternateSets,c=0;c<p.length;c++)n.push({sub:p[c],by:u[c]});return n},wt.prototype.getLigatures=function(e,t,r){for(var n=[],a=this.getLookupTables(t,r,e,4),o=0;o<a.length;o++)for(var i=a[o].subtables,s=0;s<i.length;s++)for(var l=i[s],p=this.expandCoverage(l.coverage),u=l.ligatureSets,c=0;c<p.length;c++)for(var d=p[c],h=u[c],m=0;m<h.length;m++){var f=h[m];n.push({sub:[d].concat(f.components),by:f.ligGlyph});}return n},wt.prototype.addSingle=function(e,t,r,n){var a=Et(this.getLookupTables(r,n,e,1,!0)[0],2,{substFormat:2,coverage:{format:1,glyphs:[]},substitute:[]});L.assert(1===a.coverage.format,"Ligature: unable to modify coverage table format "+a.coverage.format);var o=t.sub,i=this.binSearch(a.coverage.glyphs,o);i<0&&(i=-1-i,a.coverage.glyphs.splice(i,0,o),a.substitute.splice(i,0,0)),a.substitute[i]=t.by;},wt.prototype.addAlternate=function(e,t,r,n){var a=Et(this.getLookupTables(r,n,e,3,!0)[0],1,{substFormat:1,coverage:{format:1,glyphs:[]},alternateSets:[]});L.assert(1===a.coverage.format,"Ligature: unable to modify coverage table format "+a.coverage.format);var o=t.sub,i=this.binSearch(a.coverage.glyphs,o);i<0&&(i=-1-i,a.coverage.glyphs.splice(i,0,o),a.alternateSets.splice(i,0,0)),a.alternateSets[i]=t.by;},wt.prototype.addLigature=function(e,t,r,n){var a=this.getLookupTables(r,n,e,4,!0)[0],o=a.subtables[0];o||(o={substFormat:1,coverage:{format:1,glyphs:[]},ligatureSets:[]},a.subtables[0]=o),L.assert(1===o.coverage.format,"Ligature: unable to modify coverage table format "+o.coverage.format);var i=t.sub[0],s=t.sub.slice(1),l={ligGlyph:t.by,components:s},p=this.binSearch(o.coverage.glyphs,i);if(0<=p){for(var u=o.ligatureSets[p],c=0;c<u.length;c++)if(Mt(u[c].components,s))return;u.push(l);}else p=-1-p,o.coverage.glyphs.splice(p,0,i),o.ligatureSets.splice(p,0,[l]);},wt.prototype.getFeature=function(e,t,r){if(/ss\d\d/.test(e))return this.getSingle(e,t,r);switch(e){case"aalt":case"salt":return this.getSingle(e,t,r).concat(this.getAlternates(e,t,r));case"dlig":case"liga":case"rlig":return this.getLigatures(e,t,r)}},wt.prototype.add=function(e,t,r,n){if(/ss\d\d/.test(e))return this.addSingle(e,t,r,n);switch(e){case"aalt":case"salt":return "number"==typeof t.by?this.addSingle(e,t,r,n):this.addAlternate(e,t,r,n);case"dlig":case"liga":case"rlig":return this.addLigature(e,t,r,n)}};var Rt,Dt,At,kt,Ft={getPath:It,parse:function(e,t,r,n){for(var a=new xe.GlyphSet(n),o=0;o<r.length-1;o+=1){var i=r[o];i!==r[o+1]?a.push(o,xe.ttfGlyphLoader(n,o,Ot,e,t+i,Pt)):a.push(o,xe.glyphLoader(n,o));}return a}};function Ut(e){this.font=e,this.getCommands=function(e){return Ft.getPath(e).commands},this._fpgmState=this._prepState=void 0,this._errorState=0;}function Bt(e){return e}function Gt(e){return Math.sign(e)*Math.round(Math.abs(e))}function jt(e){return Math.sign(e)*Math.round(Math.abs(2*e))/2}function Vt(e){return Math.sign(e)*(Math.round(Math.abs(e)+.5)-.5)}function zt(e){return Math.sign(e)*Math.ceil(Math.abs(e))}function Ht(e){return Math.sign(e)*Math.floor(Math.abs(e))}function Wt(e){var t=this.srPeriod,r=this.srPhase,n=1;return e<0&&(e=-e,n=-1),e+=this.srThreshold-r,e=Math.trunc(e/t)*t,(e+=r)<0?r*n:e*n}var Xt={x:1,y:0,axis:"x",distance:function(e,t,r,n){return (r?e.xo:e.x)-(n?t.xo:t.x)},interpolate:function(e,t,r,n){var a,o,i,s,l,p,u;if(!n||n===this)return a=e.xo-t.xo,o=e.xo-r.xo,l=t.x-t.xo,p=r.x-r.xo,0===(u=(i=Math.abs(a))+(s=Math.abs(o)))?void(e.x=e.xo+(l+p)/2):void(e.x=e.xo+(l*s+p*i)/u);a=n.distance(e,t,!0,!0),o=n.distance(e,r,!0,!0),l=n.distance(t,t,!1,!0),p=n.distance(r,r,!1,!0),0!==(u=(i=Math.abs(a))+(s=Math.abs(o)))?Xt.setRelative(e,e,(l*s+p*i)/u,n,!0):Xt.setRelative(e,e,(l+p)/2,n,!0);},normalSlope:Number.NEGATIVE_INFINITY,setRelative:function(e,t,r,n,a){if(n&&n!==this){var o=a?t.xo:t.x,i=a?t.yo:t.y,s=o+r*n.x,l=i+r*n.y;e.x=s+(e.y-l)/n.normalSlope;}else e.x=(a?t.xo:t.x)+r;},slope:0,touch:function(e){e.xTouched=!0;},touched:function(e){return e.xTouched},untouch:function(e){e.xTouched=!1;}},qt={x:0,y:1,axis:"y",distance:function(e,t,r,n){return (r?e.yo:e.y)-(n?t.yo:t.y)},interpolate:function(e,t,r,n){var a,o,i,s,l,p,u;if(!n||n===this)return a=e.yo-t.yo,o=e.yo-r.yo,l=t.y-t.yo,p=r.y-r.yo,0===(u=(i=Math.abs(a))+(s=Math.abs(o)))?void(e.y=e.yo+(l+p)/2):void(e.y=e.yo+(l*s+p*i)/u);a=n.distance(e,t,!0,!0),o=n.distance(e,r,!0,!0),l=n.distance(t,t,!1,!0),p=n.distance(r,r,!1,!0),0!==(u=(i=Math.abs(a))+(s=Math.abs(o)))?qt.setRelative(e,e,(l*s+p*i)/u,n,!0):qt.setRelative(e,e,(l+p)/2,n,!0);},normalSlope:0,setRelative:function(e,t,r,n,a){if(n&&n!==this){var o=a?t.xo:t.x,i=a?t.yo:t.y,s=o+r*n.x,l=i+r*n.y;e.y=l+n.normalSlope*(e.x-s);}else e.y=(a?t.yo:t.y)+r;},slope:Number.POSITIVE_INFINITY,touch:function(e){e.yTouched=!0;},touched:function(e){return e.yTouched},untouch:function(e){e.yTouched=!1;}};function Yt(e,t){this.x=e,this.y=t,this.axis=void 0,this.slope=t/e,this.normalSlope=-e/t,Object.freeze(this);}function Zt(e,t){var r=Math.sqrt(e*e+t*t);return t/=r,1===(e/=r)&&0===t?Xt:0===e&&1===t?qt:new Yt(e,t)}function Qt(e,t,r,n){this.x=this.xo=Math.round(64*e)/64,this.y=this.yo=Math.round(64*t)/64,this.lastPointOfContour=r,this.onCurve=n,this.prevPointOnContour=void 0,this.nextPointOnContour=void 0,this.xTouched=!1,this.yTouched=!1,Object.preventExtensions(this);}Object.freeze(Xt),Object.freeze(qt),Yt.prototype.distance=function(e,t,r,n){return this.x*Xt.distance(e,t,r,n)+this.y*qt.distance(e,t,r,n)},Yt.prototype.interpolate=function(e,t,r,n){var a,o,i,s,l,p,u;i=n.distance(e,t,!0,!0),s=n.distance(e,r,!0,!0),a=n.distance(t,t,!1,!0),o=n.distance(r,r,!1,!0),0!==(u=(l=Math.abs(i))+(p=Math.abs(s)))?this.setRelative(e,e,(a*p+o*l)/u,n,!0):this.setRelative(e,e,(a+o)/2,n,!0);},Yt.prototype.setRelative=function(e,t,r,n,a){n=n||this;var o=a?t.xo:t.x,i=a?t.yo:t.y,s=o+r*n.x,l=i+r*n.y,p=n.normalSlope,u=this.slope,c=e.x,d=e.y;e.x=(u*c-p*s+l-d)/(u-p),e.y=u*(e.x-c)+d;},Yt.prototype.touch=function(e){e.xTouched=!0,e.yTouched=!0;},Qt.prototype.nextTouched=function(e){for(var t=this.nextPointOnContour;!e.touched(t)&&t!==this;)t=t.nextPointOnContour;return t},Qt.prototype.prevTouched=function(e){for(var t=this.prevPointOnContour;!e.touched(t)&&t!==this;)t=t.prevPointOnContour;return t};var Kt=Object.freeze(new Qt(0,0)),Jt={cvCutIn:17/16,deltaBase:9,deltaShift:.125,loop:1,minDis:1,autoFlip:!0};function $t(e,t){switch(this.env=e,this.stack=[],this.prog=t,e){case"glyf":this.zp0=this.zp1=this.zp2=1,this.rp0=this.rp1=this.rp2=0;case"prep":this.fv=this.pv=this.dpv=Xt,this.round=Gt;}}function er(e){for(var t=e.tZone=new Array(e.gZone.length),r=0;r<t.length;r++)t[r]=new Qt(0,0);}function tr(e,t){var r,n=e.prog,a=e.ip,o=1;do{if(88===(r=n[++a]))o++;else if(89===r)o--;else if(64===r)a+=n[a+1]+1;else if(65===r)a+=2*n[a+1]+1;else if(176<=r&&r<=183)a+=r-176+1;else if(184<=r&&r<=191)a+=2*(r-184+1);else if(t&&1===o&&27===r)break}while(0<o);e.ip=a;}function rr(e,t){E.DEBUG&&console.log(t.step,"SVTCA["+e.axis+"]"),t.fv=t.pv=t.dpv=e;}function nr(e,t){E.DEBUG&&console.log(t.step,"SPVTCA["+e.axis+"]"),t.pv=t.dpv=e;}function ar(e,t){E.DEBUG&&console.log(t.step,"SFVTCA["+e.axis+"]"),t.fv=e;}function or(e,t){var r,n,a=t.stack,o=a.pop(),i=a.pop(),s=t.z2[o],l=t.z1[i];E.DEBUG&&console.log("SPVTL["+e+"]",o,i),n=e?(r=s.y-l.y,l.x-s.x):(r=l.x-s.x,l.y-s.y),t.pv=t.dpv=Zt(r,n);}function ir(e,t){var r,n,a=t.stack,o=a.pop(),i=a.pop(),s=t.z2[o],l=t.z1[i];E.DEBUG&&console.log("SFVTL["+e+"]",o,i),n=e?(r=s.y-l.y,l.x-s.x):(r=l.x-s.x,l.y-s.y),t.fv=Zt(r,n);}function sr(e){E.DEBUG&&console.log(e.step,"POP[]"),e.stack.pop();}function lr(e,t){var r=t.stack.pop(),n=t.z0[r],a=t.fv,o=t.pv;E.DEBUG&&console.log(t.step,"MDAP["+e+"]",r);var i=o.distance(n,Kt);e&&(i=t.round(i)),a.setRelative(n,Kt,i,o),a.touch(n),t.rp0=t.rp1=r;}function pr(e,t){var r,n,a,o=t.z2,i=o.length-2;E.DEBUG&&console.log(t.step,"IUP["+e.axis+"]");for(var s=0;s<i;s++)r=o[s],e.touched(r)||(n=r.prevTouched(e))!==r&&(n===(a=r.nextTouched(e))&&e.setRelative(r,r,e.distance(n,n,!1,!0),e,!0),e.interpolate(r,n,a,e));}function ur(e,t){for(var r=t.stack,n=e?t.rp1:t.rp2,a=(e?t.z0:t.z1)[n],o=t.fv,i=t.pv,s=t.loop,l=t.z2;s--;){var p=r.pop(),u=l[p],c=i.distance(a,a,!1,!0);o.setRelative(u,u,c,i),o.touch(u),E.DEBUG&&console.log(t.step,(1<t.loop?"loop "+(t.loop-s)+": ":"")+"SHP["+(e?"rp1":"rp2")+"]",p);}t.loop=1;}function cr(e,t){var r=t.stack,n=e?t.rp1:t.rp2,a=(e?t.z0:t.z1)[n],o=t.fv,i=t.pv,s=r.pop(),l=t.z2[t.contours[s]],p=l;E.DEBUG&&console.log(t.step,"SHC["+e+"]",s);for(var u=i.distance(a,a,!1,!0);p!==a&&o.setRelative(p,p,u,i),(p=p.nextPointOnContour)!==l;);}function dr(e,t){var r,n,a=t.stack,o=e?t.rp1:t.rp2,i=(e?t.z0:t.z1)[o],s=t.fv,l=t.pv,p=a.pop();switch(E.DEBUG&&console.log(t.step,"SHZ["+e+"]",p),p){case 0:r=t.tZone;break;case 1:r=t.gZone;break;default:throw new Error("Invalid zone")}for(var u=l.distance(i,i,!1,!0),c=r.length-2,d=0;d<c;d++)n=r[d],s.setRelative(n,n,u,l);}function hr(e,t){var r=t.stack,n=r.pop()/64,a=r.pop(),o=t.z1[a],i=t.z0[t.rp0],s=t.fv,l=t.pv;s.setRelative(o,i,n,l),s.touch(o),E.DEBUG&&console.log(t.step,"MSIRP["+e+"]",n,a),t.rp1=t.rp0,t.rp2=a,e&&(t.rp0=a);}function mr(e,t){var r=t.stack,n=r.pop(),a=r.pop(),o=t.z0[a],i=t.fv,s=t.pv,l=t.cvt[n];E.DEBUG&&console.log(t.step,"MIAP["+e+"]",n,"(",l,")",a);var p=s.distance(o,Kt);e&&(Math.abs(p-l)<t.cvCutIn&&(p=l),p=t.round(p)),i.setRelative(o,Kt,p,s),0===t.zp0&&(o.xo=o.x,o.yo=o.y),i.touch(o),t.rp0=t.rp1=a;}function fr(e,t){var r=t.stack,n=r.pop(),a=t.z2[n];E.DEBUG&&console.log(t.step,"GC["+e+"]",n),r.push(64*t.dpv.distance(a,Kt,e,!1));}function yr(e,t){var r=t.stack,n=r.pop(),a=r.pop(),o=t.z1[n],i=t.z0[a],s=t.dpv.distance(i,o,e,e);E.DEBUG&&console.log(t.step,"MD["+e+"]",n,a,"->",s),t.stack.push(Math.round(64*s));}function gr(e,t){var r=t.stack,n=r.pop(),a=t.fv,o=t.pv,i=t.ppem,s=t.deltaBase+16*(e-1),l=t.deltaShift,p=t.z0;E.DEBUG&&console.log(t.step,"DELTAP["+e+"]",n,r);for(var u=0;u<n;u++){var c=r.pop(),d=r.pop();if(s+((240&d)>>4)===i){var h=(15&d)-8;0<=h&&h++,E.DEBUG&&console.log(t.step,"DELTAPFIX",c,"by",h*l);var m=p[c];a.setRelative(m,m,h*l,o);}}}function vr(e,t){var r=t.stack,n=r.pop();E.DEBUG&&console.log(t.step,"ROUND[]"),r.push(64*t.round(n/64));}function br(e,t){var r=t.stack,n=r.pop(),a=t.ppem,o=t.deltaBase+16*(e-1),i=t.deltaShift;E.DEBUG&&console.log(t.step,"DELTAC["+e+"]",n,r);for(var s=0;s<n;s++){var l=r.pop(),p=r.pop();if(o+((240&p)>>4)===a){var u=(15&p)-8;0<=u&&u++;var c=u*i;E.DEBUG&&console.log(t.step,"DELTACFIX",l,"by",c),t.cvt[l]+=c;}}}function _r(e,t){var r,n,a=t.stack,o=a.pop(),i=a.pop(),s=t.z2[o],l=t.z1[i];E.DEBUG&&console.log(t.step,"SDPVTL["+e+"]",o,i),n=e?(r=s.y-l.y,l.x-s.x):(r=l.x-s.x,l.y-s.y),t.dpv=Zt(r,n);}function xr(e,t){var r=t.stack,n=t.prog,a=t.ip;E.DEBUG&&console.log(t.step,"PUSHB["+e+"]");for(var o=0;o<e;o++)r.push(n[++a]);t.ip=a;}function Sr(e,t){var r=t.ip,n=t.prog,a=t.stack;E.DEBUG&&console.log(t.ip,"PUSHW["+e+"]");for(var o=0;o<e;o++){var i=n[++r]<<8|n[++r];32768&i&&(i=-(1+(65535^i))),a.push(i);}t.ip=r;}function wr(e,t,r,n,a,o){var i,s,l,p,u=o.stack,c=e&&u.pop(),d=u.pop(),h=o.rp0,m=o.z0[h],f=o.z1[d],y=o.minDis,g=o.fv,v=o.dpv;l=0<=(s=i=v.distance(f,m,!0,!0))?1:-1,s=Math.abs(s),e&&(p=o.cvt[c],n&&Math.abs(s-p)<o.cvCutIn&&(s=p)),r&&s<y&&(s=y),n&&(s=o.round(s)),g.setRelative(f,m,l*s,v),g.touch(f),E.DEBUG&&console.log(o.step,(e?"MIRP[":"MDRP[")+(t?"M":"m")+(r?">":"_")+(n?"R":"_")+(0===a?"Gr":1===a?"Bl":2===a?"Wh":"")+"]",e?c+"("+o.cvt[c]+","+p+")":"",d,"(d =",i,"->",l*s,")"),o.rp1=o.rp0,o.rp2=d,t&&(o.rp0=d);}Ut.prototype.exec=function(e,t){if("number"!=typeof t)throw new Error("Point size is not a number!");if(!(2<this._errorState)){var r=this.font,n=this._prepState;if(!n||n.ppem!==t){var a=this._fpgmState;if(!a){$t.prototype=Jt,(a=this._fpgmState=new $t("fpgm",r.tables.fpgm)).funcs=[],a.font=r,E.DEBUG&&(console.log("---EXEC FPGM---"),a.step=-1);try{Dt(a);}catch(e){return console.log("Hinting error in FPGM:"+e),void(this._errorState=3)}}$t.prototype=a,(n=this._prepState=new $t("prep",r.tables.prep)).ppem=t;var o=r.tables.cvt;if(o)for(var i=n.cvt=new Array(o.length),s=t/r.unitsPerEm,l=0;l<o.length;l++)i[l]=o[l]*s;else n.cvt=[];E.DEBUG&&(console.log("---EXEC PREP---"),n.step=-1);try{Dt(n);}catch(e){this._errorState<2&&console.log("Hinting error in PREP:"+e),this._errorState=2;}}if(!(1<this._errorState))try{return At(e,n)}catch(e){return this._errorState<1&&(console.log("Hinting error:"+e),console.log("Note: further hinting errors are silenced")),void(this._errorState=1)}}},At=function(e,t){var r,n,a,o=t.ppem/t.font.unitsPerEm,i=o,s=e.components;if($t.prototype=t,s){var l=t.font;n=[],r=[];for(var p=0;p<s.length;p++){var u=s[p],c=l.glyphs.get(u.glyphIndex);a=new $t("glyf",c.instructions),E.DEBUG&&(console.log("---EXEC COMP "+p+"---"),a.step=-1),kt(c,a,o,i);for(var d=Math.round(u.dx*o),h=Math.round(u.dy*i),m=a.gZone,f=a.contours,y=0;y<m.length;y++){var g=m[y];g.xTouched=g.yTouched=!1,g.xo=g.x=g.x+d,g.yo=g.y=g.y+h;}var v=n.length;n.push.apply(n,m);for(var b=0;b<f.length;b++)r.push(f[b]+v);}e.instructions&&!a.inhibitGridFit&&((a=new $t("glyf",e.instructions)).gZone=a.z0=a.z1=a.z2=n,a.contours=r,n.push(new Qt(0,0),new Qt(Math.round(e.advanceWidth*o),0)),E.DEBUG&&(console.log("---EXEC COMPOSITE---"),a.step=-1),Dt(a),n.length-=2);}else a=new $t("glyf",e.instructions),E.DEBUG&&(console.log("---EXEC GLYPH---"),a.step=-1),kt(e,a,o,i),n=a.gZone;return n},kt=function(e,t,r,n){for(var a,o,i,s=e.points||[],l=s.length,p=t.gZone=t.z0=t.z1=t.z2=[],u=t.contours=[],c=0;c<l;c++)a=s[c],p[c]=new Qt(a.x*r,a.y*n,a.lastPointOfContour,a.onCurve);for(var d=0;d<l;d++)a=p[d],o||(o=a,u.push(d)),a.lastPointOfContour?((a.nextPointOnContour=o).prevPointOnContour=a,o=void 0):(i=p[d+1],(a.nextPointOnContour=i).prevPointOnContour=a);if(!t.inhibitGridFit){if(E.DEBUG){console.log("PROCESSING GLYPH",t.stack);for(var h=0;h<l;h++)console.log(h,p[h].x,p[h].y);}if(p.push(new Qt(0,0),new Qt(Math.round(e.advanceWidth*r),0)),Dt(t),p.length-=2,E.DEBUG){console.log("FINISHED GLYPH",t.stack);for(var m=0;m<l;m++)console.log(m,p[m].x,p[m].y);}}},Dt=function(e){var t=e.prog;if(t){var r,n=t.length;for(e.ip=0;e.ip<n;e.ip++){if(E.DEBUG&&e.step++,!(r=Rt[t[e.ip]]))throw new Error("unknown instruction: 0x"+Number(t[e.ip]).toString(16));r(e);}}},Rt=[rr.bind(void 0,qt),rr.bind(void 0,Xt),nr.bind(void 0,qt),nr.bind(void 0,Xt),ar.bind(void 0,qt),ar.bind(void 0,Xt),or.bind(void 0,0),or.bind(void 0,1),ir.bind(void 0,0),ir.bind(void 0,1),function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"SPVFS[]",r,n),e.pv=e.dpv=Zt(n,r);},function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"SPVFS[]",r,n),e.fv=Zt(n,r);},function(e){var t=e.stack,r=e.pv;E.DEBUG&&console.log(e.step,"GPV[]"),t.push(16384*r.x),t.push(16384*r.y);},function(e){var t=e.stack,r=e.fv;E.DEBUG&&console.log(e.step,"GFV[]"),t.push(16384*r.x),t.push(16384*r.y);},function(e){e.fv=e.pv,E.DEBUG&&console.log(e.step,"SFVTPV[]");},function(e){var t=e.stack,r=t.pop(),n=t.pop(),a=t.pop(),o=t.pop(),i=t.pop(),s=e.z0,l=e.z1,p=s[r],u=s[n],c=l[a],d=l[o],h=e.z2[i];E.DEBUG&&console.log("ISECT[], ",r,n,a,o,i);var m=p.x,f=p.y,y=u.x,g=u.y,v=c.x,b=c.y,_=d.x,x=d.y,S=(m-y)*(b-x)-(f-g)*(v-_),w=m*g-f*y,M=v*x-b*_;h.x=(w*(v-_)-M*(m-y))/S,h.y=(w*(b-x)-M*(f-g))/S;},function(e){e.rp0=e.stack.pop(),E.DEBUG&&console.log(e.step,"SRP0[]",e.rp0);},function(e){e.rp1=e.stack.pop(),E.DEBUG&&console.log(e.step,"SRP1[]",e.rp1);},function(e){e.rp2=e.stack.pop(),E.DEBUG&&console.log(e.step,"SRP2[]",e.rp2);},function(e){var t=e.stack.pop();switch(E.DEBUG&&console.log(e.step,"SZP0[]",t),e.zp0=t){case 0:e.tZone||er(e),e.z0=e.tZone;break;case 1:e.z0=e.gZone;break;default:throw new Error("Invalid zone pointer")}},function(e){var t=e.stack.pop();switch(E.DEBUG&&console.log(e.step,"SZP1[]",t),e.zp1=t){case 0:e.tZone||er(e),e.z1=e.tZone;break;case 1:e.z1=e.gZone;break;default:throw new Error("Invalid zone pointer")}},function(e){var t=e.stack.pop();switch(E.DEBUG&&console.log(e.step,"SZP2[]",t),e.zp2=t){case 0:e.tZone||er(e),e.z2=e.tZone;break;case 1:e.z2=e.gZone;break;default:throw new Error("Invalid zone pointer")}},function(e){var t=e.stack.pop();switch(E.DEBUG&&console.log(e.step,"SZPS[]",t),e.zp0=e.zp1=e.zp2=t,t){case 0:e.tZone||er(e),e.z0=e.z1=e.z2=e.tZone;break;case 1:e.z0=e.z1=e.z2=e.gZone;break;default:throw new Error("Invalid zone pointer")}},function(e){e.loop=e.stack.pop(),E.DEBUG&&console.log(e.step,"SLOOP[]",e.loop);},function(e){E.DEBUG&&console.log(e.step,"RTG[]"),e.round=Gt;},function(e){E.DEBUG&&console.log(e.step,"RTHG[]"),e.round=Vt;},function(e){var t=e.stack.pop();E.DEBUG&&console.log(e.step,"SMD[]",t),e.minDis=t/64;},function(e){E.DEBUG&&console.log(e.step,"ELSE[]"),tr(e,!1);},function(e){var t=e.stack.pop();E.DEBUG&&console.log(e.step,"JMPR[]",t),e.ip+=t-1;},function(e){var t=e.stack.pop();E.DEBUG&&console.log(e.step,"SCVTCI[]",t),e.cvCutIn=t/64;},void 0,void 0,function(e){var t=e.stack;E.DEBUG&&console.log(e.step,"DUP[]"),t.push(t[t.length-1]);},sr,function(e){E.DEBUG&&console.log(e.step,"CLEAR[]"),e.stack.length=0;},function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"SWAP[]"),t.push(r),t.push(n);},function(e){var t=e.stack;E.DEBUG&&console.log(e.step,"DEPTH[]"),t.push(t.length);},function(e){var t=e.stack,r=t.pop();E.DEBUG&&console.log(e.step,"CINDEX[]",r),t.push(t[t.length-r]);},function(e){var t=e.stack,r=t.pop();E.DEBUG&&console.log(e.step,"MINDEX[]",r),t.push(t.splice(t.length-r,1)[0]);},void 0,void 0,void 0,function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"LOOPCALL[]",r,n);var a=e.ip,o=e.prog;e.prog=e.funcs[r];for(var i=0;i<n;i++)Dt(e),E.DEBUG&&console.log(++e.step,i+1<n?"next loopcall":"done loopcall",i);e.ip=a,e.prog=o;},function(e){var t=e.stack.pop();E.DEBUG&&console.log(e.step,"CALL[]",t);var r=e.ip,n=e.prog;e.prog=e.funcs[t],Dt(e),e.ip=r,e.prog=n,E.DEBUG&&console.log(++e.step,"returning from",t);},function(e){if("fpgm"!==e.env)throw new Error("FDEF not allowed here");var t=e.stack,r=e.prog,n=e.ip,a=t.pop(),o=n;for(E.DEBUG&&console.log(e.step,"FDEF[]",a);45!==r[++n];);e.ip=n,e.funcs[a]=r.slice(o+1,n);},void 0,lr.bind(void 0,0),lr.bind(void 0,1),pr.bind(void 0,qt),pr.bind(void 0,Xt),ur.bind(void 0,0),ur.bind(void 0,1),cr.bind(void 0,0),cr.bind(void 0,1),dr.bind(void 0,0),dr.bind(void 0,1),function(e){for(var t=e.stack,r=e.loop,n=e.fv,a=t.pop()/64,o=e.z2;r--;){var i=t.pop(),s=o[i];E.DEBUG&&console.log(e.step,(1<e.loop?"loop "+(e.loop-r)+": ":"")+"SHPIX[]",i,a),n.setRelative(s,s,a),n.touch(s);}e.loop=1;},function(e){for(var t=e.stack,r=e.rp1,n=e.rp2,a=e.loop,o=e.z0[r],i=e.z1[n],s=e.fv,l=e.dpv,p=e.z2;a--;){var u=t.pop(),c=p[u];E.DEBUG&&console.log(e.step,(1<e.loop?"loop "+(e.loop-a)+": ":"")+"IP[]",u,r,"<->",n),s.interpolate(c,o,i,l),s.touch(c);}e.loop=1;},hr.bind(void 0,0),hr.bind(void 0,1),function(e){for(var t=e.stack,r=e.rp0,n=e.z0[r],a=e.loop,o=e.fv,i=e.pv,s=e.z1;a--;){var l=t.pop(),p=s[l];E.DEBUG&&console.log(e.step,(1<e.loop?"loop "+(e.loop-a)+": ":"")+"ALIGNRP[]",l),o.setRelative(p,n,0,i),o.touch(p);}e.loop=1;},function(e){E.DEBUG&&console.log(e.step,"RTDG[]"),e.round=jt;},mr.bind(void 0,0),mr.bind(void 0,1),function(e){var t=e.prog,r=e.ip,n=e.stack,a=t[++r];E.DEBUG&&console.log(e.step,"NPUSHB[]",a);for(var o=0;o<a;o++)n.push(t[++r]);e.ip=r;},function(e){var t=e.ip,r=e.prog,n=e.stack,a=r[++t];E.DEBUG&&console.log(e.step,"NPUSHW[]",a);for(var o=0;o<a;o++){var i=r[++t]<<8|r[++t];32768&i&&(i=-(1+(65535^i))),n.push(i);}e.ip=t;},function(e){var t=e.stack,r=e.store;r=r||(e.store=[]);var n=t.pop(),a=t.pop();E.DEBUG&&console.log(e.step,"WS",n,a),r[a]=n;},function(e){var t=e.stack,r=e.store,n=t.pop();E.DEBUG&&console.log(e.step,"RS",n);var a=r&&r[n]||0;t.push(a);},function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"WCVTP",r,n),e.cvt[n]=r/64;},function(e){var t=e.stack,r=t.pop();E.DEBUG&&console.log(e.step,"RCVT",r),t.push(64*e.cvt[r]);},fr.bind(void 0,0),fr.bind(void 0,1),void 0,yr.bind(void 0,0),yr.bind(void 0,1),function(e){E.DEBUG&&console.log(e.step,"MPPEM[]"),e.stack.push(e.ppem);},void 0,function(e){E.DEBUG&&console.log(e.step,"FLIPON[]"),e.autoFlip=!0;},void 0,void 0,function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"LT[]",r,n),t.push(n<r?1:0);},function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"LTEQ[]",r,n),t.push(n<=r?1:0);},function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"GT[]",r,n),t.push(r<n?1:0);},function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"GTEQ[]",r,n),t.push(r<=n?1:0);},function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"EQ[]",r,n),t.push(r===n?1:0);},function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"NEQ[]",r,n),t.push(r!==n?1:0);},function(e){var t=e.stack,r=t.pop();E.DEBUG&&console.log(e.step,"ODD[]",r),t.push(Math.trunc(r)%2?1:0);},function(e){var t=e.stack,r=t.pop();E.DEBUG&&console.log(e.step,"EVEN[]",r),t.push(Math.trunc(r)%2?0:1);},function(e){var t=e.stack.pop();E.DEBUG&&console.log(e.step,"IF[]",t),t||(tr(e,!0),E.DEBUG&&console.log(e.step,"EIF[]"));},function(e){E.DEBUG&&console.log(e.step,"EIF[]");},function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"AND[]",r,n),t.push(r&&n?1:0);},function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"OR[]",r,n),t.push(r||n?1:0);},function(e){var t=e.stack,r=t.pop();E.DEBUG&&console.log(e.step,"NOT[]",r),t.push(r?0:1);},gr.bind(void 0,1),function(e){var t=e.stack.pop();E.DEBUG&&console.log(e.step,"SDB[]",t),e.deltaBase=t;},function(e){var t=e.stack.pop();E.DEBUG&&console.log(e.step,"SDS[]",t),e.deltaShift=Math.pow(.5,t);},function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"ADD[]",r,n),t.push(n+r);},function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"SUB[]",r,n),t.push(n-r);},function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"DIV[]",r,n),t.push(64*n/r);},function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"MUL[]",r,n),t.push(n*r/64);},function(e){var t=e.stack,r=t.pop();E.DEBUG&&console.log(e.step,"ABS[]",r),t.push(Math.abs(r));},function(e){var t=e.stack,r=t.pop();E.DEBUG&&console.log(e.step,"NEG[]",r),t.push(-r);},function(e){var t=e.stack,r=t.pop();E.DEBUG&&console.log(e.step,"FLOOR[]",r),t.push(64*Math.floor(r/64));},function(e){var t=e.stack,r=t.pop();E.DEBUG&&console.log(e.step,"CEILING[]",r),t.push(64*Math.ceil(r/64));},vr.bind(void 0,0),vr.bind(void 0,1),vr.bind(void 0,2),vr.bind(void 0,3),void 0,void 0,void 0,void 0,function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"WCVTF[]",r,n),e.cvt[n]=r*e.ppem/e.font.unitsPerEm;},gr.bind(void 0,2),gr.bind(void 0,3),br.bind(void 0,1),br.bind(void 0,2),br.bind(void 0,3),function(e){var t,r=e.stack.pop();switch(E.DEBUG&&console.log(e.step,"SROUND[]",r),e.round=Wt,192&r){case 0:t=.5;break;case 64:t=1;break;case 128:t=2;break;default:throw new Error("invalid SROUND value")}switch(e.srPeriod=t,48&r){case 0:e.srPhase=0;break;case 16:e.srPhase=.25*t;break;case 32:e.srPhase=.5*t;break;case 48:e.srPhase=.75*t;break;default:throw new Error("invalid SROUND value")}r&=15,e.srThreshold=0===r?0:(r/8-.5)*t;},function(e){var t,r=e.stack.pop();switch(E.DEBUG&&console.log(e.step,"S45ROUND[]",r),e.round=Wt,192&r){case 0:t=Math.sqrt(2)/2;break;case 64:t=Math.sqrt(2);break;case 128:t=2*Math.sqrt(2);break;default:throw new Error("invalid S45ROUND value")}switch(e.srPeriod=t,48&r){case 0:e.srPhase=0;break;case 16:e.srPhase=.25*t;break;case 32:e.srPhase=.5*t;break;case 48:e.srPhase=.75*t;break;default:throw new Error("invalid S45ROUND value")}r&=15,e.srThreshold=0===r?0:(r/8-.5)*t;},void 0,void 0,function(e){E.DEBUG&&console.log(e.step,"ROFF[]"),e.round=Bt;},void 0,function(e){E.DEBUG&&console.log(e.step,"RUTG[]"),e.round=zt;},function(e){E.DEBUG&&console.log(e.step,"RDTG[]"),e.round=Ht;},sr,sr,void 0,void 0,void 0,void 0,void 0,function(e){var t=e.stack.pop();E.DEBUG&&console.log(e.step,"SCANCTRL[]",t);},_r.bind(void 0,0),_r.bind(void 0,1),function(e){var t=e.stack,r=t.pop(),n=0;E.DEBUG&&console.log(e.step,"GETINFO[]",r),1&r&&(n=35),32&r&&(n|=4096),t.push(n);},void 0,function(e){var t=e.stack,r=t.pop(),n=t.pop(),a=t.pop();E.DEBUG&&console.log(e.step,"ROLL[]"),t.push(n),t.push(r),t.push(a);},function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"MAX[]",r,n),t.push(Math.max(n,r));},function(e){var t=e.stack,r=t.pop(),n=t.pop();E.DEBUG&&console.log(e.step,"MIN[]",r,n),t.push(Math.min(n,r));},function(e){var t=e.stack.pop();E.DEBUG&&console.log(e.step,"SCANTYPE[]",t);},function(e){var t=e.stack.pop(),r=e.stack.pop();switch(E.DEBUG&&console.log(e.step,"INSTCTRL[]",t,r),t){case 1:return void(e.inhibitGridFit=!!r);case 2:return void(e.ignoreCvt=!!r);default:throw new Error("invalid INSTCTRL[] selector")}},void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,xr.bind(void 0,1),xr.bind(void 0,2),xr.bind(void 0,3),xr.bind(void 0,4),xr.bind(void 0,5),xr.bind(void 0,6),xr.bind(void 0,7),xr.bind(void 0,8),Sr.bind(void 0,1),Sr.bind(void 0,2),Sr.bind(void 0,3),Sr.bind(void 0,4),Sr.bind(void 0,5),Sr.bind(void 0,6),Sr.bind(void 0,7),Sr.bind(void 0,8),wr.bind(void 0,0,0,0,0,0),wr.bind(void 0,0,0,0,0,1),wr.bind(void 0,0,0,0,0,2),wr.bind(void 0,0,0,0,0,3),wr.bind(void 0,0,0,0,1,0),wr.bind(void 0,0,0,0,1,1),wr.bind(void 0,0,0,0,1,2),wr.bind(void 0,0,0,0,1,3),wr.bind(void 0,0,0,1,0,0),wr.bind(void 0,0,0,1,0,1),wr.bind(void 0,0,0,1,0,2),wr.bind(void 0,0,0,1,0,3),wr.bind(void 0,0,0,1,1,0),wr.bind(void 0,0,0,1,1,1),wr.bind(void 0,0,0,1,1,2),wr.bind(void 0,0,0,1,1,3),wr.bind(void 0,0,1,0,0,0),wr.bind(void 0,0,1,0,0,1),wr.bind(void 0,0,1,0,0,2),wr.bind(void 0,0,1,0,0,3),wr.bind(void 0,0,1,0,1,0),wr.bind(void 0,0,1,0,1,1),wr.bind(void 0,0,1,0,1,2),wr.bind(void 0,0,1,0,1,3),wr.bind(void 0,0,1,1,0,0),wr.bind(void 0,0,1,1,0,1),wr.bind(void 0,0,1,1,0,2),wr.bind(void 0,0,1,1,0,3),wr.bind(void 0,0,1,1,1,0),wr.bind(void 0,0,1,1,1,1),wr.bind(void 0,0,1,1,1,2),wr.bind(void 0,0,1,1,1,3),wr.bind(void 0,1,0,0,0,0),wr.bind(void 0,1,0,0,0,1),wr.bind(void 0,1,0,0,0,2),wr.bind(void 0,1,0,0,0,3),wr.bind(void 0,1,0,0,1,0),wr.bind(void 0,1,0,0,1,1),wr.bind(void 0,1,0,0,1,2),wr.bind(void 0,1,0,0,1,3),wr.bind(void 0,1,0,1,0,0),wr.bind(void 0,1,0,1,0,1),wr.bind(void 0,1,0,1,0,2),wr.bind(void 0,1,0,1,0,3),wr.bind(void 0,1,0,1,1,0),wr.bind(void 0,1,0,1,1,1),wr.bind(void 0,1,0,1,1,2),wr.bind(void 0,1,0,1,1,3),wr.bind(void 0,1,1,0,0,0),wr.bind(void 0,1,1,0,0,1),wr.bind(void 0,1,1,0,0,2),wr.bind(void 0,1,1,0,0,3),wr.bind(void 0,1,1,0,1,0),wr.bind(void 0,1,1,0,1,1),wr.bind(void 0,1,1,0,1,2),wr.bind(void 0,1,1,0,1,3),wr.bind(void 0,1,1,1,0,0),wr.bind(void 0,1,1,1,0,1),wr.bind(void 0,1,1,1,0,2),wr.bind(void 0,1,1,1,0,3),wr.bind(void 0,1,1,1,1,0),wr.bind(void 0,1,1,1,1,1),wr.bind(void 0,1,1,1,1,2),wr.bind(void 0,1,1,1,1,3)];var Mr=Array.from||function(e){return e.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]?|[^\uD800-\uDFFF]|./g)||[]};function Er(e){(e=e||{}).empty||(Ct(e.familyName,"When creating a new Font object, familyName is required."),Ct(e.styleName,"When creating a new Font object, styleName is required."),Ct(e.unitsPerEm,"When creating a new Font object, unitsPerEm is required."),Ct(e.ascender,"When creating a new Font object, ascender is required."),Ct(e.descender,"When creating a new Font object, descender is required."),Ct(e.descender<0,"Descender should be negative (e.g. -512)."),this.names={fontFamily:{en:e.familyName||" "},fontSubfamily:{en:e.styleName||" "},fullName:{en:e.fullName||e.familyName+" "+e.styleName},postScriptName:{en:e.postScriptName||(e.familyName+e.styleName).replace(/\s/g,"")},designer:{en:e.designer||" "},designerURL:{en:e.designerURL||" "},manufacturer:{en:e.manufacturer||" "},manufacturerURL:{en:e.manufacturerURL||" "},license:{en:e.license||" "},licenseURL:{en:e.licenseURL||" "},version:{en:e.version||"Version 0.1"},description:{en:e.description||" "},copyright:{en:e.copyright||" "},trademark:{en:e.trademark||" "}},this.unitsPerEm=e.unitsPerEm||1e3,this.ascender=e.ascender,this.descender=e.descender,this.createdTimestamp=e.createdTimestamp,this.tables={os2:{usWeightClass:e.weightClass||this.usWeightClasses.MEDIUM,usWidthClass:e.widthClass||this.usWidthClasses.MEDIUM,fsSelection:e.fsSelection||this.fsSelectionValues.REGULAR}}),this.supported=!0,this.glyphs=new xe.GlyphSet(this,e.glyphs||[]),this.encoding=new he(this),this.position=new St(this),this.substitution=new wt(this),this.tables=this.tables||{},Object.defineProperty(this,"hinting",{get:function(){return this._hinting?this._hinting:"truetype"===this.outlinesFormat?this._hinting=new Ut(this):void 0}});}function Tr(e,t){var r=JSON.stringify(e),n=256;for(var a in t){var o=parseInt(a);if(o&&!(o<256)){if(JSON.stringify(t[a])===r)return o;n<=o&&(n=o+1);}}return t[n]=e,n}function Cr(e,t,r,n){for(var a=[{name:"nameID_"+e,type:"USHORT",value:Tr(t.name,n)},{name:"flags_"+e,type:"USHORT",value:0}],o=0;o<r.length;++o){var i=r[o].tag;a.push({name:"axis_"+e+" "+i,type:"FIXED",value:t.coordinates[i]<<16});}return a}function Nr(e,t,r,n){var a={},o=new se.Parser(e,t);a.name=n[o.parseUShort()]||{},o.skip("uShort",1),a.coordinates={};for(var i=0;i<r.length;++i)a.coordinates[r[i].tag]=o.parseFixed();return a}Er.prototype.hasChar=function(e){return null!==this.encoding.charToGlyphIndex(e)},Er.prototype.charToGlyphIndex=function(e){return this.encoding.charToGlyphIndex(e)},Er.prototype.charToGlyph=function(e){var t=this.charToGlyphIndex(e),r=this.glyphs.get(t);return r=r||this.glyphs.get(0)},Er.prototype.stringToGlyphs=function(e,t){t=t||this.defaultRenderOptions;for(var r=Mr(e),n=[],a=0;a<r.length;a+=1){var o=r[a];n.push(this.charToGlyphIndex(o));}var i=n.length;if(t.features){var s=t.script||this.substitution.getDefaultScriptName(),l=[];t.features.liga&&(l=l.concat(this.substitution.getFeature("liga",s,t.language))),t.features.rlig&&(l=l.concat(this.substitution.getFeature("rlig",s,t.language)));for(var p=0;p<i;p+=1)for(var u=0;u<l.length;u++){for(var c=l[u],d=c.sub,h=d.length,m=0;m<h&&d[m]===n[p+m];)m++;m===h&&(n.splice(p,h,c.by),i=i-h+1);}}for(var f=new Array(i),y=this.glyphs.get(0),g=0;g<i;g+=1)f[g]=this.glyphs.get(n[g])||y;return f},Er.prototype.nameToGlyphIndex=function(e){return this.glyphNames.nameToGlyphIndex(e)},Er.prototype.nameToGlyph=function(e){var t=this.nameToGlyphIndex(e),r=this.glyphs.get(t);return r=r||this.glyphs.get(0)},Er.prototype.glyphIndexToName=function(e){return this.glyphNames.glyphIndexToName?this.glyphNames.glyphIndexToName(e):""},Er.prototype.getKerningValue=function(e,t){e=e.index||e,t=t.index||t;var r=this.position.defaultKerningTables;return r?this.position.getKerningValue(r,e,t):this.kerningPairs[e+","+t]||0},Er.prototype.defaultRenderOptions={kerning:!0,features:{liga:!0,rlig:!0}},Er.prototype.forEachGlyph=function(e,t,r,n,a,o){t=void 0!==t?t:0,r=void 0!==r?r:0,n=void 0!==n?n:72,a=a||this.defaultRenderOptions;var i,s=1/this.unitsPerEm*n,l=this.stringToGlyphs(e,a);if(a.kerning){var p=a.script||this.position.getDefaultScriptName();i=this.position.getKerningTables(p,a.language);}for(var u=0;u<l.length;u+=1){var c=l[u];if(o.call(this,c,t,r,n,a),c.advanceWidth&&(t+=c.advanceWidth*s),a.kerning&&u<l.length-1)t+=(i?this.position.getKerningValue(i,c.index,l[u+1].index):this.getKerningValue(c,l[u+1]))*s;a.letterSpacing?t+=a.letterSpacing*n:a.tracking&&(t+=a.tracking/1e3*n);}return t},Er.prototype.getPath=function(e,t,r,n,o){var i=new A;return this.forEachGlyph(e,t,r,n,o,function(e,t,r,n){var a=e.getPath(t,r,n,o,this);i.extend(a);}),i},Er.prototype.getPaths=function(e,t,r,n,o){var i=[];return this.forEachGlyph(e,t,r,n,o,function(e,t,r,n){var a=e.getPath(t,r,n,o,this);i.push(a);}),i},Er.prototype.getAdvanceWidth=function(e,t,r){return this.forEachGlyph(e,0,0,t,r,function(){})},Er.prototype.draw=function(e,t,r,n,a,o){this.getPath(t,r,n,a,o).draw(e);},Er.prototype.drawPoints=function(a,e,t,r,n,o){this.forEachGlyph(e,t,r,n,o,function(e,t,r,n){e.drawPoints(a,t,r,n);});},Er.prototype.drawMetrics=function(a,e,t,r,n,o){this.forEachGlyph(e,t,r,n,o,function(e,t,r,n){e.drawMetrics(a,t,r,n);});},Er.prototype.getEnglishName=function(e){var t=this.names[e];if(t)return t.en},Er.prototype.validate=function(){var r=this;function e(e){var t=r.getEnglishName(e);t&&t.trim().length;}e("fontFamily"),e("weightName"),e("manufacturer"),e("copyright"),e("version"),this.unitsPerEm;},Er.prototype.toTables=function(){return gt.fontToTable(this)},Er.prototype.toBuffer=function(){return console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."),this.toArrayBuffer()},Er.prototype.toArrayBuffer=function(){for(var e=this.toTables().encode(),t=new ArrayBuffer(e.length),r=new Uint8Array(t),n=0;n<e.length;n++)r[n]=e[n];return t},Er.prototype.download=function(t){var e=this.getEnglishName("fontFamily"),r=this.getEnglishName("fontSubfamily");t=t||e.replace(/\s/g,"")+"-"+r+".otf";var a=this.toArrayBuffer();if("undefined"!=typeof window)window.requestFileSystem=window.requestFileSystem||window.webkitRequestFileSystem,window.requestFileSystem(window.TEMPORARY,a.byteLength,function(e){e.root.getFile(t,{create:!0},function(n){n.createWriter(function(e){var t=new DataView(a),r=new Blob([t],{type:"font/opentype"});e.write(r),e.addEventListener("writeend",function(){location.href=n.toURL();},!1);});});},function(e){throw new Error(e.name+": "+e.message)});else {var n=jr("fs"),o=function(e){for(var t=new Gr(e.byteLength),r=new Uint8Array(e),n=0;n<t.length;++n)t[n]=r[n];return t}(a);n.writeFileSync(t,o);}},Er.prototype.fsSelectionValues={ITALIC:1,UNDERSCORE:2,NEGATIVE:4,OUTLINED:8,STRIKEOUT:16,BOLD:32,REGULAR:64,USER_TYPO_METRICS:128,WWS:256,OBLIQUE:512},Er.prototype.usWidthClasses={ULTRA_CONDENSED:1,EXTRA_CONDENSED:2,CONDENSED:3,SEMI_CONDENSED:4,MEDIUM:5,SEMI_EXPANDED:6,EXPANDED:7,EXTRA_EXPANDED:8,ULTRA_EXPANDED:9},Er.prototype.usWeightClasses={THIN:100,EXTRA_LIGHT:200,LIGHT:300,NORMAL:400,MEDIUM:500,SEMI_BOLD:600,BOLD:700,EXTRA_BOLD:800,BLACK:900};var Or={make:function(e,t){var r,n,a,o,i=new $.Table("fvar",[{name:"version",type:"ULONG",value:65536},{name:"offsetToData",type:"USHORT",value:0},{name:"countSizePairs",type:"USHORT",value:2},{name:"axisCount",type:"USHORT",value:e.axes.length},{name:"axisSize",type:"USHORT",value:20},{name:"instanceCount",type:"USHORT",value:e.instances.length},{name:"instanceSize",type:"USHORT",value:4+4*e.axes.length}]);i.offsetToData=i.sizeOf();for(var s=0;s<e.axes.length;s++)i.fields=i.fields.concat((r=s,n=e.axes[s],a=t,o=Tr(n.name,a),[{name:"tag_"+r,type:"TAG",value:n.tag},{name:"minValue_"+r,type:"FIXED",value:n.minValue<<16},{name:"defaultValue_"+r,type:"FIXED",value:n.defaultValue<<16},{name:"maxValue_"+r,type:"FIXED",value:n.maxValue<<16},{name:"flags_"+r,type:"USHORT",value:0},{name:"nameID_"+r,type:"USHORT",value:o}]));for(var l=0;l<e.instances.length;l++)i.fields=i.fields.concat(Cr(l,e.instances[l],e.axes,t));return i},parse:function(e,t,r){var n=new se.Parser(e,t),a=n.parseULong();L.argument(65536===a,"Unsupported fvar table version.");var o=n.parseOffset16();n.skip("uShort",1);for(var i,s,l,p,u,c=n.parseUShort(),d=n.parseUShort(),h=n.parseUShort(),m=n.parseUShort(),f=[],y=0;y<c;y++)f.push((i=e,s=t+o+y*d,l=r,u=p=void 0,p={},u=new se.Parser(i,s),p.tag=u.parseTag(),p.minValue=u.parseFixed(),p.defaultValue=u.parseFixed(),p.maxValue=u.parseFixed(),u.skip("uShort",1),p.name=l[u.parseUShort()]||{},p));for(var g=[],v=t+o+c*d,b=0;b<h;b++)g.push(Nr(e,v+b*m,f,r));return {axes:f,instances:g}}},Lr=new Array(10);Lr[1]=function(){var e=this.offset+this.relativeOffset,t=this.parseUShort();return 1===t?{posFormat:1,coverage:this.parsePointer(oe.coverage),value:this.parseValueRecord()}:2===t?{posFormat:2,coverage:this.parsePointer(oe.coverage),values:this.parseValueRecordList()}:void L.assert(!1,"0x"+e.toString(16)+": GPOS lookup type 1 format must be 1 or 2.")},Lr[2]=function(){var e=this.offset+this.relativeOffset,t=this.parseUShort();L.assert(1===t||2===t,"0x"+e.toString(16)+": GPOS lookup type 2 format must be 1 or 2.");var r=this.parsePointer(oe.coverage),n=this.parseUShort(),a=this.parseUShort();if(1===t)return {posFormat:t,coverage:r,valueFormat1:n,valueFormat2:a,pairSets:this.parseList(oe.pointer(oe.list(function(){return {secondGlyph:this.parseUShort(),value1:this.parseValueRecord(n),value2:this.parseValueRecord(a)}})))};if(2===t){var o=this.parsePointer(oe.classDef),i=this.parsePointer(oe.classDef),s=this.parseUShort(),l=this.parseUShort();return {posFormat:t,coverage:r,valueFormat1:n,valueFormat2:a,classDef1:o,classDef2:i,class1Count:s,class2Count:l,classRecords:this.parseList(s,oe.list(l,function(){return {value1:this.parseValueRecord(n),value2:this.parseValueRecord(a)}}))}}},Lr[3]=function(){return {error:"GPOS Lookup 3 not supported"}},Lr[4]=function(){return {error:"GPOS Lookup 4 not supported"}},Lr[5]=function(){return {error:"GPOS Lookup 5 not supported"}},Lr[6]=function(){return {error:"GPOS Lookup 6 not supported"}},Lr[7]=function(){return {error:"GPOS Lookup 7 not supported"}},Lr[8]=function(){return {error:"GPOS Lookup 8 not supported"}},Lr[9]=function(){return {error:"GPOS Lookup 9 not supported"}};var Ir=new Array(10);var Pr={parse:function(e,t){var r=new oe(e,t=t||0),n=r.parseVersion(1);return L.argument(1===n||1.1===n,"Unsupported GPOS table version "+n),1===n?{version:n,scripts:r.parseScriptList(),features:r.parseFeatureList(),lookups:r.parseLookupList(Lr)}:{version:n,scripts:r.parseScriptList(),features:r.parseFeatureList(),lookups:r.parseLookupList(Lr),variations:r.parseFeatureVariationsList()}},make:function(e){return new $.Table("GPOS",[{name:"version",type:"ULONG",value:65536},{name:"scripts",type:"TABLE",value:new $.ScriptList(e.scripts)},{name:"features",type:"TABLE",value:new $.FeatureList(e.features)},{name:"lookups",type:"TABLE",value:new $.LookupList(e.lookups,Ir)}])}};var Rr={parse:function(e,t){var r=new se.Parser(e,t),n=r.parseUShort();if(0===n)return function(e){var t={};e.skip("uShort");var r=e.parseUShort();L.argument(0===r,"Unsupported kern sub-table version."),e.skip("uShort",2);var n=e.parseUShort();e.skip("uShort",3);for(var a=0;a<n;a+=1){var o=e.parseUShort(),i=e.parseUShort(),s=e.parseShort();t[o+","+i]=s;}return t}(r);if(1===n)return function(e){var t={};e.skip("uShort"),1<e.parseULong()&&console.warn("Only the first kern subtable is supported."),e.skip("uLong");var r=255&e.parseUShort();if(e.skip("uShort"),0==r){var n=e.parseUShort();e.skip("uShort",3);for(var a=0;a<n;a+=1){var o=e.parseUShort(),i=e.parseUShort(),s=e.parseShort();t[o+","+i]=s;}}return t}(r);throw new Error("Unsupported kern table version ("+n+").")}};var Dr={parse:function(e,t,r,n){for(var a=new se.Parser(e,t),o=n?a.parseUShort:a.parseULong,i=[],s=0;s<r+1;s+=1){var l=o.call(a);n&&(l*=2),i.push(l);}return i}};function Ar(e,r){jr("fs").readFile(e,function(e,t){if(e)return r(e.message);r(null,Tt(t));});}function kr(e,t){var r=new XMLHttpRequest;r.open("get",e,!0),r.responseType="arraybuffer",r.onload=function(){return r.response?t(null,r.response):t("Font could not be loaded: "+r.statusText)},r.onerror=function(){t("Font could not be loaded");},r.send();}function Fr(e,t){for(var r=[],n=12,a=0;a<t;a+=1){var o=se.getTag(e,n),i=se.getULong(e,n+4),s=se.getULong(e,n+8),l=se.getULong(e,n+12);r.push({tag:o,checksum:i,offset:s,length:l,compression:!1}),n+=16;}return r}function Ur(e,t){if("WOFF"!==t.compression)return {data:e,offset:t.offset};var r=new Uint8Array(e.buffer,t.offset+2,t.compressedLength-2),n=new Uint8Array(t.length);if(a(r,n),n.byteLength!==t.length)throw new Error("Decompression error: "+t.tag+" decompressed length doesn't match recorded length");return {data:new DataView(n.buffer,0),offset:0}}function Br(e){var t,r,n,a,o,i,s,l,p,u,c,d,h,m,f=new Er({empty:!0}),y=new DataView(e,0),g=[],v=se.getTag(y,0);if(v===String.fromCharCode(0,1,0,0)||"true"===v||"typ1"===v)f.outlinesFormat="truetype",g=Fr(y,n=se.getUShort(y,4));else if("OTTO"===v)f.outlinesFormat="cff",g=Fr(y,n=se.getUShort(y,4));else {if("wOFF"!==v)throw new Error("Unsupported OpenType signature "+v);var b=se.getTag(y,4);if(b===String.fromCharCode(0,1,0,0))f.outlinesFormat="truetype";else {if("OTTO"!==b)throw new Error("Unsupported OpenType flavor "+v);f.outlinesFormat="cff";}g=function(e,t){for(var r=[],n=44,a=0;a<t;a+=1){var o=se.getTag(e,n),i=se.getULong(e,n+4),s=se.getULong(e,n+8),l=se.getULong(e,n+12),p=void 0;p=s<l&&"WOFF",r.push({tag:o,offset:i,compression:p,compressedLength:s,length:l}),n+=20;}return r}(y,n=se.getUShort(y,12));}for(var _=0;_<n;_+=1){var x=g[_],S=void 0;switch(x.tag){case"cmap":S=Ur(y,x),f.tables.cmap=le.parse(S.data,S.offset),f.encoding=new me(f.tables.cmap);break;case"cvt ":S=Ur(y,x),m=new se.Parser(S.data,S.offset),f.tables.cvt=m.parseShortList(x.length/2);break;case"fvar":o=x;break;case"fpgm":S=Ur(y,x),m=new se.Parser(S.data,S.offset),f.tables.fpgm=m.parseByteList(x.length);break;case"head":S=Ur(y,x),f.tables.head=Ge.parse(S.data,S.offset),f.unitsPerEm=f.tables.head.unitsPerEm,t=f.tables.head.indexToLocFormat;break;case"hhea":S=Ur(y,x),f.tables.hhea=je.parse(S.data,S.offset),f.ascender=f.tables.hhea.ascender,f.descender=f.tables.hhea.descender,f.numberOfHMetrics=f.tables.hhea.numberOfHMetrics;break;case"hmtx":p=x;break;case"ltag":S=Ur(y,x),r=ze.parse(S.data,S.offset);break;case"maxp":S=Ur(y,x),f.tables.maxp=He.parse(S.data,S.offset),f.numGlyphs=f.tables.maxp.numGlyphs;break;case"name":d=x;break;case"OS/2":S=Ur(y,x),f.tables.os2=ot.parse(S.data,S.offset);break;case"post":S=Ur(y,x),f.tables.post=it.parse(S.data,S.offset),f.glyphNames=new ye(f.tables.post);break;case"prep":S=Ur(y,x),m=new se.Parser(S.data,S.offset),f.tables.prep=m.parseByteList(x.length);break;case"glyf":i=x;break;case"loca":c=x;break;case"CFF ":a=x;break;case"kern":u=x;break;case"GPOS":s=x;break;case"GSUB":l=x;break;case"meta":h=x;}}var w=Ur(y,d);if(f.tables.name=nt.parse(w.data,w.offset,r),f.names=f.tables.name,i&&c){var M=0===t,E=Ur(y,c),T=Dr.parse(E.data,E.offset,f.numGlyphs,M),C=Ur(y,i);f.glyphs=Ft.parse(C.data,C.offset,T,f);}else {if(!a)throw new Error("Font doesn't contain TrueType or CFF outlines.");var N=Ur(y,a);Be.parse(N.data,N.offset,f);}var O=Ur(y,p);if(Ve.parse(O.data,O.offset,f.numberOfHMetrics,f.numGlyphs,f.glyphs),function(e){for(var t,r=e.tables.cmap.glyphIndexMap,n=Object.keys(r),a=0;a<n.length;a+=1){var o=n[a],i=r[o];(t=e.glyphs.get(i)).addUnicode(parseInt(o));}for(var s=0;s<e.glyphs.length;s+=1)t=e.glyphs.get(s),e.cffEncoding?e.isCIDFont?t.name="gid"+s:t.name=e.cffEncoding.charset[s]:e.glyphNames.names&&(t.name=e.glyphNames.glyphIndexToName(s));}(f),u){var L=Ur(y,u);f.kerningPairs=Rr.parse(L.data,L.offset);}else f.kerningPairs={};if(s){var I=Ur(y,s);f.tables.gpos=Pr.parse(I.data,I.offset),f.position.init();}if(l){var P=Ur(y,l);f.tables.gsub=ut.parse(P.data,P.offset);}if(o){var R=Ur(y,o);f.tables.fvar=Or.parse(R.data,R.offset,f.names);}if(h){var D=Ur(y,h);f.tables.meta=ct.parse(D.data,D.offset),f.metas=f.tables.meta;}return f}E.Font=Er,E.Glyph=ve,E.Path=A,E.BoundingBox=C,E._parse=se,E.parse=Br,E.load=function(e,n){("undefined"==typeof window?Ar:kr)(e,function(e,t){if(e)return n(e);var r;try{r=Br(t);}catch(e){return n(e,null)}return n(null,r)});},E.loadSync=function(e){return Br(Tt(jr("fs").readFileSync(e)))},Object.defineProperty(E,"__esModule",{value:!0});}("object"==typeof r&&void 0!==t?r:e.opentype={});}).call(this,jr("buffer").Buffer);},{buffer:5,fs:3}],14:[function(e,t,p){(function(a){function o(e,t){for(var r=0,n=e.length-1;0<=n;n--){var a=e[n];"."===a?e.splice(n,1):".."===a?(e.splice(n,1),r++):r&&(e.splice(n,1),r--);}if(t)for(;r--;)e.unshift("..");return e}function i(e,t){if(e.filter)return e.filter(t);for(var r=[],n=0;n<e.length;n++)t(e[n],n,e)&&r.push(e[n]);return r}p.resolve=function(){for(var e="",t=!1,r=arguments.length-1;-1<=r&&!t;r--){var n=0<=r?arguments[r]:a.cwd();if("string"!=typeof n)throw new TypeError("Arguments to path.resolve must be strings");n&&(e=n+"/"+e,t="/"===n.charAt(0));}return (t?"/":"")+(e=o(i(e.split("/"),function(e){return !!e}),!t).join("/"))||"."},p.normalize=function(e){var t=p.isAbsolute(e),r="/"===n(e,-1);return (e=o(i(e.split("/"),function(e){return !!e}),!t).join("/"))||t||(e="."),e&&r&&(e+="/"),(t?"/":"")+e},p.isAbsolute=function(e){return "/"===e.charAt(0)},p.join=function(){var e=Array.prototype.slice.call(arguments,0);return p.normalize(i(e,function(e,t){if("string"!=typeof e)throw new TypeError("Arguments to path.join must be strings");return e}).join("/"))},p.relative=function(e,t){function r(e){for(var t=0;t<e.length&&""===e[t];t++);for(var r=e.length-1;0<=r&&""===e[r];r--);return r<t?[]:e.slice(t,r-t+1)}e=p.resolve(e).substr(1),t=p.resolve(t).substr(1);for(var n=r(e.split("/")),a=r(t.split("/")),o=Math.min(n.length,a.length),i=o,s=0;s<o;s++)if(n[s]!==a[s]){i=s;break}var l=[];for(s=i;s<n.length;s++)l.push("..");return (l=l.concat(a.slice(i))).join("/")},p.sep="/",p.delimiter=":",p.dirname=function(e){if("string"!=typeof e&&(e+=""),0===e.length)return ".";for(var t=e.charCodeAt(0),r=47===t,n=-1,a=!0,o=e.length-1;1<=o;--o)if(47===(t=e.charCodeAt(o))){if(!a){n=o;break}}else a=!1;return -1===n?r?"/":".":r&&1===n?"/":e.slice(0,n)},p.basename=function(e,t){var r=function(e){"string"!=typeof e&&(e+="");var t,r=0,n=-1,a=!0;for(t=e.length-1;0<=t;--t)if(47===e.charCodeAt(t)){if(!a){r=t+1;break}}else -1===n&&(a=!1,n=t+1);return -1===n?"":e.slice(r,n)}(e);return t&&r.substr(-1*t.length)===t&&(r=r.substr(0,r.length-t.length)),r},p.extname=function(e){"string"!=typeof e&&(e+="");for(var t=-1,r=0,n=-1,a=!0,o=0,i=e.length-1;0<=i;--i){var s=e.charCodeAt(i);if(47===s){if(a)continue;r=i+1;break}-1===n&&(a=!1,n=i+1),46===s?-1===t?t=i:1!==o&&(o=1):-1!==t&&(o=-1);}return -1===t||-1===n||0===o||1===o&&t===n-1&&t===r+1?"":e.slice(t,n)};var n="b"==="ab".substr(-1)?function(e,t,r){return e.substr(t,r)}:function(e,t,r){return t<0&&(t=e.length+t),e.substr(t,r)};}).call(this,e("_process"));},{_process:15}],15:[function(e,t,r){var n,a,o=t.exports={};function i(){throw new Error("setTimeout has not been defined")}function s(){throw new Error("clearTimeout has not been defined")}function l(t){if(n===setTimeout)return setTimeout(t,0);if((n===i||!n)&&setTimeout)return n=setTimeout,setTimeout(t,0);try{return n(t,0)}catch(e){try{return n.call(null,t,0)}catch(e){return n.call(this,t,0)}}}!function(){try{n="function"==typeof setTimeout?setTimeout:i;}catch(e){n=i;}try{a="function"==typeof clearTimeout?clearTimeout:s;}catch(e){a=s;}}();var p,u=[],c=!1,d=-1;function h(){c&&p&&(c=!1,p.length?u=p.concat(u):d=-1,u.length&&m());}function m(){if(!c){var e=l(h);c=!0;for(var t=u.length;t;){for(p=u,u=[];++d<t;)p&&p[d].run();d=-1,t=u.length;}p=null,c=!1,function(t){if(a===clearTimeout)return clearTimeout(t);if((a===s||!a)&&clearTimeout)return a=clearTimeout,clearTimeout(t);try{a(t);}catch(e){try{return a.call(null,t)}catch(e){return a.call(this,t)}}}(e);}}function f(e,t){this.fun=e,this.array=t;}function y(){}o.nextTick=function(e){var t=new Array(arguments.length-1);if(1<arguments.length)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];u.push(new f(e,t)),1!==u.length||c||l(m);},f.prototype.run=function(){this.fun.apply(null,this.array);},o.title="browser",o.browser=!0,o.env={},o.argv=[],o.version="",o.versions={},o.on=y,o.addListener=y,o.once=y,o.off=y,o.removeListener=y,o.removeAllListeners=y,o.emit=y,o.prependListener=y,o.prependOnceListener=y,o.listeners=function(e){return []},o.binding=function(e){throw new Error("process.binding is not supported")},o.cwd=function(){return "/"},o.chdir=function(e){throw new Error("process.chdir is not supported")},o.umask=function(){return 0};},{}],16:[function(e,t,r){!function(e){if(!e.fetch){var t="URLSearchParams"in e,r="Symbol"in e&&"iterator"in Symbol,i="FileReader"in e&&"Blob"in e&&function(){try{return new Blob,!0}catch(e){return !1}}(),n="FormData"in e,a="ArrayBuffer"in e;if(a)var o=["[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]"],s=function(e){return e&&DataView.prototype.isPrototypeOf(e)},l=ArrayBuffer.isView||function(e){return e&&-1<o.indexOf(Object.prototype.toString.call(e))};m.prototype.append=function(e,t){e=c(e),t=d(t);var r=this.map[e];this.map[e]=r?r+","+t:t;},m.prototype.delete=function(e){delete this.map[c(e)];},m.prototype.get=function(e){return e=c(e),this.has(e)?this.map[e]:null},m.prototype.has=function(e){return this.map.hasOwnProperty(c(e))},m.prototype.set=function(e,t){this.map[c(e)]=d(t);},m.prototype.forEach=function(e,t){for(var r in this.map)this.map.hasOwnProperty(r)&&e.call(t,this.map[r],r,this);},m.prototype.keys=function(){var r=[];return this.forEach(function(e,t){r.push(t);}),h(r)},m.prototype.values=function(){var t=[];return this.forEach(function(e){t.push(e);}),h(t)},m.prototype.entries=function(){var r=[];return this.forEach(function(e,t){r.push([t,e]);}),h(r)},r&&(m.prototype[Symbol.iterator]=m.prototype.entries);var p=["DELETE","GET","HEAD","OPTIONS","POST","PUT"];_.prototype.clone=function(){return new _(this,{body:this._bodyInit})},b.call(_.prototype),b.call(S.prototype),S.prototype.clone=function(){return new S(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new m(this.headers),url:this.url})},S.error=function(){var e=new S(null,{status:0,statusText:""});return e.type="error",e};var u=[301,302,303,307,308];S.redirect=function(e,t){if(-1===u.indexOf(t))throw new RangeError("Invalid status code");return new S(null,{status:t,headers:{location:e}})},e.Headers=m,e.Request=_,e.Response=S,e.fetch=function(r,a){return new Promise(function(n,e){var t=new _(r,a),o=new XMLHttpRequest;o.onload=function(){var e,a,t={status:o.status,statusText:o.statusText,headers:(e=o.getAllResponseHeaders()||"",a=new m,e.replace(/\r?\n[\t ]+/g," ").split(/\r?\n/).forEach(function(e){var t=e.split(":"),r=t.shift().trim();if(r){var n=t.join(":").trim();a.append(r,n);}}),a)};t.url="responseURL"in o?o.responseURL:t.headers.get("X-Request-URL");var r="response"in o?o.response:o.responseText;n(new S(r,t));},o.onerror=function(){e(new TypeError("Network request failed"));},o.ontimeout=function(){e(new TypeError("Network request failed"));},o.open(t.method,t.url,!0),"include"===t.credentials?o.withCredentials=!0:"omit"===t.credentials&&(o.withCredentials=!1),"responseType"in o&&i&&(o.responseType="blob"),t.headers.forEach(function(e,t){o.setRequestHeader(t,e);}),o.send(void 0===t._bodyInit?null:t._bodyInit);})},e.fetch.polyfill=!0;}function c(e){if("string"!=typeof e&&(e=String(e)),/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(e))throw new TypeError("Invalid character in header field name");return e.toLowerCase()}function d(e){return "string"!=typeof e&&(e=String(e)),e}function h(t){var e={next:function(){var e=t.shift();return {done:void 0===e,value:e}}};return r&&(e[Symbol.iterator]=function(){return e}),e}function m(t){this.map={},t instanceof m?t.forEach(function(e,t){this.append(t,e);},this):Array.isArray(t)?t.forEach(function(e){this.append(e[0],e[1]);},this):t&&Object.getOwnPropertyNames(t).forEach(function(e){this.append(e,t[e]);},this);}function f(e){if(e.bodyUsed)return Promise.reject(new TypeError("Already read"));e.bodyUsed=!0;}function y(r){return new Promise(function(e,t){r.onload=function(){e(r.result);},r.onerror=function(){t(r.error);};})}function g(e){var t=new FileReader,r=y(t);return t.readAsArrayBuffer(e),r}function v(e){if(e.slice)return e.slice(0);var t=new Uint8Array(e.byteLength);return t.set(new Uint8Array(e)),t.buffer}function b(){return this.bodyUsed=!1,this._initBody=function(e){if(this._bodyInit=e)if("string"==typeof e)this._bodyText=e;else if(i&&Blob.prototype.isPrototypeOf(e))this._bodyBlob=e;else if(n&&FormData.prototype.isPrototypeOf(e))this._bodyFormData=e;else if(t&&URLSearchParams.prototype.isPrototypeOf(e))this._bodyText=e.toString();else if(a&&i&&s(e))this._bodyArrayBuffer=v(e.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer]);else {if(!a||!ArrayBuffer.prototype.isPrototypeOf(e)&&!l(e))throw new Error("unsupported BodyInit type");this._bodyArrayBuffer=v(e);}else this._bodyText="";this.headers.get("content-type")||("string"==typeof e?this.headers.set("content-type","text/plain;charset=UTF-8"):this._bodyBlob&&this._bodyBlob.type?this.headers.set("content-type",this._bodyBlob.type):t&&URLSearchParams.prototype.isPrototypeOf(e)&&this.headers.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"));},i&&(this.blob=function(){var e=f(this);if(e)return e;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error("could not read FormData body as blob");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?f(this)||Promise.resolve(this._bodyArrayBuffer):this.blob().then(g)}),this.text=function(){var e,t,r,n=f(this);if(n)return n;if(this._bodyBlob)return e=this._bodyBlob,t=new FileReader,r=y(t),t.readAsText(e),r;if(this._bodyArrayBuffer)return Promise.resolve(function(e){for(var t=new Uint8Array(e),r=new Array(t.length),n=0;n<t.length;n++)r[n]=String.fromCharCode(t[n]);return r.join("")}(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error("could not read FormData body as text");return Promise.resolve(this._bodyText)},n&&(this.formData=function(){return this.text().then(x)}),this.json=function(){return this.text().then(JSON.parse)},this}function _(e,t){var r,n,a=(t=t||{}).body;if(e instanceof _){if(e.bodyUsed)throw new TypeError("Already read");this.url=e.url,this.credentials=e.credentials,t.headers||(this.headers=new m(e.headers)),this.method=e.method,this.mode=e.mode,a||null==e._bodyInit||(a=e._bodyInit,e.bodyUsed=!0);}else this.url=String(e);if(this.credentials=t.credentials||this.credentials||"omit",!t.headers&&this.headers||(this.headers=new m(t.headers)),this.method=(r=t.method||this.method||"GET",n=r.toUpperCase(),-1<p.indexOf(n)?n:r),this.mode=t.mode||this.mode||null,this.referrer=null,("GET"===this.method||"HEAD"===this.method)&&a)throw new TypeError("Body not allowed for GET or HEAD requests");this._initBody(a);}function x(e){var a=new FormData;return e.trim().split("&").forEach(function(e){if(e){var t=e.split("="),r=t.shift().replace(/\+/g," "),n=t.join("=").replace(/\+/g," ");a.append(decodeURIComponent(r),decodeURIComponent(n));}}),a}function S(e,t){t=t||{},this.type="default",this.status=void 0===t.status?200:t.status,this.ok=200<=this.status&&this.status<300,this.statusText="statusText"in t?t.statusText:"OK",this.headers=new m(t.headers),this.url=t.url||"",this._initBody(e);}}("undefined"!=typeof self?self:this);},{}],17:[function(e,t,r){var n,a=(n=e("./core/main"))&&n.__esModule?n:{default:n};e("./core/constants"),e("./core/environment"),e("./core/friendly_errors/stacktrace"),e("./core/friendly_errors/validate_params"),e("./core/friendly_errors/file_errors"),e("./core/friendly_errors/fes_core"),e("./core/helpers"),e("./core/legacy"),e("./core/preload"),e("./core/p5.Element"),e("./core/p5.Graphics"),e("./core/p5.Renderer"),e("./core/p5.Renderer2D"),e("./core/rendering"),e("./core/shim"),e("./core/structure"),e("./core/transform"),e("./core/shape/2d_primitives"),e("./core/shape/attributes"),e("./core/shape/curves"),e("./core/shape/vertex"),e("./color/color_conversion"),e("./color/creating_reading"),e("./color/p5.Color"),e("./color/setting"),e("./data/p5.TypedDict"),e("./data/local_storage.js"),e("./dom/dom"),e("./events/acceleration"),e("./events/keyboard"),e("./events/mouse"),e("./events/touch"),e("./image/filters"),e("./image/image"),e("./image/loading_displaying"),e("./image/p5.Image"),e("./image/pixels"),e("./io/files"),e("./io/p5.Table"),e("./io/p5.TableRow"),e("./io/p5.XML"),e("./math/calculation"),e("./math/math"),e("./math/noise"),e("./math/p5.Vector"),e("./math/random"),e("./math/trigonometry"),e("./typography/attributes"),e("./typography/loading_displaying"),e("./typography/p5.Font"),e("./utilities/array_functions"),e("./utilities/conversion"),e("./utilities/string_functions"),e("./utilities/time_date"),e("./webgl/3d_primitives"),e("./webgl/interaction"),e("./webgl/light"),e("./webgl/loading"),e("./webgl/material"),e("./webgl/p5.Camera"),e("./webgl/p5.Geometry"),e("./webgl/p5.Matrix"),e("./webgl/p5.RendererGL.Immediate"),e("./webgl/p5.RendererGL"),e("./webgl/p5.RendererGL.Retained"),e("./webgl/p5.Shader"),e("./webgl/p5.RenderBuffer"),e("./webgl/p5.Texture"),e("./webgl/text"),e("./core/init"),t.exports=a.default;},{"./color/color_conversion":18,"./color/creating_reading":19,"./color/p5.Color":20,"./color/setting":21,"./core/constants":22,"./core/environment":23,"./core/friendly_errors/fes_core":24,"./core/friendly_errors/file_errors":25,"./core/friendly_errors/stacktrace":26,"./core/friendly_errors/validate_params":27,"./core/helpers":28,"./core/init":29,"./core/legacy":31,"./core/main":32,"./core/p5.Element":33,"./core/p5.Graphics":34,"./core/p5.Renderer":35,"./core/p5.Renderer2D":36,"./core/preload":37,"./core/rendering":38,"./core/shape/2d_primitives":39,"./core/shape/attributes":40,"./core/shape/curves":41,"./core/shape/vertex":42,"./core/shim":43,"./core/structure":44,"./core/transform":45,"./data/local_storage.js":46,"./data/p5.TypedDict":47,"./dom/dom":48,"./events/acceleration":49,"./events/keyboard":50,"./events/mouse":51,"./events/touch":52,"./image/filters":53,"./image/image":54,"./image/loading_displaying":55,"./image/p5.Image":56,"./image/pixels":57,"./io/files":58,"./io/p5.Table":59,"./io/p5.TableRow":60,"./io/p5.XML":61,"./math/calculation":62,"./math/math":63,"./math/noise":64,"./math/p5.Vector":65,"./math/random":66,"./math/trigonometry":67,"./typography/attributes":68,"./typography/loading_displaying":69,"./typography/p5.Font":70,"./utilities/array_functions":71,"./utilities/conversion":72,"./utilities/string_functions":73,"./utilities/time_date":74,"./webgl/3d_primitives":75,"./webgl/interaction":76,"./webgl/light":77,"./webgl/loading":78,"./webgl/material":79,"./webgl/p5.Camera":80,"./webgl/p5.Geometry":81,"./webgl/p5.Matrix":82,"./webgl/p5.RenderBuffer":83,"./webgl/p5.RendererGL":86,"./webgl/p5.RendererGL.Immediate":84,"./webgl/p5.RendererGL.Retained":85,"./webgl/p5.Shader":87,"./webgl/p5.Texture":88,"./webgl/text":89}],18:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};a.default.ColorConversion={},a.default.ColorConversion._hsbaToHSLA=function(e){var t=e[0],r=e[1],n=e[2],a=(2-r)*n/2;return 0!=a&&(1==a?r=0:a<.5?r/=2-r:r=r*n/(2-2*a)),[t,r,a,e[3]]},a.default.ColorConversion._hsbaToRGBA=function(e){var t=6*e[0],r=e[1],n=e[2],a=[];if(0===r)a=[n,n,n,e[3]];else {var o,i,s,l=Math.floor(t),p=n*(1-r),u=n*(1-r*(t-l)),c=n*(1-r*(1+l-t));s=1===l?(o=u,i=n,p):2===l?(o=p,i=n,c):3===l?(o=p,i=u,n):4===l?(o=c,i=p,n):5===l?(o=n,i=p,u):(o=n,i=c,p),a=[o,i,s,e[3]];}return a},a.default.ColorConversion._hslaToHSBA=function(e){var t,r=e[0],n=e[1],a=e[2];return [r,n=2*((t=a<.5?(1+n)*a:a+n-a*n)-a)/t,t,e[3]]},a.default.ColorConversion._hslaToRGBA=function(e){var t=6*e[0],r=e[1],n=e[2],a=[];if(0===r)a=[n,n,n,e[3]];else {var o,i=2*n-(o=n<.5?(1+r)*n:n+r-n*r),s=function(e,t,r){return e<0?e+=6:6<=e&&(e-=6),e<1?t+(r-t)*e:e<3?r:e<4?t+(r-t)*(4-e):t};a=[s(2+t,i,o),s(t,i,o),s(t-2,i,o),e[3]];}return a},a.default.ColorConversion._rgbaToHSBA=function(e){var t,r,n=e[0],a=e[1],o=e[2],i=Math.max(n,a,o),s=i-Math.min(n,a,o);return 0==s?r=t=0:(r=s/i,n===i?t=(a-o)/s:a===i?t=2+(o-n)/s:o===i&&(t=4+(n-a)/s),t<0?t+=6:6<=t&&(t-=6)),[t/6,r,i,e[3]]},a.default.ColorConversion._rgbaToHSLA=function(e){var t,r,n=e[0],a=e[1],o=e[2],i=Math.max(n,a,o),s=Math.min(n,a,o),l=i+s,p=i-s;return 0==p?r=t=0:(r=l<1?p/l:p/(2-l),n===i?t=(a-o)/p:a===i?t=2+(o-n)/p:o===i&&(t=4+(n-a)/p),t<0?t+=6:6<=t&&(t-=6)),[t/6,r,l/2,e[3]]};var o=a.default.ColorConversion;r.default=o;},{"../core/main":32}],19:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,c=(n=e("../core/main"))&&n.__esModule?n:{default:n},d=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}e("./p5.Color"),e("../core/friendly_errors/validate_params"),e("../core/friendly_errors/file_errors"),e("../core/friendly_errors/fes_core"),c.default.prototype.alpha=function(e){return c.default._validateParameters("alpha",arguments),this.color(e)._getAlpha()},c.default.prototype.blue=function(e){return c.default._validateParameters("blue",arguments),this.color(e)._getBlue()},c.default.prototype.brightness=function(e){return c.default._validateParameters("brightness",arguments),this.color(e)._getBrightness()},c.default.prototype.color=function(){if(c.default._validateParameters("color",arguments),arguments[0]instanceof c.default.Color)return arguments[0];var e=arguments[0]instanceof Array?arguments[0]:arguments;return new c.default.Color(this,e)},c.default.prototype.green=function(e){return c.default._validateParameters("green",arguments),this.color(e)._getGreen()},c.default.prototype.hue=function(e){return c.default._validateParameters("hue",arguments),this.color(e)._getHue()},c.default.prototype.lerpColor=function(e,t,r){c.default._validateParameters("lerpColor",arguments);var n,a,o,i,s,l,p=this._colorMode,u=this._colorMaxes;if(p===d.RGB)s=e.levels.map(function(e){return e/255}),l=t.levels.map(function(e){return e/255});else if(p===d.HSB)e._getBrightness(),t._getBrightness(),s=e.hsba,l=t.hsba;else {if(p!==d.HSL)throw new Error("".concat(p,"cannot be used for interpolation."));e._getLightness(),t._getLightness(),s=e.hsla,l=t.hsla;}return r=Math.max(Math.min(r,1),0),void 0===this.lerp&&(this.lerp=function(e,t,r){return r*(t-e)+e}),n=this.lerp(s[0],l[0],r),a=this.lerp(s[1],l[1],r),o=this.lerp(s[2],l[2],r),i=this.lerp(s[3],l[3],r),n*=u[p][0],a*=u[p][1],o*=u[p][2],i*=u[p][3],this.color(n,a,o,i)},c.default.prototype.lightness=function(e){return c.default._validateParameters("lightness",arguments),this.color(e)._getLightness()},c.default.prototype.red=function(e){return c.default._validateParameters("red",arguments),this.color(e)._getRed()},c.default.prototype.saturation=function(e){return c.default._validateParameters("saturation",arguments),this.color(e)._getSaturation()};var a=c.default;r.default=a;},{"../core/constants":22,"../core/friendly_errors/fes_core":24,"../core/friendly_errors/file_errors":25,"../core/friendly_errors/validate_params":27,"../core/main":32,"./p5.Color":20}],20:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var c=n(e("../core/main")),d=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants")),h=n(e("./color_conversion"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}function n(e){return e&&e.__esModule?e:{default:e}}c.default.Color=function(e,t){if(this._storeModeAndMaxes(e._colorMode,e._colorMaxes),this.mode!==d.RGB&&this.mode!==d.HSL&&this.mode!==d.HSB)throw new Error("".concat(this.mode," is an invalid colorMode."));return this._array=c.default.Color._parseInputs.apply(this,t),this._calculateLevels(),this},c.default.Color.prototype.toString=function(e){var t=this.levels,r=this._array,n=r[3];switch(e){case"#rrggbb":return "#".concat(t[0]<16?"0".concat(t[0].toString(16)):t[0].toString(16),t[1]<16?"0".concat(t[1].toString(16)):t[1].toString(16),t[2]<16?"0".concat(t[2].toString(16)):t[2].toString(16));case"#rrggbbaa":return "#".concat(t[0]<16?"0".concat(t[0].toString(16)):t[0].toString(16),t[1]<16?"0".concat(t[1].toString(16)):t[1].toString(16),t[2]<16?"0".concat(t[2].toString(16)):t[2].toString(16),t[3]<16?"0".concat(t[2].toString(16)):t[3].toString(16));case"#rgb":return "#".concat(Math.round(15*r[0]).toString(16),Math.round(15*r[1]).toString(16),Math.round(15*r[2]).toString(16));case"#rgba":return "#".concat(Math.round(15*r[0]).toString(16),Math.round(15*r[1]).toString(16),Math.round(15*r[2]).toString(16),Math.round(15*r[3]).toString(16));case"rgb":return "rgb(".concat(t[0],", ",t[1],", ",t[2],")");case"rgb%":return "rgb(".concat((100*r[0]).toPrecision(3),"%, ",(100*r[1]).toPrecision(3),"%, ",(100*r[2]).toPrecision(3),"%)");case"rgba%":return "rgba(".concat((100*r[0]).toPrecision(3),"%, ",(100*r[1]).toPrecision(3),"%, ",(100*r[2]).toPrecision(3),"%, ",(100*r[3]).toPrecision(3),"%)");case"hsb":case"hsv":return this.hsba||(this.hsba=h.default._rgbaToHSBA(this._array)),"hsb(".concat(this.hsba[0]*this.maxes[d.HSB][0],", ",this.hsba[1]*this.maxes[d.HSB][1],", ",this.hsba[2]*this.maxes[d.HSB][2],")");case"hsb%":case"hsv%":return this.hsba||(this.hsba=h.default._rgbaToHSBA(this._array)),"hsb(".concat((100*this.hsba[0]).toPrecision(3),"%, ",(100*this.hsba[1]).toPrecision(3),"%, ",(100*this.hsba[2]).toPrecision(3),"%)");case"hsba":case"hsva":return this.hsba||(this.hsba=h.default._rgbaToHSBA(this._array)),"hsba(".concat(this.hsba[0]*this.maxes[d.HSB][0],", ",this.hsba[1]*this.maxes[d.HSB][1],", ",this.hsba[2]*this.maxes[d.HSB][2],", ",n,")");case"hsba%":case"hsva%":return this.hsba||(this.hsba=h.default._rgbaToHSBA(this._array)),"hsba(".concat((100*this.hsba[0]).toPrecision(3),"%, ",(100*this.hsba[1]).toPrecision(3),"%, ",(100*this.hsba[2]).toPrecision(3),"%, ",(100*n).toPrecision(3),"%)");case"hsl":return this.hsla||(this.hsla=h.default._rgbaToHSLA(this._array)),"hsl(".concat(this.hsla[0]*this.maxes[d.HSL][0],", ",this.hsla[1]*this.maxes[d.HSL][1],", ",this.hsla[2]*this.maxes[d.HSL][2],")");case"hsl%":return this.hsla||(this.hsla=h.default._rgbaToHSLA(this._array)),"hsl(".concat((100*this.hsla[0]).toPrecision(3),"%, ",(100*this.hsla[1]).toPrecision(3),"%, ",(100*this.hsla[2]).toPrecision(3),"%)");case"hsla":return this.hsla||(this.hsla=h.default._rgbaToHSLA(this._array)),"hsla(".concat(this.hsla[0]*this.maxes[d.HSL][0],", ",this.hsla[1]*this.maxes[d.HSL][1],", ",this.hsla[2]*this.maxes[d.HSL][2],", ",n,")");case"hsla%":return this.hsla||(this.hsla=h.default._rgbaToHSLA(this._array)),"hsl(".concat((100*this.hsla[0]).toPrecision(3),"%, ",(100*this.hsla[1]).toPrecision(3),"%, ",(100*this.hsla[2]).toPrecision(3),"%, ",(100*n).toPrecision(3),"%)");case"rgba":default:return "rgba(".concat(t[0],",",t[1],",",t[2],",",n,")")}},c.default.Color.prototype.setRed=function(e){this._array[0]=e/this.maxes[d.RGB][0],this._calculateLevels();},c.default.Color.prototype.setGreen=function(e){this._array[1]=e/this.maxes[d.RGB][1],this._calculateLevels();},c.default.Color.prototype.setBlue=function(e){this._array[2]=e/this.maxes[d.RGB][2],this._calculateLevels();},c.default.Color.prototype.setAlpha=function(e){this._array[3]=e/this.maxes[this.mode][3],this._calculateLevels();},c.default.Color.prototype._calculateLevels=function(){for(var e=this._array,t=this.levels=new Array(e.length),r=e.length-1;0<=r;--r)t[r]=Math.round(255*e[r]);},c.default.Color.prototype._getAlpha=function(){return this._array[3]*this.maxes[this.mode][3]},c.default.Color.prototype._storeModeAndMaxes=function(e,t){this.mode=e,this.maxes=t;},c.default.Color.prototype._getMode=function(){return this.mode},c.default.Color.prototype._getMaxes=function(){return this.maxes},c.default.Color.prototype._getBlue=function(){return this._array[2]*this.maxes[d.RGB][2]},c.default.Color.prototype._getBrightness=function(){return this.hsba||(this.hsba=h.default._rgbaToHSBA(this._array)),this.hsba[2]*this.maxes[d.HSB][2]},c.default.Color.prototype._getGreen=function(){return this._array[1]*this.maxes[d.RGB][1]},c.default.Color.prototype._getHue=function(){return this.mode===d.HSB?(this.hsba||(this.hsba=h.default._rgbaToHSBA(this._array)),this.hsba[0]*this.maxes[d.HSB][0]):(this.hsla||(this.hsla=h.default._rgbaToHSLA(this._array)),this.hsla[0]*this.maxes[d.HSL][0])},c.default.Color.prototype._getLightness=function(){return this.hsla||(this.hsla=h.default._rgbaToHSLA(this._array)),this.hsla[2]*this.maxes[d.HSL][2]},c.default.Color.prototype._getRed=function(){return this._array[0]*this.maxes[d.RGB][0]},c.default.Color.prototype._getSaturation=function(){return this.mode===d.HSB?(this.hsba||(this.hsba=h.default._rgbaToHSBA(this._array)),this.hsba[1]*this.maxes[d.HSB][1]):(this.hsla||(this.hsla=h.default._rgbaToHSLA(this._array)),this.hsla[1]*this.maxes[d.HSL][1])};var m={aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",gray:"#808080",green:"#008000",greenyellow:"#adff2f",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370db",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#db7093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",rebeccapurple:"#663399",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32"},a=/\s*/,o=/(\d{1,3})/,l=/((?:\d+(?:\.\d+)?)|(?:\.\d+))/,p=new RegExp("".concat(l.source,"%")),f={HEX3:/^#([a-f0-9])([a-f0-9])([a-f0-9])$/i,HEX4:/^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])$/i,HEX6:/^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i,HEX8:/^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i,RGB:new RegExp(["^rgb\\(",o.source,",",o.source,",",o.source,"\\)$"].join(a.source),"i"),RGB_PERCENT:new RegExp(["^rgb\\(",p.source,",",p.source,",",p.source,"\\)$"].join(a.source),"i"),RGBA:new RegExp(["^rgba\\(",o.source,",",o.source,",",o.source,",",l.source,"\\)$"].join(a.source),"i"),RGBA_PERCENT:new RegExp(["^rgba\\(",p.source,",",p.source,",",p.source,",",l.source,"\\)$"].join(a.source),"i"),HSL:new RegExp(["^hsl\\(",o.source,",",p.source,",",p.source,"\\)$"].join(a.source),"i"),HSLA:new RegExp(["^hsla\\(",o.source,",",p.source,",",p.source,",",l.source,"\\)$"].join(a.source),"i"),HSB:new RegExp(["^hsb\\(",o.source,",",p.source,",",p.source,"\\)$"].join(a.source),"i"),HSBA:new RegExp(["^hsba\\(",o.source,",",p.source,",",p.source,",",l.source,"\\)$"].join(a.source),"i")};c.default.Color._parseInputs=function(e,t,r,n){var a,o=arguments.length,i=this.mode,s=this.maxes[i],l=[];if(3<=o){for(l[0]=e/s[0],l[1]=t/s[1],l[2]=r/s[2],l[3]="number"==typeof n?n/s[3]:1,a=l.length-1;0<=a;--a){var p=l[a];p<0?l[a]=0:1<p&&(l[a]=1);}return i===d.HSL?h.default._hslaToRGBA(l):i===d.HSB?h.default._hsbaToRGBA(l):l}if(1===o&&"string"==typeof e){var u=e.trim().toLowerCase();if(m[u])return c.default.Color._parseInputs.call(this,m[u]);if(f.HEX3.test(u))return (l=f.HEX3.exec(u).slice(1).map(function(e){return parseInt(e+e,16)/255}))[3]=1,l;if(f.HEX6.test(u))return (l=f.HEX6.exec(u).slice(1).map(function(e){return parseInt(e,16)/255}))[3]=1,l;if(f.HEX4.test(u))return l=f.HEX4.exec(u).slice(1).map(function(e){return parseInt(e+e,16)/255});if(f.HEX8.test(u))return l=f.HEX8.exec(u).slice(1).map(function(e){return parseInt(e,16)/255});if(f.RGB.test(u))return (l=f.RGB.exec(u).slice(1).map(function(e){return e/255}))[3]=1,l;if(f.RGB_PERCENT.test(u))return (l=f.RGB_PERCENT.exec(u).slice(1).map(function(e){return parseFloat(e)/100}))[3]=1,l;if(f.RGBA.test(u))return l=f.RGBA.exec(u).slice(1).map(function(e,t){return 3===t?parseFloat(e):e/255});if(f.RGBA_PERCENT.test(u))return l=f.RGBA_PERCENT.exec(u).slice(1).map(function(e,t){return 3===t?parseFloat(e):parseFloat(e)/100});if(f.HSL.test(u)?(l=f.HSL.exec(u).slice(1).map(function(e,t){return 0===t?parseInt(e,10)/360:parseInt(e,10)/100}))[3]=1:f.HSLA.test(u)&&(l=f.HSLA.exec(u).slice(1).map(function(e,t){return 0===t?parseInt(e,10)/360:3===t?parseFloat(e):parseInt(e,10)/100})),(l=l.map(function(e){return Math.max(Math.min(e,1),0)})).length)return h.default._hslaToRGBA(l);if(f.HSB.test(u)?(l=f.HSB.exec(u).slice(1).map(function(e,t){return 0===t?parseInt(e,10)/360:parseInt(e,10)/100}))[3]=1:f.HSBA.test(u)&&(l=f.HSBA.exec(u).slice(1).map(function(e,t){return 0===t?parseInt(e,10)/360:3===t?parseFloat(e):parseInt(e,10)/100})),l.length){for(a=l.length-1;0<=a;--a)l[a]=Math.max(Math.min(l[a],1),0);return h.default._hsbaToRGBA(l)}l=[1,1,1,1];}else {if(1!==o&&2!==o||"number"!=typeof e)throw new Error("".concat(arguments,"is not a valid color representation."));l[0]=e/s[2],l[1]=e/s[2],l[2]=e/s[2],l[3]="number"==typeof t?t/s[3]:1,l=l.map(function(e){return Math.max(Math.min(e,1),0)});}return l};var u=c.default.Color;r.default=u;},{"../core/constants":22,"../core/main":32,"./color_conversion":18}],21:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,s=(n=e("../core/main"))&&n.__esModule?n:{default:n},l=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=p();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants"));function p(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return p=function(){return e},e}e("./p5.Color"),s.default.prototype.background=function(){var e;return (e=this._renderer).background.apply(e,arguments),this},s.default.prototype.clear=function(){return this._renderer.clear(),this},s.default.prototype.colorMode=function(e,t,r,n,a){if(s.default._validateParameters("colorMode",arguments),e===l.RGB||e===l.HSB||e===l.HSL){this._colorMode=e;var o=this._colorMaxes[e];2===arguments.length?(o[0]=t,o[1]=t,o[2]=t,o[3]=t):4===arguments.length?(o[0]=t,o[1]=r,o[2]=n):5===arguments.length&&(o[0]=t,o[1]=r,o[2]=n,o[3]=a);}return this},s.default.prototype.fill=function(){var e;return this._renderer._setProperty("_fillSet",!0),this._renderer._setProperty("_doFill",!0),(e=this._renderer).fill.apply(e,arguments),this},s.default.prototype.noFill=function(){return this._renderer._setProperty("_doFill",!1),this},s.default.prototype.noStroke=function(){return this._renderer._setProperty("_doStroke",!1),this},s.default.prototype.stroke=function(){var e;return this._renderer._setProperty("_strokeSet",!0),this._renderer._setProperty("_doStroke",!0),(e=this._renderer).stroke.apply(e,arguments),this},s.default.prototype.erase=function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:255,t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:255;return this._renderer.erase(e,t),this},s.default.prototype.noErase=function(){return this._renderer.noErase(),this};var a=s.default;r.default=a;},{"../core/constants":22,"../core/main":32,"./p5.Color":20}],22:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.FILL=r.STROKE=r.CURVE=r.BEZIER=r.QUADRATIC=r.LINEAR=r._CTX_MIDDLE=r._DEFAULT_LEADMULT=r._DEFAULT_TEXT_FILL=r.BOLDITALIC=r.BOLD=r.ITALIC=r.NORMAL=r.BLUR=r.ERODE=r.DILATE=r.POSTERIZE=r.INVERT=r.OPAQUE=r.GRAY=r.THRESHOLD=r.BURN=r.DODGE=r.SOFT_LIGHT=r.HARD_LIGHT=r.OVERLAY=r.REPLACE=r.SCREEN=r.MULTIPLY=r.EXCLUSION=r.SUBTRACT=r.DIFFERENCE=r.LIGHTEST=r.DARKEST=r.ADD=r.REMOVE=r.BLEND=r.UP_ARROW=r.TAB=r.SHIFT=r.RIGHT_ARROW=r.RETURN=r.OPTION=r.LEFT_ARROW=r.ESCAPE=r.ENTER=r.DOWN_ARROW=r.DELETE=r.CONTROL=r.BACKSPACE=r.ALT=r.AUTO=r.HSL=r.HSB=r.RGB=r.MITER=r.BEVEL=r.ROUND=r.SQUARE=r.PROJECT=r.PIE=r.CHORD=r.OPEN=r.CLOSE=r.TESS=r.QUAD_STRIP=r.QUADS=r.TRIANGLE_STRIP=r.TRIANGLE_FAN=r.TRIANGLES=r.LINE_LOOP=r.LINE_STRIP=r.LINES=r.POINTS=r.BASELINE=r.BOTTOM=r.TOP=r.CENTER=r.LEFT=r.RIGHT=r.RADIUS=r.CORNERS=r.CORNER=r.RAD_TO_DEG=r.DEG_TO_RAD=r.RADIANS=r.DEGREES=r.TWO_PI=r.TAU=r.QUARTER_PI=r.PI=r.HALF_PI=r.WAIT=r.TEXT=r.MOVE=r.HAND=r.CROSS=r.ARROW=r.WEBGL=r.P2D=void 0,r.AXES=r.GRID=r._DEFAULT_FILL=r._DEFAULT_STROKE=r.PORTRAIT=r.LANDSCAPE=r.MIRROR=r.CLAMP=r.REPEAT=r.NEAREST=r.IMAGE=r.IMMEDIATE=r.TEXTURE=void 0;var n=Math.PI;r.P2D="p2d";r.WEBGL="webgl";r.ARROW="default";r.CROSS="crosshair";r.HAND="pointer";r.MOVE="move";r.TEXT="text";r.WAIT="wait";var a=n/2;r.HALF_PI=a;var o=n;r.PI=o;var i=n/4;r.QUARTER_PI=i;var s=2*n;r.TAU=s;var l=2*n;r.TWO_PI=l;r.DEGREES="degrees";r.RADIANS="radians";var p=n/180;r.DEG_TO_RAD=p;var u=180/n;r.RAD_TO_DEG=u;r.CORNER="corner";r.CORNERS="corners";r.RADIUS="radius";r.RIGHT="right";r.LEFT="left";r.CENTER="center";r.TOP="top";r.BOTTOM="bottom";r.BASELINE="alphabetic";r.POINTS=0;r.LINES=1;r.LINE_STRIP=3;r.LINE_LOOP=2;r.TRIANGLES=4;r.TRIANGLE_FAN=6;r.TRIANGLE_STRIP=5;r.QUADS="quads";r.QUAD_STRIP="quad_strip";r.TESS="tess";r.CLOSE="close";r.OPEN="open";r.CHORD="chord";r.PIE="pie";r.PROJECT="square";r.SQUARE="butt";r.ROUND="round";r.BEVEL="bevel";r.MITER="miter";r.RGB="rgb";r.HSB="hsb";r.HSL="hsl";r.AUTO="auto";r.ALT=18;r.BACKSPACE=8;r.CONTROL=17;r.DELETE=46;r.DOWN_ARROW=40;r.ENTER=13;r.ESCAPE=27;r.LEFT_ARROW=37;r.OPTION=18;r.RETURN=13;r.RIGHT_ARROW=39;r.SHIFT=16;r.TAB=9;r.UP_ARROW=38;r.BLEND="source-over";r.REMOVE="destination-out";r.ADD="lighter";r.DARKEST="darken";r.LIGHTEST="lighten";r.DIFFERENCE="difference";r.SUBTRACT="subtract";r.EXCLUSION="exclusion";r.MULTIPLY="multiply";r.SCREEN="screen";r.REPLACE="copy";r.OVERLAY="overlay";r.HARD_LIGHT="hard-light";r.SOFT_LIGHT="soft-light";r.DODGE="color-dodge";r.BURN="color-burn";r.THRESHOLD="threshold";r.GRAY="gray";r.OPAQUE="opaque";r.INVERT="invert";r.POSTERIZE="posterize";r.DILATE="dilate";r.ERODE="erode";r.BLUR="blur";r.NORMAL="normal";r.ITALIC="italic";r.BOLD="bold";r.BOLDITALIC="bold italic";r._DEFAULT_TEXT_FILL="#000000";r._DEFAULT_LEADMULT=1.25;r._CTX_MIDDLE="middle";r.LINEAR="linear";r.QUADRATIC="quadratic";r.BEZIER="bezier";r.CURVE="curve";r.STROKE="stroke";r.FILL="fill";r.TEXTURE="texture";r.IMMEDIATE="immediate";r.IMAGE="image";r.NEAREST="nearest";r.REPEAT="repeat";r.CLAMP="clamp";r.MIRROR="mirror";r.LANDSCAPE="landscape";r.PORTRAIT="portrait";r._DEFAULT_STROKE="#000000";r._DEFAULT_FILL="#FFFFFF";r.GRID="grid";r.AXES="axes";},{}],23:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("./main"))&&n.__esModule?n:{default:n},o=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("./constants"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}var l=[o.ARROW,o.CROSS,o.HAND,o.MOVE,o.TEXT,o.WAIT];a.default.prototype._frameRate=0,a.default.prototype._lastFrameTime=window.performance.now(),a.default.prototype._targetFrameRate=60;var p=window.print;function u(){return window.innerWidth||document.documentElement&&document.documentElement.clientWidth||document.body&&document.body.clientWidth||0}function c(){return window.innerHeight||document.documentElement&&document.documentElement.clientHeight||document.body&&document.body.clientHeight||0}a.default.prototype.print=function(){var e;arguments.length?(e=console).log.apply(e,arguments):p();},a.default.prototype.frameCount=0,a.default.prototype.deltaTime=0,a.default.prototype.focused=document.hasFocus(),a.default.prototype.cursor=function(e,t,r){var n="auto",a=this._curElement.elt;if(l.includes(e))n=e;else if("string"==typeof e){var o="";t&&r&&"number"==typeof t&&"number"==typeof r&&(o="".concat(t," ").concat(r)),n="http://"===e.substring(0,7)||"https://"===e.substring(0,8)?"url(".concat(e,") ").concat(o,", auto"):/\.(cur|jpg|jpeg|gif|png|CUR|JPG|JPEG|GIF|PNG)$/.test(e)?"url(".concat(e,") ").concat(o,", auto"):e;}a.style.cursor=n;},a.default.prototype.frameRate=function(e){return a.default._validateParameters("frameRate",arguments),"number"!=typeof e||e<0?this._frameRate:(this._setProperty("_targetFrameRate",e),0===e&&this._setProperty("_frameRate",e),this)},a.default.prototype.getFrameRate=function(){return this.frameRate()},a.default.prototype.setFrameRate=function(e){return this.frameRate(e)},a.default.prototype.noCursor=function(){this._curElement.elt.style.cursor="none";},a.default.prototype.displayWidth=screen.width,a.default.prototype.displayHeight=screen.height,a.default.prototype.windowWidth=u(),a.default.prototype.windowHeight=c(),a.default.prototype._onresize=function(e){this._setProperty("windowWidth",u()),this._setProperty("windowHeight",c());var t,r=this._isGlobal?window:this;"function"==typeof r.windowResized&&(void 0===(t=r.windowResized(e))||t||e.preventDefault());},a.default.prototype.width=0,a.default.prototype.height=0,a.default.prototype.fullscreen=function(e){if(a.default._validateParameters("fullscreen",arguments),void 0===e)return document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement||document.msFullscreenElement;e?function(e){if(!(document.fullscreenEnabled||document.webkitFullscreenEnabled||document.mozFullScreenEnabled||document.msFullscreenEnabled))throw new Error("Fullscreen not enabled in this browser.");e.requestFullscreen?e.requestFullscreen():e.mozRequestFullScreen?e.mozRequestFullScreen():e.webkitRequestFullscreen?e.webkitRequestFullscreen():e.msRequestFullscreen&&e.msRequestFullscreen();}(document.documentElement):document.exitFullscreen?document.exitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen?document.webkitExitFullscreen():document.msExitFullscreen&&document.msExitFullscreen();},a.default.prototype.pixelDensity=function(e){var t;return a.default._validateParameters("pixelDensity",arguments),"number"==typeof e?(e!==this._pixelDensity&&(this._pixelDensity=e),(t=this).resizeCanvas(this.width,this.height,!0)):t=this._pixelDensity,t},a.default.prototype.displayDensity=function(){return window.devicePixelRatio},a.default.prototype.getURL=function(){return location.href},a.default.prototype.getURLPath=function(){return location.pathname.split("/").filter(function(e){return ""!==e})},a.default.prototype.getURLParams=function(){for(var e,t=/[?&]([^&=]+)(?:[&=])([^&=]+)/gim,r={};null!=(e=t.exec(location.search));)e.index===t.lastIndex&&t.lastIndex++,r[e[1]]=e[2];return r};var d=a.default;r.default=d;},{"./constants":22,"./main":32}],24:[function(r,e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n,a=(n=r("../main"))&&n.__esModule?n:{default:n};r("../internationalization");var o=null,i=null;a.default._friendlyError=a.default._checkForUserDefinedFunctions=a.default._fesErrorMonitor=function(){},o=null;var s="https://github.com/processing/p5.js/wiki/p5.js-overview#why-cant-i-assign-variables-using-p5-functions-and-variables-before-setup";i=function(){function e(r){return Object.getOwnPropertyNames(r).filter(function(e){return "_"!==e[0]&&(!(e in t)&&(t[e]=!0))}).map(function(e){var t;return t="function"==typeof r[e]?"function":e===e.toUpperCase()?"constant":"variable",{name:e,type:t}})}var t={};(o=[].concat(e(a.default.prototype),e(r("../constants")))).sort(function(e,t){return t.name.length-e.name.length});};function l(r,n){n=n||console.log.bind(console),o||i(),o.some(function(e){if(r.message&&null!==r.message.match("\\W?".concat(e.name,"\\W"))){var t="function"===e.type?"".concat(e.name,"()"):e.name;return n("Did you just try to use p5.js's ".concat(t," ").concat(e.type,"? If so, you may want to move it into your sketch's setup() function.\n\nFor more details, see: ").concat(s)),!0}});}a.default.prototype._helpForMisusedAtTopLevelCode=l,"complete"!==document.readyState&&(window.addEventListener("error",l,!1),window.addEventListener("load",function(){window.removeEventListener("error",l,!1);}));var p=a.default;t.default=p;},{"../constants":22,"../internationalization":30,"../main":32,"./browser_errors":void 0}],25:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../main"))&&n.__esModule?n:{default:n};e("../internationalization");a.default._friendlyFileLoadError=function(){};var o=a.default;r.default=o;},{"../internationalization":30,"../main":32}],26:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../main"))&&n.__esModule?n:{default:n};function o(){var t=/(^|@)\S+:\d+/,r=/^\s*at .*(\S+:\d+|\(native\))/m,n=/^(eval@)?(\[native code])?$/;return {parse:function(e){return void 0!==e.stacktrace||void 0!==e["opera#sourceloc"]?this.parseOpera(e):e.stack&&e.stack.match(r)?this.parseV8OrIE(e):e.stack?this.parseFFOrSafari(e):void 0},extractLocation:function(e){if(-1===e.indexOf(":"))return [e];var t=/(.+?)(?::(\d+))?(?::(\d+))?$/.exec(e.replace(/[()]/g,""));return [t[1],t[2]||void 0,t[3]||void 0]},parseV8OrIE:function(e){return e.stack.split("\n").filter(function(e){return !!e.match(r)},this).map(function(e){-1<e.indexOf("(eval ")&&(e=e.replace(/eval code/g,"eval").replace(/(\(eval at [^()]*)|(\),.*$)/g,""));var t=e.replace(/^\s+/,"").replace(/\(eval code/g,"("),r=t.match(/ (\((.+):(\d+):(\d+)\)$)/),n=(t=r?t.replace(r[0],""):t).split(/\s+/).slice(1),a=this.extractLocation(r?r[1]:n.pop());return {functionName:n.join(" ")||void 0,fileName:-1<["eval","<anonymous>"].indexOf(a[0])?void 0:a[0],lineNumber:a[1],columnNumber:a[2],source:e}},this)},parseFFOrSafari:function(e){return e.stack.split("\n").filter(function(e){return !e.match(n)},this).map(function(e){if(-1<e.indexOf(" > eval")&&(e=e.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g,":$1")),-1===e.indexOf("@")&&-1===e.indexOf(":"))return {functionName:e};var t=/((.*".+"[^@]*)?[^@]*)(?:@)/,r=e.match(t),n=r&&r[1]?r[1]:void 0,a=this.extractLocation(e.replace(t,""));return {functionName:n,fileName:a[0],lineNumber:a[1],columnNumber:a[2],source:e}},this)},parseOpera:function(e){return !e.stacktrace||-1<e.message.indexOf("\n")&&e.message.split("\n").length>e.stacktrace.split("\n").length?this.parseOpera9(e):e.stack?this.parseOpera11(e):this.parseOpera10(e)},parseOpera9:function(e){for(var t=/Line (\d+).*script (?:in )?(\S+)/i,r=e.message.split("\n"),n=[],a=2,o=r.length;a<o;a+=2){var i=t.exec(r[a]);i&&n.push({fileName:i[2],lineNumber:i[1],source:r[a]});}return n},parseOpera10:function(e){for(var t=/Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i,r=e.stacktrace.split("\n"),n=[],a=0,o=r.length;a<o;a+=2){var i=t.exec(r[a]);i&&n.push({functionName:i[3]||void 0,fileName:i[2],lineNumber:i[1],source:r[a]});}return n},parseOpera11:function(e){return e.stack.split("\n").filter(function(e){return !!e.match(t)&&!e.match(/^Error created at/)},this).map(function(e){var t,r=e.split("@"),n=this.extractLocation(r.pop()),a=r.shift()||"",o=a.replace(/<anonymous function(: (\w+))?>/,"$2").replace(/\([^)]*\)/g,"")||void 0;return a.match(/\(([^)]*)\)/)&&(t=a.replace(/^[^(]+\(([^)]*)\)$/,"$1")),{functionName:o,args:void 0===t||"[arguments not available]"===t?void 0:t.split(","),fileName:n[0],lineNumber:n[1],columnNumber:n[2],source:e}},this)}}}a.default._getErrorStackParser=function(){return new o};var i=a.default;r.default=i;},{"../main":32}],27:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../main"))&&n.__esModule?n:{default:n};(function(e){if(e&&e.__esModule)return;if(null===e||"object"!==s(e)&&"function"!=typeof e)return;var t=i();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);})(e("../constants")),e("../internationalization");function i(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return i=function(){return e},e}function s(e){return (s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}a.default._validateParameters=a.default._clearValidateParamsCache=function(){};var o=a.default;r.default=o;},{"../../../docs/parameterData.json":1,"../constants":22,"../internationalization":30,"../main":32}],28:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var o=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("./constants"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}var n={modeAdjust:function(e,t,r,n,a){return a===o.CORNER?{x:e,y:t,w:r,h:n}:a===o.CORNERS?{x:e,y:t,w:r-e,h:n-t}:a===o.RADIUS?{x:e-r,y:t-n,w:2*r,h:2*n}:a===o.CENTER?{x:e-.5*r,y:t-.5*n,w:r,h:n}:void 0}};r.default=n;},{"./constants":22}],29:[function(e,t,r){var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};e("./internationalization");var o=Promise.resolve();Promise.all([new Promise(function(e,t){"complete"===document.readyState?e():window.addEventListener("load",e,!1);}),o]).then(function(){void 0===window._setupDone?window.mocha||(window.setup&&"function"==typeof window.setup||window.draw&&"function"==typeof window.draw)&&!a.default.instance&&new a.default:console.warn("p5.js seems to have been imported multiple times. Please remove the duplicate import");});},{"../core/main":32,"./internationalization":30}],30:[function(e,t,n){Object.defineProperty(n,"__esModule",{value:!0}),n.initialize=n.translator=void 0;var a,o=r(e("i18next")),i=r(e("i18next-browser-languagedetector"));function r(e){return e&&e.__esModule?e:{default:e}}var s=function(){return console.debug("p5.js translator called before translations were loaded"),""};n.translator=s;n.initialize=function(){return new Promise(function(t,r){o.default.use(i.default).init({fallbackLng:"en",nestingPrefix:"$tr(",nestingSuffix:")",defaultNS:"translation",returnEmptyString:!1,interpolation:{escapeValue:!1},detection:{checkWhitelist:!1},resources:a}).then(function(e){n.translator=s=e,t();},function(e){return r("Translations failed to load (".concat(e,")"))});})};},{"../../translations":void 0,i18next:4,"i18next-browser-languagedetector":4}],31:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("./main"))&&n.__esModule?n:{default:n};a.default.prototype.pushStyle=function(){throw new Error("pushStyle() not used, see push()")},a.default.prototype.popStyle=function(){throw new Error("popStyle() not used, see pop()")},a.default.prototype.popMatrix=function(){throw new Error("popMatrix() not used, see pop()")},a.default.prototype.pushMatrix=function(){throw new Error("pushMatrix() not used, see push()")};var o=a.default;r.default=o;},{"./main":32}],32:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0,e("./shim");var n=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("./constants"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}function a(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}var o=function(){function _(e,t,r){var d=this;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,_),this._setupDone=!1,this._pixelDensity=Math.ceil(window.devicePixelRatio)||1,this._userNode=t,this._curElement=null,this._elements=[],this._glAttributes=null,this._requestAnimId=0,this._preloadCount=0,this._isGlobal=!1,this._loop=!0,this._initializeInstanceVariables(),this._defaultCanvasSize={width:100,height:100},this._events={mousemove:null,mousedown:null,mouseup:null,dragend:null,dragover:null,click:null,dblclick:null,mouseover:null,mouseout:null,keydown:null,keyup:null,keypress:null,touchstart:null,touchmove:null,touchend:null,resize:null,blur:null},this._millisStart=-1,this._lcg_random_state=null,this._gaussian_previous=!1,this._events.wheel=null,this._loadingScreenId="p5_loading",this._registeredMethods={};var n=Object.getOwnPropertyNames(_.prototype._registeredMethods),a=!0,o=!1,i=void 0;try{for(var s,l=n[Symbol.iterator]();!(a=(s=l.next()).done);a=!0){var p=s.value;this._registeredMethods[p]=_.prototype._registeredMethods[p].slice();}}catch(e){o=!0,i=e;}finally{try{a||null==l.return||l.return();}finally{if(o)throw i}}window.DeviceOrientationEvent&&(this._events.deviceorientation=null),window.DeviceMotionEvent&&!window._isNodeWebkit&&(this._events.devicemotion=null),this._start=function(){d._userNode&&"string"==typeof d._userNode&&(d._userNode=document.getElementById(d._userNode));var e=(d._isGlobal?window:d).preload;if(e){var t=document.getElementById(d._loadingScreenId);if(!t)(t=document.createElement("div")).innerHTML="Loading...",t.style.position="absolute",t.id=d._loadingScreenId,(d._userNode||document.body).appendChild(t);var r=d._preloadMethods;for(var n in r){r[n]=r[n]||_;var a=r[n];a!==_.prototype&&a!==_||(d._isGlobal&&(window[n]=d._wrapPreload(d,n)),a=d),d._registeredPreloadMethods[n]=a[n],a[n]=d._wrapPreload(a,n);}e(),d._runIfPreloadsAreDone();}else d._setup(),d._draw();},this._runIfPreloadsAreDone=function(){var e=this._isGlobal?window:this;if(0===e._preloadCount){var t=document.getElementById(e._loadingScreenId);t&&t.parentNode.removeChild(t),this._lastFrameTime=window.performance.now(),e._setup(),e._draw();}},this._decrementPreload=function(){var e=this._isGlobal?window:this;"function"==typeof e.preload&&(e._setProperty("_preloadCount",e._preloadCount-1),e._runIfPreloadsAreDone());},this._wrapPreload=function(n,a){var o=this;return function(){o._incrementPreload();for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return o._registeredPreloadMethods[a].apply(n,t)}},this._incrementPreload=function(){var e=this._isGlobal?window:this;e._setProperty("_preloadCount",e._preloadCount+1);},this._setup=function(){d.createCanvas(d._defaultCanvasSize.width,d._defaultCanvasSize.height,"p2d");var e=d._isGlobal?window:d;if("function"==typeof e.preload)for(var t in d._preloadMethods)e[t]=d._preloadMethods[t][t],e[t]&&d&&(e[t]=e[t].bind(d));d._millisStart=window.performance.now(),"function"==typeof e.setup&&e.setup();var r=document.getElementsByTagName("canvas"),n=!0,a=!1,o=void 0;try{for(var i,s=r[Symbol.iterator]();!(n=(i=s.next()).done);n=!0){var l=i.value;"true"===l.dataset.hidden&&(l.style.visibility="",delete l.dataset.hidden);}}catch(e){a=!0,o=e;}finally{try{n||null==s.return||s.return();}finally{if(a)throw o}}d._lastFrameTime=window.performance.now(),d._setupDone=!0;},this._draw=function(){var e=window.performance.now(),t=e-d._lastFrameTime,r=1e3/d._targetFrameRate;(!d._loop||r-5<=t)&&(d.redraw(),d._frameRate=1e3/(e-d._lastFrameTime),d.deltaTime=e-d._lastFrameTime,d._setProperty("deltaTime",d.deltaTime),d._lastFrameTime=e,void 0!==d._updateMouseCoords&&(d._updateMouseCoords(),d._setProperty("movedX",0),d._setProperty("movedY",0))),d._loop&&(d._requestAnimId=window.requestAnimationFrame(d._draw));},this._setProperty=function(e,t){d[e]=t,d._isGlobal&&(window[e]=t);},this.remove=function(){var e=document.getElementById(d._loadingScreenId);if(e&&(e.parentNode.removeChild(e),d._incrementPreload()),d._curElement){for(var t in d._loop=!1,d._requestAnimId&&window.cancelAnimationFrame(d._requestAnimId),d._events)window.removeEventListener(t,d._events[t]);var r=!0,n=!1,a=void 0;try{for(var o,i=d._elements[Symbol.iterator]();!(r=(o=i.next()).done);r=!0){var s=o.value;for(var l in s.elt&&s.elt.parentNode&&s.elt.parentNode.removeChild(s.elt),s._events)s.elt.removeEventListener(l,s._events[l]);}}catch(e){n=!0,a=e;}finally{try{r||null==i.return||i.return();}finally{if(n)throw a}}var p=d;d._registeredMethods.remove.forEach(function(e){void 0!==e&&e.call(p);});}if(d._isGlobal){for(var u in _.prototype)try{delete window[u];}catch(e){window[u]=void 0;}for(var c in d)if(d.hasOwnProperty(c))try{delete window[c];}catch(e){window[c]=void 0;}_.instance=null;}},this._registeredMethods.init.forEach(function(e){void 0!==e&&e.call(this);},this),this._setupPromisePreloads();var u=this._createFriendlyGlobalFunctionBinder();if(e)e(this),_._checkForUserDefinedFunctions(this);else {for(var c in this._isGlobal=!0,_.instance=this,_.prototype)if("function"==typeof _.prototype[c]){var h=c.substring(2);this._events.hasOwnProperty(h)||(Math.hasOwnProperty(c)&&Math[c]===_.prototype[c]?u(c,_.prototype[c]):u(c,_.prototype[c].bind(this)));}else u(c,_.prototype[c]);for(var m in this)this.hasOwnProperty(m)&&u(m,this[m]);}for(var f in this._events){var y=this["_on".concat(f)];if(y){var g=y.bind(this);window.addEventListener(f,g,{passive:!1}),this._events[f]=g;}}function v(){d._setProperty("focused",!0);}function b(){d._setProperty("focused",!1);}window.addEventListener("focus",v),window.addEventListener("blur",b),this.registerMethod("remove",function(){window.removeEventListener("focus",v),window.removeEventListener("blur",b);}),"complete"===document.readyState?this._start():window.addEventListener("load",this._start.bind(this),!1);}var e,t;return e=_,(t=[{key:"_initializeInstanceVariables",value:function(){this._styles=[],this._bezierDetail=20,this._curveDetail=20,this._colorMode=n.RGB,this._colorMaxes={rgb:[255,255,255,255],hsb:[360,100,100,1],hsl:[360,100,100,1]},this._downKeys={};}},{key:"registerPreloadMethod",value:function(e,t){_.prototype._preloadMethods.hasOwnProperty(e)||(_.prototype._preloadMethods[e]=t);}},{key:"registerMethod",value:function(e,t){var r=this||_.prototype;r._registeredMethods.hasOwnProperty(e)||(r._registeredMethods[e]=[]),r._registeredMethods[e].push(t);}},{key:"_createFriendlyGlobalFunctionBinder",value:function(e){var t=0<arguments.length&&void 0!==e?e:{},r=t.globalObject||window;t.log||console.log.bind(console);return function(e,t){r[e]=t;}}}])&&a(e.prototype,t),_}();for(var l in o.instance=null,o.disableFriendlyErrors=!1,n)o.prototype[l]=n[l];o.prototype._preloadMethods={loadJSON:o.prototype,loadImage:o.prototype,loadStrings:o.prototype,loadXML:o.prototype,loadBytes:o.prototype,loadTable:o.prototype,loadFont:o.prototype,loadModel:o.prototype,loadShader:o.prototype},o.prototype._registeredMethods={init:[],pre:[],post:[],remove:[]},o.prototype._registeredPreloadMethods={};var p=o;r.default=p;},{"./constants":22,"./shim":43}],33:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("./main"))&&n.__esModule?n:{default:n};a.default.Element=function(e,t){this.elt=e,this._pInst=this._pixelsState=t,this._events={},this.width=this.elt.offsetWidth,this.height=this.elt.offsetHeight;},a.default.Element.prototype.parent=function(e){return void 0===e?this.elt.parentNode:("string"==typeof e?("#"===e[0]&&(e=e.substring(1)),e=document.getElementById(e)):e instanceof a.default.Element&&(e=e.elt),e.appendChild(this.elt),this)},a.default.Element.prototype.id=function(e){return void 0===e?this.elt.id:(this.elt.id=e,this.width=this.elt.offsetWidth,this.height=this.elt.offsetHeight,this)},a.default.Element.prototype.class=function(e){return void 0===e?this.elt.className:(this.elt.className=e,this)},a.default.Element.prototype.mousePressed=function(t){return a.default.Element._adjustListener("mousedown",function(e){return this._pInst._setProperty("mouseIsPressed",!0),this._pInst._setMouseButton(e),t.call(this)},this),this},a.default.Element.prototype.doubleClicked=function(e){return a.default.Element._adjustListener("dblclick",e,this),this},a.default.Element.prototype.mouseWheel=function(e){return a.default.Element._adjustListener("wheel",e,this),this},a.default.Element.prototype.mouseReleased=function(e){return a.default.Element._adjustListener("mouseup",e,this),this},a.default.Element.prototype.mouseClicked=function(e){return a.default.Element._adjustListener("click",e,this),this},a.default.Element.prototype.mouseMoved=function(e){return a.default.Element._adjustListener("mousemove",e,this),this},a.default.Element.prototype.mouseOver=function(e){return a.default.Element._adjustListener("mouseover",e,this),this},a.default.Element.prototype.mouseOut=function(e){return a.default.Element._adjustListener("mouseout",e,this),this},a.default.Element.prototype.touchStarted=function(e){return a.default.Element._adjustListener("touchstart",e,this),this},a.default.Element.prototype.touchMoved=function(e){return a.default.Element._adjustListener("touchmove",e,this),this},a.default.Element.prototype.touchEnded=function(e){return a.default.Element._adjustListener("touchend",e,this),this},a.default.Element.prototype.dragOver=function(e){return a.default.Element._adjustListener("dragover",e,this),this},a.default.Element.prototype.dragLeave=function(e){return a.default.Element._adjustListener("dragleave",e,this),this},a.default.Element._adjustListener=function(e,t,r){return !1===t?a.default.Element._detachListener(e,r):a.default.Element._attachListener(e,t,r),this},a.default.Element._attachListener=function(e,t,r){r._events[e]&&a.default.Element._detachListener(e,r);var n=t.bind(r);r.elt.addEventListener(e,n,!1),r._events[e]=n;},a.default.Element._detachListener=function(e,t){var r=t._events[e];t.elt.removeEventListener(e,r,!1),t._events[e]=null;},a.default.Element.prototype._setProperty=function(e,t){this[e]=t;};var o=a.default.Element;r.default=o;},{"./main":32}],34:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,s=(n=e("./main"))&&n.__esModule?n:{default:n},l=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=p();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("./constants"));function p(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return p=function(){return e},e}s.default.Graphics=function(e,t,r,n){var a=r||l.P2D;this.canvas=document.createElement("canvas");var o=n._userNode||document.body;for(var i in o.appendChild(this.canvas),s.default.Element.call(this,this.canvas,n),s.default.prototype)this[i]||("function"==typeof s.default.prototype[i]?this[i]=s.default.prototype[i].bind(this):this[i]=s.default.prototype[i]);return s.default.prototype._initializeInstanceVariables.apply(this),this.width=e,this.height=t,this._pixelDensity=n._pixelDensity,a===l.WEBGL?this._renderer=new s.default.RendererGL(this.canvas,this,!1):this._renderer=new s.default.Renderer2D(this.canvas,this,!1),n._elements.push(this),Object.defineProperty(this,"deltaTime",{get:function(){return this._pInst.deltaTime}}),this._renderer.resize(e,t),this._renderer._applyDefaults(),this},s.default.Graphics.prototype=Object.create(s.default.Element.prototype),s.default.Graphics.prototype.reset=function(){this._renderer.resetMatrix(),this._renderer.isP3D&&this._renderer._update();},s.default.Graphics.prototype.remove=function(){this.elt.parentNode&&this.elt.parentNode.removeChild(this.elt);var e=this._pInst._elements.indexOf(this);for(var t in -1!==e&&this._pInst._elements.splice(e,1),this._events)this.elt.removeEventListener(t,this._events[t]);};var a=s.default.Graphics;r.default=a;},{"./constants":22,"./main":32}],35:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,l=(n=e("./main"))&&n.__esModule?n:{default:n},b=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==s(e)&&"function"!=typeof e)return {default:e};var t=i();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants"));function i(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return i=function(){return e},e}function s(e){return (s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function p(e){var t=0,r=0;if(e.offsetParent)for(;t+=e.offsetLeft,r+=e.offsetTop,e=e.offsetParent;);else t+=e.offsetLeft,r+=e.offsetTop;return [t,r]}l.default.Renderer=function(e,t,r){l.default.Element.call(this,e,t),this.canvas=e,this._pixelsState=t,r?(this._isMainCanvas=!0,this._pInst._setProperty("_curElement",this),this._pInst._setProperty("canvas",this.canvas),this._pInst._setProperty("width",this.width),this._pInst._setProperty("height",this.height)):(this.canvas.style.display="none",this._styles=[]),this._textSize=12,this._textLeading=15,this._textFont="sans-serif",this._textStyle=b.NORMAL,this._textAscent=null,this._textDescent=null,this._textAlign=b.LEFT,this._textBaseline=b.BASELINE,this._rectMode=b.CORNER,this._ellipseMode=b.CENTER,this._curveTightness=0,this._imageMode=b.CORNER,this._tint=null,this._doStroke=!0,this._doFill=!0,this._strokeSet=!1,this._fillSet=!1;},l.default.Renderer.prototype=Object.create(l.default.Element.prototype),l.default.Renderer.prototype.push=function(){return {properties:{_doStroke:this._doStroke,_strokeSet:this._strokeSet,_doFill:this._doFill,_fillSet:this._fillSet,_tint:this._tint,_imageMode:this._imageMode,_rectMode:this._rectMode,_ellipseMode:this._ellipseMode,_textFont:this._textFont,_textLeading:this._textLeading,_textSize:this._textSize,_textAlign:this._textAlign,_textBaseline:this._textBaseline,_textStyle:this._textStyle}}},l.default.Renderer.prototype.pop=function(e){e.properties&&Object.assign(this,e.properties);},l.default.Renderer.prototype.resize=function(e,t){this.width=e,this.height=t,this.elt.width=e*this._pInst._pixelDensity,this.elt.height=t*this._pInst._pixelDensity,this.elt.style.width="".concat(e,"px"),this.elt.style.height="".concat(t,"px"),this._isMainCanvas&&(this._pInst._setProperty("width",this.width),this._pInst._setProperty("height",this.height));},l.default.Renderer.prototype.get=function(e,t,r,n){var a=this._pixelsState,o=a._pixelDensity,i=this.canvas;if(void 0===e&&void 0===t)e=t=0,r=a.width,n=a.height;else if(e*=o,t*=o,void 0===r&&void 0===n)return e<0||t<0||e>=i.width||t>=i.height?[0,0,0,0]:this._getPixel(e,t);var s=new l.default.Image(r,n);return s.canvas.getContext("2d").drawImage(i,e,t,r*o,n*o,0,0,r,n),s},l.default.Renderer.prototype.textLeading=function(e){return "number"==typeof e?(this._setProperty("_textLeading",e),this._pInst):this._textLeading},l.default.Renderer.prototype.textSize=function(e){return "number"==typeof e?(this._setProperty("_textSize",e),this._setProperty("_textLeading",e*b._DEFAULT_LEADMULT),this._applyTextProperties()):this._textSize},l.default.Renderer.prototype.textStyle=function(e){return e?(e!==b.NORMAL&&e!==b.ITALIC&&e!==b.BOLD&&e!==b.BOLDITALIC||this._setProperty("_textStyle",e),this._applyTextProperties()):this._textStyle},l.default.Renderer.prototype.textAscent=function(){return null===this._textAscent&&this._updateTextMetrics(),this._textAscent},l.default.Renderer.prototype.textDescent=function(){return null===this._textDescent&&this._updateTextMetrics(),this._textDescent},l.default.Renderer.prototype.textAlign=function(e,t){return void 0!==e?(this._setProperty("_textAlign",e),void 0!==t&&this._setProperty("_textBaseline",t),this._applyTextProperties()):{horizontal:this._textAlign,vertical:this._textBaseline}},l.default.Renderer.prototype.text=function(e,t,r,n,a){var o,i,s,l,p,u,c,d,h,m=this._pInst,f=Number.MAX_VALUE;if((this._doFill||this._doStroke)&&void 0!==e){if("string"!=typeof e&&(e=e.toString()),o=(e=e.replace(/(\t)/g,"  ")).split("\n"),void 0!==n){for(c=1,s=h=0;s<o.length;s++){for(p="",d=o[s].split(" "),i=0;i<d.length;i++)u="".concat(p+d[i]," "),n<this.textWidth(u)&&1<c?(p="".concat(d[i]," "),h+=m.textLeading(),c=1):(p=u,c+=1);s<o.length-1&&(h+=m.textLeading());}switch(this._rectMode===b.CENTER&&(t-=n/2,r-=a/2),this._textAlign){case b.CENTER:t+=n/2;break;case b.RIGHT:t+=n;}var y=!1;if(void 0!==a){switch(this._textBaseline){case b.BOTTOM:r+=a-h;break;case b.CENTER:r+=(a-h)/2;break;case b.BASELINE:y=!0,this._textBaseline=b.TOP;}f=r+a-m.textAscent();}for(s=0;s<o.length;s++){for(p="",d=o[s].split(" "),i=0;i<d.length;i++)u="".concat(p+d[i]," "),n<this.textWidth(u)&&0<p.length?(this._renderText(m,p,t,r,f),p="".concat(d[i]," "),r+=m.textLeading()):p=u;this._renderText(m,p,t,r,f),r+=m.textLeading(),y&&(this._textBaseline=b.BASELINE);}}else {var g=0,v=m.textAlign().vertical;for(v===b.CENTER?g=(o.length-1)*m.textLeading()/2:v===b.BOTTOM&&(g=(o.length-1)*m.textLeading()),l=0;l<o.length;l++)this._renderText(m,o[l],t,r-g,f),r+=m.textLeading();}return m}},l.default.Renderer.prototype._applyDefaults=function(){return this},l.default.Renderer.prototype._isOpenType=function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:this._textFont;return "object"===s(e)&&e.font&&e.font.supported},l.default.Renderer.prototype._updateTextMetrics=function(){if(this._isOpenType())return this._setProperty("_textAscent",this._textFont._textAscent()),this._setProperty("_textDescent",this._textFont._textDescent()),this;var e=document.createElement("span");e.style.fontFamily=this._textFont,e.style.fontSize="".concat(this._textSize,"px"),e.innerHTML="ABCjgq|";var t=document.createElement("div");t.style.display="inline-block",t.style.width="1px",t.style.height="0px";var r=document.createElement("div");r.appendChild(e),r.appendChild(t),r.style.height="0px",r.style.overflow="hidden",document.body.appendChild(r),t.style.verticalAlign="baseline";var n=p(t),a=p(e),o=n[1]-a[1];t.style.verticalAlign="bottom",n=p(t),a=p(e);var i=n[1]-a[1]-o;return document.body.removeChild(r),this._setProperty("_textAscent",o),this._setProperty("_textDescent",i),this};var a=l.default.Renderer;r.default=a;},{"../core/constants":22,"./main":32}],36:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var c=n(e("./main")),m=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("./constants")),d=n(e("../image/filters"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}function n(e){return e&&e.__esModule?e:{default:e}}e("./p5.Renderer");var y="rgba(0,0,0,0)";c.default.Renderer2D=function(e,t,r){return c.default.Renderer.call(this,e,t,r),this.drawingContext=this.canvas.getContext("2d"),this._pInst._setProperty("drawingContext",this.drawingContext),this},c.default.Renderer2D.prototype=Object.create(c.default.Renderer.prototype),c.default.Renderer2D.prototype._applyDefaults=function(){this._cachedFillStyle=this._cachedStrokeStyle=void 0,this._cachedBlendMode=m.BLEND,this._setFill(m._DEFAULT_FILL),this._setStroke(m._DEFAULT_STROKE),this.drawingContext.lineCap=m.ROUND,this.drawingContext.font="normal 12px sans-serif";},c.default.Renderer2D.prototype.resize=function(e,t){c.default.Renderer.prototype.resize.call(this,e,t),this.drawingContext.scale(this._pInst._pixelDensity,this._pInst._pixelDensity);},c.default.Renderer2D.prototype.background=function(){if(this.drawingContext.save(),this.resetMatrix(),(arguments.length<=0?void 0:arguments[0])instanceof c.default.Image)this._pInst.image(arguments.length<=0?void 0:arguments[0],0,0,this.width,this.height);else {var e,t=this._getFill(),r=(e=this._pInst).color.apply(e,arguments).toString();this._setFill(r),this._isErasing&&this.blendMode(this._cachedBlendMode),this.drawingContext.fillRect(0,0,this.width,this.height),this._setFill(t),this._isErasing&&this._pInst.erase();}this.drawingContext.restore();},c.default.Renderer2D.prototype.clear=function(){this.drawingContext.save(),this.resetMatrix(),this.drawingContext.clearRect(0,0,this.width,this.height),this.drawingContext.restore();},c.default.Renderer2D.prototype.fill=function(){var e,t=(e=this._pInst).color.apply(e,arguments);this._setFill(t.toString());},c.default.Renderer2D.prototype.stroke=function(){var e,t=(e=this._pInst).color.apply(e,arguments);this._setStroke(t.toString());},c.default.Renderer2D.prototype.erase=function(e,t){if(!this._isErasing){this._cachedFillStyle=this.drawingContext.fillStyle;var r=this._pInst.color(255,e).toString();this.drawingContext.fillStyle=r,this._cachedStrokeStyle=this.drawingContext.strokeStyle;var n=this._pInst.color(255,t).toString();this.drawingContext.strokeStyle=n;var a=this._cachedBlendMode;this.blendMode(m.REMOVE),this._cachedBlendMode=a,this._isErasing=!0;}},c.default.Renderer2D.prototype.noErase=function(){this._isErasing&&(this.drawingContext.fillStyle=this._cachedFillStyle,this.drawingContext.strokeStyle=this._cachedStrokeStyle,this.blendMode(this._cachedBlendMode),this._isErasing=!1);},c.default.Renderer2D.prototype.image=function(e,t,r,n,a,o,i,s,l){var p;e.gifProperties&&e._animateGif(this._pInst);try{this._tint&&(c.default.MediaElement&&e instanceof c.default.MediaElement&&e.loadPixels(),e.canvas&&(p=this._getTintedImageCanvas(e))),p=p||(e.canvas||e.elt);var u=1;e.width&&0<e.width&&(u=p.width/e.width),this._isErasing&&this.blendMode(this._cachedBlendMode),this.drawingContext.drawImage(p,u*t,u*r,u*n,u*a,o,i,s,l),this._isErasing&&this._pInst.erase();}catch(e){if("NS_ERROR_NOT_AVAILABLE"!==e.name)throw e}},c.default.Renderer2D.prototype._getTintedImageCanvas=function(e){if(!e.canvas)return e;var t=d.default._toPixels(e.canvas),r=document.createElement("canvas");r.width=e.canvas.width,r.height=e.canvas.height;for(var n=r.getContext("2d"),a=n.createImageData(e.canvas.width,e.canvas.height),o=a.data,i=0;i<t.length;i+=4){var s=t[i],l=t[i+1],p=t[i+2],u=t[i+3];o[i]=s*this._tint[0]/255,o[i+1]=l*this._tint[1]/255,o[i+2]=p*this._tint[2]/255,o[i+3]=u*this._tint[3]/255;}return n.putImageData(a,0,0),r},c.default.Renderer2D.prototype.blendMode=function(e){if(e===m.SUBTRACT)console.warn("blendMode(SUBTRACT) only works in WEBGL mode.");else {if(e!==m.BLEND&&e!==m.REMOVE&&e!==m.DARKEST&&e!==m.LIGHTEST&&e!==m.DIFFERENCE&&e!==m.MULTIPLY&&e!==m.EXCLUSION&&e!==m.SCREEN&&e!==m.REPLACE&&e!==m.OVERLAY&&e!==m.HARD_LIGHT&&e!==m.SOFT_LIGHT&&e!==m.DODGE&&e!==m.BURN&&e!==m.ADD)throw new Error("Mode ".concat(e," not recognized."));this._cachedBlendMode=e,this.drawingContext.globalCompositeOperation=e;}},c.default.Renderer2D.prototype.blend=function(){for(var e=this.drawingContext.globalCompositeOperation,t=arguments.length,r=new Array(t),n=0;n<t;n++)r[n]=arguments[n];var a=r[r.length-1],o=Array.prototype.slice.call(r,0,r.length-1);this.drawingContext.globalCompositeOperation=a,c.default.prototype.copy.apply(this,o),this.drawingContext.globalCompositeOperation=e;},c.default.Renderer2D.prototype._getPixel=function(e,t){var r;return [(r=this.drawingContext.getImageData(e,t,1,1).data)[0],r[1],r[2],r[3]]},c.default.Renderer2D.prototype.loadPixels=function(){var e=this._pixelsState,t=e._pixelDensity,r=this.width*t,n=this.height*t,a=this.drawingContext.getImageData(0,0,r,n);e._setProperty("imageData",a),e._setProperty("pixels",a.data);},c.default.Renderer2D.prototype.set=function(e,t,r){e=Math.floor(e),t=Math.floor(t);var n=this._pixelsState;if(r instanceof c.default.Image)this.drawingContext.save(),this.drawingContext.setTransform(1,0,0,1,0,0),this.drawingContext.scale(n._pixelDensity,n._pixelDensity),this.drawingContext.clearRect(e,t,r.width,r.height),this.drawingContext.drawImage(r.canvas,e,t),this.drawingContext.restore();else {var a=0,o=0,i=0,s=0,l=4*(t*n._pixelDensity*(this.width*n._pixelDensity)+e*n._pixelDensity);if(n.imageData||n.loadPixels.call(n),"number"==typeof r)l<n.pixels.length&&(i=o=a=r,s=255);else if(r instanceof Array){if(r.length<4)throw new Error("pixel array must be of the form [R, G, B, A]");l<n.pixels.length&&(a=r[0],o=r[1],i=r[2],s=r[3]);}else r instanceof c.default.Color&&l<n.pixels.length&&(a=r.levels[0],o=r.levels[1],i=r.levels[2],s=r.levels[3]);for(var p=0;p<n._pixelDensity;p++)for(var u=0;u<n._pixelDensity;u++)l=4*((t*n._pixelDensity+u)*this.width*n._pixelDensity+(e*n._pixelDensity+p)),n.pixels[l]=a,n.pixels[l+1]=o,n.pixels[l+2]=i,n.pixels[l+3]=s;}},c.default.Renderer2D.prototype.updatePixels=function(e,t,r,n){var a=this._pixelsState,o=a._pixelDensity;void 0===e&&void 0===t&&void 0===r&&void 0===n&&(t=e=0,r=this.width,n=this.height),e*=o,t*=o,r*=o,n*=o,this.gifProperties&&(this.gifProperties.frames[this.gifProperties.displayIndex].image=a.imageData),this.drawingContext.putImageData(a.imageData,e,t,0,0,r,n);},c.default.Renderer2D.prototype._acuteArcToBezier=function(e,t){var r=t/2,n=Math.cos(r),a=Math.sin(r),o=1/Math.tan(r),i=e+r,s=Math.cos(i),l=Math.sin(i),p=(4-n)/3,u=a+(n-p)*o;return {ax:Math.cos(e).toFixed(7),ay:Math.sin(e).toFixed(7),bx:(p*s+u*l).toFixed(7),by:(p*l-u*s).toFixed(7),cx:(p*s-u*l).toFixed(7),cy:(p*l+u*s).toFixed(7),dx:Math.cos(e+t).toFixed(7),dy:Math.sin(e+t).toFixed(7)}},c.default.Renderer2D.prototype.arc=function(r,n,e,t,a,o,i){var s=this.drawingContext,l=e/2,p=t/2,u=0,c=[];for(r+=l,n+=p;1e-5<=o-a;)u=Math.min(o-a,m.HALF_PI),c.push(this._acuteArcToBezier(a,u)),a+=u;return this._doFill&&(s.beginPath(),c.forEach(function(e,t){0===t&&s.moveTo(r+e.ax*l,n+e.ay*p),s.bezierCurveTo(r+e.bx*l,n+e.by*p,r+e.cx*l,n+e.cy*p,r+e.dx*l,n+e.dy*p);}),i!==m.PIE&&null!=i||s.lineTo(r,n),s.closePath(),s.fill()),this._doStroke&&(s.beginPath(),c.forEach(function(e,t){0===t&&s.moveTo(r+e.ax*l,n+e.ay*p),s.bezierCurveTo(r+e.bx*l,n+e.by*p,r+e.cx*l,n+e.cy*p,r+e.dx*l,n+e.dy*p);}),i===m.PIE?(s.lineTo(r,n),s.closePath()):i===m.CHORD&&s.closePath(),s.stroke()),this},c.default.Renderer2D.prototype.ellipse=function(e){var t=this.drawingContext,r=this._doFill,n=this._doStroke,a=parseFloat(e[0]),o=parseFloat(e[1]),i=parseFloat(e[2]),s=parseFloat(e[3]);if(r&&!n){if(this._getFill()===y)return this}else if(!r&&n&&this._getStroke()===y)return this;var l=i/2*.5522847498,p=s/2*.5522847498,u=a+i,c=o+s,d=a+i/2,h=o+s/2;t.beginPath(),t.moveTo(a,h),t.bezierCurveTo(a,h-p,d-l,o,d,o),t.bezierCurveTo(d+l,o,u,h-p,u,h),t.bezierCurveTo(u,h+p,d+l,c,d,c),t.bezierCurveTo(d-l,c,a,h+p,a,h),r&&t.fill(),n&&t.stroke();},c.default.Renderer2D.prototype.line=function(e,t,r,n){var a=this.drawingContext;return this._doStroke&&(this._getStroke()===y||(a.beginPath(),a.moveTo(e,t),a.lineTo(r,n),a.stroke())),this},c.default.Renderer2D.prototype.point=function(e,t){var r=this.drawingContext;if(!this._doStroke)return this;if(this._getStroke()===y)return this;var n=this._getStroke(),a=this._getFill();e=Math.round(e),t=Math.round(t),this._setFill(n),1<r.lineWidth?(r.beginPath(),r.arc(e,t,r.lineWidth/2,0,m.TWO_PI,!1),r.fill()):r.fillRect(e,t,1,1),this._setFill(a);},c.default.Renderer2D.prototype.quad=function(e,t,r,n,a,o,i,s){var l=this.drawingContext,p=this._doFill,u=this._doStroke;if(p&&!u){if(this._getFill()===y)return this}else if(!p&&u&&this._getStroke()===y)return this;return l.beginPath(),l.moveTo(e,t),l.lineTo(r,n),l.lineTo(a,o),l.lineTo(i,s),l.closePath(),p&&l.fill(),u&&l.stroke(),this},c.default.Renderer2D.prototype.rect=function(e){var t=e[0],r=e[1],n=e[2],a=e[3],o=e[4],i=e[5],s=e[6],l=e[7],p=this.drawingContext,u=this._doFill,c=this._doStroke;if(u&&!c){if(this._getFill()===y)return this}else if(!u&&c&&this._getStroke()===y)return this;if(p.beginPath(),void 0===o)p.rect(t,r,n,a);else {void 0===i&&(i=o),void 0===s&&(s=i),void 0===l&&(l=s);var d=Math.abs(n),h=Math.abs(a),m=d/2,f=h/2;d<2*o&&(o=m),h<2*o&&(o=f),d<2*i&&(i=m),h<2*i&&(i=f),d<2*s&&(s=m),h<2*s&&(s=f),d<2*l&&(l=m),h<2*l&&(l=f),p.beginPath(),p.moveTo(t+o,r),p.arcTo(t+n,r,t+n,r+a,i),p.arcTo(t+n,r+a,t,r+a,s),p.arcTo(t,r+a,t,r,l),p.arcTo(t,r,t+n,r,o),p.closePath();}return this._doFill&&p.fill(),this._doStroke&&p.stroke(),this},c.default.Renderer2D.prototype.triangle=function(e){var t=this.drawingContext,r=this._doFill,n=this._doStroke,a=e[0],o=e[1],i=e[2],s=e[3],l=e[4],p=e[5];if(r&&!n){if(this._getFill()===y)return this}else if(!r&&n&&this._getStroke()===y)return this;t.beginPath(),t.moveTo(a,o),t.lineTo(i,s),t.lineTo(l,p),t.closePath(),r&&t.fill(),n&&t.stroke();},c.default.Renderer2D.prototype.endShape=function(e,t,r,n,a,o,i){if(0===t.length)return this;if(!this._doStroke&&!this._doFill)return this;var s,l,p,u=e===m.CLOSE;u&&!o&&t.push(t[0]);var c=t.length;if(!r||i!==m.POLYGON&&null!==i)if(!n||i!==m.POLYGON&&null!==i)if(!a||i!==m.POLYGON&&null!==i)if(i===m.POINTS)for(l=0;l<c;l++)s=t[l],this._doStroke&&this._pInst.stroke(s[6]),this._pInst.point(s[0],s[1]);else if(i===m.LINES)for(l=0;l+1<c;l+=2)s=t[l],this._doStroke&&this._pInst.stroke(t[l+1][6]),this._pInst.line(s[0],s[1],t[l+1][0],t[l+1][1]);else if(i===m.TRIANGLES)for(l=0;l+2<c;l+=3)s=t[l],this.drawingContext.beginPath(),this.drawingContext.moveTo(s[0],s[1]),this.drawingContext.lineTo(t[l+1][0],t[l+1][1]),this.drawingContext.lineTo(t[l+2][0],t[l+2][1]),this.drawingContext.closePath(),this._doFill&&(this._pInst.fill(t[l+2][5]),this.drawingContext.fill()),this._doStroke&&(this._pInst.stroke(t[l+2][6]),this.drawingContext.stroke());else if(i===m.TRIANGLE_STRIP)for(l=0;l+1<c;l++)s=t[l],this.drawingContext.beginPath(),this.drawingContext.moveTo(t[l+1][0],t[l+1][1]),this.drawingContext.lineTo(s[0],s[1]),this._doStroke&&this._pInst.stroke(t[l+1][6]),this._doFill&&this._pInst.fill(t[l+1][5]),l+2<c&&(this.drawingContext.lineTo(t[l+2][0],t[l+2][1]),this._doStroke&&this._pInst.stroke(t[l+2][6]),this._doFill&&this._pInst.fill(t[l+2][5])),this._doFillStrokeClose(u);else if(i===m.TRIANGLE_FAN){if(2<c){for(this.drawingContext.beginPath(),l=2;l<c;l++)s=t[l],this.drawingContext.moveTo(t[0][0],t[0][1]),this.drawingContext.lineTo(t[l-1][0],t[l-1][1]),this.drawingContext.lineTo(s[0],s[1]),this.drawingContext.lineTo(t[0][0],t[0][1]),l<c-1&&(this._doFill&&s[5]!==t[l+1][5]||this._doStroke&&s[6]!==t[l+1][6])&&(this._doFill&&(this._pInst.fill(s[5]),this.drawingContext.fill(),this._pInst.fill(t[l+1][5])),this._doStroke&&(this._pInst.stroke(s[6]),this.drawingContext.stroke(),this._pInst.stroke(t[l+1][6])),this.drawingContext.closePath(),this.drawingContext.beginPath());this._doFillStrokeClose(u);}}else if(i===m.QUADS)for(l=0;l+3<c;l+=4){for(s=t[l],this.drawingContext.beginPath(),this.drawingContext.moveTo(s[0],s[1]),p=1;p<4;p++)this.drawingContext.lineTo(t[l+p][0],t[l+p][1]);this.drawingContext.lineTo(s[0],s[1]),this._doFill&&this._pInst.fill(t[l+3][5]),this._doStroke&&this._pInst.stroke(t[l+3][6]),this._doFillStrokeClose(u);}else if(i===m.QUAD_STRIP){if(3<c)for(l=0;l+1<c;l+=2)s=t[l],this.drawingContext.beginPath(),l+3<c?(this.drawingContext.moveTo(t[l+2][0],t[l+2][1]),this.drawingContext.lineTo(s[0],s[1]),this.drawingContext.lineTo(t[l+1][0],t[l+1][1]),this.drawingContext.lineTo(t[l+3][0],t[l+3][1]),this._doFill&&this._pInst.fill(t[l+3][5]),this._doStroke&&this._pInst.stroke(t[l+3][6])):(this.drawingContext.moveTo(s[0],s[1]),this.drawingContext.lineTo(t[l+1][0],t[l+1][1])),this._doFillStrokeClose(u);}else {for(this.drawingContext.beginPath(),this.drawingContext.moveTo(t[0][0],t[0][1]),l=1;l<c;l++)(s=t[l]).isVert&&(s.moveTo?this.drawingContext.moveTo(s[0],s[1]):this.drawingContext.lineTo(s[0],s[1]));this._doFillStrokeClose(u);}else {for(this.drawingContext.beginPath(),l=0;l<c;l++)t[l].isVert?t[l].moveTo?this.drawingContext.moveTo(t[l][0],t[l][1]):this.drawingContext.lineTo(t[l][0],t[l][1]):this.drawingContext.quadraticCurveTo(t[l][0],t[l][1],t[l][2],t[l][3]);this._doFillStrokeClose(u);}else {for(this.drawingContext.beginPath(),l=0;l<c;l++)t[l].isVert?t[l].moveTo?this.drawingContext.moveTo(t[l][0],t[l][1]):this.drawingContext.lineTo(t[l][0],t[l][1]):this.drawingContext.bezierCurveTo(t[l][0],t[l][1],t[l][2],t[l][3],t[l][4],t[l][5]);this._doFillStrokeClose(u);}else if(3<c){var d=[],h=1-this._curveTightness;for(this.drawingContext.beginPath(),this.drawingContext.moveTo(t[1][0],t[1][1]),l=1;l+2<c;l++)s=t[l],d[0]=[s[0],s[1]],d[1]=[s[0]+(h*t[l+1][0]-h*t[l-1][0])/6,s[1]+(h*t[l+1][1]-h*t[l-1][1])/6],d[2]=[t[l+1][0]+(h*t[l][0]-h*t[l+2][0])/6,t[l+1][1]+(h*t[l][1]-h*t[l+2][1])/6],d[3]=[t[l+1][0],t[l+1][1]],this.drawingContext.bezierCurveTo(d[1][0],d[1][1],d[2][0],d[2][1],d[3][0],d[3][1]);u&&this.drawingContext.lineTo(t[l+1][0],t[l+1][1]),this._doFillStrokeClose(u);}return o=a=n=r=!1,u&&t.pop(),this},c.default.Renderer2D.prototype.strokeCap=function(e){return e!==m.ROUND&&e!==m.SQUARE&&e!==m.PROJECT||(this.drawingContext.lineCap=e),this},c.default.Renderer2D.prototype.strokeJoin=function(e){return e!==m.ROUND&&e!==m.BEVEL&&e!==m.MITER||(this.drawingContext.lineJoin=e),this},c.default.Renderer2D.prototype.strokeWeight=function(e){return this.drawingContext.lineWidth=void 0===e||0===e?1e-4:e,this},c.default.Renderer2D.prototype._getFill=function(){return this._cachedFillStyle||(this._cachedFillStyle=this.drawingContext.fillStyle),this._cachedFillStyle},c.default.Renderer2D.prototype._setFill=function(e){e!==this._cachedFillStyle&&(this.drawingContext.fillStyle=e,this._cachedFillStyle=e);},c.default.Renderer2D.prototype._getStroke=function(){return this._cachedStrokeStyle||(this._cachedStrokeStyle=this.drawingContext.strokeStyle),this._cachedStrokeStyle},c.default.Renderer2D.prototype._setStroke=function(e){e!==this._cachedStrokeStyle&&(this.drawingContext.strokeStyle=e,this._cachedStrokeStyle=e);},c.default.Renderer2D.prototype.bezier=function(e,t,r,n,a,o,i,s){return this._pInst.beginShape(),this._pInst.vertex(e,t),this._pInst.bezierVertex(r,n,a,o,i,s),this._pInst.endShape(),this},c.default.Renderer2D.prototype.curve=function(e,t,r,n,a,o,i,s){return this._pInst.beginShape(),this._pInst.curveVertex(e,t),this._pInst.curveVertex(r,n),this._pInst.curveVertex(a,o),this._pInst.curveVertex(i,s),this._pInst.endShape(),this},c.default.Renderer2D.prototype._doFillStrokeClose=function(e){e&&this.drawingContext.closePath(),this._doFill&&this.drawingContext.fill(),this._doStroke&&this.drawingContext.stroke();},c.default.Renderer2D.prototype.applyMatrix=function(e,t,r,n,a,o){this.drawingContext.transform(e,t,r,n,a,o);},c.default.Renderer2D.prototype.resetMatrix=function(){return this.drawingContext.setTransform(1,0,0,1,0,0),this.drawingContext.scale(this._pInst._pixelDensity,this._pInst._pixelDensity),this},c.default.Renderer2D.prototype.rotate=function(e){this.drawingContext.rotate(e);},c.default.Renderer2D.prototype.scale=function(e,t){return this.drawingContext.scale(e,t),this},c.default.Renderer2D.prototype.translate=function(e,t){return e instanceof c.default.Vector&&(t=e.y,e=e.x),this.drawingContext.translate(e,t),this},c.default.Renderer2D.prototype.text=function(e,t,r,n,a){var o;void 0!==n&&this.drawingContext.textBaseline===m.BASELINE&&(o=!0,this.drawingContext.textBaseline=m.TOP);var i=c.default.Renderer.prototype.text.apply(this,arguments);return o&&(this.drawingContext.textBaseline=m.BASELINE),i},c.default.Renderer2D.prototype._renderText=function(e,t,r,n,a){if(!(a<=n))return e.push(),this._isOpenType()?this._textFont._renderPath(t,r,n,{renderer:this}):(this._doStroke&&this._strokeSet&&this.drawingContext.strokeText(t,r,n),this._doFill&&(this._fillSet||this._setFill(m._DEFAULT_TEXT_FILL),this.drawingContext.fillText(t,r,n))),e.pop(),e},c.default.Renderer2D.prototype.textWidth=function(e){return this._isOpenType()?this._textFont._textWidth(e,this._textSize):this.drawingContext.measureText(e).width},c.default.Renderer2D.prototype._applyTextProperties=function(){var e,t=this._pInst;return this._setProperty("_textAscent",null),this._setProperty("_textDescent",null),e=this._textFont,this._isOpenType()&&(e=this._textFont.font.familyName,this._setProperty("_textStyle",this._textFont.font.styleName)),this.drawingContext.font="".concat(this._textStyle||"normal"," ").concat(this._textSize||12,"px ").concat(e||"sans-serif"),this.drawingContext.textAlign=this._textAlign,this._textBaseline===m.CENTER?this.drawingContext.textBaseline=m._CTX_MIDDLE:this.drawingContext.textBaseline=this._textBaseline,t},c.default.Renderer2D.prototype.push=function(){return this.drawingContext.save(),c.default.Renderer.prototype.push.apply(this)},c.default.Renderer2D.prototype.pop=function(e){this.drawingContext.restore(),this._cachedFillStyle=this.drawingContext.fillStyle,this._cachedStrokeStyle=this.drawingContext.strokeStyle,c.default.Renderer.prototype.pop.call(this,e);};var a=c.default.Renderer2D;r.default=a;},{"../image/filters":53,"./constants":22,"./main":32,"./p5.Renderer":35}],37:[function(e,t,r){var n,d=(n=e("./main"))&&n.__esModule?n:{default:n};d.default.prototype._promisePreloads=[];var h=!(d.default.prototype.registerPromisePreload=function(e){d.default.prototype._promisePreloads.push(e);});d.default.prototype._setupPromisePreloads=function(){var e=!0,t=!1,r=void 0;try{for(var n,a=this._promisePreloads[Symbol.iterator]();!(e=(n=a.next()).done);e=!0){var o=n.value,i=this,s=o.method,l=o.addCallbacks,p=o.legacyPreloadSetup,u=o.target||this,c=u[s].bind(u);if(u===d.default.prototype){if(h)continue;i=null,c=u[s];}if(u[s]=this._wrapPromisePreload(i,c,l),p)u[p.method]=this._legacyPreloadGenerator(i,p,u[s]);}}catch(e){t=!0,r=e;}finally{try{e||null==a.return||a.return();}finally{if(t)throw r}}h=!0;},d.default.prototype._wrapPromisePreload=function(e,l,p){var t=function(){var e=this;this._incrementPreload();for(var t=null,r=null,n=arguments.length,a=new Array(n),o=0;o<n;o++)a[o]=arguments[o];if(p)for(var i=a.length-1;0<=i&&!r&&"function"==typeof a[i];i--)r=t,t=a.pop();var s=Promise.resolve(l.apply(this,a));return t&&s.then(t),r&&s.catch(r),s.then(function(){return e._decrementPreload()}),s};return e&&(t=t.bind(e)),t};function o(){return {}}d.default.prototype._legacyPreloadGenerator=function(e,t,n){var a=t.createBaseObject||o,r=function(){var t=this;this._incrementPreload();var r=a.apply(this,arguments);return n.apply(this,arguments).then(function(e){Object.assign(r,e),t._decrementPreload();}),r};return e&&(r=r.bind(e)),r};},{"./main":32}],38:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,l=(n=e("./main"))&&n.__esModule?n:{default:n},p=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==s(e)&&"function"!=typeof e)return {default:e};var t=i();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("./constants"));function i(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return i=function(){return e},e}function s(e){return (s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}e("./p5.Graphics"),e("./p5.Renderer2D"),e("../webgl/p5.RendererGL");var u="defaultCanvas0";l.default.prototype.createCanvas=function(e,t,r){l.default._validateParameters("createCanvas",arguments);var n,a=r||p.P2D;if(a===p.WEBGL){if(n=document.getElementById(u)){n.parentNode.removeChild(n);var o=this._renderer;this._elements=this._elements.filter(function(e){return e!==o});}(n=document.createElement("canvas")).id=u,n.classList.add("p5Canvas");}else if(this._defaultGraphicsCreated)n=this.canvas;else {n=document.createElement("canvas");for(var i=0;document.getElementById("defaultCanvas".concat(i));)i++;u="defaultCanvas".concat(i),n.id=u,n.classList.add("p5Canvas");}if(this._setupDone||(n.dataset.hidden=!0,n.style.visibility="hidden"),this._userNode)this._userNode.appendChild(n);else {if(0===document.getElementsByTagName("main").length){var s=document.createElement("main");document.body.appendChild(s);}document.getElementsByTagName("main")[0].appendChild(n);}return a===p.WEBGL?(this._setProperty("_renderer",new l.default.RendererGL(n,this,!0)),this._elements.push(this._renderer)):this._defaultGraphicsCreated||(this._setProperty("_renderer",new l.default.Renderer2D(n,this,!0)),this._defaultGraphicsCreated=!0,this._elements.push(this._renderer)),this._renderer.resize(e,t),this._renderer._applyDefaults(),this._renderer},l.default.prototype.resizeCanvas=function(e,t,r){if(l.default._validateParameters("resizeCanvas",arguments),this._renderer){var n={};for(var a in this.drawingContext){var o=this.drawingContext[a];"object"!==s(o)&&"function"!=typeof o&&(n[a]=o);}for(var i in this._renderer.resize(e,t),this.width=e,this.height=t,n)try{this.drawingContext[i]=n[i];}catch(e){}r||this.redraw();}},l.default.prototype.noCanvas=function(){this.canvas&&this.canvas.parentNode.removeChild(this.canvas);},l.default.prototype.createGraphics=function(e,t,r){return l.default._validateParameters("createGraphics",arguments),new l.default.Graphics(e,t,r,this)},l.default.prototype.blendMode=function(e){l.default._validateParameters("blendMode",arguments),e===p.NORMAL&&(console.warn("NORMAL has been deprecated for use in blendMode. defaulting to BLEND instead."),e=p.BLEND),this._renderer.blendMode(e);};var a=l.default;r.default=a;},{"../webgl/p5.RendererGL":86,"./constants":22,"./main":32,"./p5.Graphics":34,"./p5.Renderer2D":36}],39:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var u=n(e("../main")),s=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=l();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../constants")),c=n(e("../helpers"));function l(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return l=function(){return e},e}function n(e){return e&&e.__esModule?e:{default:e}}e("../friendly_errors/fes_core"),e("../friendly_errors/file_errors"),e("../friendly_errors/validate_params"),u.default.prototype._normalizeArcAngles=function(e,t,r,n,a){var o;return e-=s.TWO_PI*Math.floor(e/s.TWO_PI),t-=s.TWO_PI*Math.floor(t/s.TWO_PI),o=Math.min(Math.abs(e-t),s.TWO_PI-Math.abs(e-t)),a&&(e=e<=s.HALF_PI?Math.atan(r/n*Math.tan(e)):e>s.HALF_PI&&e<=3*s.HALF_PI?Math.atan(r/n*Math.tan(e))+s.PI:Math.atan(r/n*Math.tan(e))+s.TWO_PI,t=t<=s.HALF_PI?Math.atan(r/n*Math.tan(t)):t>s.HALF_PI&&t<=3*s.HALF_PI?Math.atan(r/n*Math.tan(t))+s.PI:Math.atan(r/n*Math.tan(t))+s.TWO_PI),t<e&&(t+=s.TWO_PI),{start:e,stop:t,correspondToSamePoint:o<1e-5}},u.default.prototype.arc=function(e,t,r,n,a,o,i,s){if(u.default._validateParameters("arc",arguments),!this._renderer._doStroke&&!this._renderer._doFill)return this;if(a===o)return this;a=this._toRadians(a),o=this._toRadians(o),r=Math.abs(r),n=Math.abs(n);var l=c.default.modeAdjust(e,t,r,n,this._renderer._ellipseMode),p=this._normalizeArcAngles(a,o,l.w,l.h,!0);return p.correspondToSamePoint?this._renderer.ellipse([l.x,l.y,l.w,l.h,s]):this._renderer.arc(l.x,l.y,l.w,l.h,p.start,p.stop,i,s),this},u.default.prototype.ellipse=function(e,t,r,n,a){return u.default._validateParameters("ellipse",arguments),this._renderEllipse.apply(this,arguments)},u.default.prototype.circle=function(){u.default._validateParameters("circle",arguments);var e=Array.prototype.slice.call(arguments,0,2);return e.push(arguments[2]),e.push(arguments[2]),this._renderEllipse.apply(this,e)},u.default.prototype._renderEllipse=function(e,t,r,n,a){if(!this._renderer._doStroke&&!this._renderer._doFill)return this;r<0&&(r=Math.abs(r)),void 0===n?n=r:n<0&&(n=Math.abs(n));var o=c.default.modeAdjust(e,t,r,n,this._renderer._ellipseMode);return this._renderer.ellipse([o.x,o.y,o.w,o.h,a]),this},u.default.prototype.line=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];var n;u.default._validateParameters("line",t),this._renderer._doStroke&&(n=this._renderer).line.apply(n,t);return this},u.default.prototype.point=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];var n;u.default._validateParameters("point",t),this._renderer._doStroke&&(1===t.length&&t[0]instanceof u.default.Vector?this._renderer.point.call(this._renderer,t[0].x,t[0].y,t[0].z):(n=this._renderer).point.apply(n,t));return this},u.default.prototype.quad=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];var n;u.default._validateParameters("quad",t),(this._renderer._doStroke||this._renderer._doFill)&&(this._renderer.isP3D&&12!==t.length?this._renderer.quad.call(this._renderer,t[0],t[1],0,t[2],t[3],0,t[4],t[5],0,t[6],t[7],0):(n=this._renderer).quad.apply(n,t));return this},u.default.prototype.rect=function(){return u.default._validateParameters("rect",arguments),this._renderRect.apply(this,arguments)},u.default.prototype.square=function(e,t,r,n,a,o,i){return u.default._validateParameters("square",arguments),this._renderRect.call(this,e,t,r,r,n,a,o,i)},u.default.prototype._renderRect=function(){if(this._renderer._doStroke||this._renderer._doFill){3===arguments.length&&(arguments[3]=arguments[2]);for(var e=c.default.modeAdjust(arguments[0],arguments[1],arguments[2],arguments[3],this._renderer._rectMode),t=[e.x,e.y,e.w,e.h],r=4;r<arguments.length;r++)t[r]=arguments[r];this._renderer.rect(t);}return this},u.default.prototype.triangle=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return u.default._validateParameters("triangle",t),(this._renderer._doStroke||this._renderer._doFill)&&this._renderer.triangle(t),this};var a=u.default;r.default=a;},{"../constants":22,"../friendly_errors/fes_core":24,"../friendly_errors/file_errors":25,"../friendly_errors/validate_params":27,"../helpers":28,"../main":32}],40:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../main"))&&n.__esModule?n:{default:n},o=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../constants"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}a.default.prototype.ellipseMode=function(e){return a.default._validateParameters("ellipseMode",arguments),e!==o.CORNER&&e!==o.CORNERS&&e!==o.RADIUS&&e!==o.CENTER||(this._renderer._ellipseMode=e),this},a.default.prototype.noSmooth=function(){return this.setAttributes("antialias",!1),this._renderer.isP3D||"imageSmoothingEnabled"in this.drawingContext&&(this.drawingContext.imageSmoothingEnabled=!1),this},a.default.prototype.rectMode=function(e){return a.default._validateParameters("rectMode",arguments),e!==o.CORNER&&e!==o.CORNERS&&e!==o.RADIUS&&e!==o.CENTER||(this._renderer._rectMode=e),this},a.default.prototype.smooth=function(){return this.setAttributes("antialias",!0),this._renderer.isP3D||"imageSmoothingEnabled"in this.drawingContext&&(this.drawingContext.imageSmoothingEnabled=!0),this},a.default.prototype.strokeCap=function(e){return a.default._validateParameters("strokeCap",arguments),e!==o.ROUND&&e!==o.SQUARE&&e!==o.PROJECT||this._renderer.strokeCap(e),this},a.default.prototype.strokeJoin=function(e){return a.default._validateParameters("strokeJoin",arguments),e!==o.ROUND&&e!==o.BEVEL&&e!==o.MITER||this._renderer.strokeJoin(e),this},a.default.prototype.strokeWeight=function(e){return a.default._validateParameters("strokeWeight",arguments),this._renderer.strokeWeight(e),this};var l=a.default;r.default=l;},{"../constants":22,"../main":32}],41:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,s=(n=e("../main"))&&n.__esModule?n:{default:n};e("../friendly_errors/fes_core"),e("../friendly_errors/file_errors"),e("../friendly_errors/validate_params"),s.default.prototype.bezier=function(){for(var e,t=arguments.length,r=new Array(t),n=0;n<t;n++)r[n]=arguments[n];return s.default._validateParameters("bezier",r),(this._renderer._doStroke||this._renderer._doFill)&&(e=this._renderer).bezier.apply(e,r),this},s.default.prototype.bezierDetail=function(e){return s.default._validateParameters("bezierDetail",arguments),this._bezierDetail=e,this},s.default.prototype.bezierPoint=function(e,t,r,n,a){s.default._validateParameters("bezierPoint",arguments);var o=1-a;return Math.pow(o,3)*e+3*Math.pow(o,2)*a*t+3*o*Math.pow(a,2)*r+Math.pow(a,3)*n},s.default.prototype.bezierTangent=function(e,t,r,n,a){s.default._validateParameters("bezierTangent",arguments);var o=1-a;return 3*n*Math.pow(a,2)-3*r*Math.pow(a,2)+6*r*o*a-6*t*o*a+3*t*Math.pow(o,2)-3*e*Math.pow(o,2)},s.default.prototype.curve=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];var n;s.default._validateParameters("curve",t),this._renderer._doStroke&&(n=this._renderer).curve.apply(n,t);return this},s.default.prototype.curveDetail=function(e){return s.default._validateParameters("curveDetail",arguments),this._curveDetail=e<3?3:e,this},s.default.prototype.curveTightness=function(e){return s.default._validateParameters("curveTightness",arguments),this._renderer._curveTightness=e,this},s.default.prototype.curvePoint=function(e,t,r,n,a){s.default._validateParameters("curvePoint",arguments);var o=a*a*a,i=a*a;return e*(-.5*o+i-.5*a)+t*(1.5*o-2.5*i+1)+r*(-1.5*o+2*i+.5*a)+n*(.5*o-.5*i)},s.default.prototype.curveTangent=function(e,t,r,n,a){s.default._validateParameters("curveTangent",arguments);var o=a*a;return e*(-3*o/2+2*a-.5)+t*(9*o/2-5*a)+r*(-9*o/2+4*a+.5)+n*(3*o/2-a)};var a=s.default;r.default=a;},{"../friendly_errors/fes_core":24,"../friendly_errors/file_errors":25,"../friendly_errors/validate_params":27,"../main":32}],42:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,s=(n=e("../main"))&&n.__esModule?n:{default:n},l=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=p();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../constants"));function p(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return p=function(){return e},e}var a=null,u=[],c=[],d=!1,o=!1,h=!1,m=!1,f=!0;s.default.prototype.beginContour=function(){return c=[],m=!0,this},s.default.prototype.beginShape=function(e){var t;(s.default._validateParameters("beginShape",arguments),this._renderer.isP3D)?(t=this._renderer).beginShape.apply(t,arguments):(a=e===l.POINTS||e===l.LINES||e===l.TRIANGLES||e===l.TRIANGLE_FAN||e===l.TRIANGLE_STRIP||e===l.QUADS||e===l.QUAD_STRIP?e:null,u=[],c=[]);return this},s.default.prototype.bezierVertex=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];var n;if(s.default._validateParameters("bezierVertex",t),this._renderer.isP3D)(n=this._renderer).bezierVertex.apply(n,t);else if(0===u.length)s.default._friendlyError("vertex() must be used once before calling bezierVertex()","bezierVertex");else {d=!0;for(var a=[],o=0;o<t.length;o++)a[o]=t[o];a.isVert=!1,m?c.push(a):u.push(a);}return this},s.default.prototype.curveVertex=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];var n;(s.default._validateParameters("curveVertex",t),this._renderer.isP3D)?(n=this._renderer).curveVertex.apply(n,t):(o=!0,this.vertex(t[0],t[1]));return this},s.default.prototype.endContour=function(){var e=c[0].slice();e.isVert=c[0].isVert,e.moveTo=!1,c.push(e),f&&(u.push(u[0]),f=!1);for(var t=0;t<c.length;t++)u.push(c[t]);return this},s.default.prototype.endShape=function(e){if(s.default._validateParameters("endShape",arguments),this._renderer.isP3D)this._renderer.endShape(e,o,d,h,m,a);else {if(0===u.length)return this;if(!this._renderer._doStroke&&!this._renderer._doFill)return this;var t=e===l.CLOSE;t&&!m&&u.push(u[0]),this._renderer.endShape(e,u,o,d,h,m,a),f=!(m=h=d=o=!1),t&&u.pop();}return this},s.default.prototype.quadraticVertex=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];if(s.default._validateParameters("quadraticVertex",t),this._renderer.isP3D){var n;(n=this._renderer).quadraticVertex.apply(n,t);}else {if(this._contourInited){var a={};return a.x=t[0],a.y=t[1],a.x3=t[2],a.y3=t[3],a.type=l.QUADRATIC,this._contourVertices.push(a),this}if(0<u.length){h=!0;for(var o=[],i=0;i<t.length;i++)o[i]=t[i];o.isVert=!1,m?c.push(o):u.push(o);}else s.default._friendlyError("vertex() must be used once before calling quadraticVertex()","quadraticVertex");}return this},s.default.prototype.vertex=function(e,t,r,n,a){if(this._renderer.isP3D){var o;(o=this._renderer).vertex.apply(o,arguments);}else {var i=[];i.isVert=!0,i[0]=e,i[1]=t,i[2]=0,i[3]=0,i[4]=0,i[5]=this._renderer._getFill(),i[6]=this._renderer._getStroke(),r&&(i.moveTo=r),m?(0===c.length&&(i.moveTo=!0),c.push(i)):u.push(i);}return this};var y=s.default;r.default=y;},{"../constants":22,"../main":32}],43:[function(e,t,r){function n(e){return (n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}window.requestAnimationFrame=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(e,t){window.setTimeout(e,1e3/60);},"undefined"==typeof Uint8ClampedArray||Uint8ClampedArray.prototype.slice||Object.defineProperty(Uint8ClampedArray.prototype,"slice",{value:Array.prototype.slice,writable:!0,configurable:!0,enumerable:!1}),function(){if(!Object.assign){var s=Object.keys,e=Object.defineProperty,l="function"==typeof Symbol&&"symbol"===n(Symbol()),r=Object.prototype.propertyIsEnumerable,p=function(t){return function(e){return r.call(t,e)}};e(Object,"assign",{value:function(e,t){if(null==e)throw new TypeError("target must be an object");var r,n,a,o,i=Object(e);for(r=1;r<arguments.length;++r)for(n=Object(arguments[r]),o=s(n),l&&Object.getOwnPropertySymbols&&o.push.apply(o,Object.getOwnPropertySymbols(n).filter(p(n))),a=0;a<o.length;++a)i[o[a]]=n[o[a]];return i},configurable:!0,enumerable:!1,writable:!0});}}();},{}],44:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("./main"))&&n.__esModule?n:{default:n};a.default.prototype.noLoop=function(){this._loop=!1;},a.default.prototype.loop=function(){this._loop||(this._loop=!0,this._setupDone&&this._draw());},a.default.prototype.isLooping=function(){return this._loop},a.default.prototype.push=function(){this._styles.push({props:{_colorMode:this._colorMode},renderer:this._renderer.push()});},a.default.prototype.pop=function(){var e=this._styles.pop();e?(this._renderer.pop(e.renderer),Object.assign(this,e.props)):console.warn("pop() was called without matching push()");},a.default.prototype.redraw=function(e){if(!this._inUserDraw&&this._setupDone){var t=parseInt(e);(isNaN(t)||t<1)&&(t=1);var r=this._isGlobal?window:this,n=r.setup,a=r.draw;if("function"==typeof a){void 0===n&&r.scale(r._pixelDensity,r._pixelDensity);for(var o=function(e){e.call(r);},i=0;i<t;i++){r.resetMatrix(),r._renderer.isP3D&&r._renderer._update(),r._setProperty("frameCount",r.frameCount+1),r._registeredMethods.pre.forEach(o),this._inUserDraw=!0;try{a();}finally{this._inUserDraw=!1;}r._registeredMethods.post.forEach(o);}}}};var o=a.default;r.default=o;},{"./main":32}],45:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,o=(n=e("./main"))&&n.__esModule?n:{default:n};o.default.prototype.applyMatrix=function(e,t,r,n,a,o){var i;return (i=this._renderer).applyMatrix.apply(i,arguments),this},o.default.prototype.resetMatrix=function(){return this._renderer.resetMatrix(),this},o.default.prototype.rotate=function(e,t){return o.default._validateParameters("rotate",arguments),this._renderer.rotate(this._toRadians(e),t),this},o.default.prototype.rotateX=function(e){return this._assert3d("rotateX"),o.default._validateParameters("rotateX",arguments),this._renderer.rotateX(this._toRadians(e)),this},o.default.prototype.rotateY=function(e){return this._assert3d("rotateY"),o.default._validateParameters("rotateY",arguments),this._renderer.rotateY(this._toRadians(e)),this},o.default.prototype.rotateZ=function(e){return this._assert3d("rotateZ"),o.default._validateParameters("rotateZ",arguments),this._renderer.rotateZ(this._toRadians(e)),this},o.default.prototype.scale=function(e,t,r){if(o.default._validateParameters("scale",arguments),e instanceof o.default.Vector){var n=e;e=n.x,t=n.y,r=n.z;}else if(e instanceof Array){var a=e;e=a[0],t=a[1],r=a[2]||1;}return isNaN(t)?t=r=e:isNaN(r)&&(r=1),this._renderer.scale.call(this._renderer,e,t,r),this},o.default.prototype.shearX=function(e){o.default._validateParameters("shearX",arguments);var t=this._toRadians(e);return this._renderer.applyMatrix(1,0,Math.tan(t),1,0,0),this},o.default.prototype.shearY=function(e){o.default._validateParameters("shearY",arguments);var t=this._toRadians(e);return this._renderer.applyMatrix(1,Math.tan(t),0,1,0,0),this},o.default.prototype.translate=function(e,t,r){return o.default._validateParameters("translate",arguments),this._renderer.isP3D?this._renderer.translate(e,t,r):this._renderer.translate(e,t),this};var a=o.default;r.default=a;},{"./main":32}],46:[function(e,t,r){var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};function o(e){return function(e){if(Array.isArray(e)){for(var t=0,r=new Array(e.length);t<e.length;t++)r[t]=e[t];return r}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}a.default.prototype.storeItem=function(e,t){"string"!=typeof e&&console.log("The argument that you passed to storeItem() - ".concat(e," is not a string.")),e.endsWith("p5TypeID")&&console.log("The argument that you passed to storeItem() - ".concat(e," must not end with 'p5TypeID'.")),void 0===t&&console.log("You cannot store undefined variables using storeItem().");var r=i(t);switch(r){case"number":case"boolean":t=t.toString();break;case"object":if(t instanceof a.default.Color)r="p5.Color";else if(t instanceof a.default.Vector){r="p5.Vector",t=[t.x,t.y,t.z];}t=JSON.stringify(t);}localStorage.setItem(e,t);var n="".concat(e,"p5TypeID");localStorage.setItem(n,r);},a.default.prototype.getItem=function(e){var t=localStorage.getItem(e),r=localStorage.getItem("".concat(e,"p5TypeID"));if(void 0===r)console.log("Unable to determine type of item stored under ".concat(e,"in local storage. Did you save the item with something other than setItem()?"));else if(null!==t)switch(r){case"number":t=parseInt(t);break;case"boolean":t="true"===t;break;case"object":t=JSON.parse(t);break;case"p5.Color":t=JSON.parse(t),t=this.color.apply(this,o(t.levels));break;case"p5.Vector":t=JSON.parse(t),t=this.createVector.apply(this,o(t));}return t},a.default.prototype.clearStorage=function(){localStorage.clear();},a.default.prototype.removeItem=function(e){"string"!=typeof e&&console.log("The argument that you passed to removeItem() - ".concat(e," is not a string.")),localStorage.removeItem(e),localStorage.removeItem("".concat(e,"p5TypeID"));};},{"../core/main":32}],47:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};a.default.prototype.createStringDict=function(e,t){return a.default._validateParameters("createStringDict",arguments),new a.default.StringDict(e,t)},a.default.prototype.createNumberDict=function(e,t){return a.default._validateParameters("createNumberDict",arguments),new a.default.NumberDict(e,t)},a.default.TypedDict=function(e,t){return e instanceof Object?this.data=e:(this.data={},this.data[e]=t),this},a.default.TypedDict.prototype.size=function(){return Object.keys(this.data).length},a.default.TypedDict.prototype.hasKey=function(e){return this.data.hasOwnProperty(e)},a.default.TypedDict.prototype.get=function(e){if(this.data.hasOwnProperty(e))return this.data[e];console.log("".concat(e," does not exist in this Dictionary"));},a.default.TypedDict.prototype.set=function(e,t){this._validate(t)?this.data[e]=t:console.log("Those values dont work for this dictionary type.");},a.default.TypedDict.prototype._addObj=function(e){for(var t in e)this.set(t,e[t]);},a.default.TypedDict.prototype.create=function(e,t){e instanceof Object&&void 0===t?this._addObj(e):void 0!==e?this.set(e,t):console.log("In order to create a new Dictionary entry you must pass an object or a key, value pair");},a.default.TypedDict.prototype.clear=function(){this.data={};},a.default.TypedDict.prototype.remove=function(e){if(!this.data.hasOwnProperty(e))throw new Error("".concat(e," does not exist in this Dictionary"));delete this.data[e];},a.default.TypedDict.prototype.print=function(){for(var e in this.data)console.log("key:".concat(e," value:").concat(this.data[e]));},a.default.TypedDict.prototype.saveTable=function(e){var t="";for(var r in this.data)t+="".concat(r,",").concat(this.data[r],"\n");var n=new Blob([t],{type:"text/csv"});a.default.prototype.downloadFile(n,e||"mycsv","csv");},a.default.TypedDict.prototype.saveJSON=function(e,t){a.default.prototype.saveJSON(this.data,e,t);},a.default.TypedDict.prototype._validate=function(e){return !0},a.default.StringDict=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];a.default.TypedDict.apply(this,t);},a.default.StringDict.prototype=Object.create(a.default.TypedDict.prototype),a.default.StringDict.prototype._validate=function(e){return "string"==typeof e},a.default.NumberDict=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];a.default.TypedDict.apply(this,t);},a.default.NumberDict.prototype=Object.create(a.default.TypedDict.prototype),a.default.NumberDict.prototype._validate=function(e){return "number"==typeof e},a.default.NumberDict.prototype.add=function(e,t){this.data.hasOwnProperty(e)?this.data[e]+=t:console.log("The key - ".concat(e," does not exist in this dictionary."));},a.default.NumberDict.prototype.sub=function(e,t){this.add(e,-t);},a.default.NumberDict.prototype.mult=function(e,t){this.data.hasOwnProperty(e)?this.data[e]*=t:console.log("The key - ".concat(e," does not exist in this dictionary."));},a.default.NumberDict.prototype.div=function(e,t){this.data.hasOwnProperty(e)?this.data[e]/=t:console.log("The key - ".concat(e," does not exist in this dictionary."));},a.default.NumberDict.prototype._valueTest=function(e){if(0===Object.keys(this.data).length)throw new Error("Unable to search for a minimum or maximum value on an empty NumberDict");if(1===Object.keys(this.data).length)return this.data[Object.keys(this.data)[0]];var t=this.data[Object.keys(this.data)[0]];for(var r in this.data)this.data[r]*e<t*e&&(t=this.data[r]);return t},a.default.NumberDict.prototype.minValue=function(){return this._valueTest(1)},a.default.NumberDict.prototype.maxValue=function(){return this._valueTest(-1)},a.default.NumberDict.prototype._keyTest=function(e){if(0===Object.keys(this.data).length)throw new Error("Unable to use minValue on an empty NumberDict");if(1===Object.keys(this.data).length)return Object.keys(this.data)[0];for(var t=Object.keys(this.data)[0],r=1;r<Object.keys(this.data).length;r++)Object.keys(this.data)[r]*e<t*e&&(t=Object.keys(this.data)[r]);return t},a.default.NumberDict.prototype.minKey=function(){return this._keyTest(1)},a.default.NumberDict.prototype.maxKey=function(){return this._keyTest(-1)};var o=a.default.TypedDict;r.default=o;},{"../core/main":32}],48:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,d=(n=e("../core/main"))&&n.__esModule?n:{default:n};function h(e){return (h="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function f(e,t,r){(t._userNode?t._userNode:document.body).appendChild(e);var n=r?new d.default.MediaElement(e,t):new d.default.Element(e,t);return t._elements.push(n),n}function a(e,t,r,n){var a=document.createElement(t);"string"==typeof(r=r||"")&&(r=[r]);var o=!0,i=!1,s=void 0;try{for(var l,p=r[Symbol.iterator]();!(o=(l=p.next()).done);o=!0){var u=l.value,c=document.createElement("source");c.setAttribute("src",u),a.appendChild(c);}}catch(e){i=!0,s=e;}finally{try{o||null==p.return||p.return();}finally{if(i)throw s}}if("function"==typeof n){a.addEventListener("canplaythrough",function e(){n(),a.removeEventListener("canplaythrough",e);});}var d=f(a,e,!0);return d.loadedmetadata=!1,a.addEventListener("loadedmetadata",function(){d.width=a.videoWidth,d.height=a.videoHeight,0===d.elt.width&&(d.elt.width=a.videoWidth),0===d.elt.height&&(d.elt.height=a.videoHeight),d.presetPlaybackRate&&(d.elt.playbackRate=d.presetPlaybackRate,delete d.presetPlaybackRate),d.loadedmetadata=!0;}),d}d.default.prototype.select=function(e,t){d.default._validateParameters("select",arguments);var r=this._getContainer(t).querySelector(e);return r?this._wrapElement(r):null},d.default.prototype.selectAll=function(e,t){d.default._validateParameters("selectAll",arguments);var r=[],n=this._getContainer(t).querySelectorAll(e);if(n)for(var a=0;a<n.length;a++){var o=this._wrapElement(n[a]);r.push(o);}return r},d.default.prototype._getContainer=function(e){var t=document;return "string"==typeof e?t=document.querySelector(e)||document:e instanceof d.default.Element?t=e.elt:e instanceof HTMLElement&&(t=e),t},d.default.prototype._wrapElement=function(e){var t=Array.prototype.slice.call(e.children);if("INPUT"!==e.tagName||"checkbox"!==e.type)return "VIDEO"===e.tagName||"AUDIO"===e.tagName?new d.default.MediaElement(e,this):"SELECT"===e.tagName?this.createSelect(new d.default.Element(e,this)):0<t.length&&t.every(function(e){return "INPUT"===e.tagName||"LABEL"===e.tagName})?this.createRadio(new d.default.Element(e,this)):new d.default.Element(e,this);var r=new d.default.Element(e,this);return r.checked=function(){return 0===arguments.length?this.elt.checked:(this.elt.checked=!!arguments[0],this)},r},d.default.prototype.removeElements=function(e){d.default._validateParameters("removeElements",arguments);this._elements.filter(function(e){return !(e.elt instanceof HTMLCanvasElement)}).map(function(e){return e.remove()});},d.default.Element.prototype.changed=function(e){return d.default.Element._adjustListener("change",e,this),this},d.default.Element.prototype.input=function(e){return d.default.Element._adjustListener("input",e,this),this},d.default.prototype.createDiv=function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:"",t=document.createElement("div");return t.innerHTML=e,f(t,this)},d.default.prototype.createP=function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:"",t=document.createElement("p");return t.innerHTML=e,f(t,this)},d.default.prototype.createSpan=function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:"",t=document.createElement("span");return t.innerHTML=e,f(t,this)},d.default.prototype.createImg=function(){d.default._validateParameters("createImg",arguments);var t,r=document.createElement("img"),n=arguments;return 1<n.length&&"string"==typeof n[1]&&(r.alt=n[1]),2<n.length&&"string"==typeof n[2]&&(r.crossOrigin=n[2]),r.src=n[0],t=f(r,this),r.addEventListener("load",function(){t.width=r.offsetWidth||r.width,t.height=r.offsetHeight||r.height;var e=n[n.length-1];"function"==typeof e&&e(t);}),t},d.default.prototype.createA=function(e,t,r){d.default._validateParameters("createA",arguments);var n=document.createElement("a");return n.href=e,n.innerHTML=t,r&&(n.target=r),f(n,this)},d.default.prototype.createSlider=function(e,t,r,n){d.default._validateParameters("createSlider",arguments);var a=document.createElement("input");return a.type="range",a.min=e,a.max=t,0===n?a.step=1e-18:n&&(a.step=n),"number"==typeof r&&(a.value=r),f(a,this)},d.default.prototype.createButton=function(e,t){d.default._validateParameters("createButton",arguments);var r=document.createElement("button");return r.innerHTML=e,t&&(r.value=t),f(r,this)},d.default.prototype.createCheckbox=function(){d.default._validateParameters("createCheckbox",arguments);var e=document.createElement("div"),t=document.createElement("input");t.type="checkbox",e.appendChild(t);var r=f(e,this);if(r.checked=function(){var e=r.elt.getElementsByTagName("input")[0];if(e){if(0===arguments.length)return e.checked;e.checked=!!arguments[0];}return r},this.value=function(e){return r.value=e,this},arguments[0]){var n=Math.random().toString(36).slice(2),a=document.createElement("label");t.setAttribute("id",n),a.htmlFor=n,r.value(arguments[0]),a.appendChild(document.createTextNode(arguments[0])),e.appendChild(a);}return arguments[1]&&(t.checked=!0),r},d.default.prototype.createSelect=function(){var e;d.default._validateParameters("createSelect",arguments);var t=arguments[0];if(t instanceof d.default.Element&&t.elt instanceof HTMLSelectElement)e=t,this.elt=t.elt;else if(t instanceof HTMLSelectElement)e=f(t,this),this.elt=t;else {var r=document.createElement("select");t&&"boolean"==typeof t&&r.setAttribute("multiple","true"),e=f(r,this),this.elt=r;}return e.option=function(e,t){var r;if(void 0!==e){for(var n=0;n<this.elt.length;n+=1)if(this.elt[n].innerHTML===e){r=n;break}if(void 0!==r)!1===t?this.elt.remove(r):this.elt[r].value=t;else {var a=document.createElement("option");a.innerHTML=e,a.value=void 0===t?e:t,this.elt.appendChild(a),this._pInst._elements.push(a);}}},e.selected=function(e){if(void 0!==e){for(var t=0;t<this.elt.length;t+=1)this.elt[t].value.toString()===e.toString()&&(this.elt.selectedIndex=t);return this}if(this.elt.getAttribute("multiple")){var r=[],n=!0,a=!1,o=void 0;try{for(var i,s=this.elt.selectedOptions[Symbol.iterator]();!(n=(i=s.next()).done);n=!0){var l=i.value;r.push(l.value);}}catch(e){a=!0,o=e;}finally{try{n||null==s.return||s.return();}finally{if(a)throw o}}return r}return this.elt.value},e.disable=function(e){if("string"==typeof e)for(var t=0;t<this.elt.length;t++)this.elt[t].value.toString()===e&&(this.elt[t].disabled=!0,this.elt[t].selected=!1);else this.elt.disabled=!0;return this},e},d.default.prototype.createRadio=function(){var e,t,r=arguments[0];r instanceof HTMLDivElement||r instanceof HTMLSpanElement?(e=r,"string"==typeof arguments[1]&&(t=arguments[1])):("string"==typeof r&&(t=r),e=document.createElement("div"));var m=f(this.elt=e,this);m._name=t||"radioOption";function n(e){return e instanceof HTMLInputElement&&"radio"===e.type}function u(e){return e.nextElementSibling instanceof HTMLLabelElement}return m._getOptionsArray=function(){return Array.from(this.elt.children).filter(n)},m.option=function(e,t){var r,n,a=!0,o=!1,i=void 0;try{for(var s,l=m._getOptionsArray()[Symbol.iterator]();!(a=(s=l.next()).done);a=!0){var p=s.value;if(p.value===e){r=p;break}}}catch(e){o=!0,i=e;}finally{try{a||null==l.return||l.return();}finally{if(o)throw i}}return void 0===r&&((r=document.createElement("input")).setAttribute("type","radio"),r.setAttribute("value",e),this.elt.appendChild(r)),u(r)?n=r.nextElementSibling:(n=document.createElement("label"),r.insertAdjacentElement("afterend",n)),n.innerHTML=void 0===t?e:t,r.setAttribute("name",m._name),r},m.remove=function(e){var t=!0,r=!1,n=void 0;try{for(var a,o=m._getOptionsArray()[Symbol.iterator]();!(t=(a=o.next()).done);t=!0){var i=a.value;if(i.value===e)return u(i)&&i.nextElementSibling.remove(),void i.remove()}}catch(e){r=!0,n=e;}finally{try{t||null==o.return||o.return();}finally{if(r)throw n}}},m.value=function(){var e="",t=!0,r=!1,n=void 0;try{for(var a,o=m._getOptionsArray()[Symbol.iterator]();!(t=(a=o.next()).done);t=!0){var i=a.value;if(i.checked){e=i.value;break}}}catch(e){r=!0,n=e;}finally{try{t||null==o.return||o.return();}finally{if(r)throw n}}return e},m.selected=function(e){var t=null;if(void 0===e){var r=!0,n=!1,a=void 0;try{for(var o,i=m._getOptionsArray()[Symbol.iterator]();!(r=(o=i.next()).done);r=!0){var s=o.value;if(s.checked){t=s;break}}}catch(e){n=!0,a=e;}finally{try{r||null==i.return||i.return();}finally{if(n)throw a}}}else {var l=!0,p=!1,u=void 0;try{for(var c,d=m._getOptionsArray()[Symbol.iterator]();!(l=(c=d.next()).done);l=!0){var h=c.value;h.value===e&&(h.setAttribute("checked",!0),t=h);}}catch(e){p=!0,u=e;}finally{try{l||null==d.return||d.return();}finally{if(p)throw u}}}return t},m.disable=function(){var e=!(0<arguments.length&&void 0!==arguments[0])||arguments[0],t=!0,r=!1,n=void 0;try{for(var a,o=m._getOptionsArray()[Symbol.iterator]();!(t=(a=o.next()).done);t=!0){a.value.setAttribute("disabled",e);}}catch(e){r=!0,n=e;}finally{try{t||null==o.return||o.return();}finally{if(r)throw n}}},m},d.default.prototype.createColorPicker=function(e){d.default._validateParameters("createColorPicker",arguments);var t,r=document.createElement("input");return r.type="color",e?e instanceof d.default.Color?r.value=e.toString("#rrggbb"):(d.default.prototype._colorMode="rgb",d.default.prototype._colorMaxes={rgb:[255,255,255,255],hsb:[360,100,100,1],hsl:[360,100,100,1]},r.value=d.default.prototype.color(e).toString("#rrggbb")):r.value="#000000",(t=f(r,this)).color=function(){return e&&(e.mode&&(d.default.prototype._colorMode=e.mode),e.maxes&&(d.default.prototype._colorMaxes=e.maxes)),d.default.prototype.color(this.elt.value)},t},d.default.prototype.createInput=function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:"",t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:"text";d.default._validateParameters("createInput",arguments);var r=document.createElement("input");return r.setAttribute("value",e),r.setAttribute("type",t),f(r,this)},d.default.prototype.createFileInput=function(s){var e=1<arguments.length&&void 0!==arguments[1]&&arguments[1];d.default._validateParameters("createFileInput",arguments);if(window.File&&window.FileReader&&window.FileList&&window.Blob){var t=document.createElement("input");return t.setAttribute("type","file"),e&&t.setAttribute("multiple",!0),t.addEventListener("change",function(e){var t=!0,r=!1,n=void 0;try{for(var a,o=e.target.files[Symbol.iterator]();!(t=(a=o.next()).done);t=!0){var i=a.value;d.default.File._load(i,s);}}catch(e){r=!0,n=e;}finally{try{t||null==o.return||o.return();}finally{if(r)throw n}}},!1),f(t,this)}console.log("The File APIs are not fully supported in this browser. Cannot create element.");},d.default.prototype.createVideo=function(e,t){return d.default._validateParameters("createVideo",arguments),a(this,"video",e,t)},d.default.prototype.createAudio=function(e,t){return d.default._validateParameters("createAudio",arguments),a(this,"audio",e,t)},d.default.prototype.VIDEO="video",d.default.prototype.AUDIO="audio",void 0===navigator.mediaDevices&&(navigator.mediaDevices={}),void 0===navigator.mediaDevices.getUserMedia&&(navigator.mediaDevices.getUserMedia=function(r){var n=navigator.webkitGetUserMedia||navigator.mozGetUserMedia;return n?new Promise(function(e,t){n.call(navigator,r,e,t);}):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}),d.default.prototype.createCapture=function(){if(d.default._validateParameters("createCapture",arguments),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new DOMException("getUserMedia not supported in this browser");var e,t,r=!0,n=!0,a=!0,o=!1,i=void 0;try{for(var s,l=arguments[Symbol.iterator]();!(a=(s=l.next()).done);a=!0){var p=s.value;p===d.default.prototype.VIDEO?n=!1:p===d.default.prototype.AUDIO?r=!1:"object"===h(p)?e=p:"function"==typeof p&&(t=p);}}catch(e){o=!0,i=e;}finally{try{a||null==l.return||l.return();}finally{if(o)throw i}}e=e||{video:r,audio:n};var u=document.createElement("video");u.setAttribute("playsinline",""),navigator.mediaDevices.getUserMedia(e).then(function(t){try{"srcObject"in u?u.srcObject=t:u.src=window.URL.createObjectURL(t);}catch(e){u.src=t;}},console.log);var c=f(u,this,!0);return c.loadedmetadata=!1,u.addEventListener("loadedmetadata",function(){u.play(),u.width?(c.width=u.width,c.height=u.height):(c.width=c.elt.width=u.videoWidth,c.height=c.elt.height=u.videoHeight),c.loadedmetadata=!0,t&&t(u.srcObject);}),c},d.default.prototype.createElement=function(e,t){d.default._validateParameters("createElement",arguments);var r=document.createElement(e);return void 0!==t&&(r.innerHTML=t),f(r,this)},d.default.Element.prototype.addClass=function(e){return this.elt.className?this.hasClass(e)||(this.elt.className=this.elt.className+" "+e):this.elt.className=e,this},d.default.Element.prototype.removeClass=function(e){return this.elt.classList.remove(e),this},d.default.Element.prototype.hasClass=function(e){return this.elt.classList.contains(e)},d.default.Element.prototype.toggleClass=function(e){return this.elt.classList.contains(e)?this.elt.classList.remove(e):this.elt.classList.add(e),this},d.default.Element.prototype.child=function(e){return void 0===e?this.elt.childNodes:("string"==typeof e?("#"===e[0]&&(e=e.substring(1)),e=document.getElementById(e)):e instanceof d.default.Element&&(e=e.elt),e instanceof HTMLElement&&this.elt.appendChild(e),this)},d.default.Element.prototype.center=function(e){var t=this.elt.style.display,r="none"===this.elt.style.display,n="none"===this.parent().style.display,a={x:this.elt.offsetLeft,y:this.elt.offsetTop};r&&this.show(),n&&this.parent().show(),this.elt.style.display="block",this.position(0,0);var o=Math.abs(this.parent().offsetWidth-this.elt.offsetWidth),i=Math.abs(this.parent().offsetHeight-this.elt.offsetHeight);return "both"===e||void 0===e?this.position(o/2+this.parent().offsetLeft,i/2+this.parent().offsetTop):"horizontal"===e?this.position(o/2+this.parent().offsetLeft,a.y):"vertical"===e&&this.position(a.x,i/2+this.parent().offsetTop),this.style("display",t),r&&this.hide(),n&&this.parent().hide(),this},d.default.Element.prototype.html=function(){return 0===arguments.length?this.elt.innerHTML:(arguments[1]?this.elt.insertAdjacentHTML("beforeend",arguments[0]):this.elt.innerHTML=arguments[0],this)},d.default.Element.prototype.position=function(){if(0===arguments.length)return {x:this.elt.offsetLeft,y:this.elt.offsetTop};var e="absolute";return "static"!==arguments[2]&&"fixed"!==arguments[2]&&"relative"!==arguments[2]&&"sticky"!==arguments[2]&&"initial"!==arguments[2]&&"inherit"!==arguments[2]||(e=arguments[2]),this.elt.style.position=e,this.elt.style.left=arguments[0]+"px",this.elt.style.top=arguments[1]+"px",this.x=arguments[0],this.y=arguments[1],this},d.default.Element.prototype._translate=function(){this.elt.style.position="absolute";var e="";return this.elt.style.transform&&(e=(e=this.elt.style.transform.replace(/translate3d\(.*\)/g,"")).replace(/translate[X-Z]?\(.*\)/g,"")),2===arguments.length?this.elt.style.transform="translate("+arguments[0]+"px, "+arguments[1]+"px)":2<arguments.length&&(this.elt.style.transform="translate3d("+arguments[0]+"px,"+arguments[1]+"px,"+arguments[2]+"px)",this.elt.parentElement.style.perspective=3===arguments.length?"1000px":arguments[3]+"px"),this.elt.style.transform+=e,this},d.default.Element.prototype._rotate=function(){var e="";return this.elt.style.transform&&(e=(e=this.elt.style.transform.replace(/rotate3d\(.*\)/g,"")).replace(/rotate[X-Z]?\(.*\)/g,"")),1===arguments.length?this.elt.style.transform="rotate("+arguments[0]+"deg)":2===arguments.length?this.elt.style.transform="rotate("+arguments[0]+"deg, "+arguments[1]+"deg)":3===arguments.length&&(this.elt.style.transform="rotateX("+arguments[0]+"deg)",this.elt.style.transform+="rotateY("+arguments[1]+"deg)",this.elt.style.transform+="rotateZ("+arguments[2]+"deg)"),this.elt.style.transform+=e,this},d.default.Element.prototype.style=function(e,t){if(t instanceof d.default.Color&&(t="rgba("+t.levels[0]+","+t.levels[1]+","+t.levels[2]+","+t.levels[3]/255+")"),void 0===t){if(-1===e.indexOf(":"))return window.getComputedStyle(this.elt).getPropertyValue(e);for(var r=e.split(";"),n=0;n<r.length;n++){var a=r[n].split(":");a[0]&&a[1]&&(this.elt.style[a[0].trim()]=a[1].trim());}}else if(this.elt.style[e]=t,"width"===e||"height"===e||"left"===e||"top"===e){var o=window.getComputedStyle(this.elt).getPropertyValue(e).replace(/\D+/g,"");this[e]=parseInt(o,10);}return this},d.default.Element.prototype.attribute=function(e,t){if(null==this.elt.firstChild||"checkbox"!==this.elt.firstChild.type&&"radio"!==this.elt.firstChild.type)return void 0===t?this.elt.getAttribute(e):(this.elt.setAttribute(e,t),this);if(void 0===t)return this.elt.firstChild.getAttribute(e);for(var r=0;r<this.elt.childNodes.length;r++)this.elt.childNodes[r].setAttribute(e,t);},d.default.Element.prototype.removeAttribute=function(e){if(null!=this.elt.firstChild&&("checkbox"===this.elt.firstChild.type||"radio"===this.elt.firstChild.type))for(var t=0;t<this.elt.childNodes.length;t++)this.elt.childNodes[t].removeAttribute(e);return this.elt.removeAttribute(e),this},d.default.Element.prototype.value=function(){return 0<arguments.length?(this.elt.value=arguments[0],this):"range"===this.elt.type?parseFloat(this.elt.value):this.elt.value},d.default.Element.prototype.show=function(){return this.elt.style.display="block",this},d.default.Element.prototype.hide=function(){return this.elt.style.display="none",this},d.default.Element.prototype.size=function(e,t){if(0===arguments.length)return {width:this.elt.offsetWidth,height:this.elt.offsetHeight};var r=e,n=t,a=d.default.prototype.AUTO;if(r!==a||n!==a){if(r===a?r=t*this.width/this.height:n===a&&(n=e*this.height/this.width),this.elt instanceof HTMLCanvasElement){var o,i={},s=this.elt.getContext("2d");for(o in s)i[o]=s[o];for(o in this.elt.setAttribute("width",r*this._pInst._pixelDensity),this.elt.setAttribute("height",n*this._pInst._pixelDensity),this.elt.style.width=r+"px",this.elt.style.height=n+"px",this._pInst.scale(this._pInst._pixelDensity,this._pInst._pixelDensity),i)this.elt.getContext("2d")[o]=i[o];}else this.elt.style.width=r+"px",this.elt.style.height=n+"px",this.elt.width=r,this.elt.height=n;this.width=this.elt.offsetWidth,this.height=this.elt.offsetHeight,this._pInst&&this._pInst._curElement&&this._pInst._curElement.elt===this.elt&&(this._pInst._setProperty("width",this.elt.offsetWidth),this._pInst._setProperty("height",this.elt.offsetHeight));}return this},d.default.Element.prototype.remove=function(){this instanceof d.default.MediaElement&&this.elt.srcObject.getTracks().forEach(function(e){e.stop();});var e=this._pInst._elements.indexOf(this);for(var t in -1!==e&&this._pInst._elements.splice(e,1),this._events)this.elt.removeEventListener(t,this._events[t]);this.elt&&this.elt.parentNode&&this.elt.parentNode.removeChild(this.elt);},d.default.Element.prototype.drop=function(a,o){if(window.File&&window.FileReader&&window.FileList&&window.Blob){if(!this._dragDisabled){this._dragDisabled=!0;var e=function(e){e.preventDefault();};this.elt.addEventListener("dragover",e),this.elt.addEventListener("dragleave",e);}d.default.Element._attachListener("drop",function(e){e.preventDefault(),"function"==typeof o&&o.call(this,e);for(var t=e.dataTransfer.files,r=0;r<t.length;r++){var n=t[r];d.default.File._load(n,a);}},this);}else console.log("The File APIs are not fully supported in this browser.");return this},d.default.MediaElement=function(n,e){d.default.Element.call(this,n,e);var a=this;this.elt.crossOrigin="anonymous",this._prevTime=0,this._cueIDCounter=0,this._cues=[],(this._pixelsState=this)._pixelDensity=1,this._modified=!1,Object.defineProperty(a,"src",{get:function(){var e=a.elt.children[0].src,t=a.elt.src===window.location.href?"":a.elt.src;return e===window.location.href?t:e},set:function(e){for(var t=0;t<a.elt.children.length;t++)a.elt.removeChild(a.elt.children[t]);var r=document.createElement("source");r.src=e,n.appendChild(r),a.elt.src=e,a.modified=!0;}}),a._onended=function(){},a.elt.onended=function(){a._onended(a);};},d.default.MediaElement.prototype=Object.create(d.default.Element.prototype),d.default.MediaElement.prototype.play=function(){var e;return this.elt.currentTime===this.elt.duration&&(this.elt.currentTime=0),(e=(1<this.elt.readyState||this.elt.load(),this.elt.play()))&&e.catch&&e.catch(function(e){"NotAllowedError"===e.name?d.default._friendlyAutoplayError(this.src):console.error("Media play method encountered an unexpected error",e);}),this},d.default.MediaElement.prototype.stop=function(){return this.elt.pause(),this.elt.currentTime=0,this},d.default.MediaElement.prototype.pause=function(){return this.elt.pause(),this},d.default.MediaElement.prototype.loop=function(){return this.elt.setAttribute("loop",!0),this.play(),this},d.default.MediaElement.prototype.noLoop=function(){return this.elt.removeAttribute("loop"),this},d.default.MediaElement.prototype._setupAutoplayFailDetection=function(){var e=this,t=setTimeout(function(){return d.default._friendlyAutoplayError(e.src)},500);this.elt.addEventListener("play",function(){return clearTimeout(t)},{passive:!0,once:!0});},d.default.MediaElement.prototype.autoplay=function(e){var t=this,r=this.elt.getAttribute("autoplay");if(this.elt.setAttribute("autoplay",e),e&&!r){var n=function(){return t._setupAutoplayFailDetection()};4===this.elt.readyState?n():this.elt.addEventListener("canplay",n,{passive:!0,once:!0});}return this},d.default.MediaElement.prototype.volume=function(e){if(void 0===e)return this.elt.volume;this.elt.volume=e;},d.default.MediaElement.prototype.speed=function(e){if(void 0===e)return this.presetPlaybackRate||this.elt.playbackRate;this.loadedmetadata?this.elt.playbackRate=e:this.presetPlaybackRate=e;},d.default.MediaElement.prototype.time=function(e){return void 0===e?this.elt.currentTime:(this.elt.currentTime=e,this)},d.default.MediaElement.prototype.duration=function(){return this.elt.duration},d.default.MediaElement.prototype.pixels=[],d.default.MediaElement.prototype._ensureCanvas=function(){this.canvas||(this.canvas=document.createElement("canvas"),this.drawingContext=this.canvas.getContext("2d"),this.setModified(!0)),this.loadedmetadata&&(this.canvas.width!==this.elt.width&&(this.canvas.width=this.elt.width,this.canvas.height=this.elt.height,this.width=this.canvas.width,this.height=this.canvas.height),this.drawingContext.drawImage(this.elt,0,0,this.canvas.width,this.canvas.height),this.setModified(!0));},d.default.MediaElement.prototype.loadPixels=function(){return this._ensureCanvas(),d.default.Renderer2D.prototype.loadPixels.apply(this,arguments)},d.default.MediaElement.prototype.updatePixels=function(e,t,r,n){return this.loadedmetadata&&(this._ensureCanvas(),d.default.Renderer2D.prototype.updatePixels.call(this,e,t,r,n)),this.setModified(!0),this},d.default.MediaElement.prototype.get=function(){return this._ensureCanvas(),d.default.Renderer2D.prototype.get.apply(this,arguments)},d.default.MediaElement.prototype._getPixel=function(){return this.loadPixels(),d.default.Renderer2D.prototype._getPixel.apply(this,arguments)},d.default.MediaElement.prototype.set=function(e,t,r){this.loadedmetadata&&(this._ensureCanvas(),d.default.Renderer2D.prototype.set.call(this,e,t,r),this.setModified(!0));},d.default.MediaElement.prototype.copy=function(){this._ensureCanvas(),d.default.prototype.copy.apply(this,arguments);},d.default.MediaElement.prototype.mask=function(){this.loadPixels(),this.setModified(!0),d.default.Image.prototype.mask.apply(this,arguments);},d.default.MediaElement.prototype.isModified=function(){return this._modified},d.default.MediaElement.prototype.setModified=function(e){this._modified=e;},d.default.MediaElement.prototype.onended=function(e){return this._onended=e,this},d.default.MediaElement.prototype.connect=function(e){var t,r;if("function"==typeof d.default.prototype.getAudioContext)t=d.default.prototype.getAudioContext(),r=d.default.soundOut.input;else try{r=(t=e.context).destination;}catch(e){throw "connect() is meant to be used with Web Audio API or p5.sound.js"}this.audioSourceNode||(this.audioSourceNode=t.createMediaElementSource(this.elt),this.audioSourceNode.connect(r)),e?e.input?this.audioSourceNode.connect(e.input):this.audioSourceNode.connect(e):this.audioSourceNode.connect(r);},d.default.MediaElement.prototype.disconnect=function(){if(!this.audioSourceNode)throw "nothing to disconnect";this.audioSourceNode.disconnect();},d.default.MediaElement.prototype.showControls=function(){this.elt.style["text-align"]="inherit",this.elt.controls=!0;},d.default.MediaElement.prototype.hideControls=function(){this.elt.controls=!1;};function o(e,t,r,n){this.callback=e,this.time=t,this.id=r,this.val=n;}d.default.MediaElement.prototype.addCue=function(e,t,r){var n=this._cueIDCounter++,a=new o(t,e,n,r);return this._cues.push(a),this.elt.ontimeupdate||(this.elt.ontimeupdate=this._onTimeUpdate.bind(this)),n},d.default.MediaElement.prototype.removeCue=function(e){for(var t=0;t<this._cues.length;t++)this._cues[t].id===e&&(console.log(e),this._cues.splice(t,1));0===this._cues.length&&(this.elt.ontimeupdate=null);},d.default.MediaElement.prototype.clearCues=function(){this._cues=[],this.elt.ontimeupdate=null;},d.default.MediaElement.prototype._onTimeUpdate=function(){for(var e=this.time(),t=0;t<this._cues.length;t++){var r=this._cues[t].time,n=this._cues[t].val;this._prevTime<r&&r<=e&&this._cues[t].callback(n);}this._prevTime=e;},d.default.File=function(e,t){this.file=e,this._pInst=t;var r=e.type.split("/");this.type=r[0],this.subtype=r[1],this.name=e.name,this.size=e.size,this.data=void 0;},d.default.File._createLoader=function(n,a){var e=new FileReader;return e.onload=function(e){var t=new d.default.File(n);if("application/json"===t.file.type)t.data=JSON.parse(e.target.result);else if("text/xml"===t.file.type){var r=(new DOMParser).parseFromString(e.target.result,"text/xml");t.data=new d.default.XML(r.documentElement);}else t.data=e.target.result;a(t);},e},d.default.File._load=function(e,t){if(/^text\//.test(e.type)||"application/json"===e.type)d.default.File._createLoader(e,t).readAsText(e);else if(/^(video|audio)\//.test(e.type)){var r=new d.default.File(e);r.data=URL.createObjectURL(e),t(r);}else d.default.File._createLoader(e,t).readAsDataURL(e);};var i=d.default;r.default=i;},{"../core/main":32}],49:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n},o=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}a.default.prototype.deviceOrientation=1<window.innerWidth/window.innerHeight?"landscape":"portrait",a.default.prototype.accelerationX=0,a.default.prototype.accelerationY=0,a.default.prototype.accelerationZ=0,a.default.prototype.pAccelerationX=0,a.default.prototype.pAccelerationY=0,a.default.prototype.pAccelerationZ=0,a.default.prototype._updatePAccelerations=function(){this._setProperty("pAccelerationX",this.accelerationX),this._setProperty("pAccelerationY",this.accelerationY),this._setProperty("pAccelerationZ",this.accelerationZ);},a.default.prototype.rotationX=0,a.default.prototype.rotationY=0,a.default.prototype.rotationZ=0,a.default.prototype.pRotationX=0,a.default.prototype.pRotationY=0;var c=a.default.prototype.pRotationZ=0,d=0,h=0,m="clockwise",f="clockwise",y="clockwise";a.default.prototype.pRotateDirectionX=void 0,a.default.prototype.pRotateDirectionY=void 0,a.default.prototype.pRotateDirectionZ=void 0,a.default.prototype._updatePRotations=function(){this._setProperty("pRotationX",this.rotationX),this._setProperty("pRotationY",this.rotationY),this._setProperty("pRotationZ",this.rotationZ);},a.default.prototype.turnAxis=void 0;var g=.5,v=30;a.default.prototype.setMoveThreshold=function(e){a.default._validateParameters("setMoveThreshold",arguments),g=e;},a.default.prototype.setShakeThreshold=function(e){a.default._validateParameters("setShakeThreshold",arguments),v=e;},a.default.prototype._ondeviceorientation=function(e){this._updatePRotations(),this._angleMode===o.radians&&(e.beta=e.beta*(_PI/180),e.gamma=e.gamma*(_PI/180),e.alpha=e.alpha*(_PI/180)),this._setProperty("rotationX",e.beta),this._setProperty("rotationY",e.gamma),this._setProperty("rotationZ",e.alpha),this._handleMotion();},a.default.prototype._ondevicemotion=function(e){this._updatePAccelerations(),this._setProperty("accelerationX",2*e.acceleration.x),this._setProperty("accelerationY",2*e.acceleration.y),this._setProperty("accelerationZ",2*e.acceleration.z),this._handleMotion();},a.default.prototype._handleMotion=function(){90===window.orientation||-90===window.orientation?this._setProperty("deviceOrientation","landscape"):0===window.orientation?this._setProperty("deviceOrientation","portrait"):void 0===window.orientation&&this._setProperty("deviceOrientation","undefined");var e=this.deviceMoved||window.deviceMoved;"function"==typeof e&&(Math.abs(this.accelerationX-this.pAccelerationX)>g||Math.abs(this.accelerationY-this.pAccelerationY)>g||Math.abs(this.accelerationZ-this.pAccelerationZ)>g)&&e();var t=this.deviceTurned||window.deviceTurned;if("function"==typeof t){var r=this.rotationX+180,n=this.pRotationX+180,a=c+180;0<r-n&&r-n<270||r-n<-270?m="clockwise":(r-n<0||270<r-n)&&(m="counter-clockwise"),m!==this.pRotateDirectionX&&(a=r),90<Math.abs(r-a)&&Math.abs(r-a)<270&&(a=r,this._setProperty("turnAxis","X"),t()),this.pRotateDirectionX=m,c=a-180;var o=this.rotationY+180,i=this.pRotationY+180,s=d+180;0<o-i&&o-i<270||o-i<-270?f="clockwise":(o-i<0||270<o-this.pRotationY)&&(f="counter-clockwise"),f!==this.pRotateDirectionY&&(s=o),90<Math.abs(o-s)&&Math.abs(o-s)<270&&(s=o,this._setProperty("turnAxis","Y"),t()),this.pRotateDirectionY=f,d=s-180,0<this.rotationZ-this.pRotationZ&&this.rotationZ-this.pRotationZ<270||this.rotationZ-this.pRotationZ<-270?y="clockwise":(this.rotationZ-this.pRotationZ<0||270<this.rotationZ-this.pRotationZ)&&(y="counter-clockwise"),y!==this.pRotateDirectionZ&&(h=this.rotationZ),90<Math.abs(this.rotationZ-h)&&Math.abs(this.rotationZ-h)<270&&(h=this.rotationZ,this._setProperty("turnAxis","Z"),t()),this.pRotateDirectionZ=y,this._setProperty("turnAxis",void 0);}var l,p,u=this.deviceShaken||window.deviceShaken;"function"==typeof u&&(null!==this.pAccelerationX&&(l=Math.abs(this.accelerationX-this.pAccelerationX),p=Math.abs(this.accelerationY-this.pAccelerationY)),v<l+p&&u());};var l=a.default;r.default=l;},{"../core/constants":22,"../core/main":32}],50:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};a.default.prototype.isKeyPressed=!1,a.default.prototype.keyIsPressed=!1,a.default.prototype.key="",a.default.prototype.keyCode=0,a.default.prototype._onkeydown=function(e){if(!this._downKeys[e.which]){this._setProperty("isKeyPressed",!0),this._setProperty("keyIsPressed",!0),this._setProperty("keyCode",e.which),this._downKeys[e.which]=!0,this._setProperty("key",e.key||String.fromCharCode(e.which)||e.which);var t=this.keyPressed||window.keyPressed;if("function"==typeof t&&!e.charCode)!1===t(e)&&e.preventDefault();}},a.default.prototype._onkeyup=function(e){var t=this.keyReleased||window.keyReleased;this._downKeys[e.which]=!1,this._areDownKeys()||(this._setProperty("isKeyPressed",!1),this._setProperty("keyIsPressed",!1)),this._setProperty("_lastKeyCodeTyped",null),this._setProperty("key",e.key||String.fromCharCode(e.which)||e.which),this._setProperty("keyCode",e.which),"function"!=typeof t||!1===t(e)&&e.preventDefault();},a.default.prototype._onkeypress=function(e){if(e.which!==this._lastKeyCodeTyped){this._setProperty("_lastKeyCodeTyped",e.which),this._setProperty("key",String.fromCharCode(e.which));var t=this.keyTyped||window.keyTyped;if("function"==typeof t)!1===t(e)&&e.preventDefault();}},a.default.prototype._onblur=function(e){this._downKeys={};},a.default.prototype.keyIsDown=function(e){return a.default._validateParameters("keyIsDown",arguments),this._downKeys[e]||!1},a.default.prototype._areDownKeys=function(){for(var e in this._downKeys)if(this._downKeys.hasOwnProperty(e)&&!0===this._downKeys[e])return !0;return !1};var o=a.default;r.default=o;},{"../core/main":32}],51:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n},o=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}a.default.prototype.movedX=0,a.default.prototype.movedY=0,a.default.prototype._hasMouseInteracted=!1,a.default.prototype.mouseX=0,a.default.prototype.mouseY=0,a.default.prototype.pmouseX=0,a.default.prototype.pmouseY=0,a.default.prototype.winMouseX=0,a.default.prototype.winMouseY=0,a.default.prototype.pwinMouseX=0,a.default.prototype.pwinMouseY=0,a.default.prototype.mouseButton=0,a.default.prototype.mouseIsPressed=!1,a.default.prototype._updateNextMouseCoords=function(e){if(null!==this._curElement&&(!e.touches||0<e.touches.length)){var t=function(e,t,r,n){n&&!n.clientX&&(n.touches?n=n.touches[0]:n.changedTouches&&(n=n.changedTouches[0]));var a=e.getBoundingClientRect(),o=e.scrollWidth/t||1,i=e.scrollHeight/r||1;return {x:(n.clientX-a.left)/o,y:(n.clientY-a.top)/i,winX:n.clientX,winY:n.clientY,id:n.identifier}}(this._curElement.elt,this.width,this.height,e);this._setProperty("movedX",e.movementX),this._setProperty("movedY",e.movementY),this._setProperty("mouseX",t.x),this._setProperty("mouseY",t.y),this._setProperty("winMouseX",t.winX),this._setProperty("winMouseY",t.winY);}this._hasMouseInteracted||(this._updateMouseCoords(),this._setProperty("_hasMouseInteracted",!0));},a.default.prototype._updateMouseCoords=function(){this._setProperty("pmouseX",this.mouseX),this._setProperty("pmouseY",this.mouseY),this._setProperty("pwinMouseX",this.winMouseX),this._setProperty("pwinMouseY",this.winMouseY),this._setProperty("_pmouseWheelDeltaY",this._mouseWheelDeltaY);},a.default.prototype._setMouseButton=function(e){1===e.button?this._setProperty("mouseButton",o.CENTER):2===e.button?this._setProperty("mouseButton",o.RIGHT):this._setProperty("mouseButton",o.LEFT);},a.default.prototype._onmousemove=function(e){var t=this._isGlobal?window:this;this._updateNextMouseCoords(e),this.mouseIsPressed?"function"==typeof t.mouseDragged?!1===t.mouseDragged(e)&&e.preventDefault():"function"==typeof t.touchMoved&&!1===t.touchMoved(e)&&e.preventDefault():"function"==typeof t.mouseMoved&&!1===t.mouseMoved(e)&&e.preventDefault();},a.default.prototype._onmousedown=function(e){var t=this._isGlobal?window:this;this._setProperty("mouseIsPressed",!0),this._setMouseButton(e),this._updateNextMouseCoords(e),"function"==typeof t.mousePressed?!1===t.mousePressed(e)&&e.preventDefault():navigator.userAgent.toLowerCase().includes("safari")&&"function"==typeof t.touchStarted&&!1===t.touchStarted(e)&&e.preventDefault();},a.default.prototype._onmouseup=function(e){var t=this._isGlobal?window:this;this._setProperty("mouseIsPressed",!1),"function"==typeof t.mouseReleased?!1===t.mouseReleased(e)&&e.preventDefault():"function"==typeof t.touchEnded&&!1===t.touchEnded(e)&&e.preventDefault();},a.default.prototype._ondragend=a.default.prototype._onmouseup,a.default.prototype._ondragover=a.default.prototype._onmousemove,a.default.prototype._onclick=function(e){var t=this._isGlobal?window:this;"function"==typeof t.mouseClicked&&!1===t.mouseClicked(e)&&e.preventDefault();},a.default.prototype._ondblclick=function(e){var t=this._isGlobal?window:this;"function"==typeof t.doubleClicked&&!1===t.doubleClicked(e)&&e.preventDefault();},a.default.prototype._mouseWheelDeltaY=0,a.default.prototype._pmouseWheelDeltaY=0,a.default.prototype._onwheel=function(e){var t=this._isGlobal?window:this;this._setProperty("_mouseWheelDeltaY",e.deltaY),"function"==typeof t.mouseWheel&&(e.delta=e.deltaY,!1===t.mouseWheel(e)&&e.preventDefault());},a.default.prototype.requestPointerLock=function(){var e=this._curElement.elt;return e.requestPointerLock=e.requestPointerLock||e.mozRequestPointerLock,e.requestPointerLock?(e.requestPointerLock(),!0):(console.log("requestPointerLock is not implemented in this browser"),!1)},a.default.prototype.exitPointerLock=function(){document.exitPointerLock();};var l=a.default;r.default=l;},{"../core/constants":22,"../core/main":32}],52:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};function o(e,t,r,n,a){var o=4<arguments.length&&void 0!==a?a:0,i=e.getBoundingClientRect(),s=e.scrollWidth/t||1,l=e.scrollHeight/r||1,p=n.touches[o]||n.changedTouches[o];return {x:(p.clientX-i.left)/s,y:(p.clientY-i.top)/l,winX:p.clientX,winY:p.clientY,id:p.identifier}}a.default.prototype.touches=[],a.default.prototype._updateTouchCoords=function(e){if(null!==this._curElement){for(var t=[],r=0;r<e.touches.length;r++)t[r]=o(this._curElement.elt,this.width,this.height,e,r);this._setProperty("touches",t);}},a.default.prototype._ontouchstart=function(e){var t=this._isGlobal?window:this;this._setProperty("mouseIsPressed",!0),this._updateTouchCoords(e),this._updateNextMouseCoords(e),this._updateMouseCoords(),"function"==typeof t.touchStarted?!1===t.touchStarted(e)&&e.preventDefault():navigator.userAgent.toLowerCase().includes("safari")&&"function"==typeof t.mousePressed&&!1===t.mousePressed(e)&&e.preventDefault();},a.default.prototype._ontouchmove=function(e){var t=this._isGlobal?window:this;this._updateTouchCoords(e),this._updateNextMouseCoords(e),"function"==typeof t.touchMoved?!1===t.touchMoved(e)&&e.preventDefault():"function"==typeof t.mouseDragged&&!1===t.mouseDragged(e)&&e.preventDefault();},a.default.prototype._ontouchend=function(e){this._setProperty("mouseIsPressed",!1),this._updateTouchCoords(e),this._updateNextMouseCoords(e);var t=this._isGlobal?window:this;"function"==typeof t.touchEnded?!1===t.touchEnded(e)&&e.preventDefault():"function"==typeof t.mouseReleased&&!1===t.mouseReleased(e)&&e.preventDefault();};var i=a.default;r.default=i;},{"../core/main":32}],53:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var N,O,L,I,P={};function n(e,t){for(var r,n,a,o,i,s,l,p,u,c,d=P._toPixels(e),h=e.width,m=e.height,f=h*m,y=new Int32Array(f),g=0;g<f;g++)y[g]=P._getARGB(d,g);var v,b,_,x,S=new Int32Array(f),w=new Int32Array(f),M=new Int32Array(f),E=new Int32Array(f),T=0;for(!function(e){var t=3.5*e|0;if(N!==(t=t<1?1:t<248?t:248)){O=1+(N=t)<<1,L=new Int32Array(O),I=new Array(O);for(var r=0;r<O;r++)I[r]=new Int32Array(256);for(var n,a,o,i,s=1,l=t-1;s<t;s++){L[t+s]=L[l]=a=l*l,o=I[t+s],i=I[l--];for(var p=0;p<256;p++)o[p]=i[p]=a*p;}n=L[t]=t*t,o=I[t];for(var u=0;u<256;u++)o[u]=n*u;}}(t),b=0;b<m;b++){for(v=0;v<h;v++){if(o=a=n=i=r=0,(s=v-N)<0)c=-s,s=0;else {if(h<=s)break;c=0;}for(_=c;_<O&&!(h<=s);_++){var C=y[s+T];i+=(x=I[_])[(-16777216&C)>>>24],n+=x[(16711680&C)>>16],a+=x[(65280&C)>>8],o+=x[255&C],r+=L[_],s++;}S[l=T+v]=i/r,w[l]=n/r,M[l]=a/r,E[l]=o/r;}T+=h;}for(u=(p=-N)*h,b=T=0;b<m;b++){for(v=0;v<h;v++){if(o=a=n=i=r=0,p<0)c=l=-p,s=v;else {if(m<=p)break;c=0,l=p,s=v+u;}for(_=c;_<O&&!(m<=l);_++)i+=(x=I[_])[S[s]],n+=x[w[s]],a+=x[M[s]],o+=x[E[s]],r+=L[_],l++,s+=h;y[v+T]=i/r<<24|n/r<<16|a/r<<8|o/r;}T+=h,u+=h,p++;}P._setPixels(d,y);}P._toPixels=function(e){return e instanceof ImageData?e.data:e.getContext("2d").getImageData(0,0,e.width,e.height).data},P._getARGB=function(e,t){var r=4*t;return e[3+r]<<24&4278190080|e[r]<<16&16711680|e[1+r]<<8&65280|255&e[2+r]},P._setPixels=function(e,t){for(var r=0,n=0,a=e.length;n<a;n++)e[(r=4*n)+0]=(16711680&t[n])>>>16,e[r+1]=(65280&t[n])>>>8,e[r+2]=255&t[n],e[r+3]=(4278190080&t[n])>>>24;},P._toImageData=function(e){return e instanceof ImageData?e:e.getContext("2d").getImageData(0,0,e.width,e.height)},P._createImageData=function(e,t){return P._tmpCanvas=document.createElement("canvas"),P._tmpCtx=P._tmpCanvas.getContext("2d"),this._tmpCtx.createImageData(e,t)},P.apply=function(e,t,r){var n=e.getContext("2d"),a=n.getImageData(0,0,e.width,e.height),o=t(a,r);o instanceof ImageData?n.putImageData(o,0,0,0,0,e.width,e.height):n.putImageData(a,0,0,0,0,e.width,e.height);},P.threshold=function(e,t){var r=P._toPixels(e);void 0===t&&(t=.5);for(var n=Math.floor(255*t),a=0;a<r.length;a+=4){var o=void 0;o=n<=.2126*r[a]+.7152*r[a+1]+.0722*r[a+2]?255:0,r[a]=r[a+1]=r[a+2]=o;}},P.gray=function(e){for(var t=P._toPixels(e),r=0;r<t.length;r+=4){var n=.2126*t[r]+.7152*t[r+1]+.0722*t[r+2];t[r]=t[r+1]=t[r+2]=n;}},P.opaque=function(e){for(var t=P._toPixels(e),r=0;r<t.length;r+=4)t[r+3]=255;return t},P.invert=function(e){for(var t=P._toPixels(e),r=0;r<t.length;r+=4)t[r]=255-t[r],t[r+1]=255-t[r+1],t[r+2]=255-t[r+2];},P.posterize=function(e,t){var r=P._toPixels(e);if(t<2||255<t)throw new Error("Level must be greater than 2 and less than 255 for posterize");for(var n=t-1,a=0;a<r.length;a+=4){var o=r[a],i=r[a+1],s=r[a+2];r[a]=255*(o*t>>8)/n,r[a+1]=255*(i*t>>8)/n,r[a+2]=255*(s*t>>8)/n;}},P.dilate=function(e){for(var t,r,n,a,o,i,s,l,p,u,c,d,h,m,f,y,g,v=P._toPixels(e),b=0,_=v.length?v.length/4:0,x=new Int32Array(_);b<_;)for(r=(t=b)+e.width;b<r;)n=a=P._getARGB(v,b),(s=b-1)<t&&(s=b),r<=(i=b+1)&&(i=b),(l=b-e.width)<0&&(l=0),_<=(p=b+e.width)&&(p=b),d=P._getARGB(v,l),c=P._getARGB(v,s),h=P._getARGB(v,p),(o=77*(n>>16&255)+151*(n>>8&255)+28*(255&n))<(f=77*(c>>16&255)+151*(c>>8&255)+28*(255&c))&&(a=c,o=f),o<(m=77*((u=P._getARGB(v,i))>>16&255)+151*(u>>8&255)+28*(255&u))&&(a=u,o=m),o<(y=77*(d>>16&255)+151*(d>>8&255)+28*(255&d))&&(a=d,o=y),o<(g=77*(h>>16&255)+151*(h>>8&255)+28*(255&h))&&(a=h,o=g),x[b++]=a;P._setPixels(v,x);},P.erode=function(e){for(var t,r,n,a,o,i,s,l,p,u,c,d,h,m,f,y,g,v=P._toPixels(e),b=0,_=v.length?v.length/4:0,x=new Int32Array(_);b<_;)for(r=(t=b)+e.width;b<r;)n=a=P._getARGB(v,b),(s=b-1)<t&&(s=b),r<=(i=b+1)&&(i=b),(l=b-e.width)<0&&(l=0),_<=(p=b+e.width)&&(p=b),d=P._getARGB(v,l),c=P._getARGB(v,s),h=P._getARGB(v,p),(f=77*(c>>16&255)+151*(c>>8&255)+28*(255&c))<(o=77*(n>>16&255)+151*(n>>8&255)+28*(255&n))&&(a=c,o=f),(m=77*((u=P._getARGB(v,i))>>16&255)+151*(u>>8&255)+28*(255&u))<o&&(a=u,o=m),(y=77*(d>>16&255)+151*(d>>8&255)+28*(255&d))<o&&(a=d,o=y),(g=77*(h>>16&255)+151*(h>>8&255)+28*(255&h))<o&&(a=h,o=g),x[b++]=a;P._setPixels(v,x);},P.blur=function(e,t){n(e,t);};var a=P;r.default=a;},{}],54:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var P=n(e("../core/main")),R=n(e("omggif"));function n(e){return e&&e.__esModule?e:{default:e}}function D(e){return function(e){if(Array.isArray(e)){for(var t=0,r=new Array(e.length);t<e.length;t++)r[t]=e[t];return r}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}P.default.prototype.createImage=function(e,t){return P.default._validateParameters("createImage",arguments),new P.default.Image(e,t)},P.default.prototype.saveCanvas=function(){P.default._validateParameters("saveCanvas",arguments);var e,t,r,n,a=[].slice.call(arguments);switch(arguments[0]instanceof HTMLCanvasElement?(e=arguments[0],a.shift()):arguments[0]instanceof P.default.Element?(e=arguments[0].elt,a.shift()):e=this._curElement&&this._curElement.elt,1<=a.length&&(t=a[0]),2<=a.length&&(r=a[1]),r=r||P.default.prototype._checkFileExtension(t,r)[1]||"png"){default:n="image/png";break;case"jpeg":case"jpg":n="image/jpeg";}e.toBlob(function(e){P.default.prototype.downloadFile(e,t,r);},n);},P.default.prototype.saveGif=function(m,e){var f=m.gifProperties,t=f.loopLimit;1===t?t=null:null===t&&(t=0);for(var r=new Uint8Array(m.width*m.height*f.numFrames),y=[],n={},a=0;a<f.numFrames;a++){for(var o=new Set,i=f.frames[a].image.data,s=i.length,l=new Uint32Array(m.width*m.height),p=0,u=0;p<s;p+=4,u++){var c=i[p+0]<<16|i[p+1]<<8|i[p+2]<<0;o.add(c),l[u]=c;}var d=D(o).sort().toString();void 0===n[d]?n[d]={freq:1,frames:[a]}:(n[d].freq+=1,n[d].frames.push(a)),y.push(l);}var g=[],h=Object.keys(n).sort(function(e,t){return n[t].freq-n[e].freq}),v=h[0].split(",").map(function(e){return parseInt(e)});g=g.concat(n[v].frames);for(var b=new Set(v),_=1;_<h.length;_++){var x=h[_].split(",").map(function(e){return parseInt(e)}).filter(function(e){return !b.has(e)});if(v.length+x.length<=256){for(var S=0;S<x.length;S++)v.push(x[S]),b.add(x[S]);g=g.concat(n[h[_]].frames);}}g=new Set(g);for(var w={},M=0;M<v.length;M++)w[v[M]]||(w[v[M]]=M);for(var E=1;E<v.length;)E<<=1;v.length=E;for(var T={loop:t,palette:new Uint32Array(v)},C=new R.default.GifWriter(r,m.width,m.height,T),N={},O=function(e){for(var t=!g.has(e),r=t?[]:v,n=new Uint8Array(m.width*m.height),a={},o=new Set,i=0;i<y[e].length;i++){var s=y[e][i];t?(void 0===a[s]&&(a[s]=r.length,r.push(s)),n[i]=a[s]):n[i]=w[s],0<e&&y[e-1][i]!==s&&o.add(s);}var l={},p=r.filter(function(e){return !o.has(e)});if(0<p.length){var u=p[0],c=t?a[u]:w[u];if(0<e){for(var d=0;d<y[e].length;d++)y[e-1][d]===y[e][d]&&(n[d]=c);l.transparent=c,N.frameOpts.disposal=1;}}if(l.delay=f.frames[e].delay/10,t){for(var h=1;h<r.length;)h<<=1;r.length=h,l.palette=new Uint32Array(r);}0<e&&C.addFrame(0,0,m.width,m.height,N.pixelPaletteIndex,N.frameOpts),N={pixelPaletteIndex:n,frameOpts:l};},L=0;L<f.numFrames;L++)O(L);N.frameOpts.disposal=1,C.addFrame(0,0,m.width,m.height,N.pixelPaletteIndex,N.frameOpts);var I=new Blob([r.slice(0,C.end())],{type:"image/gif"});P.default.prototype.downloadFile(I,e,"gif");},P.default.prototype.saveFrames=function(e,t,r,n,i){P.default._validateParameters("saveFrames",arguments);var a=r||3;a=P.default.prototype.constrain(a,0,15),a*=1e3;var o=n||15;o=P.default.prototype.constrain(o,0,22);var s=0,l=P.default.prototype._makeFrame,p=this._curElement.elt,u=[],c=setInterval(function(){u.push(l(e+s,t,p)),s++;},1e3/o);setTimeout(function(){if(clearInterval(c),i)i(u);else {var e=!0,t=!1,r=void 0;try{for(var n,a=u[Symbol.iterator]();!(e=(n=a.next()).done);e=!0){var o=n.value;P.default.prototype.downloadFile(o.imageData,o.filename,o.ext);}}catch(e){t=!0,r=e;}finally{try{e||null==a.return||a.return();}finally{if(t)throw r}}}u=[];},a+.01);},P.default.prototype._makeFrame=function(e,t,r){var n,a;if(n=this?this._curElement.elt:r,t)switch(t.toLowerCase()){case"png":a="image/png";break;case"jpeg":case"jpg":a="image/jpeg";break;default:a="image/png";}else t="png",a="image/png";var o=n.toDataURL(a);o=o.replace(a,"image/octet-stream");var i={};return i.imageData=o,i.filename=e,i.ext=t,i};var a=P.default;r.default=a;},{"../core/main":32,omggif:12}],55:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var x=a(e("../core/main")),c=a(e("./filters")),S=a(e("../core/helpers")),n=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants")),m=a(e("omggif"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}function a(e){return e&&e.__esModule?e:{default:e}}function w(e,t){return 0<e&&e<t?e:t}e("../core/friendly_errors/validate_params"),e("../core/friendly_errors/file_errors"),e("../core/friendly_errors/fes_core"),x.default.prototype.loadImage=function(n,a,o){x.default._validateParameters("loadImage",arguments);var i=new x.default.Image(1,1,this),s=this,e=new Request(n,{method:"GET",mode:"cors"});return fetch(n,e).then(function(e){var t=e.headers.get("content-type");if(null===t&&console.warn("The image you loaded does not have a Content-Type header. If you are using the online editor consider reuploading the asset."),t&&t.includes("image/gif"))e.arrayBuffer().then(function(e){e&&function(e,r,t,n,a){var o=new m.default.GifReader(e);r.width=r.canvas.width=o.width,r.height=r.canvas.height=o.height;var i=[],s=o.numFrames(),l=new Uint8ClampedArray(r.width*r.height*4);if(1<s){for(var p=function(e,t){try{t.decodeAndBlitFrameRGBA(e,l);}catch(e){x.default._friendlyFileLoadError(8,r.src),"function"==typeof n?n(e):console.error(e);}},u=0;u<s;u++){var c=o.frameInfo(u);1===o.frameInfo(u).disposal&&0<u?r.drawingContext.putImageData(i[u-1].image,0,0):(r.drawingContext.clearRect(0,0,r.width,r.height),l=new Uint8ClampedArray(r.width*r.height*4)),p(u,o);var d=new ImageData(l,r.width,r.height);r.drawingContext.putImageData(d,0,0),i.push({image:r.drawingContext.getImageData(0,0,r.width,r.height),delay:10*c.delay});}var h=o.loopCount();null===h?h=1:0===h&&(h=null),r.gifProperties={displayIndex:0,loopLimit:h,loopCount:0,frames:i,numFrames:s,playing:!0,timeDisplayed:0};}"function"==typeof t&&t(r);a();}(new Uint8Array(e),i,a,o,function(e){s._decrementPreload();}.bind(s));},function(e){"function"==typeof o?o(e):console.error(e);});else {var r=new Image;r.onload=function(){i.width=i.canvas.width=r.width,i.height=i.canvas.height=r.height,i.drawingContext.drawImage(r,0,0),i.modified=!0,"function"==typeof a&&a(i),s._decrementPreload();},r.onerror=function(e){x.default._friendlyFileLoadError(0,r.src),"function"==typeof o?o(e):console.error(e);},0!==n.indexOf("data:image/")&&(r.crossOrigin="Anonymous"),r.src=n;}i.modified=!0;}),i},x.default.prototype.image=function(e,t,r,n,a,o,i,s,l){x.default._validateParameters("image",arguments);var p=e.width,u=e.height;e.elt&&e.elt.videoWidth&&!e.canvas&&(p=e.elt.videoWidth,u=e.elt.videoHeight);var c=t,d=r,h=n||p,m=a||u,f=o||0,y=i||0,g=s||p,v=l||u;g=w(g,p),v=w(v,u);var b=1;e.elt&&!e.canvas&&e.elt.style.width&&(b=e.elt.videoWidth&&!n?e.elt.videoWidth:e.elt.width,b/=parseInt(e.elt.style.width,10)),f*=b,y*=b,v*=b,g*=b;var _=S.default.modeAdjust(c,d,h,m,this._renderer._imageMode);this._renderer.image(e,f,y,g,v,_.x,_.y,_.w,_.h);},x.default.prototype.tint=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];x.default._validateParameters("tint",t);var n=this.color.apply(this,t);this._renderer._tint=n.levels;},x.default.prototype.noTint=function(){this._renderer._tint=null;},x.default.prototype._getTintedImageCanvas=function(e){if(!e.canvas)return e;var t=c.default._toPixels(e.canvas),r=document.createElement("canvas");r.width=e.canvas.width,r.height=e.canvas.height;for(var n=r.getContext("2d"),a=n.createImageData(e.canvas.width,e.canvas.height),o=a.data,i=0;i<t.length;i+=4){var s=t[i],l=t[i+1],p=t[i+2],u=t[i+3];o[i]=s*this._renderer._tint[0]/255,o[i+1]=l*this._renderer._tint[1]/255,o[i+2]=p*this._renderer._tint[2]/255,o[i+3]=u*this._renderer._tint[3]/255;}return n.putImageData(a,0,0),r},x.default.prototype.imageMode=function(e){x.default._validateParameters("imageMode",arguments),e!==n.CORNER&&e!==n.CORNERS&&e!==n.CENTER||(this._renderer._imageMode=e);};var o=x.default;r.default=o;},{"../core/constants":22,"../core/friendly_errors/fes_core":24,"../core/friendly_errors/file_errors":25,"../core/friendly_errors/validate_params":27,"../core/helpers":28,"../core/main":32,"./filters":53,omggif:12}],56:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var a=o(e("../core/main")),n=o(e("./filters"));function o(e){return e&&e.__esModule?e:{default:e}}a.default.Image=function(e,t){this.width=e,this.height=t,this.canvas=document.createElement("canvas"),this.canvas.width=this.width,this.canvas.height=this.height,this.drawingContext=this.canvas.getContext("2d"),(this._pixelsState=this)._pixelDensity=1,this.gifProperties=null,this._modified=!1,this.pixels=[];},a.default.Image.prototype._animateGif=function(e){var t=this.gifProperties;if(t.playing){t.timeDisplayed+=e.deltaTime;var r=t.frames[t.displayIndex].delay;if(t.timeDisplayed>=r){var n=Math.floor(t.timeDisplayed/r);if(t.timeDisplayed=0,t.displayIndex+=n,t.loopCount=Math.floor(t.displayIndex/t.numFrames),null!==t.loopLimit&&t.loopCount>=t.loopLimit)t.playing=!1;else {var a=t.displayIndex%t.numFrames;this.drawingContext.putImageData(t.frames[a].image,0,0),t.displayIndex=a,this.setModified(!0);}}}},a.default.Image.prototype._setProperty=function(e,t){this[e]=t,this.setModified(!0);},a.default.Image.prototype.loadPixels=function(){a.default.Renderer2D.prototype.loadPixels.call(this),this.setModified(!0);},a.default.Image.prototype.updatePixels=function(e,t,r,n){a.default.Renderer2D.prototype.updatePixels.call(this,e,t,r,n),this.setModified(!0);},a.default.Image.prototype.get=function(e,t,r,n){return a.default._validateParameters("p5.Image.get",arguments),a.default.Renderer2D.prototype.get.apply(this,arguments)},a.default.Image.prototype._getPixel=a.default.Renderer2D.prototype._getPixel,a.default.Image.prototype.set=function(e,t,r){a.default.Renderer2D.prototype.set.call(this,e,t,r),this.setModified(!0);},a.default.Image.prototype.resize=function(e,t){0===e&&0===t?(e=this.canvas.width,t=this.canvas.height):0===e?e=this.canvas.width*t/this.canvas.height:0===t&&(t=this.canvas.height*e/this.canvas.width),e=Math.floor(e),t=Math.floor(t);var r=document.createElement("canvas");if(r.width=e,r.height=t,this.gifProperties)for(var n=this.gifProperties,a=function(e,t){for(var r=0,n=0;n<t.height;n++)for(var a=0;a<t.width;a++){var o=Math.floor(a*e.width/t.width),i=4*(Math.floor(n*e.height/t.height)*e.width+o);t.data[r++]=e.data[i++],t.data[r++]=e.data[i++],t.data[r++]=e.data[i++],t.data[r++]=e.data[i++];}},o=0;o<n.numFrames;o++){var i=this.drawingContext.createImageData(e,t);a(n.frames[o].image,i),n.frames[o].image=i;}r.getContext("2d").drawImage(this.canvas,0,0,this.canvas.width,this.canvas.height,0,0,r.width,r.height),this.canvas.width=this.width=e,this.canvas.height=this.height=t,this.drawingContext.drawImage(r,0,0,e,t,0,0,e,t),0<this.pixels.length&&this.loadPixels(),this.setModified(!0);},a.default.Image.prototype.copy=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];a.default.prototype.copy.apply(this,t);},a.default.Image.prototype.mask=function(e){void 0===e&&(e=this);var t=this.drawingContext.globalCompositeOperation,r=1;e instanceof a.default.Renderer&&(r=e._pInst._pixelDensity);var n=[e,0,0,r*e.width,r*e.height,0,0,this.width,this.height];this.drawingContext.globalCompositeOperation="destination-in",a.default.Image.prototype.copy.apply(this,n),this.drawingContext.globalCompositeOperation=t,this.setModified(!0);},a.default.Image.prototype.filter=function(e,t){n.default.apply(this.canvas,n.default[e],t),this.setModified(!0);},a.default.Image.prototype.blend=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];a.default._validateParameters("p5.Image.blend",arguments),a.default.prototype.blend.apply(this,t),this.setModified(!0);},a.default.Image.prototype.setModified=function(e){this._modified=e;},a.default.Image.prototype.isModified=function(){return this._modified},a.default.Image.prototype.save=function(e,t){this.gifProperties?a.default.prototype.saveGif(this,e):a.default.prototype.saveCanvas(this.canvas,e,t);},a.default.Image.prototype.reset=function(){if(this.gifProperties){var e=this.gifProperties;e.playing=!0,e.timeSinceStart=0,e.timeDisplayed=0,e.loopCount=0,e.displayIndex=0,this.drawingContext.putImageData(e.frames[0].image,0,0);}},a.default.Image.prototype.getCurrentFrame=function(){if(this.gifProperties){var e=this.gifProperties;return e.displayIndex%e.numFrames}},a.default.Image.prototype.setFrame=function(e){if(this.gifProperties){var t=this.gifProperties;e<t.numFrames&&0<=e?(t.timeDisplayed=0,t.displayIndex=e,this.drawingContext.putImageData(t.frames[e].image,0,0)):console.log("Cannot set GIF to a frame number that is higher than total number of frames or below zero.");}},a.default.Image.prototype.numFrames=function(){if(this.gifProperties)return this.gifProperties.numFrames},a.default.Image.prototype.play=function(){this.gifProperties&&(this.gifProperties.playing=!0);},a.default.Image.prototype.pause=function(){this.gifProperties&&(this.gifProperties.playing=!1);},a.default.Image.prototype.delay=function(e,t){if(this.gifProperties){var r=this.gifProperties;if(t<r.numFrames&&0<=t)r.frames[t].delay=e;else {var n=!0,a=!1,o=void 0;try{for(var i,s=r.frames[Symbol.iterator]();!(n=(i=s.next()).done);n=!0){i.value.delay=e;}}catch(e){a=!0,o=e;}finally{try{n||null==s.return||s.return();}finally{if(a)throw o}}}}};var i=a.default.Image;r.default=i;},{"../core/main":32,"./filters":53}],57:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var h=a(e("../core/main")),n=a(e("./filters"));function a(e){return e&&e.__esModule?e:{default:e}}e("../color/p5.Color"),h.default.prototype.pixels=[],h.default.prototype.blend=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];var n;(h.default._validateParameters("blend",t),this._renderer)?(n=this._renderer).blend.apply(n,t):h.default.Renderer2D.prototype.blend.apply(this,t);},h.default.prototype.copy=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];var n,a,o,i,s,l,p,u,c;if(h.default._validateParameters("copy",t),9===t.length)n=t[0],a=t[1],o=t[2],i=t[3],s=t[4],l=t[5],p=t[6],u=t[7],c=t[8];else {if(8!==t.length)throw new Error("Signature not supported");n=this,a=t[0],o=t[1],i=t[2],s=t[3],l=t[4],p=t[5],u=t[6],c=t[7];}h.default.prototype._copyHelper(this,n,a,o,i,s,l,p,u,c);},h.default.prototype._copyHelper=function(e,t,r,n,a,o,i,s,l,p){t.loadPixels();var u=t.canvas.width/t.width,c=0,d=0;t._renderer&&t._renderer.isP3D&&(c=t.width/2,d=t.height/2),e._renderer&&e._renderer.isP3D?h.default.RendererGL.prototype.image.call(e._renderer,t,r+c,n+d,a,o,i,s,l,p):e.drawingContext.drawImage(t.canvas,u*(r+c),u*(n+d),u*a,u*o,i,s,l,p);},h.default.prototype.filter=function(e,t){h.default._validateParameters("filter",arguments),void 0!==this.canvas?n.default.apply(this.canvas,n.default[e],t):n.default.apply(this.elt,n.default[e],t);},h.default.prototype.get=function(e,t,r,n){var a;return h.default._validateParameters("get",arguments),(a=this._renderer).get.apply(a,arguments)},h.default.prototype.loadPixels=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];h.default._validateParameters("loadPixels",t),this._renderer.loadPixels();},h.default.prototype.set=function(e,t,r){this._renderer.set(e,t,r);},h.default.prototype.updatePixels=function(e,t,r,n){h.default._validateParameters("updatePixels",arguments),0!==this.pixels.length&&this._renderer.updatePixels(e,t,r,n);};var o=h.default;r.default=o;},{"../color/p5.Color":20,"../core/main":32,"./filters":53}],58:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var g=n(e("../core/main"));e("whatwg-fetch"),e("es6-promise/auto");var y=n(e("fetch-jsonp")),s=n(e("file-saver"));function n(e){return e&&e.__esModule?e:{default:e}}function v(e){return (v="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function b(e,t){var r={};if(void 0===(t=t||[]))for(var n=0;n<e.length;n++)t[n.toString()]=n;for(var a=0;a<t.length;a++){var o=t[a],i=e[a];r[o]=i;}return r}function f(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;")}function l(e,t){t&&!0!==t&&"true"!==t||(t="");var r="";return (e=e||"untitled")&&e.includes(".")&&(r=e.split(".").pop()),t&&r!==t&&(r=t,e="".concat(e,".").concat(r)),[e,r]}e("../core/friendly_errors/validate_params"),e("../core/friendly_errors/file_errors"),e("../core/friendly_errors/fes_core"),g.default.prototype.loadJSON=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];g.default._validateParameters("loadJSON",t);for(var n,a,o,i=t[0],s={},l="json",p=1;p<t.length;p++){var u=t[p];"string"==typeof u?"jsonp"!==u&&"json"!==u||(l=u):"function"==typeof u?n?a=u:n=u:"object"===v(u)&&(u.hasOwnProperty("jsonpCallback")||u.hasOwnProperty("jsonpCallbackFunction"))&&(l="jsonp",o=u);}var c=this;return this.httpDo(i,"GET",o,l,function(e){for(var t in e)s[t]=e[t];void 0!==n&&n(e),c._decrementPreload();},function(e){if(g.default._friendlyFileLoadError(5,i),!a)throw e;a(e);}),s},g.default.prototype.loadStrings=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];g.default._validateParameters("loadStrings",t);for(var n,a,o=[],i=1;i<t.length;i++){var s=t[i];"function"==typeof s&&(void 0===n?n=s:void 0===a&&(a=s));}var l=this;return g.default.prototype.httpDo.call(this,t[0],"GET","text",function(e){var t=e.replace(/\r\n/g,"\r").replace(/\n/g,"\r").split(/\r/);Array.prototype.push.apply(o,t),void 0!==n&&n(o),l._decrementPreload();},function(e){if(g.default._friendlyFileLoadError(3,e),!a)throw e;a(e);}),o},g.default.prototype.loadTable=function(t){var d,r,h,m=!1,n=t.substring(t.lastIndexOf(".")+1,t.length);"csv"===n?h=",":"ssv"===n?h=";":"tsv"===n&&(h="\t");for(var a=1;a<arguments.length;a++)"function"==typeof arguments[a]?void 0===d?d=arguments[a]:void 0===r&&(r=arguments[a]):"string"==typeof arguments[a]&&("header"===arguments[a]&&(m=!0),"csv"===arguments[a]?h=",":"ssv"===arguments[a]?h=";":"tsv"===arguments[a]&&(h="\t"));console.log("SEP IS "+h);var f=new g.default.Table,y=this;return this.httpDo(t,"GET","table",function(e){for(var t,r,n={},a=[],o=0,i=null,s=function(){n.currentState=0,n.token="";},l=function(){i.push(n.token),s();},p=function(){n.currentState=4,a.push(i),i=null;};;){if(null==(t=e[o++])){if(n.escaped)throw new Error("Unclosed quote in file.");if(i){l(),p();break}}if(null===i&&(n.escaped=!1,i=[],s()),0===n.currentState){if('"'===t){n.escaped=!0,n.currentState=1;continue}n.currentState=1;}if(1===n.currentState&&n.escaped)if('"'===t)'"'===e[o]?(n.token+='"',o++):(n.escaped=!1,n.currentState=2);else {if("\r"===t)continue;n.token+=t;}else "\r"===t?("\n"===e[o]&&o++,l(),p()):"\n"===t?(l(),p()):t===h?l():1===n.currentState&&(n.token+=t);}if(m)f.columns=a.shift();else for(var u=0;u<a[0].length;u++)f.columns[u]="null";for(var c=0;c<a.length;c++)(1!==a[c].length||"undefined"!==a[c][0]&&""!==a[c][0])&&((r=new g.default.TableRow).arr=a[c],r.obj=b(a[c],f.columns),f.addRow(r));"function"==typeof d&&d(f),y._decrementPreload();},function(e){g.default._friendlyFileLoadError(2,t),r?r(e):console.error(e);}),f},g.default.prototype.loadXML=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];for(var n,a,o=new g.default.XML,i=1;i<t.length;i++){var s=t[i];"function"==typeof s&&(void 0===n?n=s:void 0===a&&(a=s));}var l=this;return this.httpDo(t[0],"GET","xml",function(e){for(var t in e)o[t]=e[t];void 0!==n&&n(o),l._decrementPreload();},function(e){if(g.default._friendlyFileLoadError(1,e),!a)throw e;a(e);}),o},g.default.prototype.loadBytes=function(t,r,n){var a={},o=this;return this.httpDo(t,"GET","arrayBuffer",function(e){a.bytes=new Uint8Array(e),"function"==typeof r&&r(a),o._decrementPreload();},function(e){if(g.default._friendlyFileLoadError(6,t),!n)throw e;n(e);}),a},g.default.prototype.httpGet=function(){g.default._validateParameters("httpGet",arguments);var e=Array.prototype.slice.call(arguments);return e.splice(1,0,"GET"),g.default.prototype.httpDo.apply(this,e)},g.default.prototype.httpPost=function(){g.default._validateParameters("httpPost",arguments);var e=Array.prototype.slice.call(arguments);return e.splice(1,0,"POST"),g.default.prototype.httpDo.apply(this,e)},g.default.prototype.httpDo=function(){for(var n,e,t,r,a,o={},i=0,s="text/plain",l=arguments.length-1;0<l&&"function"==typeof(l<0||arguments.length<=l?void 0:arguments[l]);l--)i++;var p=arguments.length<=0?void 0:arguments[0];if(2==arguments.length-i&&"string"==typeof p&&"object"===v(arguments.length<=1?void 0:arguments[1]))r=new Request(p,arguments.length<=1?void 0:arguments[1]),e=arguments.length<=2?void 0:arguments[2],t=arguments.length<=3?void 0:arguments[3];else {for(var u,c="GET",d=1;d<arguments.length;d++){var h=d<0||arguments.length<=d?void 0:arguments[d];if("string"==typeof h)"GET"===h||"POST"===h||"PUT"===h||"DELETE"===h?c=h:"json"===h||"jsonp"===h||"binary"===h||"arrayBuffer"===h||"xml"===h||"text"===h||"table"===h?n=h:u=h;else if("number"==typeof h)u=h.toString();else if("object"===v(h))if(h.hasOwnProperty("jsonpCallback")||h.hasOwnProperty("jsonpCallbackFunction"))for(var m in h)o[m]=h[m];else s=h instanceof g.default.XML?(u=h.serialize(),"application/xml"):(u=JSON.stringify(h),"application/json");else "function"==typeof h&&(e?t=h:e=h);}var f="GET"===c?new Headers:new Headers({"Content-Type":s});r=new Request(p,{method:c,mode:"cors",body:u,headers:f});}return (a=(a="jsonp"===(n=n||(p.includes("json")?"json":p.includes("xml")?"xml":"text"))?(0, y.default)(p,o):fetch(r)).then(function(e){if(!e.ok){var t=new Error(e.body);throw t.status=e.status,t.ok=!1,t}var r=0;switch("jsonp"!==n&&(r=e.headers.get("content-length")),r&&64e6<r&&g.default._friendlyFileLoadError(7,p),n){case"json":case"jsonp":return e.json();case"binary":return e.blob();case"arrayBuffer":return e.arrayBuffer();case"xml":return e.text().then(function(e){var t=(new DOMParser).parseFromString(e,"text/xml");return new g.default.XML(t.documentElement)});default:return e.text()}})).then(e||function(){}),a.catch(t||console.error),a},window.URL=window.URL||window.webkitURL,g.default.prototype._pWriters=[],g.default.prototype.createWriter=function(e,t){var r;for(var n in g.default.prototype._pWriters)if(g.default.prototype._pWriters[n].name===e)return r=new g.default.PrintWriter(e+this.millis(),t),g.default.prototype._pWriters.push(r),r;return r=new g.default.PrintWriter(e,t),g.default.prototype._pWriters.push(r),r},g.default.PrintWriter=function(r,n){var a=this;this.name=r,this.content="",this.write=function(e){this.content+=e;},this.print=function(e){this.content+="".concat(e,"\n");},this.clear=function(){this.content="";},this.close=function(){var e=[];for(var t in e.push(this.content),g.default.prototype.writeFile(e,r,n),g.default.prototype._pWriters)g.default.prototype._pWriters[t].name===this.name&&g.default.prototype._pWriters.splice(t,1);a.clear(),a={};};},g.default.prototype.save=function(e,t,r){var n=arguments,a=this._curElement?this._curElement.elt:this.elt;if(0!==n.length)if(n[0]instanceof g.default.Renderer||n[0]instanceof g.default.Graphics)g.default.prototype.saveCanvas(n[0].elt,n[1],n[2]);else if(1===n.length&&"string"==typeof n[0])g.default.prototype.saveCanvas(a,n[0]);else switch(l(n[1],n[2])[1]){case"json":return void g.default.prototype.saveJSON(n[0],n[1],n[2]);case"txt":return void g.default.prototype.saveStrings(n[0],n[1],n[2]);default:n[0]instanceof Array?g.default.prototype.saveStrings(n[0],n[1],n[2]):n[0]instanceof g.default.Table?g.default.prototype.saveTable(n[0],n[1],n[2]):n[0]instanceof g.default.Image?g.default.prototype.saveCanvas(n[0].canvas,n[1]):n[0]instanceof g.default.SoundFile&&g.default.prototype.saveSound(n[0],n[1],n[2],n[3]);}else g.default.prototype.saveCanvas(a);},g.default.prototype.saveJSON=function(e,t,r){var n;g.default._validateParameters("saveJSON",arguments),n=r?JSON.stringify(e):JSON.stringify(e,void 0,2),this.saveStrings(n.split("\n"),t,"json");},g.default.prototype.saveJSONObject=g.default.prototype.saveJSON,g.default.prototype.saveJSONArray=g.default.prototype.saveJSON,g.default.prototype.saveStrings=function(e,t,r,n){g.default._validateParameters("saveStrings",arguments);for(var a=r||"txt",o=this.createWriter(t,a),i=0;i<e.length;i++)n?o.write(e[i]+"\r\n"):o.write(e[i]+"\n");o.close(),o.clear();},g.default.prototype.saveTable=function(e,t,r){var n;g.default._validateParameters("saveTable",arguments),n=void 0===r?t.substring(t.lastIndexOf(".")+1,t.length):r;var a=this.createWriter(t,n),o=e.columns,i=",";if("tsv"===n&&(i="\t"),"html"!==n){if("0"!==o[0]){for(var s=0;s<o.length;s++)s<o.length-1?a.write(o[s]+i):a.write(o[s]);a.write("\n");}for(var l=0;l<e.rows.length;l++){var p=void 0;for(p=0;p<e.rows[l].arr.length;p++)p<e.rows[l].arr.length-1?a.write(e.rows[l].arr[p]+i):(e.rows.length,a.write(e.rows[l].arr[p]));a.write("\n");}}else {a.print("<html>"),a.print("<head>");if(a.print('  <meta http-equiv="content-type" content="text/html;charset=utf-8" />'),a.print("</head>"),a.print("<body>"),a.print("  <table>"),"0"!==o[0]){a.print("    <tr>");for(var u=0;u<o.length;u++){var c=f(o[u]);a.print("      <td>".concat(c)),a.print("      </td>");}a.print("    </tr>");}for(var d=0;d<e.rows.length;d++){a.print("    <tr>");for(var h=0;h<e.columns.length;h++){var m=f(e.rows[d].getString(h));a.print("      <td>".concat(m)),a.print("      </td>");}a.print("    </tr>");}a.print("  </table>"),a.print("</body>"),a.print("</html>");}a.close(),a.clear();},g.default.prototype.writeFile=function(e,t,r){var n="application/octet-stream";g.default.prototype._isSafari()&&(n="text/plain");var a=new Blob(e,{type:n});g.default.prototype.downloadFile(a,t,r);},g.default.prototype.downloadFile=function(e,t,r){var n=l(t,r),a=n[0];if(e instanceof Blob)s.default.saveAs(e,a);else {var o=document.createElement("a");if(o.href=e,o.download=a,o.onclick=function(e){var t;t=e,document.body.removeChild(t.target),e.stopPropagation();},o.style.display="none",document.body.appendChild(o),g.default.prototype._isSafari()){var i="Hello, Safari user! To download this file...\n";i+="1. Go to File --\x3e Save As.\n",i+='2. Choose "Page Source" as the Format.\n',i+='3. Name it with this extension: ."'.concat(n[1],'"'),alert(i);}o.click();}},g.default.prototype._checkFileExtension=l,g.default.prototype._isSafari=function(){return 0<Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor")};var a=g.default;r.default=a;},{"../core/friendly_errors/fes_core":24,"../core/friendly_errors/file_errors":25,"../core/friendly_errors/validate_params":27,"../core/main":32,"es6-promise/auto":6,"fetch-jsonp":8,"file-saver":9,"whatwg-fetch":16}],59:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};a.default.Table=function(e){this.columns=[],this.rows=[];},a.default.Table.prototype.addRow=function(e){var t=e||new a.default.TableRow;if(void 0===t.arr||void 0===t.obj)throw new Error("invalid TableRow: ".concat(t));return (t.table=this).rows.push(t),t},a.default.Table.prototype.removeRow=function(e){this.rows[e].table=null;var t=this.rows.splice(e+1,this.rows.length);this.rows.pop(),this.rows=this.rows.concat(t);},a.default.Table.prototype.getRow=function(e){return this.rows[e]},a.default.Table.prototype.getRows=function(){return this.rows},a.default.Table.prototype.findRow=function(e,t){if("string"==typeof t){for(var r=0;r<this.rows.length;r++)if(this.rows[r].obj[t]===e)return this.rows[r]}else for(var n=0;n<this.rows.length;n++)if(this.rows[n].arr[t]===e)return this.rows[n];return null},a.default.Table.prototype.findRows=function(e,t){var r=[];if("string"==typeof t)for(var n=0;n<this.rows.length;n++)this.rows[n].obj[t]===e&&r.push(this.rows[n]);else for(var a=0;a<this.rows.length;a++)this.rows[a].arr[t]===e&&r.push(this.rows[a]);return r},a.default.Table.prototype.matchRow=function(e,t){if("number"==typeof t){for(var r=0;r<this.rows.length;r++)if(this.rows[r].arr[t].match(e))return this.rows[r]}else for(var n=0;n<this.rows.length;n++)if(this.rows[n].obj[t].match(e))return this.rows[n];return null},a.default.Table.prototype.matchRows=function(e,t){var r=[];if("number"==typeof t)for(var n=0;n<this.rows.length;n++)this.rows[n].arr[t].match(e)&&r.push(this.rows[n]);else for(var a=0;a<this.rows.length;a++)this.rows[a].obj[t].match(e)&&r.push(this.rows[a]);return r},a.default.Table.prototype.getColumn=function(e){var t=[];if("string"==typeof e)for(var r=0;r<this.rows.length;r++)t.push(this.rows[r].obj[e]);else for(var n=0;n<this.rows.length;n++)t.push(this.rows[n].arr[e]);return t},a.default.Table.prototype.clearRows=function(){delete this.rows,this.rows=[];},a.default.Table.prototype.addColumn=function(e){var t=e||null;this.columns.push(t);},a.default.Table.prototype.getColumnCount=function(){return this.columns.length},a.default.Table.prototype.getRowCount=function(){return this.rows.length},a.default.Table.prototype.removeTokens=function(e,t){for(var r=[],n=0;n<e.length;n++)r.push(e.charAt(n).replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&"));var a=new RegExp(r.join("|"),"g");if(void 0===t)for(var o=0;o<this.columns.length;o++)for(var i=0;i<this.rows.length;i++){var s=this.rows[i].arr[o];s=s.replace(a,""),this.rows[i].arr[o]=s,this.rows[i].obj[this.columns[o]]=s;}else if("string"==typeof t)for(var l=0;l<this.rows.length;l++){var p=this.rows[l].obj[t];p=p.replace(a,""),this.rows[l].obj[t]=p;var u=this.columns.indexOf(t);this.rows[l].arr[u]=p;}else for(var c=0;c<this.rows.length;c++){var d=this.rows[c].arr[t];d=d.replace(a,""),this.rows[c].arr[t]=d,this.rows[c].obj[this.columns[t]]=d;}},a.default.Table.prototype.trim=function(e){var t=new RegExp(" ","g");if(void 0===e)for(var r=0;r<this.columns.length;r++)for(var n=0;n<this.rows.length;n++){var a=this.rows[n].arr[r];a=a.replace(t,""),this.rows[n].arr[r]=a,this.rows[n].obj[this.columns[r]]=a;}else if("string"==typeof e)for(var o=0;o<this.rows.length;o++){var i=this.rows[o].obj[e];i=i.replace(t,""),this.rows[o].obj[e]=i;var s=this.columns.indexOf(e);this.rows[o].arr[s]=i;}else for(var l=0;l<this.rows.length;l++){var p=this.rows[l].arr[e];p=p.replace(t,""),this.rows[l].arr[e]=p,this.rows[l].obj[this.columns[e]]=p;}},a.default.Table.prototype.removeColumn=function(e){var t,r;"string"==typeof e?(t=e,r=this.columns.indexOf(e)):(r=e,t=this.columns[e]);var n=this.columns.splice(r+1,this.columns.length);this.columns.pop(),this.columns=this.columns.concat(n);for(var a=0;a<this.rows.length;a++){var o=this.rows[a].arr,i=o.splice(r+1,o.length);o.pop(),this.rows[a].arr=o.concat(i),delete this.rows[a].obj[t];}},a.default.Table.prototype.set=function(e,t,r){this.rows[e].set(t,r);},a.default.Table.prototype.setNum=function(e,t,r){this.rows[e].setNum(t,r);},a.default.Table.prototype.setString=function(e,t,r){this.rows[e].setString(t,r);},a.default.Table.prototype.get=function(e,t){return this.rows[e].get(t)},a.default.Table.prototype.getNum=function(e,t){return this.rows[e].getNum(t)},a.default.Table.prototype.getString=function(e,t){return this.rows[e].getString(t)},a.default.Table.prototype.getObject=function(e){for(var t,r={},n=0;n<this.rows.length;n++)if(t=this.rows[n].obj,"string"==typeof e){if(!(0<=this.columns.indexOf(e)))throw new Error('This table has no column named "'.concat(e,'"'));r[t[e]]=t;}else r[n]=this.rows[n].obj;return r},a.default.Table.prototype.getArray=function(){for(var e=[],t=0;t<this.rows.length;t++)e.push(this.rows[t].arr);return e};var o=a.default;r.default=o;},{"../core/main":32}],60:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};a.default.TableRow=function(e,t){var r=[],n={};e&&(t=t||",",r=e.split(t));for(var a=0;a<r.length;a++){var o=a,i=r[a];n[o]=i;}this.arr=r,this.obj=n,this.table=null;},a.default.TableRow.prototype.set=function(e,t){if("string"==typeof e){var r=this.table.columns.indexOf(e);if(!(0<=r))throw new Error('This table has no column named "'.concat(e,'"'));this.obj[e]=t,this.arr[r]=t;}else {if(!(e<this.table.columns.length))throw new Error("Column #".concat(e," is out of the range of this table"));this.arr[e]=t;var n=this.table.columns[e];this.obj[n]=t;}},a.default.TableRow.prototype.setNum=function(e,t){var r=parseFloat(t);this.set(e,r);},a.default.TableRow.prototype.setString=function(e,t){var r=t.toString();this.set(e,r);},a.default.TableRow.prototype.get=function(e){return "string"==typeof e?this.obj[e]:this.arr[e]},a.default.TableRow.prototype.getNum=function(e){var t;if("NaN"===(t="string"==typeof e?parseFloat(this.obj[e]):parseFloat(this.arr[e])).toString())throw "Error: ".concat(this.obj[e]," is NaN (Not a Number)");return t},a.default.TableRow.prototype.getString=function(e){return "string"==typeof e?this.obj[e].toString():this.arr[e].toString()};var o=a.default;r.default=o;},{"../core/main":32}],61:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,s=(n=e("../core/main"))&&n.__esModule?n:{default:n};function a(e){for(var t=[],r=0;r<e.length;r++)t.push(new s.default.XML(e[r]));return t}s.default.XML=function(e){if(e)this.DOM=e;else {var t=document.implementation.createDocument(null,"doc");this.DOM=t.createElement("root");}},s.default.XML.prototype.getParent=function(){return new s.default.XML(this.DOM.parentElement)},s.default.XML.prototype.getName=function(){return this.DOM.tagName},s.default.XML.prototype.setName=function(e){var t=this.DOM.innerHTML,r=this.DOM.attributes,n=document.implementation.createDocument(null,"default").createElement(e);n.innerHTML=t;for(var a=0;a<r.length;a++)n.setAttribute(r[a].nodeName,r.nodeValue);this.DOM=n;},s.default.XML.prototype.hasChildren=function(){return 0<this.DOM.children.length},s.default.XML.prototype.listChildren=function(){for(var e=[],t=0;t<this.DOM.childNodes.length;t++)e.push(this.DOM.childNodes[t].nodeName);return e},s.default.XML.prototype.getChildren=function(e){return a(e?this.DOM.getElementsByTagName(e):this.DOM.children)},s.default.XML.prototype.getChild=function(e){if("string"!=typeof e)return new s.default.XML(this.DOM.children[e]);var t=!0,r=!1,n=void 0;try{for(var a,o=this.DOM.children[Symbol.iterator]();!(t=(a=o.next()).done);t=!0){var i=a.value;if(i.tagName===e)return new s.default.XML(i)}}catch(e){r=!0,n=e;}finally{try{t||null==o.return||o.return();}finally{if(r)throw n}}},s.default.XML.prototype.addChild=function(e){e instanceof s.default.XML&&this.DOM.appendChild(e.DOM);},s.default.XML.prototype.removeChild=function(e){var t=-1;if("string"==typeof e){for(var r=0;r<this.DOM.children.length;r++)if(this.DOM.children[r].tagName===e){t=r;break}}else t=e;-1!==t&&this.DOM.removeChild(this.DOM.children[t]);},s.default.XML.prototype.getAttributeCount=function(){return this.DOM.attributes.length},s.default.XML.prototype.listAttributes=function(){var e=[],t=!0,r=!1,n=void 0;try{for(var a,o=this.DOM.attributes[Symbol.iterator]();!(t=(a=o.next()).done);t=!0){var i=a.value;e.push(i.nodeName);}}catch(e){r=!0,n=e;}finally{try{t||null==o.return||o.return();}finally{if(r)throw n}}return e},s.default.XML.prototype.hasAttribute=function(e){var t={},r=!0,n=!1,a=void 0;try{for(var o,i=this.DOM.attributes[Symbol.iterator]();!(r=(o=i.next()).done);r=!0){var s=o.value;t[s.nodeName]=s.nodeValue;}}catch(e){n=!0,a=e;}finally{try{r||null==i.return||i.return();}finally{if(n)throw a}}return !!t[e]},s.default.XML.prototype.getNum=function(e,t){var r={},n=!0,a=!1,o=void 0;try{for(var i,s=this.DOM.attributes[Symbol.iterator]();!(n=(i=s.next()).done);n=!0){var l=i.value;r[l.nodeName]=l.nodeValue;}}catch(e){a=!0,o=e;}finally{try{n||null==s.return||s.return();}finally{if(a)throw o}}return Number(r[e])||t||0},s.default.XML.prototype.getString=function(e,t){var r={},n=!0,a=!1,o=void 0;try{for(var i,s=this.DOM.attributes[Symbol.iterator]();!(n=(i=s.next()).done);n=!0){var l=i.value;r[l.nodeName]=l.nodeValue;}}catch(e){a=!0,o=e;}finally{try{n||null==s.return||s.return();}finally{if(a)throw o}}return r[e]?String(r[e]):t||null},s.default.XML.prototype.setAttribute=function(e,t){this.DOM.setAttribute(e,t);},s.default.XML.prototype.getContent=function(e){return this.DOM.textContent.replace(/\s\s+/g,",")||e||null},s.default.XML.prototype.setContent=function(e){this.DOM.children.length||(this.DOM.textContent=e);},s.default.XML.prototype.serialize=function(){return (new XMLSerializer).serializeToString(this.DOM)};var o=s.default;r.default=o;},{"../core/main":32}],62:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,s=(n=e("../core/main"))&&n.__esModule?n:{default:n};function a(){if("function"==typeof Math.hypot)return Math.hypot.apply(null,arguments);for(var e=arguments.length,t=[],r=0,n=0;n<e;n++){var a=arguments[n];if((a=+a)===1/0||a===-1/0)return 1/0;r<(a=Math.abs(a))&&(r=a),t[n]=a;}0===r&&(r=1);for(var o=0,i=0,s=0;s<e;s++){var l=t[s]/r,p=l*l-i,u=o+p;i=u-o-p,o=u;}return Math.sqrt(o)*r}s.default.prototype.abs=Math.abs,s.default.prototype.ceil=Math.ceil,s.default.prototype.constrain=function(e,t,r){return s.default._validateParameters("constrain",arguments),Math.max(Math.min(e,r),t)},s.default.prototype.dist=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return s.default._validateParameters("dist",t),4===t.length?a(t[2]-t[0],t[3]-t[1]):6===t.length?a(t[3]-t[0],t[4]-t[1],t[5]-t[2]):void 0},s.default.prototype.exp=Math.exp,s.default.prototype.floor=Math.floor,s.default.prototype.lerp=function(e,t,r){return s.default._validateParameters("lerp",arguments),r*(t-e)+e},s.default.prototype.log=Math.log,s.default.prototype.mag=function(e,t){return s.default._validateParameters("mag",arguments),a(e,t)},s.default.prototype.map=function(e,t,r,n,a,o){s.default._validateParameters("map",arguments);var i=(e-t)/(r-t)*(a-n)+n;return o?n<a?this.constrain(i,n,a):this.constrain(i,a,n):i},s.default.prototype.max=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return s.default._validateParameters("max",t),t[0]instanceof Array?Math.max.apply(null,t[0]):Math.max.apply(null,t)},s.default.prototype.min=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return s.default._validateParameters("min",t),t[0]instanceof Array?Math.min.apply(null,t[0]):Math.min.apply(null,t)},s.default.prototype.norm=function(e,t,r){return s.default._validateParameters("norm",arguments),this.map(e,t,r,0,1)},s.default.prototype.pow=Math.pow,s.default.prototype.round=function(e,t){return t?Number(Math.round(e+"e"+t)+"e-"+t):Math.round(e)},s.default.prototype.sq=function(e){return e*e},s.default.prototype.sqrt=Math.sqrt,s.default.prototype.fract=function(e){s.default._validateParameters("fract",arguments);var t=0,r=Number(e);if(isNaN(r)||Math.abs(r)===1/0)return r;if(r<0&&(r=-r,t=1),!String(r).includes(".")||String(r).includes("e"))return r<1?Math.abs(t-r):0;var n=String(r);return n=Number("0"+n.slice(n.indexOf("."))),Math.abs(t-n)};var o=s.default;r.default=o;},{"../core/main":32}],63:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};a.default.prototype.createVector=function(e,t,r){return this instanceof a.default?new a.default.Vector(this,arguments):new a.default.Vector(e,t,r)};var o=a.default;r.default=o;},{"../core/main":32}],64:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};function b(e){return .5*(1-Math.cos(e*Math.PI))}var _,x=4095,S=4,w=.5;a.default.prototype.noise=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0,r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0;if(null==_){_=new Array(4096);for(var n=0;n<4096;n++)_[n]=Math.random();}e<0&&(e=-e),t<0&&(t=-t),r<0&&(r=-r);for(var a,o,i,s,l,p=Math.floor(e),u=Math.floor(t),c=Math.floor(r),d=e-p,h=t-u,m=r-c,f=0,y=.5,g=0;g<S;g++){var v=p+(u<<4)+(c<<8);a=b(d),o=b(h),i=_[v&x],i+=a*(_[v+1&x]-i),s=_[v+16&x],i+=o*((s+=a*(_[v+16+1&x]-s))-i),s=_[(v+=256)&x],s+=a*(_[v+1&x]-s),l=_[v+16&x],s+=o*((l+=a*(_[v+16+1&x]-l))-s),f+=(i+=b(m)*(s-i))*y,y*=w,p<<=1,u<<=1,c<<=1,1<=(d*=2)&&(p++,d--),1<=(h*=2)&&(u++,h--),1<=(m*=2)&&(c++,m--);}return f},a.default.prototype.noiseDetail=function(e,t){0<e&&(S=e),0<t&&(w=t);},a.default.prototype.noiseSeed=function(e){var t,r,n,a=(n=4294967296,{setSeed:function(e){r=t=(null==e?Math.random()*n:e)>>>0;},getSeed:function(){return t},rand:function(){return (r=(1664525*r+1013904223)%n)/n}});a.setSeed(e),_=new Array(4096);for(var o=0;o<4096;o++)_[o]=a.rand();};var o=a.default;r.default=o;},{"../core/main":32}],65:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,l=(n=e("../core/main"))&&n.__esModule?n:{default:n},o=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}l.default.Vector=function(e,t,r){var n,a,o;o=e instanceof l.default?(this.p5=e,n=t[0]||0,a=t[1]||0,t[2]||0):(n=e||0,a=t||0,r||0),this.x=n,this.y=a,this.z=o;},l.default.Vector.prototype.toString=function(){return "p5.Vector Object : [".concat(this.x,", ").concat(this.y,", ").concat(this.z,"]")},l.default.Vector.prototype.set=function(e,t,r){return e instanceof l.default.Vector?(this.x=e.x||0,this.y=e.y||0,this.z=e.z||0):e instanceof Array?(this.x=e[0]||0,this.y=e[1]||0,this.z=e[2]||0):(this.x=e||0,this.y=t||0,this.z=r||0),this},l.default.Vector.prototype.copy=function(){return this.p5?new l.default.Vector(this.p5,[this.x,this.y,this.z]):new l.default.Vector(this.x,this.y,this.z)},l.default.Vector.prototype.add=function(e,t,r){return e instanceof l.default.Vector?(this.x+=e.x||0,this.y+=e.y||0,this.z+=e.z||0):e instanceof Array?(this.x+=e[0]||0,this.y+=e[1]||0,this.z+=e[2]||0):(this.x+=e||0,this.y+=t||0,this.z+=r||0),this};function p(e,t){return 0!==e&&(this.x=this.x%e),0!==t&&(this.y=this.y%t),this}function u(e,t,r){return 0!==e&&(this.x=this.x%e),0!==t&&(this.y=this.y%t),0!==r&&(this.z=this.z%r),this}l.default.Vector.prototype.rem=function(e,t,r){if(e instanceof l.default.Vector){if(Number.isFinite(e.x)&&Number.isFinite(e.y)&&Number.isFinite(e.z)){var n=parseFloat(e.x),a=parseFloat(e.y),o=parseFloat(e.z);u.call(this,n,a,o);}}else if(e instanceof Array)e.every(function(e){return Number.isFinite(e)})&&(2===e.length&&p.call(this,e[0],e[1]),3===e.length&&u.call(this,e[0],e[1],e[2]));else if(1===arguments.length){if(Number.isFinite(e)&&0!==e)return this.x=this.x%e,this.y=this.y%e,this.z=this.z%e,this}else if(2===arguments.length){var i=Array.prototype.slice.call(arguments);i.every(function(e){return Number.isFinite(e)})&&2===i.length&&p.call(this,i[0],i[1]);}else if(3===arguments.length){var s=Array.prototype.slice.call(arguments);s.every(function(e){return Number.isFinite(e)})&&3===s.length&&u.call(this,s[0],s[1],s[2]);}},l.default.Vector.prototype.sub=function(e,t,r){return e instanceof l.default.Vector?(this.x-=e.x||0,this.y-=e.y||0,this.z-=e.z||0):e instanceof Array?(this.x-=e[0]||0,this.y-=e[1]||0,this.z-=e[2]||0):(this.x-=e||0,this.y-=t||0,this.z-=r||0),this},l.default.Vector.prototype.mult=function(e,t,r){if(e instanceof l.default.Vector)return Number.isFinite(e.x)&&Number.isFinite(e.y)&&Number.isFinite(e.z)&&"number"==typeof e.x&&"number"==typeof e.y&&"number"==typeof e.z?(this.x*=e.x,this.y*=e.y,this.z*=e.z):console.warn("p5.Vector.prototype.mult:","x contains components that are either undefined or not finite numbers"),this;if(e instanceof Array)return e.every(function(e){return Number.isFinite(e)})&&e.every(function(e){return "number"==typeof e})?1===e.length?(this.x*=e[0],this.y*=e[0],this.z*=e[0]):2===e.length?(this.x*=e[0],this.y*=e[1]):3===e.length&&(this.x*=e[0],this.y*=e[1],this.z*=e[2]):console.warn("p5.Vector.prototype.mult:","x contains elements that are either undefined or not finite numbers"),this;var n=Array.prototype.slice.call(arguments);return n.every(function(e){return Number.isFinite(e)})&&n.every(function(e){return "number"==typeof e})?(1===arguments.length&&(this.x*=e,this.y*=e,this.z*=e),2===arguments.length&&(this.x*=e,this.y*=t),3===arguments.length&&(this.x*=e,this.y*=t,this.z*=r)):console.warn("p5.Vector.prototype.mult:","x, y, or z arguments are either undefined or not a finite number"),this},l.default.Vector.prototype.div=function(e,t,r){if(e instanceof l.default.Vector){if(Number.isFinite(e.x)&&Number.isFinite(e.y)&&Number.isFinite(e.z)&&"number"==typeof e.x&&"number"==typeof e.y&&"number"==typeof e.z){if(0===e.x||0===e.y||0===e.z)return console.warn("p5.Vector.prototype.div:","divide by 0"),this;this.x/=e.x,this.y/=e.y,this.z/=e.z;}else console.warn("p5.Vector.prototype.div:","x contains components that are either undefined or not finite numbers");return this}if(e instanceof Array){if(e.every(function(e){return Number.isFinite(e)})&&e.every(function(e){return "number"==typeof e})){if(e.some(function(e){return 0===e}))return console.warn("p5.Vector.prototype.div:","divide by 0"),this;1===e.length?(this.x/=e[0],this.y/=e[0],this.z/=e[0]):2===e.length?(this.x/=e[0],this.y/=e[1]):3===e.length&&(this.x/=e[0],this.y/=e[1],this.z/=e[2]);}else console.warn("p5.Vector.prototype.div:","x contains components that are either undefined or not finite numbers");return this}var n=Array.prototype.slice.call(arguments);if(n.every(function(e){return Number.isFinite(e)})&&n.every(function(e){return "number"==typeof e})){if(n.some(function(e){return 0===e}))return console.warn("p5.Vector.prototype.div:","divide by 0"),this;1===arguments.length&&(this.x/=e,this.y/=e,this.z/=e),2===arguments.length&&(this.x/=e,this.y/=t),3===arguments.length&&(this.x/=e,this.y/=t,this.z/=r);}else console.warn("p5.Vector.prototype.div:","x, y, or z arguments are either undefined or not a finite number");return this},l.default.Vector.prototype.mag=function(){return Math.sqrt(this.magSq())},l.default.Vector.prototype.magSq=function(){var e=this.x,t=this.y,r=this.z;return e*e+t*t+r*r},l.default.Vector.prototype.dot=function(e,t,r){return e instanceof l.default.Vector?this.dot(e.x,e.y,e.z):this.x*(e||0)+this.y*(t||0)+this.z*(r||0)},l.default.Vector.prototype.cross=function(e){var t=this.y*e.z-this.z*e.y,r=this.z*e.x-this.x*e.z,n=this.x*e.y-this.y*e.x;return this.p5?new l.default.Vector(this.p5,[t,r,n]):new l.default.Vector(t,r,n)},l.default.Vector.prototype.dist=function(e){return e.copy().sub(this).mag()},l.default.Vector.prototype.normalize=function(){var e=this.mag();return 0!==e&&this.mult(1/e),this},l.default.Vector.prototype.limit=function(e){var t=this.magSq();return e*e<t&&this.div(Math.sqrt(t)).mult(e),this},l.default.Vector.prototype.setMag=function(e){return this.normalize().mult(e)},l.default.Vector.prototype.heading=function(){var e=Math.atan2(this.y,this.x);return this.p5?this.p5._fromRadians(e):e},l.default.Vector.prototype.rotate=function(e){var t=this.heading()+e;this.p5&&(t=this.p5._toRadians(t));var r=this.mag();return this.x=Math.cos(t)*r,this.y=Math.sin(t)*r,this},l.default.Vector.prototype.angleBetween=function(e){var t,r=this.dot(e)/(this.mag()*e.mag());return t=Math.acos(Math.min(1,Math.max(-1,r))),t*=Math.sign(this.cross(e).z||1),this.p5&&(t=this.p5._fromRadians(t)),t},l.default.Vector.prototype.lerp=function(e,t,r,n){return e instanceof l.default.Vector?this.lerp(e.x,e.y,e.z,t):(this.x+=(e-this.x)*n||0,this.y+=(t-this.y)*n||0,this.z+=(r-this.z)*n||0,this)},l.default.Vector.prototype.reflect=function(e){return e.normalize(),this.sub(e.mult(2*this.dot(e)))},l.default.Vector.prototype.array=function(){return [this.x||0,this.y||0,this.z||0]},l.default.Vector.prototype.equals=function(e,t,r){var n,a,o;return o=e instanceof l.default.Vector?(n=e.x||0,a=e.y||0,e.z||0):e instanceof Array?(n=e[0]||0,a=e[1]||0,e[2]||0):(n=e||0,a=t||0,r||0),this.x===n&&this.y===a&&this.z===o},l.default.Vector.fromAngle=function(e,t){return void 0===t&&(t=1),new l.default.Vector(t*Math.cos(e),t*Math.sin(e),0)},l.default.Vector.fromAngles=function(e,t,r){void 0===r&&(r=1);var n=Math.cos(t),a=Math.sin(t),o=Math.cos(e),i=Math.sin(e);return new l.default.Vector(r*i*a,-r*o,r*i*n)},l.default.Vector.random2D=function(){return this.fromAngle(Math.random()*o.TWO_PI)},l.default.Vector.random3D=function(){var e=Math.random()*o.TWO_PI,t=2*Math.random()-1,r=Math.sqrt(1-t*t),n=r*Math.cos(e),a=r*Math.sin(e);return new l.default.Vector(n,a,t)},l.default.Vector.add=function(e,t,r){return r?r.set(e):(r=e.copy(),3===arguments.length&&l.default._friendlyError("The target parameter is undefined, it should be of type p5.Vector","p5.Vector.add")),r.add(t),r},l.default.Vector.rem=function(e,t){if(e instanceof l.default.Vector&&t instanceof l.default.Vector){var r=e.copy();return r.rem(t),r}},l.default.Vector.sub=function(e,t,r){return r?r.set(e):(r=e.copy(),3===arguments.length&&l.default._friendlyError("The target parameter is undefined, it should be of type p5.Vector","p5.Vector.sub")),r.sub(t),r},l.default.Vector.mult=function(e,t,r){return r?r.set(e):(r=e.copy(),3===arguments.length&&l.default._friendlyError("The target parameter is undefined, it should be of type p5.Vector","p5.Vector.mult")),r.mult(t),r},l.default.Vector.div=function(e,t,r){return r?r.set(e):(r=e.copy(),3===arguments.length&&l.default._friendlyError("The target parameter is undefined, it should be of type p5.Vector","p5.Vector.div")),r.div(t),r},l.default.Vector.dot=function(e,t){return e.dot(t)},l.default.Vector.cross=function(e,t){return e.cross(t)},l.default.Vector.dist=function(e,t){return e.dist(t)},l.default.Vector.lerp=function(e,t,r,n){return n?n.set(e):(n=e.copy(),4===arguments.length&&l.default._friendlyError("The target parameter is undefined, it should be of type p5.Vector","p5.Vector.lerp")),n.lerp(t,r),n},l.default.Vector.mag=function(e){var t=e.x,r=e.y,n=e.z,a=t*t+r*r+n*n;return Math.sqrt(a)};var a=l.default.Vector;r.default=a;},{"../core/constants":22,"../core/main":32}],66:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};var o="_lcg_random_state",i=4294967296,s=0;a.default.prototype._lcg=function(e){return this[e]=(1664525*this[e]+1013904223)%i,this[e]/i},a.default.prototype._lcgSetSeed=function(e,t){this[e]=(null==t?Math.random()*i:t)>>>0;},a.default.prototype.randomSeed=function(e){this._lcgSetSeed(o,e),this._gaussian_previous=!1;},a.default.prototype.random=function(e,t){var r;if(a.default._validateParameters("random",arguments),r=null!=this[o]?this._lcg(o):Math.random(),void 0===e)return r;if(void 0===t)return e instanceof Array?e[Math.floor(r*e.length)]:r*e;if(t<e){var n=e;e=t,t=n;}return r*(t-e)+e},a.default.prototype.randomGaussian=function(e,t){var r,n,a,o;if(this._gaussian_previous)r=s,this._gaussian_previous=!1;else {for(;1<=(o=(n=this.random(2)-1)*n+(a=this.random(2)-1)*a););r=n*(o=Math.sqrt(-2*Math.log(o)/o)),s=a*o,this._gaussian_previous=!0;}return r*(t||1)+(e||0)};var l=a.default;r.default=l;},{"../core/main":32}],67:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n},o=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}a.default.prototype._angleMode=o.RADIANS,a.default.prototype.acos=function(e){return this._fromRadians(Math.acos(e))},a.default.prototype.asin=function(e){return this._fromRadians(Math.asin(e))},a.default.prototype.atan=function(e){return this._fromRadians(Math.atan(e))},a.default.prototype.atan2=function(e,t){return this._fromRadians(Math.atan2(e,t))},a.default.prototype.cos=function(e){return Math.cos(this._toRadians(e))},a.default.prototype.sin=function(e){return Math.sin(this._toRadians(e))},a.default.prototype.tan=function(e){return Math.tan(this._toRadians(e))},a.default.prototype.degrees=function(e){return e*o.RAD_TO_DEG},a.default.prototype.radians=function(e){return e*o.DEG_TO_RAD},a.default.prototype.angleMode=function(e){e!==o.DEGREES&&e!==o.RADIANS||(this._angleMode=e);},a.default.prototype._toRadians=function(e){return this._angleMode===o.DEGREES?e*o.DEG_TO_RAD:e},a.default.prototype._toDegrees=function(e){return this._angleMode===o.RADIANS?e*o.RAD_TO_DEG:e},a.default.prototype._fromRadians=function(e){return this._angleMode===o.DEGREES?e*o.RAD_TO_DEG:e};var l=a.default;r.default=l;},{"../core/constants":22,"../core/main":32}],68:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};a.default.prototype.textAlign=function(e,t){var r;return a.default._validateParameters("textAlign",arguments),(r=this._renderer).textAlign.apply(r,arguments)},a.default.prototype.textLeading=function(e){var t;return a.default._validateParameters("textLeading",arguments),(t=this._renderer).textLeading.apply(t,arguments)},a.default.prototype.textSize=function(e){var t;return a.default._validateParameters("textSize",arguments),(t=this._renderer).textSize.apply(t,arguments)},a.default.prototype.textStyle=function(e){var t;return a.default._validateParameters("textStyle",arguments),(t=this._renderer).textStyle.apply(t,arguments)},a.default.prototype.textWidth=function(){for(var e,t=arguments.length,r=new Array(t),n=0;n<t;n++)r[n]=arguments[n];return r[0]+="",a.default._validateParameters("textWidth",r),0===r[0].length?0:(e=this._renderer).textWidth.apply(e,r)},a.default.prototype.textAscent=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return a.default._validateParameters("textAscent",t),this._renderer.textAscent()},a.default.prototype.textDescent=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return a.default._validateParameters("textDescent",t),this._renderer.textDescent()},a.default.prototype._updateTextMetrics=function(){return this._renderer._updateTextMetrics()};var o=a.default;r.default=o;},{"../core/main":32}],69:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,d=(n=e("../core/main"))&&n.__esModule?n:{default:n},a=l(e("../core/constants")),o=l(e("opentype.js"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}function l(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}return r.default=e,t&&t.set(e,r),r}e("../core/friendly_errors/validate_params"),e("../core/friendly_errors/file_errors"),e("../core/friendly_errors/fes_core"),d.default.prototype.loadFont=function(s,l,p){d.default._validateParameters("loadFont",arguments);var u=new d.default.Font(this),c=this;return o.load(s,function(e,t){if(e)return d.default._friendlyFileLoadError(4,s),void 0!==p?p(e):void console.error(e,s);u.font=t,void 0!==l&&l(u),c._decrementPreload();var r,n,a=s.split("\\").pop().split("/").pop(),o=a.lastIndexOf("."),i=o<1?null:a.substr(o+1);["ttf","otf","woff","woff2"].includes(i)&&(r=a.substr(0,o),(n=document.createElement("style")).appendChild(document.createTextNode("\n@font-face {\nfont-family: ".concat(r,";\nsrc: url(").concat(s,");\n}\n"))),document.head.appendChild(n));}),u},d.default.prototype.text=function(e,t,r,n,a){var o;return d.default._validateParameters("text",arguments),this._renderer._doFill||this._renderer._doStroke?(o=this._renderer).text.apply(o,arguments):this},d.default.prototype.textFont=function(e,t){if(d.default._validateParameters("textFont",arguments),arguments.length){if(!e)throw new Error("null font passed to textFont");return this._renderer._setProperty("_textFont",e),t&&(this._renderer._setProperty("_textSize",t),this._renderer._setProperty("_textLeading",t*a._DEFAULT_LEADMULT)),this._renderer._applyTextProperties()}return this._renderer._textFont};var p=d.default;r.default=p;},{"../core/constants":22,"../core/friendly_errors/fes_core":24,"../core/friendly_errors/file_errors":25,"../core/friendly_errors/validate_params":27,"../core/main":32,"opentype.js":13}],70:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n},x=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==h(e)&&"function"!=typeof e)return {default:e};var t=i();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants"));function i(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return i=function(){return e},e}function h(e){return (h="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function m(e,t){for(var r=function(e,t){if("object"!==h(e))e=t;else for(var r in t)void 0===e[r]&&(e[r]=t[r]);return e}(t,{sampleFactor:.1,simplifyThreshold:0}),n=l(e,0,1),a=n/(n*r.sampleFactor),o=[],i=0;i<n;i+=a)o.push(l(e,i));return r.simplifyThreshold&&function(e){for(var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0,r=0,n=e.length-1;3<e.length&&0<=n;--n)d(s(e,n-1),s(e,n),s(e,n+1),t)&&(e.splice(n%e.length,1),r++);}(o,r.simplifyThreshold),o}function f(e){for(var t,r=[],n=0;n<e.length;n++)"M"===e[n].type&&(t&&r.push(t),t=[]),t.push(o(e[n]));return r.push(t),r}function o(e){var t=[e.type];return "M"===e.type||"L"===e.type?t.push(e.x,e.y):"C"===e.type?t.push(e.x1,e.y1,e.x2,e.y2,e.x,e.y):"Q"===e.type&&t.push(e.x1,e.y1,e.x,e.y),t}function s(e,t){var r=e.length;return e[t<0?t%r+r:t%r]}function d(e,t,r,n){if(!n)return 0==(a=e,i=r,((o=t)[0]-a[0])*(i[1]-a[1])-(i[0]-a[0])*(o[1]-a[1]));var a,o,i;void 0===d.tmpPoint1&&(d.tmpPoint1=[],d.tmpPoint2=[]);var s=d.tmpPoint1,l=d.tmpPoint2;s.x=t.x-e.x,s.y=t.y-e.y,l.x=r.x-t.x,l.y=r.y-t.y;var p=s.x*l.x+s.y*l.y,u=Math.sqrt(s.x*s.x+s.y*s.y),c=Math.sqrt(l.x*l.x+l.y*l.y);return Math.acos(p/(u*c))<n}function c(e,t,r,n,a,o,i,s,l){var p=1-l,u=Math.pow(p,3),c=Math.pow(p,2),d=l*l,h=d*l,m=u*e+3*c*l*r+3*p*l*l*a+h*i,f=u*t+3*c*l*n+3*p*l*l*o+h*s,y=e+2*l*(r-e)+d*(a-2*r+e),g=t+2*l*(n-t)+d*(o-2*n+t),v=r+2*l*(a-r)+d*(i-2*a+r),b=n+2*l*(o-n)+d*(s-2*o+n),_=p*e+l*r,x=p*t+l*n,S=p*a+l*i,w=p*o+l*s,M=90-180*Math.atan2(y-v,g-b)/Math.PI;return (v<y||g<b)&&(M+=180),{x:m,y:f,m:{x:y,y:g},n:{x:v,y:b},start:{x:_,y:x},end:{x:S,y:w},alpha:M}}function y(e,t,r,n,a,o,i,s,l){return null==l?g(e,t,r,n,a,o,i,s):c(e,t,r,n,a,o,i,s,function(e,t,r,n,a,o,i,s,l){if(l<0||g(e,t,r,n,a,o,i,s)<l)return;var p,u=.5,c=1-u;p=g(e,t,r,n,a,o,i,s,c);for(;.01<Math.abs(p-l);)p=g(e,t,r,n,a,o,i,s,c+=(p<l?1:-1)*(u/=2));return c}(e,t,r,n,a,o,i,s,l))}function l(e,t,r){for(var n,a,o,i,s,l=0,p=0,u=(e=function(e,t){function r(e,t,r){var n,a;if(!e)return ["C",t.x,t.y,t.x,t.y,t.x,t.y];switch(e[0]in{T:1,Q:1}||(t.qx=t.qy=null),e[0]){case"M":t.X=e[1],t.Y=e[2];break;case"A":e=["C"].concat(function e(t,r,n,a,o,i,s,l,p,u){var c=Math.PI;var d=120*c/180;var h;var m;var f;var y;var g=c/180*(+o||0);var v=[];var b;var _=function(e,t,r){var n=e*Math.cos(r)-t*Math.sin(r),a=e*Math.sin(r)+t*Math.cos(r);return {x:n,y:a}};if(u)h=u[0],m=u[1],f=u[2],y=u[3];else {b=_(t,r,-g),t=b.x,r=b.y,b=_(l,p,-g),l=b.x,p=b.y;var x=(t-l)/2,S=(r-p)/2,w=x*x/(n*n)+S*S/(a*a);1<w&&(w=Math.sqrt(w),n*=w,a*=w);var M=n*n,E=a*a,T=(i===s?-1:1)*Math.sqrt(Math.abs((M*E-M*S*S-E*x*x)/(M*S*S+E*x*x)));f=T*n*S/a+(t+l)/2,y=T*-a*x/n+(r+p)/2,h=Math.asin(((r-y)/a).toFixed(9)),m=Math.asin(((p-y)/a).toFixed(9)),(h=t<f?c-h:h)<0&&(h=2*c+h),(m=l<f?c-m:m)<0&&(m=2*c+m),s&&m<h&&(h-=2*c),!s&&h<m&&(m-=2*c);}var C=m-h;if(Math.abs(C)>d){var N=m,O=l,L=p;m=h+d*(s&&h<m?1:-1),l=f+n*Math.cos(m),p=y+a*Math.sin(m),v=e(l,p,n,a,o,0,s,O,L,[m,N,f,y]);}C=m-h;var I=Math.cos(h),P=Math.sin(h),R=Math.cos(m),D=Math.sin(m),A=Math.tan(C/4),k=4/3*n*A,F=4/3*a*A,U=[t,r],B=[t+k*P,r-F*I],G=[l+k*D,p-F*R],j=[l,p];B[0]=2*U[0]-B[0];B[1]=2*U[1]-B[1];{if(u)return [B,G,j].concat(v);v=[B,G,j].concat(v).join().split(",");for(var V=[],z=0,H=v.length;z<H;z++)V[z]=z%2?_(v[z-1],v[z],g).y:_(v[z],v[z+1],g).x;return V}}.apply(0,[t.x,t.y].concat(e.slice(1))));break;case"S":a="C"===r||"S"===r?(n=2*t.x-t.bx,2*t.y-t.by):(n=t.x,t.y),e=["C",n,a].concat(e.slice(1));break;case"T":"Q"===r||"T"===r?(t.qx=2*t.x-t.qx,t.qy=2*t.y-t.qy):(t.qx=t.x,t.qy=t.y),e=["C"].concat(w(t.x,t.y,t.qx,t.qy,e[1],e[2]));break;case"Q":t.qx=e[1],t.qy=e[2],e=["C"].concat(w(t.x,t.y,e[1],e[2],e[3],e[4]));break;case"L":e=["C"].concat(S(t.x,t.y,e[1],e[2]));break;case"H":e=["C"].concat(S(t.x,t.y,e[1],t.y));break;case"V":e=["C"].concat(S(t.x,t.y,t.x,e[1]));break;case"Z":e=["C"].concat(S(t.x,t.y,t.X,t.Y));}return e}function n(e,t){if(7<e[t].length){e[t].shift();for(var r=e[t];r.length;)u[t]="A",s&&(c[t]="A"),e.splice(t++,0,["C"].concat(r.splice(0,6)));e.splice(t,1),o=Math.max(i.length,s&&s.length||0);}}function a(e,t,r,n,a){e&&t&&"M"===e[a][0]&&"M"!==t[a][0]&&(t.splice(a,0,["M",n.x,n.y]),r.bx=0,r.by=0,r.x=e[a][1],r.y=e[a][2],o=Math.max(i.length,s&&s.length||0));}var o,i=b(e),s=t&&b(t),l={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},p={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},u=[],c=[],d="",h="";o=Math.max(i.length,s&&s.length||0);for(var m=0;m<o;m++){i[m]&&(d=i[m][0]),"C"!==d&&(u[m]=d,m&&(h=u[m-1])),i[m]=r(i[m],l,h),"A"!==u[m]&&"C"===d&&(u[m]="C"),n(i,m),s&&(s[m]&&(d=s[m][0]),"C"!==d&&(c[m]=d,m&&(h=c[m-1])),s[m]=r(s[m],p,h),"A"!==c[m]&&"C"===d&&(c[m]="C"),n(s,m)),a(i,s,l,p,m),a(s,i,p,l,m);var f=i[m],y=s&&s[m],g=f.length,v=s&&y.length;l.x=f[g-2],l.y=f[g-1],l.bx=parseFloat(f[g-4])||l.x,l.by=parseFloat(f[g-3])||l.y,p.bx=s&&(parseFloat(y[v-4])||p.x),p.by=s&&(parseFloat(y[v-3])||p.y),p.x=s&&y[v-2],p.y=s&&y[v-1];}return s?[i,s]:i}(e)).length;p<u;p++){if("M"===(o=e[p])[0])n=+o[1],a=+o[2];else {if(t<l+(i=y(n,a,o[1],o[2],o[3],o[4],o[5],o[6]))&&!r)return {x:(s=y(n,a,o[1],o[2],o[3],o[4],o[5],o[6],t-l)).x,y:s.y,alpha:s.alpha};l+=i,n=+o[5],a=+o[6];}o.shift()+o;}return (s=r?l:c(n,a,o[0],o[1],o[2],o[3],o[4],o[5],1)).alpha&&(s={x:s.x,y:s.y,alpha:s.alpha}),s}function b(e){var t,r=[],n=0,a=0,o=0,i=0,s=0;if(!e)return r;"M"===e[0][0]&&(o=n=+e[0][1],i=a=+e[0][2],s++,r[0]=["M",n,a]);for(var l,p,u=3===e.length&&"M"===e[0][0]&&"R"===e[1][0].toUpperCase()&&"Z"===e[2][0].toUpperCase(),c=s,d=e.length;c<d;c++){if(r.push(l=[]),(p=e[c])[0]!==String.prototype.toUpperCase.call(p[0]))switch(l[0]=String.prototype.toUpperCase.call(p[0]),l[0]){case"A":l[1]=p[1],l[2]=p[2],l[3]=p[3],l[4]=p[4],l[5]=p[5],l[6]=+(p[6]+n),l[7]=+(p[7]+a);break;case"V":l[1]=+p[1]+a;break;case"H":l[1]=+p[1]+n;break;case"R":for(var h=2,m=(t=[n,a].concat(p.slice(1))).length;h<m;h++)t[h]=+t[h]+n,t[++h]=+t[h]+a;r.pop(),r=r.concat(_(t,u));break;case"M":o=+p[1]+n,i=+p[2]+a;break;default:for(var f=1,y=p.length;f<y;f++)l[f]=+p[f]+(f%2?n:a);}else if("R"===p[0])t=[n,a].concat(p.slice(1)),r.pop(),r=r.concat(_(t,u)),l=["R"].concat(p.slice(-2));else for(var g=0,v=p.length;g<v;g++)l[g]=p[g];switch(l[0]){case"Z":n=o,a=i;break;case"H":n=l[1];break;case"V":a=l[1];break;case"M":o=l[l.length-2],i=l[l.length-1];break;default:n=l[l.length-2],a=l[l.length-1];}}return r}function _(e,t){for(var r=[],n=0,a=e.length;n<a-2*!t;n+=2){var o=[{x:+e[n-2],y:+e[n-1]},{x:+e[n],y:+e[n+1]},{x:+e[n+2],y:+e[n+3]},{x:+e[n+4],y:+e[n+5]}];t?n?a-4===n?o[3]={x:+e[0],y:+e[1]}:a-2===n&&(o[2]={x:+e[0],y:+e[1]},o[3]={x:+e[2],y:+e[3]}):o[0]={x:+e[a-2],y:+e[a-1]}:a-4===n?o[3]=o[2]:n||(o[0]={x:+e[n],y:+e[n+1]}),r.push(["C",(-o[0].x+6*o[1].x+o[2].x)/6,(-o[0].y+6*o[1].y+o[2].y)/6,(o[1].x+6*o[2].x-o[3].x)/6,(o[1].y+6*o[2].y-o[3].y)/6,o[2].x,o[2].y]);}return r}function S(e,t,r,n){return [e,t,r,n,r,n]}function w(e,t,r,n,a,o){return [1/3*e+2/3*r,1/3*t+2/3*n,1/3*a+2/3*r,1/3*o+2/3*n,a,o]}function g(e,t,r,n,a,o,i,s,l){null==l&&(l=1);for(var p=(l=1<l?1:l<0?0:l)/2,u=[-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],c=0,d=[.2491,.2491,.2335,.2335,.2032,.2032,.1601,.1601,.1069,.1069,.0472,.0472],h=0;h<12;h++){var m=p*u[h]+p,f=v(m,e,r,a,i),y=v(m,t,n,o,s),g=f*f+y*y;c+=d[h]*Math.sqrt(g);}return p*c}function v(e,t,r,n,a){return e*(e*(-3*t+9*r-9*n+3*a)+6*t-12*r+6*n)-3*t+3*r}a.default.Font=function(e){this.parent=e,this.cache={},this.font=void 0;},a.default.Font.prototype.textBounds=function(e){var t,r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0,n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0,a=3<arguments.length?arguments[3]:void 0,o=4<arguments.length?arguments[4]:void 0,i=o&&o.renderer&&o.renderer._pInst||this.parent,s=i._renderer.drawingContext;s.textAlign||x.LEFT,s.textBaseline||x.BASELINE;if(a=a||i._renderer._textSize,!t){var l,p,u=[],c=[],d=[];d[0]=[];var h=[],m=this._scale(a),f=i._renderer.textLeading(),y=0;this.font.forEachGlyph(e,r,n,a,o,function(e,t,r,n){var a=e.getMetrics();0===e.index||10===e.index?d[y+=1]=[]:(d[y].push(t+a.xMin*m),d[y].push(t+a.xMax*m),h.push(r+y*f+-a.yMin*m),h.push(r+y*f+-a.yMax*m));}),0<d[y].length&&(u[y]=Math.min.apply(null,d[y]),c[y]=Math.max.apply(null,d[y]));for(var g=0,v=0;v<=y;v++){u[v]=Math.min.apply(null,d[v]),c[v]=Math.max.apply(null,d[v]);var b=c[v]-u[v];g<b&&(g=b);}var _=Math.min.apply(null,u);t={x:_,y:l=Math.min.apply(null,h),h:Math.max.apply(null,h)-l,w:g,advance:_-r},p=this._handleAlignment(i._renderer,e,t.x,t.y,t.w+t.advance),t.x=p.x,t.y=p.y;}return t},a.default.Font.prototype.textToPoints=function(e,t,r,n,a){var o,i=0,s=[],l=this._getGlyphs(e);n=n||this.parent._renderer._textSize;for(var p=0;p<l.length;p++){if(!(l[o=p].name&&"space"===l[o].name||e.length===l.length&&" "===e[o]||l[o].index&&3===l[o].index))for(var u=f(l[p].getPath(t,r,n).commands),c=0;c<u.length;c++)for(var d=m(u[c],a),h=0;h<d.length;h++)d[h].x+=i,s.push(d[h]);i+=l[p].advanceWidth*this._scale(n);}return s},a.default.Font.prototype._getGlyphs=function(e){return this.font.stringToGlyphs(e)},a.default.Font.prototype._getPath=function(e,t,r,n){var a=(n&&n.renderer&&n.renderer._pInst||this.parent)._renderer,o=this._handleAlignment(a,e,t,r);return this.font.getPath(e,o.x,o.y,a._textSize,n)},a.default.Font.prototype._getPathData=function(e,t,r,n){var a=3;return "string"==typeof e&&2<arguments.length?e=this._getPath(e,t,r,n):"object"===h(t)&&(n=t),n&&"number"==typeof n.decimals&&(a=n.decimals),e.toPathData(a)},a.default.Font.prototype._getSVG=function(e,t,r,n){var a=3;return "string"==typeof e&&2<arguments.length?e=this._getPath(e,t,r,n):"object"===h(t)&&(n=t),n&&("number"==typeof n.decimals&&(a=n.decimals),"number"==typeof n.strokeWidth&&(e.strokeWidth=n.strokeWidth),void 0!==n.fill&&(e.fill=n.fill),void 0!==n.stroke&&(e.stroke=n.stroke)),e.toSVG(a)},a.default.Font.prototype._renderPath=function(e,t,r,n){var a,o=n&&n.renderer||this.parent._renderer,i=o.drawingContext;a="object"===h(e)&&e.commands?e.commands:this._getPath(e,t,r,n).commands,i.beginPath();var s=!0,l=!1,p=void 0;try{for(var u,c=a[Symbol.iterator]();!(s=(u=c.next()).done);s=!0){var d=u.value;"M"===d.type?i.moveTo(d.x,d.y):"L"===d.type?i.lineTo(d.x,d.y):"C"===d.type?i.bezierCurveTo(d.x1,d.y1,d.x2,d.y2,d.x,d.y):"Q"===d.type?i.quadraticCurveTo(d.x1,d.y1,d.x,d.y):"Z"===d.type&&i.closePath();}}catch(e){l=!0,p=e;}finally{try{s||null==c.return||c.return();}finally{if(l)throw p}}return o._doStroke&&o._strokeSet&&i.stroke(),o._doFill&&(o._fillSet||o._setFill(x._DEFAULT_TEXT_FILL),i.fill()),this},a.default.Font.prototype._textWidth=function(e,t){return this.font.getAdvanceWidth(e,t)},a.default.Font.prototype._textAscent=function(e){return this.font.ascender*this._scale(e)},a.default.Font.prototype._textDescent=function(e){return -this.font.descender*this._scale(e)},a.default.Font.prototype._scale=function(e){return 1/this.font.unitsPerEm*(e||this.parent._renderer._textSize)},a.default.Font.prototype._handleAlignment=function(e,t,r,n,a){var o=e._textSize;switch(void 0===a&&(a=this._textWidth(t,o)),e._textAlign){case x.CENTER:r-=a/2;break;case x.RIGHT:r-=a;}switch(e._textBaseline){case x.TOP:n+=this._textAscent(o);break;case x.CENTER:n+=this._textAscent(o)/2;break;case x.BOTTOM:n-=this._textDescent(o);}return {x:r,y:n}};var p=a.default;r.default=p;},{"../core/constants":22,"../core/main":32}],71:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};a.default.prototype.append=function(e,t){return e.push(t),e},a.default.prototype.arrayCopy=function(e,t,r,n,a){var o,i;e=void 0!==a?(i=Math.min(a,e.length),o=n,e.slice(t,i+t)):(i=void 0!==r?(i=r,Math.min(i,e.length)):e.length,o=0,r=t,e.slice(0,i)),Array.prototype.splice.apply(r,[o,i].concat(e));},a.default.prototype.concat=function(e,t){return e.concat(t)},a.default.prototype.reverse=function(e){return e.reverse()},a.default.prototype.shorten=function(e){return e.pop(),e},a.default.prototype.shuffle=function(e,t){for(var r,n,a=ArrayBuffer&&ArrayBuffer.isView&&ArrayBuffer.isView(e),o=(e=t||a?e:e.slice()).length;1<o;)r=this.random(0,1)*o|0,n=e[--o],e[o]=e[r],e[r]=n;return e},a.default.prototype.sort=function(e,t){var r=t?e.slice(0,Math.min(t,e.length)):e,n=t?e.slice(Math.min(t,e.length)):[];return (r="string"==typeof r[0]?r.sort():r.sort(function(e,t){return e-t})).concat(n)},a.default.prototype.splice=function(e,t,r){return Array.prototype.splice.apply(e,[r,0].concat(t)),e},a.default.prototype.subset=function(e,t,r){return void 0!==r?e.slice(t,t+r):e.slice(t,e.length)};var o=a.default;r.default=o;},{"../core/main":32}],72:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};a.default.prototype.float=function(e){return e instanceof Array?e.map(parseFloat):parseFloat(e)},a.default.prototype.int=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:10;return e===1/0||"Infinity"===e?1/0:e===-1/0||"-Infinity"===e?-1/0:"string"==typeof e?parseInt(e,t):"number"==typeof e?0|e:"boolean"==typeof e?e?1:0:e instanceof Array?e.map(function(e){return a.default.prototype.int(e,t)}):void 0},a.default.prototype.str=function(e){return e instanceof Array?e.map(a.default.prototype.str):String(e)},a.default.prototype.boolean=function(e){return "number"==typeof e?0!==e:"string"==typeof e?"true"===e.toLowerCase():"boolean"==typeof e?e:e instanceof Array?e.map(a.default.prototype.boolean):void 0},a.default.prototype.byte=function(e){var t=a.default.prototype.int(e,10);return "number"==typeof t?(t+128)%256-128:t instanceof Array?t.map(a.default.prototype.byte):void 0},a.default.prototype.char=function(e){return "number"!=typeof e||isNaN(e)?e instanceof Array?e.map(a.default.prototype.char):"string"==typeof e?a.default.prototype.char(parseInt(e,10)):void 0:String.fromCharCode(e)},a.default.prototype.unchar=function(e){return "string"==typeof e&&1===e.length?e.charCodeAt(0):e instanceof Array?e.map(a.default.prototype.unchar):void 0},a.default.prototype.hex=function(e,t){if(t=null==t?t=8:t,e instanceof Array)return e.map(function(e){return a.default.prototype.hex(e,t)});if(e===1/0||e===-1/0)return (e===1/0?"F":"0").repeat(t);if("number"==typeof e){e<0&&(e=4294967295+e+1);for(var r=Number(e).toString(16).toUpperCase();r.length<t;)r="0".concat(r);return r.length>=t&&(r=r.substring(r.length-t,r.length)),r}},a.default.prototype.unhex=function(e){return e instanceof Array?e.map(a.default.prototype.unhex):parseInt("0x".concat(e),16)};var o=a.default;r.default=o;},{"../core/main":32}],73:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,i=(n=e("../core/main"))&&n.__esModule?n:{default:n};function a(e,t,r){var n=e<0,a=n?e.toString().substring(1):e.toString(),o=a.indexOf("."),i=-1!==o?a.substring(0,o):a,s=-1!==o?a.substring(o+1):"",l=n?"-":"";if(void 0!==r){var p="";(-1!==o||0<r-s.length)&&(p="."),s.length>r&&(s=s.substring(0,r));for(var u=0;u<t-i.length;u++)l+="0";l+=i,l+=p,l+=s;for(var c=0;c<r-s.length;c++)l+="0";return l}for(var d=0;d<Math.max(t-i.length,0);d++)l+="0";return l+=a}function o(e,t){var r=(e=e.toString()).indexOf("."),n=-1!==r?e.substring(r):"",a=-1!==r?e.substring(0,r):e;if(a=a.toString().replace(/\B(?=(\d{3})+(?!\d))/g,","),0===t)n="";else if(void 0!==t)if(t>n.length)for(var o=t-(n+=-1===r?".":"").length+1,i=0;i<o;i++)n+="0";else n=n.substring(0,t+1);return a+n}function s(e){return 0<parseFloat(e)?"+".concat(e.toString()):e.toString()}function l(e){return 0<=parseFloat(e)?" ".concat(e.toString()):e.toString()}e("../core/friendly_errors/validate_params"),e("../core/friendly_errors/file_errors"),e("../core/friendly_errors/fes_core"),i.default.prototype.join=function(e,t){return i.default._validateParameters("join",arguments),e.join(t)},i.default.prototype.match=function(e,t){return i.default._validateParameters("match",arguments),e.match(t)},i.default.prototype.matchAll=function(e,t){i.default._validateParameters("matchAll",arguments);for(var r=new RegExp(t,"g"),n=r.exec(e),a=[];null!==n;)a.push(n),n=r.exec(e);return a},i.default.prototype.nf=function(e,t,r){return i.default._validateParameters("nf",arguments),e instanceof Array?e.map(function(e){return a(e,t,r)}):"[object Arguments]"===Object.prototype.toString.call(e)?3===e.length?this.nf(e[0],e[1],e[2]):2===e.length?this.nf(e[0],e[1]):this.nf(e[0]):a(e,t,r)},i.default.prototype.nfc=function(e,t){return i.default._validateParameters("nfc",arguments),e instanceof Array?e.map(function(e){return o(e,t)}):o(e,t)},i.default.prototype.nfp=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];i.default._validateParameters("nfp",t);var n=i.default.prototype.nf.apply(this,t);return n instanceof Array?n.map(s):s(n)},i.default.prototype.nfs=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];i.default._validateParameters("nfs",t);var n=i.default.prototype.nf.apply(this,t);return n instanceof Array?n.map(l):l(n)},i.default.prototype.split=function(e,t){return i.default._validateParameters("split",arguments),e.split(t)},i.default.prototype.splitTokens=function(e,t){var r;if(i.default._validateParameters("splitTokens",arguments),void 0!==t){var n=t,a=/\]/g.exec(n),o=/\[/g.exec(n);r=o&&a?(n=n.slice(0,a.index)+n.slice(a.index+1),o=/\[/g.exec(n),n=n.slice(0,o.index)+n.slice(o.index+1),new RegExp("[\\[".concat(n,"\\]]"),"g")):a?(n=n.slice(0,a.index)+n.slice(a.index+1),new RegExp("[".concat(n,"\\]]"),"g")):o?(n=n.slice(0,o.index)+n.slice(o.index+1),new RegExp("[".concat(n,"\\[]"),"g")):new RegExp("[".concat(n,"]"),"g");}else r=/\s/g;return e.split(r).filter(function(e){return e})},i.default.prototype.trim=function(e){return i.default._validateParameters("trim",arguments),e instanceof Array?e.map(this.trim):e.trim()};var p=i.default;r.default=p;},{"../core/friendly_errors/fes_core":24,"../core/friendly_errors/file_errors":25,"../core/friendly_errors/validate_params":27,"../core/main":32}],74:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};a.default.prototype.day=function(){return (new Date).getDate()},a.default.prototype.hour=function(){return (new Date).getHours()},a.default.prototype.minute=function(){return (new Date).getMinutes()},a.default.prototype.millis=function(){return -1===this._millisStart?0:window.performance.now()-this._millisStart},a.default.prototype.month=function(){return (new Date).getMonth()+1},a.default.prototype.second=function(){return (new Date).getSeconds()},a.default.prototype.year=function(){return (new Date).getFullYear()};var o=a.default;r.default=o;},{"../core/main":32}],75:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,T=(n=e("../core/main"))&&n.__esModule?n:{default:n};e("./p5.Geometry");var h=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}T.default.prototype.plane=function(e,t,r,n){this._assert3d("plane"),T.default._validateParameters("plane",arguments),void 0===e&&(e=50),void 0===t&&(t=e),void 0===r&&(r=1),void 0===n&&(n=1);var a="plane|".concat(r,"|").concat(n);if(!this._renderer.geometryInHash(a)){var o=new T.default.Geometry(r,n,function(){for(var e,t,r,n=0;n<=this.detailY;n++){t=n/this.detailY;for(var a=0;a<=this.detailX;a++)e=a/this.detailX,r=new T.default.Vector(e-.5,t-.5,0),this.vertices.push(r),this.uvs.push(e,t);}});o.computeFaces().computeNormals(),r<=1&&n<=1?o._makeTriangleEdges()._edgesToVertices():this._renderer._doStroke&&console.log("Cannot draw stroke on plane objects with more than 1 detailX or 1 detailY"),this._renderer.createBuffers(a,o);}return this._renderer.drawBuffersScaled(a,e,t,1),this},T.default.prototype.box=function(e,t,r,n,a){this._assert3d("box"),T.default._validateParameters("box",arguments),void 0===e&&(e=50),void 0===t&&(t=e),void 0===r&&(r=t);var o=this._renderer.attributes&&this._renderer.attributes.perPixelLighting;void 0===n&&(n=o?1:4),void 0===a&&(a=o?1:4);var i="box|".concat(n,"|").concat(a);if(!this._renderer.geometryInHash(i)){var s=new T.default.Geometry(n,a,function(){var e=[[0,4,2,6],[1,3,5,7],[0,1,4,5],[2,6,3,7],[0,2,1,3],[4,5,6,7]];this.strokeIndices=[[0,1],[1,3],[3,2],[6,7],[8,9],[9,11],[14,15],[16,17],[17,19],[18,19],[20,21],[22,23]];for(var t=0;t<e.length;t++){for(var r=e[t],n=4*t,a=0;a<4;a++){var o=r[a],i=new T.default.Vector((2*(1&o)-1)/2,((2&o)-1)/2,((4&o)/2-1)/2);this.vertices.push(i),this.uvs.push(1&a,(2&a)/2);}this.faces.push([n,1+n,2+n]),this.faces.push([2+n,1+n,3+n]);}});s.computeNormals(),n<=4&&a<=4?s._makeTriangleEdges()._edgesToVertices():this._renderer._doStroke&&console.log("Cannot draw stroke on box objects with more than 4 detailX or 4 detailY"),this._renderer.createBuffers(i,s);}return this._renderer.drawBuffersScaled(i,e,t,r),this},T.default.prototype.sphere=function(e,t,r){return this._assert3d("sphere"),T.default._validateParameters("sphere",arguments),void 0===e&&(e=50),void 0===t&&(t=24),void 0===r&&(r=16),this.ellipsoid(e,e,e,t,r),this};function l(e,t,r,n,a,o,i){e=e<=0?1:e,t=t<0?0:t,r=r<=0?e:r,n=n<3?3:n;var s,l,p,u=(o=void 0===o||o)?-2:0,c=(a=a<1?1:a)+((i=void 0===i?0!==t:i)?2:0),d=Math.atan2(e-t,r),h=Math.sin(d),m=Math.cos(d);for(s=u;s<=c;++s){var f=s/a,y=r*f,g=void 0;for(g=s<0?(f=y=0,e):a<s?(y=r,f=1,t):e+(t-e)*f,-2!==s&&s!==a+2||(g=0),y-=r/2,l=0;l<n;++l){var v=l/(n-1),b=2*Math.PI*v,_=Math.sin(b),x=Math.cos(b);this.vertices.push(new T.default.Vector(_*g,y,x*g));var S=void 0;S=s<0?new T.default.Vector(0,-1,0):a<s&&t?new T.default.Vector(0,1,0):new T.default.Vector(_*m,h,x*m),this.vertexNormals.push(S),this.uvs.push(v,f);}}var w=0;if(o){for(p=0;p<n;++p){var M=(p+1)%n;this.faces.push([w+p,w+n+M,w+n+p]);}w+=2*n;}for(s=0;s<a;++s){for(l=0;l<n;++l){var E=(l+1)%n;this.faces.push([w+l,w+E,w+n+E]),this.faces.push([w+l,w+n+E,w+n+l]);}w+=n;}if(i)for(w+=n,l=0;l<n;++l)this.faces.push([w+l,w+(l+1)%n,w+n]);}T.default.prototype.cylinder=function(e,t,r,n,a,o){this._assert3d("cylinder"),T.default._validateParameters("cylinder",arguments),void 0===e&&(e=50),void 0===t&&(t=e),void 0===r&&(r=24),void 0===n&&(n=1),void 0===o&&(o=!0),void 0===a&&(a=!0);var i="cylinder|".concat(r,"|").concat(n,"|").concat(a,"|").concat(o);if(!this._renderer.geometryInHash(i)){var s=new T.default.Geometry(r,n);l.call(s,1,1,1,r,n,a,o),r<=24&&n<=16?s._makeTriangleEdges()._edgesToVertices():this._renderer._doStroke&&console.log("Cannot draw stroke on cylinder objects with more than 24 detailX or 16 detailY"),this._renderer.createBuffers(i,s);}return this._renderer.drawBuffersScaled(i,e,t,e),this},T.default.prototype.cone=function(e,t,r,n,a){this._assert3d("cone"),T.default._validateParameters("cone",arguments),void 0===e&&(e=50),void 0===t&&(t=e),void 0===r&&(r=24),void 0===n&&(n=1),void 0===a&&(a=!0);var o="cone|".concat(r,"|").concat(n,"|").concat(a);if(!this._renderer.geometryInHash(o)){var i=new T.default.Geometry(r,n);l.call(i,1,0,1,r,n,a,!1),r<=24&&n<=16?i._makeTriangleEdges()._edgesToVertices():this._renderer._doStroke&&console.log("Cannot draw stroke on cone objects with more than 24 detailX or 16 detailY"),this._renderer.createBuffers(o,i);}return this._renderer.drawBuffersScaled(o,e,t,e),this},T.default.prototype.ellipsoid=function(e,t,r,n,a){this._assert3d("ellipsoid"),T.default._validateParameters("ellipsoid",arguments),void 0===e&&(e=50),void 0===t&&(t=e),void 0===r&&(r=e),void 0===n&&(n=24),void 0===a&&(a=16);var o="ellipsoid|".concat(n,"|").concat(a);if(!this._renderer.geometryInHash(o)){var i=new T.default.Geometry(n,a,function(){for(var e=0;e<=this.detailY;e++)for(var t=e/this.detailY,r=Math.PI*t-Math.PI/2,n=Math.cos(r),a=Math.sin(r),o=0;o<=this.detailX;o++){var i=o/this.detailX,s=2*Math.PI*i,l=Math.cos(s),p=Math.sin(s),u=new T.default.Vector(n*p,a,n*l);this.vertices.push(u),this.vertexNormals.push(u),this.uvs.push(i,t);}});i.computeFaces(),n<=24&&a<=24?i._makeTriangleEdges()._edgesToVertices():this._renderer._doStroke&&console.log("Cannot draw stroke on ellipsoids with more than 24 detailX or 24 detailY"),this._renderer.createBuffers(o,i);}return this._renderer.drawBuffersScaled(o,e,t,r),this},T.default.prototype.torus=function(e,t,r,n){if(this._assert3d("torus"),T.default._validateParameters("torus",arguments),void 0===e)e=50;else if(!e)return;if(void 0===t)t=10;else if(!t)return;void 0===r&&(r=24),void 0===n&&(n=16);var h=(t/e).toPrecision(4),a="torus|".concat(h,"|").concat(r,"|").concat(n);if(!this._renderer.geometryInHash(a)){var o=new T.default.Geometry(r,n,function(){for(var e=0;e<=this.detailY;e++)for(var t=e/this.detailY,r=2*Math.PI*t,n=Math.cos(r),a=Math.sin(r),o=1+h*n,i=0;i<=this.detailX;i++){var s=i/this.detailX,l=2*Math.PI*s,p=Math.cos(l),u=Math.sin(l),c=new T.default.Vector(o*p,o*u,h*a),d=new T.default.Vector(n*p,n*u,a);this.vertices.push(c),this.vertexNormals.push(d),this.uvs.push(s,t);}});o.computeFaces(),r<=24&&n<=16?o._makeTriangleEdges()._edgesToVertices():this._renderer._doStroke&&console.log("Cannot draw strokes on torus object with more than 24 detailX or 16 detailY"),this._renderer.createBuffers(a,o);}return this._renderer.drawBuffersScaled(a,e,e,e),this},T.default.RendererGL.prototype.point=function(e,t,r){void 0===r&&(r=0);var n=[];return n.push(new T.default.Vector(e,t,r)),this._drawPoints(n,this.immediateMode.buffers.point),this},T.default.RendererGL.prototype.triangle=function(e){var t=e[0],r=e[1],n=e[2],a=e[3],o=e[4],i=e[5];if(!this.geometryInHash("tri")){var s=new T.default.Geometry(1,1,function(){var e=[];e.push(new T.default.Vector(0,0,0)),e.push(new T.default.Vector(0,1,0)),e.push(new T.default.Vector(1,0,0)),this.strokeIndices=[[0,1],[1,2],[2,0]],this.vertices=e,this.faces=[[0,1,2]],this.uvs=[0,0,0,1,1,1];});s._makeTriangleEdges()._edgesToVertices(),s.computeNormals(),this.createBuffers("tri",s);}var l=this.uMVMatrix.copy();try{var p=new T.default.Matrix([n-t,a-r,0,0,o-t,i-r,0,0,0,0,1,0,t,r,0,1]).mult(this.uMVMatrix);this.uMVMatrix=p,this.drawBuffers("tri");}finally{this.uMVMatrix=l;}return this},T.default.RendererGL.prototype.ellipse=function(e){this.arc(e[0],e[1],e[2],e[3],0,h.TWO_PI,h.OPEN,e[4]);},T.default.RendererGL.prototype.arc=function(e){var t,r=e,n=arguments[1],a=arguments[2],o=arguments[3],i=arguments[4],s=arguments[5],l=arguments[6],p=arguments[7]||25;if(t=Math.abs(s-i)>=h.TWO_PI?"".concat("ellipse","|").concat(p,"|"):"".concat("arc","|").concat(i,"|").concat(s,"|").concat(l,"|").concat(p,"|"),!this.geometryInHash(t)){var u=new T.default.Geometry(p,1,function(){if(this.strokeIndices=[],i.toFixed(10)!==s.toFixed(10)){l!==h.PIE&&void 0!==l||(this.vertices.push(new T.default.Vector(.5,.5,0)),this.uvs.push([.5,.5]));for(var e=0;e<=p;e++){var t=(s-i)*(e/p)+i,r=.5+Math.cos(t)/2,n=.5+Math.sin(t)/2;this.vertices.push(new T.default.Vector(r,n,0)),this.uvs.push([r,n]),e<p-1&&(this.faces.push([0,e+1,e+2]),this.strokeIndices.push([e+1,e+2]));}switch(l){case h.PIE:this.faces.push([0,this.vertices.length-2,this.vertices.length-1]),this.strokeIndices.push([0,1]),this.strokeIndices.push([this.vertices.length-2,this.vertices.length-1]),this.strokeIndices.push([0,this.vertices.length-1]);break;case h.CHORD:this.strokeIndices.push([0,1]),this.strokeIndices.push([0,this.vertices.length-1]);break;case h.OPEN:this.strokeIndices.push([0,1]);break;default:this.faces.push([0,this.vertices.length-2,this.vertices.length-1]),this.strokeIndices.push([this.vertices.length-2,this.vertices.length-1]);}}});u.computeNormals(),p<=50?u._makeTriangleEdges()._edgesToVertices(u):this._renderer._doStroke&&console.log("Cannot stroke ${shape} with more than 50 detail"),this.createBuffers(t,u);}var c=this.uMVMatrix.copy();try{this.uMVMatrix.translate([r,n,0]),this.uMVMatrix.scale(a,o,1),this.drawBuffers(t);}finally{this.uMVMatrix=c;}return this},T.default.RendererGL.prototype.rect=function(e){var t=this._pInst._glAttributes.perPixelLighting,r=e[0],n=e[1],a=e[2],o=e[3],i=e[4]||(t?1:24),s=e[5]||(t?1:16),l="rect|".concat(i,"|").concat(s);if(!this.geometryInHash(l)){var p=new T.default.Geometry(i,s,function(){for(var e=0;e<=this.detailY;e++)for(var t=e/this.detailY,r=0;r<=this.detailX;r++){var n=r/this.detailX,a=new T.default.Vector(n,t,0);this.vertices.push(a),this.uvs.push(n,t);}0<i&&0<s&&(this.strokeIndices=[[0,i],[i,(i+1)*(s+1)-1],[(i+1)*(s+1)-1,(i+1)*s],[(i+1)*s,0]]);});p.computeFaces().computeNormals()._makeTriangleEdges()._edgesToVertices(),this.createBuffers(l,p);}var u=this.uMVMatrix.copy();try{this.uMVMatrix.translate([r,n,0]),this.uMVMatrix.scale(a,o,1),this.drawBuffers(l);}finally{this.uMVMatrix=u;}return this},T.default.RendererGL.prototype.quad=function(e,t,r,n,a,o,i,s,l,p,u,c){var d="quad|".concat(e,"|").concat(t,"|").concat(r,"|").concat(n,"|").concat(a,"|").concat(o,"|").concat(i,"|").concat(s,"|").concat(l,"|").concat(p,"|").concat(u,"|").concat(c);if(!this.geometryInHash(d)){var h=new T.default.Geometry(2,2,function(){this.vertices.push(new T.default.Vector(e,t,r)),this.vertices.push(new T.default.Vector(n,a,o)),this.vertices.push(new T.default.Vector(i,s,l)),this.vertices.push(new T.default.Vector(p,u,c)),this.uvs.push(0,0,1,0,1,1,0,1),this.strokeIndices=[[0,1],[1,2],[2,3],[3,0]];});h.computeNormals()._makeTriangleEdges()._edgesToVertices(),h.faces=[[0,1,2],[2,3,0]],this.createBuffers(d,h);}return this.drawBuffers(d),this},T.default.RendererGL.prototype.bezier=function(e,t,r,n,a,o,i,s,l,p,u,c){8===arguments.length&&(u=s,p=i,s=o,i=a,a=n,n=r,r=o=l=c=0);var d=this._pInst._bezierDetail||20;this.beginShape();for(var h=0;h<=d;h++){var m=Math.pow(1-h/d,3),f=h/d*3*Math.pow(1-h/d,2),y=3*Math.pow(h/d,2)*(1-h/d),g=Math.pow(h/d,3);this.vertex(e*m+n*f+i*y+p*g,t*m+a*f+s*y+u*g,r*m+o*f+l*y+c*g);}return this.endShape(),this},T.default.RendererGL.prototype.curve=function(e,t,r,n,a,o,i,s,l,p,u,c){8===arguments.length&&(p=i,u=s,i=a,s=n,a=n=r,r=o=l=c=0);var d=this._pInst._curveDetail;this.beginShape();for(var h=0;h<=d;h++){var m=.5*Math.pow(h/d,3),f=.5*Math.pow(h/d,2),y=h/d*.5,g=m*(3*n-e-3*i+p)+f*(2*e-5*n+4*i-p)+y*(-e+i)+2*n*.5,v=m*(3*a-t-3*s+u)+f*(2*t-5*a+4*s-u)+y*(-t+s)+2*a*.5,b=m*(3*o-r-3*l+c)+f*(2*r-5*o+4*l-c)+y*(-r+l)+2*o*.5;this.vertex(g,v,b);}return this.endShape(),this},T.default.RendererGL.prototype.line=function(){return 6===arguments.length?(this.beginShape(h.LINES),this.vertex(arguments.length<=0?void 0:arguments[0],arguments.length<=1?void 0:arguments[1],arguments.length<=2?void 0:arguments[2]),this.vertex(arguments.length<=3?void 0:arguments[3],arguments.length<=4?void 0:arguments[4],arguments.length<=5?void 0:arguments[5]),this.endShape()):4===arguments.length&&(this.beginShape(h.LINES),this.vertex(arguments.length<=0?void 0:arguments[0],arguments.length<=1?void 0:arguments[1],0),this.vertex(arguments.length<=2?void 0:arguments[2],arguments.length<=3?void 0:arguments[3],0),this.endShape()),this},T.default.RendererGL.prototype.bezierVertex=function(){if(0===this.immediateMode._bezierVertex.length)throw Error("vertex() must be used once before calling bezierVertex()");var e,t,r,n,a,o=[],i=[],s=[],l=arguments.length;if((e=0)===this._lookUpTableBezier.length||this._lutBezierDetail!==this._pInst._curveDetail){this._lookUpTableBezier=[],this._lutBezierDetail=this._pInst._curveDetail;for(var p=1/this._lutBezierDetail,u=0,c=1,d=0;u<1;){if(e=parseFloat(u.toFixed(6)),this._lookUpTableBezier[d]=this._bezierCoefficients(e),c.toFixed(6)===p.toFixed(6)){e=parseFloat(c.toFixed(6))+parseFloat(u.toFixed(6)),++d,this._lookUpTableBezier[d]=this._bezierCoefficients(e);break}u+=p,c-=p,++d;}}var h=this._lookUpTableBezier.length;if(6===l){for(this.isBezier=!0,o=[this.immediateMode._bezierVertex[0],arguments.length<=0?void 0:arguments[0],arguments.length<=2?void 0:arguments[2],arguments.length<=4?void 0:arguments[4]],i=[this.immediateMode._bezierVertex[1],arguments.length<=1?void 0:arguments[1],arguments.length<=3?void 0:arguments[3],arguments.length<=5?void 0:arguments[5]],a=0;a<h;a++)t=o[0]*this._lookUpTableBezier[a][0]+o[1]*this._lookUpTableBezier[a][1]+o[2]*this._lookUpTableBezier[a][2]+o[3]*this._lookUpTableBezier[a][3],r=i[0]*this._lookUpTableBezier[a][0]+i[1]*this._lookUpTableBezier[a][1]+i[2]*this._lookUpTableBezier[a][2]+i[3]*this._lookUpTableBezier[a][3],this.vertex(t,r);this.immediateMode._bezierVertex[0]=arguments.length<=4?void 0:arguments[4],this.immediateMode._bezierVertex[1]=arguments.length<=5?void 0:arguments[5];}else if(9===l){for(this.isBezier=!0,o=[this.immediateMode._bezierVertex[0],arguments.length<=0?void 0:arguments[0],arguments.length<=3?void 0:arguments[3],arguments.length<=6?void 0:arguments[6]],i=[this.immediateMode._bezierVertex[1],arguments.length<=1?void 0:arguments[1],arguments.length<=4?void 0:arguments[4],arguments.length<=7?void 0:arguments[7]],s=[this.immediateMode._bezierVertex[2],arguments.length<=2?void 0:arguments[2],arguments.length<=5?void 0:arguments[5],arguments.length<=8?void 0:arguments[8]],a=0;a<h;a++)t=o[0]*this._lookUpTableBezier[a][0]+o[1]*this._lookUpTableBezier[a][1]+o[2]*this._lookUpTableBezier[a][2]+o[3]*this._lookUpTableBezier[a][3],r=i[0]*this._lookUpTableBezier[a][0]+i[1]*this._lookUpTableBezier[a][1]+i[2]*this._lookUpTableBezier[a][2]+i[3]*this._lookUpTableBezier[a][3],n=s[0]*this._lookUpTableBezier[a][0]+s[1]*this._lookUpTableBezier[a][1]+s[2]*this._lookUpTableBezier[a][2]+s[3]*this._lookUpTableBezier[a][3],this.vertex(t,r,n);this.immediateMode._bezierVertex[0]=arguments.length<=6?void 0:arguments[6],this.immediateMode._bezierVertex[1]=arguments.length<=7?void 0:arguments[7],this.immediateMode._bezierVertex[2]=arguments.length<=8?void 0:arguments[8];}},T.default.RendererGL.prototype.quadraticVertex=function(){if(0===this.immediateMode._quadraticVertex.length)throw Error("vertex() must be used once before calling quadraticVertex()");var e,t,r,n,a,o=[],i=[],s=[],l=arguments.length;if((e=0)===this._lookUpTableQuadratic.length||this._lutQuadraticDetail!==this._pInst._curveDetail){this._lookUpTableQuadratic=[],this._lutQuadraticDetail=this._pInst._curveDetail;for(var p=1/this._lutQuadraticDetail,u=0,c=1,d=0;u<1;){if(e=parseFloat(u.toFixed(6)),this._lookUpTableQuadratic[d]=this._quadraticCoefficients(e),c.toFixed(6)===p.toFixed(6)){e=parseFloat(c.toFixed(6))+parseFloat(u.toFixed(6)),++d,this._lookUpTableQuadratic[d]=this._quadraticCoefficients(e);break}u+=p,c-=p,++d;}}var h=this._lookUpTableQuadratic.length;if(4===l){for(this.isQuadratic=!0,o=[this.immediateMode._quadraticVertex[0],arguments.length<=0?void 0:arguments[0],arguments.length<=2?void 0:arguments[2]],i=[this.immediateMode._quadraticVertex[1],arguments.length<=1?void 0:arguments[1],arguments.length<=3?void 0:arguments[3]],a=0;a<h;a++)t=o[0]*this._lookUpTableQuadratic[a][0]+o[1]*this._lookUpTableQuadratic[a][1]+o[2]*this._lookUpTableQuadratic[a][2],r=i[0]*this._lookUpTableQuadratic[a][0]+i[1]*this._lookUpTableQuadratic[a][1]+i[2]*this._lookUpTableQuadratic[a][2],this.vertex(t,r);this.immediateMode._quadraticVertex[0]=arguments.length<=2?void 0:arguments[2],this.immediateMode._quadraticVertex[1]=arguments.length<=3?void 0:arguments[3];}else if(6===l){for(this.isQuadratic=!0,o=[this.immediateMode._quadraticVertex[0],arguments.length<=0?void 0:arguments[0],arguments.length<=3?void 0:arguments[3]],i=[this.immediateMode._quadraticVertex[1],arguments.length<=1?void 0:arguments[1],arguments.length<=4?void 0:arguments[4]],s=[this.immediateMode._quadraticVertex[2],arguments.length<=2?void 0:arguments[2],arguments.length<=5?void 0:arguments[5]],a=0;a<h;a++)t=o[0]*this._lookUpTableQuadratic[a][0]+o[1]*this._lookUpTableQuadratic[a][1]+o[2]*this._lookUpTableQuadratic[a][2],r=i[0]*this._lookUpTableQuadratic[a][0]+i[1]*this._lookUpTableQuadratic[a][1]+i[2]*this._lookUpTableQuadratic[a][2],n=s[0]*this._lookUpTableQuadratic[a][0]+s[1]*this._lookUpTableQuadratic[a][1]+s[2]*this._lookUpTableQuadratic[a][2],this.vertex(t,r,n);this.immediateMode._quadraticVertex[0]=arguments.length<=3?void 0:arguments[3],this.immediateMode._quadraticVertex[1]=arguments.length<=4?void 0:arguments[4],this.immediateMode._quadraticVertex[2]=arguments.length<=5?void 0:arguments[5];}},T.default.RendererGL.prototype.curveVertex=function(){var e,t,r,n,a,o=[],i=[],s=[],l=arguments.length;if((e=0)===this._lookUpTableBezier.length||this._lutBezierDetail!==this._pInst._curveDetail){this._lookUpTableBezier=[],this._lutBezierDetail=this._pInst._curveDetail;for(var p=1/this._lutBezierDetail,u=0,c=1,d=0;u<1;){if(e=parseFloat(u.toFixed(6)),this._lookUpTableBezier[d]=this._bezierCoefficients(e),c.toFixed(6)===p.toFixed(6)){e=parseFloat(c.toFixed(6))+parseFloat(u.toFixed(6)),++d,this._lookUpTableBezier[d]=this._bezierCoefficients(e);break}u+=p,c-=p,++d;}}var h=this._lookUpTableBezier.length;if(2===l){if(this.immediateMode._curveVertex.push(arguments.length<=0?void 0:arguments[0]),this.immediateMode._curveVertex.push(arguments.length<=1?void 0:arguments[1]),8===this.immediateMode._curveVertex.length){for(this.isCurve=!0,o=this._bezierToCatmull([this.immediateMode._curveVertex[0],this.immediateMode._curveVertex[2],this.immediateMode._curveVertex[4],this.immediateMode._curveVertex[6]]),i=this._bezierToCatmull([this.immediateMode._curveVertex[1],this.immediateMode._curveVertex[3],this.immediateMode._curveVertex[5],this.immediateMode._curveVertex[7]]),a=0;a<h;a++)t=o[0]*this._lookUpTableBezier[a][0]+o[1]*this._lookUpTableBezier[a][1]+o[2]*this._lookUpTableBezier[a][2]+o[3]*this._lookUpTableBezier[a][3],r=i[0]*this._lookUpTableBezier[a][0]+i[1]*this._lookUpTableBezier[a][1]+i[2]*this._lookUpTableBezier[a][2]+i[3]*this._lookUpTableBezier[a][3],this.vertex(t,r);for(a=0;a<l;a++)this.immediateMode._curveVertex.shift();}}else if(3===l&&(this.immediateMode._curveVertex.push(arguments.length<=0?void 0:arguments[0]),this.immediateMode._curveVertex.push(arguments.length<=1?void 0:arguments[1]),this.immediateMode._curveVertex.push(arguments.length<=2?void 0:arguments[2]),12===this.immediateMode._curveVertex.length)){for(this.isCurve=!0,o=this._bezierToCatmull([this.immediateMode._curveVertex[0],this.immediateMode._curveVertex[3],this.immediateMode._curveVertex[6],this.immediateMode._curveVertex[9]]),i=this._bezierToCatmull([this.immediateMode._curveVertex[1],this.immediateMode._curveVertex[4],this.immediateMode._curveVertex[7],this.immediateMode._curveVertex[10]]),s=this._bezierToCatmull([this.immediateMode._curveVertex[2],this.immediateMode._curveVertex[5],this.immediateMode._curveVertex[8],this.immediateMode._curveVertex[11]]),a=0;a<h;a++)t=o[0]*this._lookUpTableBezier[a][0]+o[1]*this._lookUpTableBezier[a][1]+o[2]*this._lookUpTableBezier[a][2]+o[3]*this._lookUpTableBezier[a][3],r=i[0]*this._lookUpTableBezier[a][0]+i[1]*this._lookUpTableBezier[a][1]+i[2]*this._lookUpTableBezier[a][2]+i[3]*this._lookUpTableBezier[a][3],n=s[0]*this._lookUpTableBezier[a][0]+s[1]*this._lookUpTableBezier[a][1]+s[2]*this._lookUpTableBezier[a][2]+s[3]*this._lookUpTableBezier[a][3],this.vertex(t,r,n);for(a=0;a<l;a++)this.immediateMode._curveVertex.shift();}},T.default.RendererGL.prototype.image=function(e,t,r,n,a,o,i,s,l){this._isErasing&&this.blendMode(this._cachedBlendMode),this._pInst.push(),this._pInst.noLights(),this._pInst.texture(e),this._pInst.textureMode(h.NORMAL);var p=0;t<=e.width&&(p=t/e.width);var u=1;t+n<=e.width&&(u=(t+n)/e.width);var c=0;r<=e.height&&(c=r/e.height);var d=1;r+a<=e.height&&(d=(r+a)/e.height),this.beginShape(),this.vertex(o,i,0,p,c),this.vertex(o+s,i,0,u,c),this.vertex(o+s,i+l,0,u,d),this.vertex(o,i+l,0,p,d),this.endShape(h.CLOSE),this._pInst.pop(),this._isErasing&&this.blendMode(h.REMOVE);};var a=T.default;r.default=a;},{"../core/constants":22,"../core/main":32,"./p5.Geometry":81}],76:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,d=(n=e("../core/main"))&&n.__esModule?n:{default:n},a=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}d.default.prototype.orbitControl=function(e,t,r){if(this._assert3d("orbitControl"),d.default._validateParameters("orbitControl",arguments),this.mouseX<this.width&&0<this.mouseX&&this.mouseY<this.height&&0<this.mouseY){var n=this._renderer._curCamera;void 0===e&&(e=1),void 0===t&&(t=e),void 0===r&&(r=.5),!0!==this.contextMenuDisabled&&(this.canvas.oncontextmenu=function(){return !1},this._setProperty("contextMenuDisabled",!0)),!0!==this.wheelDefaultDisabled&&(this.canvas.onwheel=function(){return !1},this._setProperty("wheelDefaultDisabled",!0));var a=this.height<this.width?this.height:this.width;if(this._mouseWheelDeltaY!==this._pmouseWheelDeltaY&&(0<this._mouseWheelDeltaY?this._renderer._curCamera._orbit(0,0,r*a):this._renderer._curCamera._orbit(0,0,-r*a)),this.mouseIsPressed)if(this.mouseButton===this.LEFT){var o=-e*(this.mouseX-this.pmouseX)/a,i=t*(this.mouseY-this.pmouseY)/a;this._renderer._curCamera._orbit(o,i,0);}else if(this.mouseButton===this.RIGHT){var s=n._getLocalAxes(),l=Math.sqrt(s.x[0]*s.x[0]+s.x[2]*s.x[2]);0!==l&&(s.x[0]/=l,s.x[2]/=l);var p=Math.sqrt(s.y[0]*s.y[0]+s.y[2]*s.y[2]);0!==p&&(s.y[0]/=p,s.y[2]/=p);var u=-1*e*(this.mouseX-this.pmouseX),c=-1*t*(this.mouseY-this.pmouseY);n.setPosition(n.eyeX+u*s.x[0]+c*s.z[0],n.eyeY,n.eyeZ+u*s.x[2]+c*s.z[2]);}return this}},d.default.prototype.debugMode=function(){this._assert3d("debugMode");for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];d.default._validateParameters("debugMode",t);for(var n=this._registeredMethods.post.length-1;0<=n;n--)this._registeredMethods.post[n].toString()!==this._grid().toString()&&this._registeredMethods.post[n].toString()!==this._axesIcon().toString()||this._registeredMethods.post.splice(n,1);t[0]===a.GRID?this.registerMethod("post",this._grid.call(this,t[1],t[2],t[3],t[4],t[5])):t[0]===a.AXES?this.registerMethod("post",this._axesIcon.call(this,t[1],t[2],t[3],t[4])):(this.registerMethod("post",this._grid.call(this,t[0],t[1],t[2],t[3],t[4])),this.registerMethod("post",this._axesIcon.call(this,t[5],t[6],t[7],t[8])));},d.default.prototype.noDebugMode=function(){this._assert3d("noDebugMode");for(var e=this._registeredMethods.post.length-1;0<=e;e--)this._registeredMethods.post[e].toString()!==this._grid().toString()&&this._registeredMethods.post[e].toString()!==this._axesIcon().toString()||this._registeredMethods.post.splice(e,1);},d.default.prototype._grid=function(e,r,n,a,o){void 0===e&&(e=this.width/2),void 0===r&&(r=Math.round(e/30)<4?4:Math.round(e/30)),void 0===n&&(n=0),void 0===a&&(a=0),void 0===o&&(o=0);var i=e/r,s=e/2;return function(){this.push(),this.stroke(255*this._renderer.curStrokeColor[0],255*this._renderer.curStrokeColor[1],255*this._renderer.curStrokeColor[2]),this._renderer.uMVMatrix.set(this._renderer._curCamera.cameraMatrix.mat4[0],this._renderer._curCamera.cameraMatrix.mat4[1],this._renderer._curCamera.cameraMatrix.mat4[2],this._renderer._curCamera.cameraMatrix.mat4[3],this._renderer._curCamera.cameraMatrix.mat4[4],this._renderer._curCamera.cameraMatrix.mat4[5],this._renderer._curCamera.cameraMatrix.mat4[6],this._renderer._curCamera.cameraMatrix.mat4[7],this._renderer._curCamera.cameraMatrix.mat4[8],this._renderer._curCamera.cameraMatrix.mat4[9],this._renderer._curCamera.cameraMatrix.mat4[10],this._renderer._curCamera.cameraMatrix.mat4[11],this._renderer._curCamera.cameraMatrix.mat4[12],this._renderer._curCamera.cameraMatrix.mat4[13],this._renderer._curCamera.cameraMatrix.mat4[14],this._renderer._curCamera.cameraMatrix.mat4[15]);for(var e=0;e<=r;e++)this.beginShape(this.LINES),this.vertex(-s+n,a,e*i-s+o),this.vertex(+s+n,a,e*i-s+o),this.endShape();for(var t=0;t<=r;t++)this.beginShape(this.LINES),this.vertex(t*i-s+n,a,-s+o),this.vertex(t*i-s+n,a,+s+o),this.endShape();this.pop();}},d.default.prototype._axesIcon=function(e,t,r,n){return void 0===e&&(e=40<this.width/20?this.width/20:40),void 0===t&&(t=-this.width/4),void 0===r&&(r=t),void 0===n&&(n=t),function(){this.push(),this._renderer.uMVMatrix.set(this._renderer._curCamera.cameraMatrix.mat4[0],this._renderer._curCamera.cameraMatrix.mat4[1],this._renderer._curCamera.cameraMatrix.mat4[2],this._renderer._curCamera.cameraMatrix.mat4[3],this._renderer._curCamera.cameraMatrix.mat4[4],this._renderer._curCamera.cameraMatrix.mat4[5],this._renderer._curCamera.cameraMatrix.mat4[6],this._renderer._curCamera.cameraMatrix.mat4[7],this._renderer._curCamera.cameraMatrix.mat4[8],this._renderer._curCamera.cameraMatrix.mat4[9],this._renderer._curCamera.cameraMatrix.mat4[10],this._renderer._curCamera.cameraMatrix.mat4[11],this._renderer._curCamera.cameraMatrix.mat4[12],this._renderer._curCamera.cameraMatrix.mat4[13],this._renderer._curCamera.cameraMatrix.mat4[14],this._renderer._curCamera.cameraMatrix.mat4[15]),this.strokeWeight(2),this.stroke(255,0,0),this.beginShape(this.LINES),this.vertex(t,r,n),this.vertex(t+e,r,n),this.endShape(),this.stroke(0,255,0),this.beginShape(this.LINES),this.vertex(t,r,n),this.vertex(t,r+e,n),this.endShape(),this.stroke(0,0,255),this.beginShape(this.LINES),this.vertex(t,r,n),this.vertex(t,r,n+e),this.endShape(),this.pop();}};var o=d.default;r.default=o;},{"../core/constants":22,"../core/main":32}],77:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,f=(n=e("../core/main"))&&n.__esModule?n:{default:n};f.default.prototype.ambientLight=function(e,t,r,n){this._assert3d("ambientLight"),f.default._validateParameters("ambientLight",arguments);var a=this.color.apply(this,arguments);return this._renderer.ambientLightColors.push(a._array[0],a._array[1],a._array[2]),this._renderer._enableLighting=!0,this},f.default.prototype.specularColor=function(e,t,r){this._assert3d("specularColor"),f.default._validateParameters("specularColor",arguments);var n=this.color.apply(this,arguments);return this._renderer.specularColors=[n._array[0],n._array[1],n._array[2]],this},f.default.prototype.directionalLight=function(e,t,r,n,a,o){var i,s,l,p;this._assert3d("directionalLight"),f.default._validateParameters("directionalLight",arguments),i=e instanceof f.default.Color?e:this.color(e,t,r);var u=arguments[arguments.length-1];p="number"==typeof u?(s=arguments[arguments.length-3],l=arguments[arguments.length-2],arguments[arguments.length-1]):(s=u.x,l=u.y,u.z);var c=Math.sqrt(s*s+l*l+p*p);return this._renderer.directionalLightDirections.push(s/c,l/c,p/c),this._renderer.directionalLightDiffuseColors.push(i._array[0],i._array[1],i._array[2]),Array.prototype.push.apply(this._renderer.directionalLightSpecularColors,this._renderer.specularColors),this._renderer._enableLighting=!0,this},f.default.prototype.pointLight=function(e,t,r,n,a,o){var i,s,l,p;this._assert3d("pointLight"),f.default._validateParameters("pointLight",arguments),i=e instanceof f.default.Color?e:this.color(e,t,r);var u=arguments[arguments.length-1];return p="number"==typeof u?(s=arguments[arguments.length-3],l=arguments[arguments.length-2],arguments[arguments.length-1]):(s=u.x,l=u.y,u.z),this._renderer.pointLightPositions.push(s,l,p),this._renderer.pointLightDiffuseColors.push(i._array[0],i._array[1],i._array[2]),Array.prototype.push.apply(this._renderer.pointLightSpecularColors,this._renderer.specularColors),this._renderer._enableLighting=!0,this},f.default.prototype.lights=function(){return this._assert3d("lights"),this.ambientLight(128,128,128),this.directionalLight(128,128,128,0,0,-1),this},f.default.prototype.lightFalloff=function(e,t,r){return this._assert3d("lightFalloff"),f.default._validateParameters("lightFalloff",arguments),e<0&&(e=0,console.warn("Value of constant argument in lightFalloff() should be never be negative. Set to 0.")),t<0&&(t=0,console.warn("Value of linear argument in lightFalloff() should be never be negative. Set to 0.")),r<0&&(r=0,console.warn("Value of quadratic argument in lightFalloff() should be never be negative. Set to 0.")),0===e&&0===t&&0===r&&(e=1,console.warn("Either one of the three arguments in lightFalloff() should be greater than zero. Set constant argument to 1.")),this._renderer.constantAttenuation=e,this._renderer.linearAttenuation=t,this._renderer.quadraticAttenuation=r,this},f.default.prototype.spotLight=function(e,t,r,n,a,o,i,s,l,p,u){var c,d,h;this._assert3d("spotLight"),f.default._validateParameters("spotLight",arguments);var m=arguments.length;switch(m){case 11:case 10:c=this.color(e,t,r),d=new f.default.Vector(n,a,o),h=new f.default.Vector(i,s,l);break;case 9:e instanceof f.default.Color?(c=e,d=new f.default.Vector(t,r,n),h=new f.default.Vector(a,o,i),p=s,u=l):n instanceof f.default.Vector?(c=this.color(e,t,r),d=n,h=new f.default.Vector(a,o,i),p=s,u=l):i instanceof f.default.Vector?(c=this.color(e,t,r),d=new f.default.Vector(n,a,o),h=i,p=s,u=l):(c=this.color(e,t,r),d=new f.default.Vector(n,a,o),h=new f.default.Vector(i,s,l));break;case 8:p=(h=e instanceof f.default.Color?(c=e,d=new f.default.Vector(t,r,n),new f.default.Vector(a,o,i)):n instanceof f.default.Vector?(c=this.color(e,t,r),d=n,new f.default.Vector(a,o,i)):(c=this.color(e,t,r),d=new f.default.Vector(n,a,o),i),s);break;case 7:e instanceof f.default.Color&&t instanceof f.default.Vector?(c=e,d=t,h=new f.default.Vector(r,n,a),p=o,u=i):e instanceof f.default.Color&&a instanceof f.default.Vector?(c=e,d=new f.default.Vector(t,r,n),h=a,p=o,u=i):n instanceof f.default.Vector&&a instanceof f.default.Vector?(c=this.color(e,t,r),d=n,h=a,p=o,u=i):h=e instanceof f.default.Color?(c=e,d=new f.default.Vector(t,r,n),new f.default.Vector(a,o,i)):n instanceof f.default.Vector?(c=this.color(e,t,r),d=n,new f.default.Vector(a,o,i)):(c=this.color(e,t,r),d=new f.default.Vector(n,a,o),i);break;case 6:n instanceof f.default.Vector&&a instanceof f.default.Vector?(c=this.color(e,t,r),d=n,h=a,p=o):e instanceof f.default.Color&&a instanceof f.default.Vector?(c=e,d=new f.default.Vector(t,r,n),h=a,p=o):e instanceof f.default.Color&&t instanceof f.default.Vector&&(c=e,d=t,h=new f.default.Vector(r,n,a),p=o);break;case 5:e instanceof f.default.Color&&t instanceof f.default.Vector&&r instanceof f.default.Vector?(c=e,d=t,h=r,p=n,u=a):n instanceof f.default.Vector&&a instanceof f.default.Vector?(c=this.color(e,t,r),d=n,h=a):e instanceof f.default.Color&&a instanceof f.default.Vector?(c=e,d=new f.default.Vector(t,r,n),h=a):e instanceof f.default.Color&&t instanceof f.default.Vector&&(c=e,d=t,h=new f.default.Vector(r,n,a));break;case 4:c=e,d=t,h=r,p=n;break;case 3:c=e,d=t,h=r;break;default:return console.warn("Sorry, input for spotlight() is not in prescribed format. Too ".concat(m<3?"few":"many"," arguments were provided")),this}return this._renderer.spotLightDiffuseColors.push(c._array[0],c._array[1],c._array[2]),Array.prototype.push.apply(this._renderer.spotLightSpecularColors,this._renderer.specularColors),this._renderer.spotLightPositions.push(d.x,d.y,d.z),h.normalize(),this._renderer.spotLightDirections.push(h.x,h.y,h.z),void 0===p&&(p=Math.PI/3),void 0!==u&&u<1?(u=1,console.warn("Value of concentration needs to be greater than 1. Setting it to 1")):void 0===u&&(u=100),p=this._renderer._pInst._toRadians(p),this._renderer.spotLightAngle.push(Math.cos(p)),this._renderer.spotLightConc.push(u),this._renderer._enableLighting=!0,this},f.default.prototype.noLights=function(){return this._assert3d("noLights"),f.default._validateParameters("noLights",arguments),this._renderer._enableLighting=!1,this._renderer.ambientLightColors.length=0,this._renderer.specularColors=[1,1,1],this._renderer.directionalLightDirections.length=0,this._renderer.directionalLightDiffuseColors.length=0,this._renderer.directionalLightSpecularColors.length=0,this._renderer.pointLightPositions.length=0,this._renderer.pointLightDiffuseColors.length=0,this._renderer.pointLightSpecularColors.length=0,this._renderer.spotLightPositions.length=0,this._renderer.spotLightDirections.length=0,this._renderer.spotLightDiffuseColors.length=0,this._renderer.spotLightSpecularColors.length=0,this._renderer.spotLightAngle.length=0,this._renderer.spotLightConc.length=0,this._renderer.constantAttenuation=1,this._renderer.linearAttenuation=0,this._renderer.quadraticAttenuation=0,this._renderer._useShininess=1,this};var a=f.default;r.default=a;},{"../core/main":32}],78:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,w=(n=e("../core/main"))&&n.__esModule?n:{default:n};function s(e,t,r){for(var n=0,a=e.length;n<a;n++)if(e[n]!==t.getUint8(r+n,!1))return !1;return !0}e("./p5.Geometry"),w.default.prototype.loadModel=function(e){var t,r,n;w.default._validateParameters("loadModel",arguments);var a=e.slice(-4);"boolean"==typeof arguments[1]?(t=arguments[1],r=arguments[2],n=arguments[3],void 0!==arguments[4]&&(a=arguments[4])):(t=!1,r=arguments[1],n=arguments[2],void 0!==arguments[3]&&(a=arguments[3]));var o=new w.default.Geometry;o.gid="".concat(e,"|").concat(t);var i=this;return a.match(/\.stl$/i)?this.httpDo(e,"GET","arrayBuffer",function(e){!function(e,t){if(function(e){for(var t=new DataView(e),r=[115,111,108,105,100],n=0;n<5;n++)if(s(r,t,n))return !1;return !0}(t))!function(e,t){for(var r,n,a,o,i,s,l,p=new DataView(t),u=p.getUint32(80,!0),c=!1,d=0;d<70;d++)1129270351===p.getUint32(d,!1)&&82===p.getUint8(d+4)&&61===p.getUint8(d+5)&&(c=!0,o=[],i=p.getUint8(d+6)/255,s=p.getUint8(d+7)/255,l=p.getUint8(d+8)/255);for(var h=0;h<u;h++){var m=84+50*h,f=p.getFloat32(m,!0),y=p.getFloat32(4+m,!0),g=p.getFloat32(8+m,!0);if(c){var v=p.getUint16(48+m,!0);a=0==(32768&v)?(r=(31&v)/31,n=(v>>5&31)/31,(v>>10&31)/31):(r=i,n=s,l);}for(var b=new w.default.Vector(f,y,g),_=1;_<=3;_++){var x=m+12*_,S=new w.default.Vector(p.getFloat32(x,!0),p.getFloat32(4+x,!0),p.getFloat32(8+x,!0));e.vertices.push(S),e.vertexNormals.push(b),c&&o.push(r,n,a);}e.faces.push([3*h,3*h+1,3*h+2]),e.uvs.push([0,0],[0,0],[0,0]);}}(e,t);else {var r=new DataView(t);if(!("TextDecoder"in window))return console.warn("Sorry, ASCII STL loading only works in browsers that support TextDecoder (https://caniuse.com/#feat=textencoder)");var n=new TextDecoder("utf-8").decode(r).split("\n");!function(e,t){for(var r,n,a="",o=[],i=0;i<t.length;++i){for(var s=t[i].trim(),l=s.split(" "),p=0;p<l.length;++p)""===l[p]&&l.splice(p,1);if(0!==l.length)switch(a){case"":if("solid"!==l[0])return console.error(s),console.error('Invalid state "'.concat(l[0],'", should be "solid"'));a="solid";break;case"solid":if("facet"!==l[0]||"normal"!==l[1])return console.error(s),console.error('Invalid state "'.concat(l[0],'", should be "facet normal"'));r=new w.default.Vector(parseFloat(l[2]),parseFloat(l[3]),parseFloat(l[4])),e.vertexNormals.push(r,r,r),a="facet normal";break;case"facet normal":if("outer"!==l[0]||"loop"!==l[1])return console.error(s),console.error('Invalid state "'.concat(l[0],'", should be "outer loop"'));a="vertex";break;case"vertex":if("vertex"===l[0])n=new w.default.Vector(parseFloat(l[1]),parseFloat(l[2]),parseFloat(l[3])),e.vertices.push(n),e.uvs.push([0,0]),o.push(e.vertices.indexOf(n));else {if("endloop"!==l[0])return console.error(s),console.error('Invalid state "'.concat(l[0],'", should be "vertex" or "endloop"'));e.faces.push(o),o=[],a="endloop";}break;case"endloop":if("endfacet"!==l[0])return console.error(s),console.error('Invalid state "'.concat(l[0],'", should be "endfacet"'));a="endfacet";break;case"endfacet":if("endsolid"!==l[0]){if("facet"!==l[0]||"normal"!==l[1])return console.error(s),console.error('Invalid state "'.concat(l[0],'", should be "endsolid" or "facet normal"'));r=new w.default.Vector(parseFloat(l[2]),parseFloat(l[3]),parseFloat(l[4])),e.vertexNormals.push(r,r,r),a="facet normal";}break;default:console.error('Invalid state "'.concat(a,'"'));}}}(e,n);}}(o,e),t&&o.normalize(),i._decrementPreload(),"function"==typeof r&&r(o);},n):a.match(/\.obj$/i)?this.loadStrings(e,function(e){!function(e,t){for(var r={v:[],vt:[],vn:[]},n={},a=0;a<t.length;++a){var o=t[a].trim().split(/\b\s+/);if(0<o.length)if("v"===o[0]||"vn"===o[0]){var i=new w.default.Vector(parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3]));r[o[0]].push(i);}else if("vt"===o[0]){var s=[parseFloat(o[1]),parseFloat(o[2])];r[o[0]].push(s);}else if("f"===o[0])for(var l=3;l<o.length;++l){for(var p=[],u=[1,l-1,l],c=0;c<u.length;++c){var d=o[u[c]],h=0;if(void 0!==n[d])h=n[d];else {for(var m=d.split("/"),f=0;f<m.length;f++)m[f]=parseInt(m[f])-1;h=n[d]=e.vertices.length,e.vertices.push(r.v[m[0]].copy()),r.vt[m[1]]?e.uvs.push(r.vt[m[1]].slice()):e.uvs.push([0,0]),r.vn[m[2]]&&e.vertexNormals.push(r.vn[m[2]].copy());}p.push(h);}p[0]!==p[1]&&p[0]!==p[2]&&p[1]!==p[2]&&e.faces.push(p);}}0===e.vertexNormals.length&&e.computeNormals();}(o,e),t&&o.normalize(),i._decrementPreload(),"function"==typeof r&&r(o);},n):(w.default._friendlyFileLoadError(3,e),n?n():console.error("Sorry, the file type is invalid. Only OBJ and STL files are supported.")),o},w.default.prototype.model=function(e){this._assert3d("model"),w.default._validateParameters("model",arguments),0<e.vertices.length&&(this._renderer.geometryInHash(e.gid)||(e._makeTriangleEdges()._edgesToVertices(),this._renderer.createBuffers(e.gid,e)),this._renderer.drawBuffers(e.gid));};var a=w.default;r.default=a;},{"../core/main":32,"./p5.Geometry":81}],79:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,p=(n=e("../core/main"))&&n.__esModule?n:{default:n},a=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}e("./p5.Texture"),p.default.prototype.loadShader=function(e,t,r,n){p.default._validateParameters("loadShader",arguments),n=n||console.error;function a(){i._decrementPreload(),r&&r(o);}var o=new p.default.Shader,i=this,s=!1,l=!1;return this.loadStrings(e,function(e){o._vertSrc=e.join("\n"),l=!0,s&&a();},n),this.loadStrings(t,function(e){o._fragSrc=e.join("\n"),s=!0,l&&a();},n),o},p.default.prototype.createShader=function(e,t){return this._assert3d("createShader"),p.default._validateParameters("createShader",arguments),new p.default.Shader(this._renderer,e,t)},p.default.prototype.shader=function(e){return this._assert3d("shader"),p.default._validateParameters("shader",arguments),void 0===e._renderer&&(e._renderer=this._renderer),e.isStrokeShader()?this._renderer.userStrokeShader=e:(this._renderer.userFillShader=e,this._renderer._useNormalMaterial=!1),e.init(),this},p.default.prototype.resetShader=function(){return this._renderer.userFillShader=this._renderer.userStrokeShader=null,this},p.default.prototype.normalMaterial=function(){this._assert3d("normalMaterial");for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return p.default._validateParameters("normalMaterial",t),this._renderer.drawMode=a.FILL,this._renderer._useSpecularMaterial=!1,this._renderer._useEmissiveMaterial=!1,this._renderer._useNormalMaterial=!0,this._renderer.curFillColor=[1,1,1,1],this._renderer._setProperty("_doFill",!0),this.noStroke(),this},p.default.prototype.texture=function(e){return this._assert3d("texture"),p.default._validateParameters("texture",arguments),e.gifProperties&&e._animateGif(this),this._renderer.drawMode=a.TEXTURE,this._renderer._useSpecularMaterial=!1,this._renderer._useEmissiveMaterial=!1,this._renderer._useNormalMaterial=!1,this._renderer._tex=e,this._renderer._setProperty("_doFill",!0),this},p.default.prototype.textureMode=function(e){e!==a.IMAGE&&e!==a.NORMAL?console.warn("You tried to set ".concat(e," textureMode only supports IMAGE & NORMAL ")):this._renderer.textureMode=e;},p.default.prototype.textureWrap=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:e;this._renderer.textureWrapX=e,this._renderer.textureWrapY=t;for(var r=this._renderer.textures,n=0;n<r.length;n++)r[n].setWrapMode(e,t);},p.default.prototype.ambientMaterial=function(e,t,r){this._assert3d("ambientMaterial"),p.default._validateParameters("ambientMaterial",arguments);var n=p.default.prototype.color.apply(this,arguments);return this._renderer.curFillColor=n._array,this._renderer._useSpecularMaterial=!1,this._renderer._useEmissiveMaterial=!1,this._renderer._useNormalMaterial=!1,this._renderer._enableLighting=!0,this._renderer._tex=null,this},p.default.prototype.emissiveMaterial=function(e,t,r,n){this._assert3d("emissiveMaterial"),p.default._validateParameters("emissiveMaterial",arguments);var a=p.default.prototype.color.apply(this,arguments);return this._renderer.curFillColor=a._array,this._renderer._useSpecularMaterial=!1,this._renderer._useEmissiveMaterial=!0,this._renderer._useNormalMaterial=!1,this._renderer._enableLighting=!0,this._renderer._tex=null,this},p.default.prototype.specularMaterial=function(e,t,r,n){this._assert3d("specularMaterial"),p.default._validateParameters("specularMaterial",arguments);var a=p.default.prototype.color.apply(this,arguments);return this._renderer.curFillColor=a._array,this._renderer._useSpecularMaterial=!0,this._renderer._useEmissiveMaterial=!1,this._renderer._useNormalMaterial=!1,this._renderer._enableLighting=!0,this._renderer._tex=null,this},p.default.prototype.shininess=function(e){return this._assert3d("shininess"),p.default._validateParameters("shininess",arguments),e<1&&(e=1),this._renderer._useShininess=e,this},p.default.RendererGL.prototype._applyColorBlend=function(e){var t=this.GL,r=this.drawMode===a.TEXTURE||e[e.length-1]<1||this._isErasing;return r!==this._isBlending&&(r||this.curBlendMode!==a.BLEND&&this.curBlendMode!==a.ADD?t.enable(t.BLEND):t.disable(t.BLEND),t.depthMask(!0),this._isBlending=r),this._applyBlendMode(),e},p.default.RendererGL.prototype._applyBlendMode=function(){if(this._cachedBlendMode!==this.curBlendMode){var e=this.GL;switch(this.curBlendMode){case a.BLEND:case a.ADD:e.blendEquation(e.FUNC_ADD),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA);break;case a.REMOVE:e.blendEquation(e.FUNC_REVERSE_SUBTRACT),e.blendFunc(e.SRC_ALPHA,e.DST_ALPHA);break;case a.MULTIPLY:e.blendEquationSeparate(e.FUNC_ADD,e.FUNC_ADD),e.blendFuncSeparate(e.ZERO,e.SRC_COLOR,e.ONE,e.ONE);break;case a.SCREEN:e.blendEquationSeparate(e.FUNC_ADD,e.FUNC_ADD),e.blendFuncSeparate(e.ONE_MINUS_DST_COLOR,e.ONE,e.ONE,e.ONE);break;case a.EXCLUSION:e.blendEquationSeparate(e.FUNC_ADD,e.FUNC_ADD),e.blendFuncSeparate(e.ONE_MINUS_DST_COLOR,e.ONE_MINUS_SRC_COLOR,e.ONE,e.ONE);break;case a.REPLACE:e.blendEquation(e.FUNC_ADD),e.blendFunc(e.ONE,e.ZERO);break;case a.SUBTRACT:e.blendEquationSeparate(e.FUNC_REVERSE_SUBTRACT,e.FUNC_ADD),e.blendFuncSeparate(e.SRC_ALPHA,e.ONE,e.ONE,e.ONE);break;case a.DARKEST:this.blendExt?(e.blendEquationSeparate(this.blendExt.MIN_EXT,e.FUNC_ADD),e.blendFuncSeparate(e.ONE,e.ONE,e.ONE,e.ONE)):console.warn("blendMode(DARKEST) does not work in your browser in WEBGL mode.");break;case a.LIGHTEST:this.blendExt?(e.blendEquationSeparate(this.blendExt.MAX_EXT,e.FUNC_ADD),e.blendFuncSeparate(e.ONE,e.ONE,e.ONE,e.ONE)):console.warn("blendMode(LIGHTEST) does not work in your browser in WEBGL mode.");break;default:console.error("Oops! Somehow RendererGL set curBlendMode to an unsupported mode.");}this._isErasing||(this._cachedBlendMode=this.curBlendMode);}};var o=p.default;r.default=o;},{"../core/constants":22,"../core/main":32,"./p5.Texture":88}],80:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,f=(n=e("../core/main"))&&n.__esModule?n:{default:n};f.default.prototype.camera=function(){var e;this._assert3d("camera");for(var t=arguments.length,r=new Array(t),n=0;n<t;n++)r[n]=arguments[n];return f.default._validateParameters("camera",r),(e=this._renderer._curCamera).camera.apply(e,r),this},f.default.prototype.perspective=function(){var e;this._assert3d("perspective");for(var t=arguments.length,r=new Array(t),n=0;n<t;n++)r[n]=arguments[n];return f.default._validateParameters("perspective",r),(e=this._renderer._curCamera).perspective.apply(e,r),this},f.default.prototype.ortho=function(){var e;this._assert3d("ortho");for(var t=arguments.length,r=new Array(t),n=0;n<t;n++)r[n]=arguments[n];return f.default._validateParameters("ortho",r),(e=this._renderer._curCamera).ortho.apply(e,r),this},f.default.prototype.frustum=function(){var e;this._assert3d("frustum");for(var t=arguments.length,r=new Array(t),n=0;n<t;n++)r[n]=arguments[n];return f.default._validateParameters("frustum",r),(e=this._renderer._curCamera).frustum.apply(e,r),this},f.default.prototype.createCamera=function(){this._assert3d("createCamera");var e=new f.default.Camera(this._renderer);return e._computeCameraDefaultSettings(),e._setDefaultCamera(),this._renderer._curCamera=e},f.default.Camera=function(e){this._renderer=e,this.cameraType="default",this.cameraMatrix=new f.default.Matrix,this.projMatrix=new f.default.Matrix;},f.default.Camera.prototype.perspective=function(e,t,r,n){this.cameraType=0<arguments.length?"custom":"default",void 0===e?(e=this.defaultCameraFOV,this.cameraFOV=e):this.cameraFOV=this._renderer._pInst._toRadians(e),void 0===t&&(t=this.defaultAspectRatio),void 0===r&&(r=this.defaultCameraNear),void 0===n&&(n=this.defaultCameraFar),r<=1e-4&&(r=.01,console.log("Avoid perspective near plane values close to or below 0. Setting value to 0.01.")),n<r&&console.log("Perspective far plane value is less than near plane value. Nothing will be shown."),this.aspectRatio=t,this.cameraNear=r,this.cameraFar=n,this.projMatrix=f.default.Matrix.identity();var a=1/Math.tan(this.cameraFOV/2),o=1/(this.cameraNear-this.cameraFar);this.projMatrix.set(a/t,0,0,0,0,-a,0,0,0,0,(n+r)*o,-1,0,0,2*n*r*o,0),this._isActive()&&this._renderer.uPMatrix.set(this.projMatrix.mat4[0],this.projMatrix.mat4[1],this.projMatrix.mat4[2],this.projMatrix.mat4[3],this.projMatrix.mat4[4],this.projMatrix.mat4[5],this.projMatrix.mat4[6],this.projMatrix.mat4[7],this.projMatrix.mat4[8],this.projMatrix.mat4[9],this.projMatrix.mat4[10],this.projMatrix.mat4[11],this.projMatrix.mat4[12],this.projMatrix.mat4[13],this.projMatrix.mat4[14],this.projMatrix.mat4[15]);},f.default.Camera.prototype.ortho=function(e,t,r,n,a,o){void 0===e&&(e=-this._renderer.width/2),void 0===t&&(t=this._renderer.width/2),void 0===r&&(r=-this._renderer.height/2),void 0===n&&(n=this._renderer.height/2),void 0===a&&(a=0),void 0===o&&(o=Math.max(this._renderer.width,this._renderer.height));var i=t-e,s=n-r,l=o-a,p=2/i,u=2/s,c=-2/l,d=-(t+e)/i,h=-(n+r)/s,m=-(o+a)/l;this.projMatrix=f.default.Matrix.identity(),this.projMatrix.set(p,0,0,0,0,-u,0,0,0,0,c,0,d,h,m,1),this._isActive()&&this._renderer.uPMatrix.set(this.projMatrix.mat4[0],this.projMatrix.mat4[1],this.projMatrix.mat4[2],this.projMatrix.mat4[3],this.projMatrix.mat4[4],this.projMatrix.mat4[5],this.projMatrix.mat4[6],this.projMatrix.mat4[7],this.projMatrix.mat4[8],this.projMatrix.mat4[9],this.projMatrix.mat4[10],this.projMatrix.mat4[11],this.projMatrix.mat4[12],this.projMatrix.mat4[13],this.projMatrix.mat4[14],this.projMatrix.mat4[15]),this.cameraType="custom";},f.default.Camera.prototype.frustum=function(e,t,r,n,a,o){void 0===e&&(e=-this._renderer.width/2),void 0===t&&(t=this._renderer.width/2),void 0===r&&(r=-this._renderer.height/2),void 0===n&&(n=this._renderer.height/2),void 0===a&&(a=0),void 0===o&&(o=Math.max(this._renderer.width,this._renderer.height));var i=t-e,s=n-r,l=o-a,p=2*a/i,u=2*a/s,c=-2*o*a/l,d=(t+e)/i,h=(n+r)/s,m=-(o+a)/l;this.projMatrix=f.default.Matrix.identity(),this.projMatrix.set(p,0,0,0,0,u,0,0,d,h,m,-1,0,0,c,0),this._isActive()&&this._renderer.uPMatrix.set(this.projMatrix.mat4[0],this.projMatrix.mat4[1],this.projMatrix.mat4[2],this.projMatrix.mat4[3],this.projMatrix.mat4[4],this.projMatrix.mat4[5],this.projMatrix.mat4[6],this.projMatrix.mat4[7],this.projMatrix.mat4[8],this.projMatrix.mat4[9],this.projMatrix.mat4[10],this.projMatrix.mat4[11],this.projMatrix.mat4[12],this.projMatrix.mat4[13],this.projMatrix.mat4[14],this.projMatrix.mat4[15]),this.cameraType="custom";},f.default.Camera.prototype._rotateView=function(e,t,r,n){var a=this.centerX,o=this.centerY,i=this.centerZ;a-=this.eyeX,o-=this.eyeY,i-=this.eyeZ;var s=f.default.Matrix.identity(this._renderer._pInst);s.rotate(this._renderer._pInst._toRadians(e),t,r,n);var l=[a*s.mat4[0]+o*s.mat4[4]+i*s.mat4[8],a*s.mat4[1]+o*s.mat4[5]+i*s.mat4[9],a*s.mat4[2]+o*s.mat4[6]+i*s.mat4[10]];l[0]+=this.eyeX,l[1]+=this.eyeY,l[2]+=this.eyeZ,this.camera(this.eyeX,this.eyeY,this.eyeZ,l[0],l[1],l[2],this.upX,this.upY,this.upZ);},f.default.Camera.prototype.pan=function(e){var t=this._getLocalAxes();this._rotateView(e,t.y[0],t.y[1],t.y[2]);},f.default.Camera.prototype.tilt=function(e){var t=this._getLocalAxes();this._rotateView(e,t.x[0],t.x[1],t.x[2]);},f.default.Camera.prototype.lookAt=function(e,t,r){this.camera(this.eyeX,this.eyeY,this.eyeZ,e,t,r,this.upX,this.upY,this.upZ);},f.default.Camera.prototype.camera=function(e,t,r,n,a,o,i,s,l){void 0===e&&(e=this.defaultEyeX,t=this.defaultEyeY,r=this.defaultEyeZ,n=e,a=t,s=1,l=i=o=0),this.eyeX=e,this.eyeY=t,this.eyeZ=r,this.centerX=n,this.centerY=a,this.centerZ=o,this.upX=i,this.upY=s,this.upZ=l;var p=this._getLocalAxes();this.cameraMatrix.set(p.x[0],p.y[0],p.z[0],0,p.x[1],p.y[1],p.z[1],0,p.x[2],p.y[2],p.z[2],0,0,0,0,1);var u=-e,c=-t,d=-r;return this.cameraMatrix.translate([u,c,d]),this._isActive()&&this._renderer.uMVMatrix.set(this.cameraMatrix.mat4[0],this.cameraMatrix.mat4[1],this.cameraMatrix.mat4[2],this.cameraMatrix.mat4[3],this.cameraMatrix.mat4[4],this.cameraMatrix.mat4[5],this.cameraMatrix.mat4[6],this.cameraMatrix.mat4[7],this.cameraMatrix.mat4[8],this.cameraMatrix.mat4[9],this.cameraMatrix.mat4[10],this.cameraMatrix.mat4[11],this.cameraMatrix.mat4[12],this.cameraMatrix.mat4[13],this.cameraMatrix.mat4[14],this.cameraMatrix.mat4[15]),this},f.default.Camera.prototype.move=function(e,t,r){var n=this._getLocalAxes(),a=[n.x[0]*e,n.x[1]*e,n.x[2]*e],o=[n.y[0]*t,n.y[1]*t,n.y[2]*t],i=[n.z[0]*r,n.z[1]*r,n.z[2]*r];this.camera(this.eyeX+a[0]+o[0]+i[0],this.eyeY+a[1]+o[1]+i[1],this.eyeZ+a[2]+o[2]+i[2],this.centerX+a[0]+o[0]+i[0],this.centerY+a[1]+o[1]+i[1],this.centerZ+a[2]+o[2]+i[2],0,1,0);},f.default.Camera.prototype.setPosition=function(e,t,r){var n=e-this.eyeX,a=t-this.eyeY,o=r-this.eyeZ;this.camera(e,t,r,this.centerX+n,this.centerY+a,this.centerZ+o,0,1,0);},f.default.Camera.prototype._computeCameraDefaultSettings=function(){this.defaultCameraFOV=60/180*Math.PI,this.defaultAspectRatio=this._renderer.width/this._renderer.height,this.defaultEyeX=0,this.defaultEyeY=0,this.defaultEyeZ=this._renderer.height/2/Math.tan(this.defaultCameraFOV/2),this.defaultCenterX=0,this.defaultCenterY=0,this.defaultCenterZ=0,this.defaultCameraNear=.1*this.defaultEyeZ,this.defaultCameraFar=10*this.defaultEyeZ;},f.default.Camera.prototype._setDefaultCamera=function(){this.cameraFOV=this.defaultCameraFOV,this.aspectRatio=this.defaultAspectRatio,this.eyeX=this.defaultEyeX,this.eyeY=this.defaultEyeY,this.eyeZ=this.defaultEyeZ,this.centerX=this.defaultCenterX,this.centerY=this.defaultCenterY,this.centerZ=this.defaultCenterZ,this.upX=0,this.upY=1,this.upZ=0,this.cameraNear=this.defaultCameraNear,this.cameraFar=this.defaultCameraFar,this.perspective(),this.camera(),this.cameraType="default";},f.default.Camera.prototype._resize=function(){"default"===this.cameraType?(this._computeCameraDefaultSettings(),this._setDefaultCamera()):this.perspective(this.cameraFOV,this._renderer.width/this._renderer.height);},f.default.Camera.prototype.copy=function(){var e=new f.default.Camera(this._renderer);return e.cameraFOV=this.cameraFOV,e.aspectRatio=this.aspectRatio,e.eyeX=this.eyeX,e.eyeY=this.eyeY,e.eyeZ=this.eyeZ,e.centerX=this.centerX,e.centerY=this.centerY,e.centerZ=this.centerZ,e.cameraNear=this.cameraNear,e.cameraFar=this.cameraFar,e.cameraType=this.cameraType,e.cameraMatrix=this.cameraMatrix.copy(),e.projMatrix=this.projMatrix.copy(),e},f.default.Camera.prototype._getLocalAxes=function(){var e=this.eyeX-this.centerX,t=this.eyeY-this.centerY,r=this.eyeZ-this.centerZ,n=Math.sqrt(e*e+t*t+r*r);0!==n&&(e/=n,t/=n,r/=n);var a=this.upX,o=this.upY,i=this.upZ,s=o*r-i*t,l=-a*r+i*e,p=a*t-o*e;a=t*p-r*l,o=-e*p+r*s,i=e*l-t*s;var u=Math.sqrt(s*s+l*l+p*p);0!==u&&(s/=u,l/=u,p/=u);var c=Math.sqrt(a*a+o*o+i*i);return 0!==c&&(a/=c,o/=c,i/=c),{x:[s,l,p],y:[a,o,i],z:[e,t,r]}},f.default.Camera.prototype._orbit=function(e,t,r){var n=this.eyeX-this.centerX,a=this.eyeY-this.centerY,o=this.eyeZ-this.centerZ,i=Math.sqrt(n*n+a*a+o*o),s=Math.atan2(n,o),l=Math.acos(Math.max(-1,Math.min(1,a/i)));s+=e,(i+=r)<0&&(i=.1),(l+=t)>Math.PI?l=Math.PI:l<=0&&(l=.001);var p=Math.sin(l)*i*Math.sin(s),u=Math.cos(l)*i,c=Math.sin(l)*i*Math.cos(s);this.camera(p+this.centerX,u+this.centerY,c+this.centerZ,this.centerX,this.centerY,this.centerZ,0,1,0);},f.default.Camera.prototype._isActive=function(){return this===this._renderer._curCamera},f.default.prototype.setCamera=function(e){this._renderer._curCamera=e,this._renderer.uPMatrix.set(e.projMatrix.mat4[0],e.projMatrix.mat4[1],e.projMatrix.mat4[2],e.projMatrix.mat4[3],e.projMatrix.mat4[4],e.projMatrix.mat4[5],e.projMatrix.mat4[6],e.projMatrix.mat4[7],e.projMatrix.mat4[8],e.projMatrix.mat4[9],e.projMatrix.mat4[10],e.projMatrix.mat4[11],e.projMatrix.mat4[12],e.projMatrix.mat4[13],e.projMatrix.mat4[14],e.projMatrix.mat4[15]);};var a=f.default.Camera;r.default=a;},{"../core/main":32}],81:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,u=(n=e("../core/main"))&&n.__esModule?n:{default:n};u.default.Geometry=function(e,t,r){return this.vertices=[],this.lineVertices=[],this.lineNormals=[],this.vertexNormals=[],this.faces=[],this.uvs=[],this.edges=[],this.vertexColors=[],this.detailX=void 0!==e?e:1,this.detailY=void 0!==t?t:1,this.dirtyFlags={},r instanceof Function&&r.call(this),this},u.default.Geometry.prototype.reset=function(){this.lineVertices.length=0,this.lineNormals.length=0,this.vertices.length=0,this.edges.length=0,this.vertexColors.length=0,this.vertexNormals.length=0,this.uvs.length=0,this.dirtyFlags={};},u.default.Geometry.prototype.computeFaces=function(){this.faces.length=0;for(var e,t,r,n,a=this.detailX+1,o=0;o<this.detailY;o++)for(var i=0;i<this.detailX;i++)t=(e=o*a+i)+1,r=(o+1)*a+i+1,n=(o+1)*a+i,this.faces.push([e,t,n]),this.faces.push([n,t,r]);return this},u.default.Geometry.prototype._getFaceNormal=function(e){var t=this.faces[e],r=this.vertices[t[0]],n=this.vertices[t[1]],a=this.vertices[t[2]],o=u.default.Vector.sub(n,r),i=u.default.Vector.sub(a,r),s=u.default.Vector.cross(o,i),l=u.default.Vector.mag(s),p=l/(u.default.Vector.mag(o)*u.default.Vector.mag(i));return 0===p||isNaN(p)?(console.warn("p5.Geometry.prototype._getFaceNormal:","face has colinear sides or a repeated vertex"),s):(1<p&&(p=1),s.mult(Math.asin(p)/l))},u.default.Geometry.prototype.computeNormals=function(){var e,t=this.vertexNormals,r=this.vertices,n=this.faces;for(e=t.length=0;e<r.length;++e)t.push(new u.default.Vector);for(var a=0;a<n.length;++a)for(var o=n[a],i=this._getFaceNormal(a),s=0;s<3;++s){t[o[s]].add(i);}for(e=0;e<r.length;++e)t[e].normalize();return this},u.default.Geometry.prototype.averageNormals=function(){for(var e=0;e<=this.detailY;e++){var t=this.detailX+1,r=u.default.Vector.add(this.vertexNormals[e*t],this.vertexNormals[e*t+this.detailX]);r=u.default.Vector.div(r,2),this.vertexNormals[e*t]=r,this.vertexNormals[e*t+this.detailX]=r;}return this},u.default.Geometry.prototype.averagePoleNormals=function(){for(var e=new u.default.Vector(0,0,0),t=0;t<this.detailX;t++)e.add(this.vertexNormals[t]);e=u.default.Vector.div(e,this.detailX);for(var r=0;r<this.detailX;r++)this.vertexNormals[r]=e;e=new u.default.Vector(0,0,0);for(var n=this.vertices.length-1;n>this.vertices.length-1-this.detailX;n--)e.add(this.vertexNormals[n]);e=u.default.Vector.div(e,this.detailX);for(var a=this.vertices.length-1;a>this.vertices.length-1-this.detailX;a--)this.vertexNormals[a]=e;return this},u.default.Geometry.prototype._makeTriangleEdges=function(){if(this.edges.length=0,Array.isArray(this.strokeIndices))for(var e=0,t=this.strokeIndices.length;e<t;e++)this.edges.push(this.strokeIndices[e]);else for(var r=0;r<this.faces.length;r++)this.edges.push([this.faces[r][0],this.faces[r][1]]),this.edges.push([this.faces[r][1],this.faces[r][2]]),this.edges.push([this.faces[r][2],this.faces[r][0]]);return this},u.default.Geometry.prototype._edgesToVertices=function(){this.lineVertices.length=0;for(var e=this.lineNormals.length=0;e<this.edges.length;e++){var t=this.vertices[this.edges[e][0]],r=this.vertices[this.edges[e][1]],n=r.copy().sub(t).normalize(),a=t.array(),o=t.array(),i=r.array(),s=r.array(),l=n.array(),p=n.array();l.push(1),p.push(-1),this.lineNormals.push(l,p,l,l,p,p),this.lineVertices.push(a,o,i,i,o,s);}return this},u.default.Geometry.prototype.normalize=function(){if(0<this.vertices.length){for(var e=this.vertices[0].copy(),t=this.vertices[0].copy(),r=0;r<this.vertices.length;r++)e.x=Math.max(e.x,this.vertices[r].x),t.x=Math.min(t.x,this.vertices[r].x),e.y=Math.max(e.y,this.vertices[r].y),t.y=Math.min(t.y,this.vertices[r].y),e.z=Math.max(e.z,this.vertices[r].z),t.z=Math.min(t.z,this.vertices[r].z);for(var n=u.default.Vector.lerp(e,t,.5),a=u.default.Vector.sub(e,t),o=200/Math.max(Math.max(a.x,a.y),a.z),i=0;i<this.vertices.length;i++)this.vertices[i].sub(n),this.vertices[i].mult(o);}return this};var a=u.default.Geometry;r.default=a;},{"../core/main":32}],82:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,L=(n=e("../core/main"))&&n.__esModule?n:{default:n};var a=Array,I=function(e){return e instanceof Array};"undefined"!=typeof Float32Array&&(a=Float32Array,I=function(e){return e instanceof Array||e instanceof Float32Array}),L.default.Matrix=function(){for(var e=new Array(arguments.length),t=0;t<e.length;++t)e[t]=arguments[t];return e.length&&e[e.length-1]instanceof L.default&&(this.p5=e[e.length-1]),"mat3"===e[0]?this.mat3=Array.isArray(e[1])?e[1]:new a([1,0,0,0,1,0,0,0,1]):this.mat4=Array.isArray(e[0])?e[0]:new a([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this},L.default.Matrix.prototype.set=function(e){return e instanceof L.default.Matrix?this.mat4=e.mat4:I(e)?this.mat4=e:16===arguments.length&&(this.mat4[0]=e,this.mat4[1]=arguments[1],this.mat4[2]=arguments[2],this.mat4[3]=arguments[3],this.mat4[4]=arguments[4],this.mat4[5]=arguments[5],this.mat4[6]=arguments[6],this.mat4[7]=arguments[7],this.mat4[8]=arguments[8],this.mat4[9]=arguments[9],this.mat4[10]=arguments[10],this.mat4[11]=arguments[11],this.mat4[12]=arguments[12],this.mat4[13]=arguments[13],this.mat4[14]=arguments[14],this.mat4[15]=arguments[15]),this},L.default.Matrix.prototype.get=function(){return new L.default.Matrix(this.mat4,this.p5)},L.default.Matrix.prototype.copy=function(){var e=new L.default.Matrix(this.p5);return e.mat4[0]=this.mat4[0],e.mat4[1]=this.mat4[1],e.mat4[2]=this.mat4[2],e.mat4[3]=this.mat4[3],e.mat4[4]=this.mat4[4],e.mat4[5]=this.mat4[5],e.mat4[6]=this.mat4[6],e.mat4[7]=this.mat4[7],e.mat4[8]=this.mat4[8],e.mat4[9]=this.mat4[9],e.mat4[10]=this.mat4[10],e.mat4[11]=this.mat4[11],e.mat4[12]=this.mat4[12],e.mat4[13]=this.mat4[13],e.mat4[14]=this.mat4[14],e.mat4[15]=this.mat4[15],e},L.default.Matrix.identity=function(e){return new L.default.Matrix(e)},L.default.Matrix.prototype.transpose=function(e){var t,r,n,a,o,i;return e instanceof L.default.Matrix?(t=e.mat4[1],r=e.mat4[2],n=e.mat4[3],a=e.mat4[6],o=e.mat4[7],i=e.mat4[11],this.mat4[0]=e.mat4[0],this.mat4[1]=e.mat4[4],this.mat4[2]=e.mat4[8],this.mat4[3]=e.mat4[12],this.mat4[4]=t,this.mat4[5]=e.mat4[5],this.mat4[6]=e.mat4[9],this.mat4[7]=e.mat4[13],this.mat4[8]=r,this.mat4[9]=a,this.mat4[10]=e.mat4[10],this.mat4[11]=e.mat4[14],this.mat4[12]=n,this.mat4[13]=o,this.mat4[14]=i,this.mat4[15]=e.mat4[15]):I(e)&&(t=e[1],r=e[2],n=e[3],a=e[6],o=e[7],i=e[11],this.mat4[0]=e[0],this.mat4[1]=e[4],this.mat4[2]=e[8],this.mat4[3]=e[12],this.mat4[4]=t,this.mat4[5]=e[5],this.mat4[6]=e[9],this.mat4[7]=e[13],this.mat4[8]=r,this.mat4[9]=a,this.mat4[10]=e[10],this.mat4[11]=e[14],this.mat4[12]=n,this.mat4[13]=o,this.mat4[14]=i,this.mat4[15]=e[15]),this},L.default.Matrix.prototype.invert=function(e){var t,r,n,a,o,i,s,l,p,u,c,d,h,m,f,y;e instanceof L.default.Matrix?(t=e.mat4[0],r=e.mat4[1],n=e.mat4[2],a=e.mat4[3],o=e.mat4[4],i=e.mat4[5],s=e.mat4[6],l=e.mat4[7],p=e.mat4[8],u=e.mat4[9],c=e.mat4[10],d=e.mat4[11],h=e.mat4[12],m=e.mat4[13],f=e.mat4[14],y=e.mat4[15]):I(e)&&(t=e[0],r=e[1],n=e[2],a=e[3],o=e[4],i=e[5],s=e[6],l=e[7],p=e[8],u=e[9],c=e[10],d=e[11],h=e[12],m=e[13],f=e[14],y=e[15]);var g=t*i-r*o,v=t*s-n*o,b=t*l-a*o,_=r*s-n*i,x=r*l-a*i,S=n*l-a*s,w=p*m-u*h,M=p*f-c*h,E=p*y-d*h,T=u*f-c*m,C=u*y-d*m,N=c*y-d*f,O=g*N-v*C+b*T+_*E-x*M+S*w;return O?(O=1/O,this.mat4[0]=(i*N-s*C+l*T)*O,this.mat4[1]=(n*C-r*N-a*T)*O,this.mat4[2]=(m*S-f*x+y*_)*O,this.mat4[3]=(c*x-u*S-d*_)*O,this.mat4[4]=(s*E-o*N-l*M)*O,this.mat4[5]=(t*N-n*E+a*M)*O,this.mat4[6]=(f*b-h*S-y*v)*O,this.mat4[7]=(p*S-c*b+d*v)*O,this.mat4[8]=(o*C-i*E+l*w)*O,this.mat4[9]=(r*E-t*C-a*w)*O,this.mat4[10]=(h*x-m*b+y*g)*O,this.mat4[11]=(u*b-p*x-d*g)*O,this.mat4[12]=(i*M-o*T-s*w)*O,this.mat4[13]=(t*T-r*M+n*w)*O,this.mat4[14]=(m*v-h*_-f*g)*O,this.mat4[15]=(p*_-u*v+c*g)*O,this):null},L.default.Matrix.prototype.invert3x3=function(){var e=this.mat3[0],t=this.mat3[1],r=this.mat3[2],n=this.mat3[3],a=this.mat3[4],o=this.mat3[5],i=this.mat3[6],s=this.mat3[7],l=this.mat3[8],p=l*a-o*s,u=-l*n+o*i,c=s*n-a*i,d=e*p+t*u+r*c;return d?(d=1/d,this.mat3[0]=p*d,this.mat3[1]=(-l*t+r*s)*d,this.mat3[2]=(o*t-r*a)*d,this.mat3[3]=u*d,this.mat3[4]=(l*e-r*i)*d,this.mat3[5]=(-o*e+r*n)*d,this.mat3[6]=c*d,this.mat3[7]=(-s*e+t*i)*d,this.mat3[8]=(a*e-t*n)*d,this):null},L.default.Matrix.prototype.transpose3x3=function(e){var t=e[1],r=e[2],n=e[5];return this.mat3[1]=e[3],this.mat3[2]=e[6],this.mat3[3]=t,this.mat3[5]=e[7],this.mat3[6]=r,this.mat3[7]=n,this},L.default.Matrix.prototype.inverseTranspose=function(e){void 0===this.mat3?console.error("sorry, this function only works with mat3"):(this.mat3[0]=e.mat4[0],this.mat3[1]=e.mat4[1],this.mat3[2]=e.mat4[2],this.mat3[3]=e.mat4[4],this.mat3[4]=e.mat4[5],this.mat3[5]=e.mat4[6],this.mat3[6]=e.mat4[8],this.mat3[7]=e.mat4[9],this.mat3[8]=e.mat4[10]);var t=this.invert3x3();if(t)t.transpose3x3(this.mat3);else for(var r=0;r<9;r++)this.mat3[r]=0;return this},L.default.Matrix.prototype.determinant=function(){var e=this.mat4[0]*this.mat4[5]-this.mat4[1]*this.mat4[4],t=this.mat4[0]*this.mat4[6]-this.mat4[2]*this.mat4[4],r=this.mat4[0]*this.mat4[7]-this.mat4[3]*this.mat4[4],n=this.mat4[1]*this.mat4[6]-this.mat4[2]*this.mat4[5],a=this.mat4[1]*this.mat4[7]-this.mat4[3]*this.mat4[5],o=this.mat4[2]*this.mat4[7]-this.mat4[3]*this.mat4[6],i=this.mat4[8]*this.mat4[13]-this.mat4[9]*this.mat4[12],s=this.mat4[8]*this.mat4[14]-this.mat4[10]*this.mat4[12],l=this.mat4[8]*this.mat4[15]-this.mat4[11]*this.mat4[12],p=this.mat4[9]*this.mat4[14]-this.mat4[10]*this.mat4[13],u=this.mat4[9]*this.mat4[15]-this.mat4[11]*this.mat4[13];return e*(this.mat4[10]*this.mat4[15]-this.mat4[11]*this.mat4[14])-t*u+r*p+n*l-a*s+o*i},L.default.Matrix.prototype.mult=function(e){var t;if(e===this||e===this.mat4)t=this.copy().mat4;else if(e instanceof L.default.Matrix)t=e.mat4;else if(I(e))t=e;else {if(16!==arguments.length)return;t=arguments;}var r=this.mat4[0],n=this.mat4[1],a=this.mat4[2],o=this.mat4[3];return this.mat4[0]=r*t[0]+n*t[4]+a*t[8]+o*t[12],this.mat4[1]=r*t[1]+n*t[5]+a*t[9]+o*t[13],this.mat4[2]=r*t[2]+n*t[6]+a*t[10]+o*t[14],this.mat4[3]=r*t[3]+n*t[7]+a*t[11]+o*t[15],r=this.mat4[4],n=this.mat4[5],a=this.mat4[6],o=this.mat4[7],this.mat4[4]=r*t[0]+n*t[4]+a*t[8]+o*t[12],this.mat4[5]=r*t[1]+n*t[5]+a*t[9]+o*t[13],this.mat4[6]=r*t[2]+n*t[6]+a*t[10]+o*t[14],this.mat4[7]=r*t[3]+n*t[7]+a*t[11]+o*t[15],r=this.mat4[8],n=this.mat4[9],a=this.mat4[10],o=this.mat4[11],this.mat4[8]=r*t[0]+n*t[4]+a*t[8]+o*t[12],this.mat4[9]=r*t[1]+n*t[5]+a*t[9]+o*t[13],this.mat4[10]=r*t[2]+n*t[6]+a*t[10]+o*t[14],this.mat4[11]=r*t[3]+n*t[7]+a*t[11]+o*t[15],r=this.mat4[12],n=this.mat4[13],a=this.mat4[14],o=this.mat4[15],this.mat4[12]=r*t[0]+n*t[4]+a*t[8]+o*t[12],this.mat4[13]=r*t[1]+n*t[5]+a*t[9]+o*t[13],this.mat4[14]=r*t[2]+n*t[6]+a*t[10]+o*t[14],this.mat4[15]=r*t[3]+n*t[7]+a*t[11]+o*t[15],this},L.default.Matrix.prototype.apply=function(e){var t;if(e===this||e===this.mat4)t=this.copy().mat4;else if(e instanceof L.default.Matrix)t=e.mat4;else if(I(e))t=e;else {if(16!==arguments.length)return;t=arguments;}var r=this.mat4,n=r[0],a=r[4],o=r[8],i=r[12];r[0]=t[0]*n+t[1]*a+t[2]*o+t[3]*i,r[4]=t[4]*n+t[5]*a+t[6]*o+t[7]*i,r[8]=t[8]*n+t[9]*a+t[10]*o+t[11]*i,r[12]=t[12]*n+t[13]*a+t[14]*o+t[15]*i;var s=r[1],l=r[5],p=r[9],u=r[13];r[1]=t[0]*s+t[1]*l+t[2]*p+t[3]*u,r[5]=t[4]*s+t[5]*l+t[6]*p+t[7]*u,r[9]=t[8]*s+t[9]*l+t[10]*p+t[11]*u,r[13]=t[12]*s+t[13]*l+t[14]*p+t[15]*u;var c=r[2],d=r[6],h=r[10],m=r[14];r[2]=t[0]*c+t[1]*d+t[2]*h+t[3]*m,r[6]=t[4]*c+t[5]*d+t[6]*h+t[7]*m,r[10]=t[8]*c+t[9]*d+t[10]*h+t[11]*m,r[14]=t[12]*c+t[13]*d+t[14]*h+t[15]*m;var f=r[3],y=r[7],g=r[11],v=r[15];return r[3]=t[0]*f+t[1]*y+t[2]*g+t[3]*v,r[7]=t[4]*f+t[5]*y+t[6]*g+t[7]*v,r[11]=t[8]*f+t[9]*y+t[10]*g+t[11]*v,r[15]=t[12]*f+t[13]*y+t[14]*g+t[15]*v,this},L.default.Matrix.prototype.scale=function(e,t,r){return e instanceof L.default.Vector?(t=e.y,r=e.z,e=e.x):e instanceof Array&&(t=e[1],r=e[2],e=e[0]),this.mat4[0]*=e,this.mat4[1]*=e,this.mat4[2]*=e,this.mat4[3]*=e,this.mat4[4]*=t,this.mat4[5]*=t,this.mat4[6]*=t,this.mat4[7]*=t,this.mat4[8]*=r,this.mat4[9]*=r,this.mat4[10]*=r,this.mat4[11]*=r,this},L.default.Matrix.prototype.rotate=function(e,t,r,n){t instanceof L.default.Vector?(r=t.y,n=t.z,t=t.x):t instanceof Array&&(r=t[1],n=t[2],t=t[0]);var a=Math.sqrt(t*t+r*r+n*n);t*=1/a,r*=1/a,n*=1/a;var o=this.mat4[0],i=this.mat4[1],s=this.mat4[2],l=this.mat4[3],p=this.mat4[4],u=this.mat4[5],c=this.mat4[6],d=this.mat4[7],h=this.mat4[8],m=this.mat4[9],f=this.mat4[10],y=this.mat4[11],g=Math.sin(e),v=Math.cos(e),b=1-v,_=t*t*b+v,x=r*t*b+n*g,S=n*t*b-r*g,w=t*r*b-n*g,M=r*r*b+v,E=n*r*b+t*g,T=t*n*b+r*g,C=r*n*b-t*g,N=n*n*b+v;return this.mat4[0]=o*_+p*x+h*S,this.mat4[1]=i*_+u*x+m*S,this.mat4[2]=s*_+c*x+f*S,this.mat4[3]=l*_+d*x+y*S,this.mat4[4]=o*w+p*M+h*E,this.mat4[5]=i*w+u*M+m*E,this.mat4[6]=s*w+c*M+f*E,this.mat4[7]=l*w+d*M+y*E,this.mat4[8]=o*T+p*C+h*N,this.mat4[9]=i*T+u*C+m*N,this.mat4[10]=s*T+c*C+f*N,this.mat4[11]=l*T+d*C+y*N,this},L.default.Matrix.prototype.translate=function(e){var t=e[0],r=e[1],n=e[2]||0;this.mat4[12]+=this.mat4[0]*t+this.mat4[4]*r+this.mat4[8]*n,this.mat4[13]+=this.mat4[1]*t+this.mat4[5]*r+this.mat4[9]*n,this.mat4[14]+=this.mat4[2]*t+this.mat4[6]*r+this.mat4[10]*n,this.mat4[15]+=this.mat4[3]*t+this.mat4[7]*r+this.mat4[11]*n;},L.default.Matrix.prototype.rotateX=function(e){this.rotate(e,1,0,0);},L.default.Matrix.prototype.rotateY=function(e){this.rotate(e,0,1,0);},L.default.Matrix.prototype.rotateZ=function(e){this.rotate(e,0,0,1);},L.default.Matrix.prototype.perspective=function(e,t,r,n){var a=1/Math.tan(e/2),o=1/(r-n);return this.mat4[0]=a/t,this.mat4[1]=0,this.mat4[2]=0,this.mat4[3]=0,this.mat4[4]=0,this.mat4[5]=a,this.mat4[6]=0,this.mat4[7]=0,this.mat4[8]=0,this.mat4[9]=0,this.mat4[10]=(n+r)*o,this.mat4[11]=-1,this.mat4[12]=0,this.mat4[13]=0,this.mat4[14]=2*n*r*o,this.mat4[15]=0,this},L.default.Matrix.prototype.ortho=function(e,t,r,n,a,o){var i=1/(e-t),s=1/(r-n),l=1/(a-o);return this.mat4[0]=-2*i,this.mat4[1]=0,this.mat4[2]=0,this.mat4[3]=0,this.mat4[4]=0,this.mat4[5]=-2*s,this.mat4[6]=0,this.mat4[7]=0,this.mat4[8]=0,this.mat4[9]=0,this.mat4[10]=2*l,this.mat4[11]=0,this.mat4[12]=(e+t)*i,this.mat4[13]=(n+r)*s,this.mat4[14]=(o+a)*l,this.mat4[15]=1,this};var o=L.default.Matrix;r.default=o;},{"../core/main":32}],83:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};a.default.RenderBuffer=function(e,t,r,n,a,o){this.size=e,this.src=t,this.dst=r,this.attr=n,this._renderer=a,this.map=o;},a.default.RenderBuffer.prototype._prepareBuffer=function(e,t){var r,n=t.attributes,a=this._renderer.GL;r=e.model?e.model:e;var o=n[this.attr];if(o){var i=e[this.dst],s=r[this.src];if(0<s.length){var l=!i;if(l&&(e[this.dst]=i=a.createBuffer()),a.bindBuffer(a.ARRAY_BUFFER,i),l||!1!==r.dirtyFlags[this.src]){var p=this.map,u=p?p(s):s;this._renderer._bindBuffer(i,a.ARRAY_BUFFER,u),r.dirtyFlags[this.src]=!1;}t.enableAttrib(o,this.size);}}};var o=a.default.RenderBuffer;r.default=o;},{"../core/main":32}],84:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,s=(n=e("../core/main"))&&n.__esModule?n:{default:n},l=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=p();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants"));function p(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return p=function(){return e},e}e("./p5.RenderBuffer"),s.default.RendererGL.prototype.beginShape=function(e){return this.immediateMode.shapeMode=void 0!==e?e:l.TRIANGLE_FAN,this.immediateMode.geometry.reset(),this},s.default.RendererGL.prototype.vertex=function(e,t){var r,n,a;r=n=a=0,3===arguments.length?r=arguments[2]:4===arguments.length?(n=arguments[2],a=arguments[3]):5===arguments.length&&(r=arguments[2],n=arguments[3],a=arguments[4]);var o=new s.default.Vector(e,t,r);this.immediateMode.geometry.vertices.push(o);var i=this.curFillColor||[.5,.5,.5,1];return this.immediateMode.geometry.vertexColors.push(i[0],i[1],i[2],i[3]),this.textureMode===l.IMAGE&&(null!==this._tex?0<this._tex.width&&0<this._tex.height&&(n/=this._tex.width,a/=this._tex.height):null===this._tex&&4<=arguments.length&&console.warn("You must first call texture() before using vertex() with image based u and v coordinates")),this.immediateMode.geometry.uvs.push(n,a),this.immediateMode._bezierVertex[0]=e,this.immediateMode._bezierVertex[1]=t,this.immediateMode._bezierVertex[2]=r,this.immediateMode._quadraticVertex[0]=e,this.immediateMode._quadraticVertex[1]=t,this.immediateMode._quadraticVertex[2]=r,this},s.default.RendererGL.prototype.endShape=function(e,t,r,n,a,o){return this.immediateMode.shapeMode===l.POINTS?this._drawPoints(this.immediateMode.geometry.vertices,this.immediateMode.buffers.point):(this._processVertices.apply(this,arguments),this._doFill&&1<this.immediateMode.geometry.vertices.length&&this._drawImmediateFill(),this._doStroke&&1<this.immediateMode.geometry.lineVertices.length&&this._drawImmediateStroke(),this.isBezier=!1,this.isQuadratic=!1,this.isCurve=!1,this.immediateMode._bezierVertex.length=0,this.immediateMode._quadraticVertex.length=0,this.immediateMode._curveVertex.length=0),this},s.default.RendererGL.prototype._processVertices=function(e){if(0!==this.immediateMode.geometry.vertices.length){var t=this._doStroke&&this.drawMode!==l.TEXTURE,r=e===l.CLOSE;t&&(this.immediateMode.geometry.edges=this._calculateEdges(this.immediateMode.shapeMode,this.immediateMode.geometry.vertices,r),this.immediateMode.geometry._edgesToVertices());var n=this.immediateMode.shapeMode===l.TESS;(this.isBezier||this.isQuadratic||this.isCurve||n)&&this.immediateMode.shapeMode!==l.LINES&&this._tesselateShape();}},s.default.RendererGL.prototype._calculateEdges=function(e,t,r){var n=[],a=0;switch(e){case l.TRIANGLE_STRIP:for(a=0;a<t.length-2;a++)n.push([a,a+1]),n.push([a,a+2]);n.push([a,a+1]);break;case l.TRIANGLES:for(a=0;a<t.length-2;a+=3)n.push([a,a+1]),n.push([a+1,a+2]),n.push([a+2,a]);break;case l.LINES:for(a=0;a<t.length-1;a+=2)n.push([a,a+1]);break;default:for(a=0;a<t.length-1;a++)n.push([a,a+1]);}return r&&n.push([t.length-1,0]),n},s.default.RendererGL.prototype._tesselateShape=function(){this.immediateMode.shapeMode=l.TRIANGLES;var e=[new Float32Array(this._vToNArray(this.immediateMode.geometry.vertices))],t=this._triangulate(e);this.immediateMode.geometry.vertices=[];for(var r=0,n=t.length;r<n;r+=3)this.vertex(t[r],t[r+1],t[r+2]);},s.default.RendererGL.prototype._drawImmediateFill=function(){var e=this.GL,t=this._getImmediateFillShader();this._calculateNormals(this.immediateMode.geometry),this._setFillUniforms(t);var r=!0,n=!1,a=void 0;try{for(var o,i=this.immediateMode.buffers.fill[Symbol.iterator]();!(r=(o=i.next()).done);r=!0){o.value._prepareBuffer(this.immediateMode.geometry,t);}}catch(e){n=!0,a=e;}finally{try{r||null==i.return||i.return();}finally{if(n)throw a}}this.immediateMode.shapeMode!==l.LINE_STRIP&&this.immediateMode.shapeMode!==l.LINES||(this.immediateMode.shapeMode=l.TRIANGLE_FAN),this._applyColorBlend(this.curFillColor),e.drawArrays(this.immediateMode.shapeMode,0,this.immediateMode.geometry.vertices.length),t.unbindShader();},s.default.RendererGL.prototype._drawImmediateStroke=function(){var e=this.GL,t=this._getImmediateStrokeShader();this._setStrokeUniforms(t);var r=!0,n=!1,a=void 0;try{for(var o,i=this.immediateMode.buffers.stroke[Symbol.iterator]();!(r=(o=i.next()).done);r=!0){o.value._prepareBuffer(this.immediateMode.geometry,t);}}catch(e){n=!0,a=e;}finally{try{r||null==i.return||i.return();}finally{if(n)throw a}}this._applyColorBlend(this.curStrokeColor),e.drawArrays(e.TRIANGLES,0,this.immediateMode.geometry.lineVertices.length),t.unbindShader();},s.default.RendererGL.prototype._calculateNormals=function(e){e.vertices.forEach(function(){e.vertexNormals.push(new s.default.Vector(0,0,1));});};var a=s.default.RendererGL;r.default=a;},{"../core/constants":22,"../core/main":32,"./p5.RenderBuffer":83}],85:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,i=(n=e("../core/main"))&&n.__esModule?n:{default:n};e("./p5.RendererGL"),e("./p5.RenderBuffer");var a=0;i.default.RendererGL.prototype._initBufferDefaults=function(e){if(this._freeBuffers(e),1e3<++a){var t=Object.keys(this.retainedMode.geometry)[0];delete this.retainedMode.geometry[t],a--;}return this.retainedMode.geometry[e]={}},i.default.RendererGL.prototype._freeBuffers=function(e){var s=this.retainedMode.geometry[e];if(s){delete this.retainedMode.geometry[e],a--;var l=this.GL;s.indexBuffer&&l.deleteBuffer(s.indexBuffer),t(this.retainedMode.buffers.stroke),t(this.retainedMode.buffers.fill);}function t(e){var t=!0,r=!1,n=void 0;try{for(var a,o=e[Symbol.iterator]();!(t=(a=o.next()).done);t=!0){var i=a.value;s[i.dst]&&(l.deleteBuffer(s[i.dst]),s[i.dst]=null);}}catch(e){r=!0,n=e;}finally{try{t||null==o.return||o.return();}finally{if(r)throw n}}}},i.default.RendererGL.prototype.createBuffers=function(e,t){var r=this.GL,n=this._initBufferDefaults(e);n.model=t;var a=n.indexBuffer;if(t.faces.length){a=a||(n.indexBuffer=r.createBuffer());var o=i.default.RendererGL.prototype._flatten(t.faces);this._bindBuffer(a,r.ELEMENT_ARRAY_BUFFER,o,Uint16Array),n.vertexCount=3*t.faces.length;}else a&&(r.deleteBuffer(a),n.indexBuffer=null),n.vertexCount=t.vertices?t.vertices.length:0;return n.lineVertexCount=t.lineVertices?t.lineVertices.length:0,n},i.default.RendererGL.prototype.drawBuffers=function(e){var t=this.GL,r=this.retainedMode.geometry[e];if(this._doStroke&&0<r.lineVertexCount){var n=this._getRetainedStrokeShader();this._setStrokeUniforms(n);var a=!0,o=!1,i=void 0;try{for(var s,l=this.retainedMode.buffers.stroke[Symbol.iterator]();!(a=(s=l.next()).done);a=!0){s.value._prepareBuffer(r,n);}}catch(e){o=!0,i=e;}finally{try{a||null==l.return||l.return();}finally{if(o)throw i}}this._applyColorBlend(this.curStrokeColor),this._drawArrays(t.TRIANGLES,e),n.unbindShader();}if(this._doFill){var p=this._getRetainedFillShader();this._setFillUniforms(p);var u=!0,c=!1,d=void 0;try{for(var h,m=this.retainedMode.buffers.fill[Symbol.iterator]();!(u=(h=m.next()).done);u=!0){h.value._prepareBuffer(r,p);}}catch(e){c=!0,d=e;}finally{try{u||null==m.return||m.return();}finally{if(c)throw d}}r.indexBuffer&&this._bindBuffer(r.indexBuffer,t.ELEMENT_ARRAY_BUFFER),this._applyColorBlend(this.curFillColor),this._drawElements(t.TRIANGLES,e),p.unbindShader();}return this},i.default.RendererGL.prototype.drawBuffersScaled=function(e,t,r,n){var a=this.uMVMatrix.copy();try{this.uMVMatrix.scale(t,r,n),this.drawBuffers(e);}finally{this.uMVMatrix=a;}},i.default.RendererGL.prototype._drawArrays=function(e,t){return this.GL.drawArrays(e,0,this.retainedMode.geometry[t].lineVertexCount),this},i.default.RendererGL.prototype._drawElements=function(e,t){var r=this.retainedMode.geometry[t],n=this.GL;r.indexBuffer?n.drawElements(n.TRIANGLES,r.vertexCount,n.UNSIGNED_SHORT,0):n.drawArrays(e||n.TRIANGLES,0,r.vertexCount);},i.default.RendererGL.prototype._drawPoints=function(e,t){var r=this.GL,n=this._getImmediatePointShader();this._setPointUniforms(n),this._bindBuffer(t,r.ARRAY_BUFFER,this._vToNArray(e),Float32Array,r.STATIC_DRAW),n.enableAttrib(n.attributes.aPosition,3),r.drawArrays(r.Points,0,e.length),n.unbindShader();};var o=i.default.RendererGL;r.default=o;},{"../core/main":32,"./p5.RenderBuffer":83,"./p5.RendererGL":86}],86:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var p=a(e("../core/main")),o=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants")),n=a(e("libtess"));e("./p5.Shader"),e("./p5.Camera"),e("../core/p5.Renderer"),e("./p5.Matrix");e("path");function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}function a(e){return e&&e.__esModule?e:{default:e}}function l(e){return function(e){if(Array.isArray(e)){for(var t=0,r=new Array(e.length);t<e.length;t++)r[t]=e[t];return r}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}var u="precision highp float;\nprecision highp int;\n\nuniform mat4 uViewMatrix;\n\nuniform bool uUseLighting;\n\nuniform int uAmbientLightCount;\nuniform vec3 uAmbientColor[5];\n\nuniform int uDirectionalLightCount;\nuniform vec3 uLightingDirection[5];\nuniform vec3 uDirectionalDiffuseColors[5];\nuniform vec3 uDirectionalSpecularColors[5];\n\nuniform int uPointLightCount;\nuniform vec3 uPointLightLocation[5];\nuniform vec3 uPointLightDiffuseColors[5];\t\nuniform vec3 uPointLightSpecularColors[5];\n\nuniform int uSpotLightCount;\nuniform float uSpotLightAngle[5];\nuniform float uSpotLightConc[5];\nuniform vec3 uSpotLightDiffuseColors[5];\nuniform vec3 uSpotLightSpecularColors[5];\nuniform vec3 uSpotLightLocation[5];\nuniform vec3 uSpotLightDirection[5];\n\nuniform bool uSpecular;\nuniform float uShininess;\n\nuniform float uConstantAttenuation;\nuniform float uLinearAttenuation;\nuniform float uQuadraticAttenuation;\n\nconst float specularFactor = 2.0;\nconst float diffuseFactor = 0.73;\n\nstruct LightResult {\n  float specular;\n  float diffuse;\n};\n\nfloat _phongSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n\n  vec3 R = reflect(lightDirection, surfaceNormal);\n  return pow(max(0.0, dot(R, viewDirection)), shininess);\n}\n\nfloat _lambertDiffuse(vec3 lightDirection, vec3 surfaceNormal) {\n  return max(0.0, dot(-lightDirection, surfaceNormal));\n}\n\nLightResult _light(vec3 viewDirection, vec3 normal, vec3 lightVector) {\n\n  vec3 lightDir = normalize(lightVector);\n\n  //compute our diffuse & specular terms\n  LightResult lr;\n  if (uSpecular)\n    lr.specular = _phongSpecular(lightDir, viewDirection, normal, uShininess);\n  lr.diffuse = _lambertDiffuse(lightDir, normal);\n  return lr;\n}\n\nvoid totalLight(\n  vec3 modelPosition,\n  vec3 normal,\n  out vec3 totalDiffuse,\n  out vec3 totalSpecular\n) {\n\n  totalSpecular = vec3(0.0);\n\n  if (!uUseLighting) {\n    totalDiffuse = vec3(1.0);\n    return;\n  }\n\n  totalDiffuse = vec3(0.0);\n\n  vec3 viewDirection = normalize(-modelPosition);\n\n  for (int j = 0; j < 5; j++) {\n    if (j < uDirectionalLightCount) {\n      vec3 lightVector = (uViewMatrix * vec4(uLightingDirection[j], 0.0)).xyz;\n      vec3 lightColor = uDirectionalDiffuseColors[j];\n      vec3 specularColor = uDirectionalSpecularColors[j];\n      LightResult result = _light(viewDirection, normal, lightVector);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if (j < uPointLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uPointLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n    \n      //calculate attenuation\n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n      vec3 lightColor = lightFalloff * uPointLightDiffuseColors[j];\n      vec3 specularColor = lightFalloff * uPointLightSpecularColors[j];\n\n      LightResult result = _light(viewDirection, normal, lightVector);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if(j < uSpotLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uSpotLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n    \n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n\n      vec3 lightDirection = (uViewMatrix * vec4(uSpotLightDirection[j], 0.0)).xyz;\n      float spotDot = dot(normalize(lightVector), normalize(lightDirection));\n      float spotFalloff;\n      if(spotDot < uSpotLightAngle[j]) {\n        spotFalloff = 0.0;\n      }\n      else {\n        spotFalloff = pow(spotDot, uSpotLightConc[j]);\n      }\n      lightFalloff *= spotFalloff;\n\n      vec3 lightColor = uSpotLightDiffuseColors[j];\n      vec3 specularColor = uSpotLightSpecularColors[j];\n     \n      LightResult result = _light(viewDirection, normal, lightVector);\n      \n      totalDiffuse += result.diffuse * lightColor * lightFalloff;\n      totalSpecular += result.specular * lightColor * specularColor * lightFalloff;\n    }\n  }\n\n  totalDiffuse *= diffuseFactor;\n  totalSpecular *= specularFactor;\n}\n",c={immediateVert:"attribute vec3 aPosition;\nattribute vec4 aVertexColor;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uResolution;\nuniform float uPointSize;\n\nvarying vec4 vColor;\nvoid main(void) {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vColor = aVertexColor;\n  gl_PointSize = uPointSize;\n}\n",vertexColorVert:"attribute vec3 aPosition;\nattribute vec4 aVertexColor;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vColor = aVertexColor;\n}\n",vertexColorFrag:"precision mediump float;\nvarying vec4 vColor;\nvoid main(void) {\n  gl_FragColor = vColor;\n}",normalVert:"attribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nvarying vec3 vVertexNormal;\nvarying highp vec2 vVertTexCoord;\n\nvoid main(void) {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vVertexNormal = normalize(vec3( uNormalMatrix * aNormal ));\n  vVertTexCoord = aTexCoord;\n}\n",normalFrag:"precision mediump float;\nvarying vec3 vVertexNormal;\nvoid main(void) {\n  gl_FragColor = vec4(vVertexNormal, 1.0);\n}",basicFrag:"precision mediump float;\nuniform vec4 uMaterialColor;\nvoid main(void) {\n  gl_FragColor = uMaterialColor;\n}",lightVert:u+"// include lighting.glgl\n\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nvarying highp vec2 vVertTexCoord;\nvarying vec3 vDiffuseColor;\nvarying vec3 vSpecularColor;\n\nvoid main(void) {\n\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * viewModelPosition;\n\n  vec3 vertexNormal = normalize(uNormalMatrix * aNormal);\n  vVertTexCoord = aTexCoord;\n\n  totalLight(viewModelPosition.xyz, vertexNormal, vDiffuseColor, vSpecularColor);\n\n  for (int i = 0; i < 8; i++) {\n    if (i < uAmbientLightCount) {\n      vDiffuseColor += uAmbientColor[i];\n    }\n  }\n}\n",lightTextureFrag:"precision highp float;\n\nuniform vec4 uMaterialColor;\nuniform vec4 uTint;\nuniform sampler2D uSampler;\nuniform bool isTexture;\nuniform bool uEmissive;\n\nvarying highp vec2 vVertTexCoord;\nvarying vec3 vDiffuseColor;\nvarying vec3 vSpecularColor;\n\nvoid main(void) {\n  if(uEmissive && !isTexture) {\n    gl_FragColor = uMaterialColor;\n  }\n  else {\n    gl_FragColor = isTexture ? texture2D(uSampler, vVertTexCoord) * (uTint / vec4(255, 255, 255, 255)) : uMaterialColor;\n    gl_FragColor.rgb = gl_FragColor.rgb * vDiffuseColor + vSpecularColor;\n  }\n}",phongVert:"precision highp float;\nprecision highp int;\n\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nuniform vec3 uAmbientColor[5];\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform int uAmbientLightCount;\n\nvarying vec3 vNormal;\nvarying vec2 vTexCoord;\nvarying vec3 vViewPosition;\nvarying vec3 vAmbientColor;\n\nvoid main(void) {\n\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n\n  // Pass varyings to fragment shader\n  vViewPosition = viewModelPosition.xyz;\n  gl_Position = uProjectionMatrix * viewModelPosition;  \n\n  vNormal = uNormalMatrix * aNormal;\n  vTexCoord = aTexCoord;\n\n  // TODO: this should be a uniform\n  vAmbientColor = vec3(0.0);\n  for (int i = 0; i < 5; i++) {\n    if (i < uAmbientLightCount) {\n      vAmbientColor += uAmbientColor[i];\n    }\n  }\n}\n",phongFrag:u+"// include lighting.glsl\nprecision highp float;\nprecision highp int;\n\nuniform vec4 uMaterialColor;\nuniform vec4 uTint;\nuniform sampler2D uSampler;\nuniform bool isTexture;\nuniform bool uEmissive;\n\nvarying vec3 vNormal;\nvarying vec2 vTexCoord;\nvarying vec3 vViewPosition;\nvarying vec3 vAmbientColor;\n\nvoid main(void) {\n\n  vec3 diffuse;\n  vec3 specular;\n  totalLight(vViewPosition, normalize(vNormal), diffuse, specular);\n\n  if(uEmissive && !isTexture) {\n    gl_FragColor = uMaterialColor;\n  }\n  else {\n    gl_FragColor = isTexture ? texture2D(uSampler, vTexCoord) * (uTint / vec4(255, 255, 255, 255)) : uMaterialColor;\n    gl_FragColor.rgb = gl_FragColor.rgb * (diffuse + vAmbientColor) + specular;\n  }\n}",fontVert:"precision mediump float;\n\nattribute vec3 aPosition;\nattribute vec2 aTexCoord;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nuniform vec4 uGlyphRect;\nuniform float uGlyphOffset;\n\nvarying vec2 vTexCoord;\nvarying float w;\n\nvoid main() {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n\n  // scale by the size of the glyph's rectangle\n  positionVec4.xy *= uGlyphRect.zw - uGlyphRect.xy;\n\n  // move to the corner of the glyph\n  positionVec4.xy += uGlyphRect.xy;\n\n  // move to the letter's line offset\n  positionVec4.x += uGlyphOffset;\n  \n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vTexCoord = aTexCoord;\n  w = gl_Position.w;\n}\n",fontFrag:"#extension GL_OES_standard_derivatives : enable\nprecision mediump float;\n\n#if 0\n  // simulate integer math using floats\n\t#define int float\n\t#define ivec2 vec2\n\t#define INT(x) float(x)\n\n\tint ifloor(float v) { return floor(v); }\n\tivec2 ifloor(vec2 v) { return floor(v); }\n\n#else\n  // use native integer math\n\tprecision highp int;\n\t#define INT(x) x\n\n\tint ifloor(float v) { return int(v); }\n\tint ifloor(int v) { return v; }\n\tivec2 ifloor(vec2 v) { return ivec2(v); }\n\n#endif\n\nuniform sampler2D uSamplerStrokes;\nuniform sampler2D uSamplerRowStrokes;\nuniform sampler2D uSamplerRows;\nuniform sampler2D uSamplerColStrokes;\nuniform sampler2D uSamplerCols;\n\nuniform ivec2 uStrokeImageSize;\nuniform ivec2 uCellsImageSize;\nuniform ivec2 uGridImageSize;\n\nuniform ivec2 uGridOffset;\nuniform ivec2 uGridSize;\nuniform vec4 uMaterialColor;\n\nvarying vec2 vTexCoord;\n\n// some helper functions\nint round(float v) { return ifloor(v + 0.5); }\nivec2 round(vec2 v) { return ifloor(v + 0.5); }\nfloat saturate(float v) { return clamp(v, 0.0, 1.0); }\nvec2 saturate(vec2 v) { return clamp(v, 0.0, 1.0); }\n\nint mul(float v1, int v2) {\n  return ifloor(v1 * float(v2));\n}\n\nivec2 mul(vec2 v1, ivec2 v2) {\n  return ifloor(v1 * vec2(v2) + 0.5);\n}\n\n// unpack a 16-bit integer from a float vec2\nint getInt16(vec2 v) {\n  ivec2 iv = round(v * 255.0);\n  return iv.x * INT(128) + iv.y;\n}\n\nvec2 pixelScale;\nvec2 coverage = vec2(0.0);\nvec2 weight = vec2(0.5);\nconst float minDistance = 1.0/8192.0;\nconst float hardness = 1.05; // amount of antialias\n\n// the maximum number of curves in a glyph\nconst int N = INT(250);\n\n// retrieves an indexed pixel from a sampler\nvec4 getTexel(sampler2D sampler, int pos, ivec2 size) {\n  int width = size.x;\n  int y = ifloor(pos / width);\n  int x = pos - y * width;  // pos % width\n\n  return texture2D(sampler, (vec2(x, y) + 0.5) / vec2(size));\n}\n\nvoid calulateCrossings(vec2 p0, vec2 p1, vec2 p2, out vec2 C1, out vec2 C2) {\n\n  // get the coefficients of the quadratic in t\n  vec2 a = p0 - p1 * 2.0 + p2;\n  vec2 b = p0 - p1;\n  vec2 c = p0 - vTexCoord;\n\n  // found out which values of 't' it crosses the axes\n  vec2 surd = sqrt(max(vec2(0.0), b * b - a * c));\n  vec2 t1 = ((b - surd) / a).yx;\n  vec2 t2 = ((b + surd) / a).yx;\n\n  // approximate straight lines to avoid rounding errors\n  if (abs(a.y) < 0.001)\n    t1.x = t2.x = c.y / (2.0 * b.y);\n\n  if (abs(a.x) < 0.001)\n    t1.y = t2.y = c.x / (2.0 * b.x);\n\n  // plug into quadratic formula to find the corrdinates of the crossings\n  C1 = ((a * t1 - b * 2.0) * t1 + c) * pixelScale;\n  C2 = ((a * t2 - b * 2.0) * t2 + c) * pixelScale;\n}\n\nvoid coverageX(vec2 p0, vec2 p1, vec2 p2) {\n\n  vec2 C1, C2;\n  calulateCrossings(p0, p1, p2, C1, C2);\n\n  // determine on which side of the x-axis the points lie\n  bool y0 = p0.y > vTexCoord.y;\n  bool y1 = p1.y > vTexCoord.y;\n  bool y2 = p2.y > vTexCoord.y;\n\n  // could web be under the curve (after t1)?\n  if (y1 ? !y2 : y0) {\n    // add the coverage for t1\n    coverage.x += saturate(C1.x + 0.5);\n    // calculate the anti-aliasing for t1\n    weight.x = min(weight.x, abs(C1.x));\n  }\n\n  // are we outside the curve (after t2)?\n  if (y1 ? !y0 : y2) {\n    // subtract the coverage for t2\n    coverage.x -= saturate(C2.x + 0.5);\n    // calculate the anti-aliasing for t2\n    weight.x = min(weight.x, abs(C2.x));\n  }\n}\n\n// this is essentially the same as coverageX, but with the axes swapped\nvoid coverageY(vec2 p0, vec2 p1, vec2 p2) {\n\n  vec2 C1, C2;\n  calulateCrossings(p0, p1, p2, C1, C2);\n\n  bool x0 = p0.x > vTexCoord.x;\n  bool x1 = p1.x > vTexCoord.x;\n  bool x2 = p2.x > vTexCoord.x;\n\n  if (x1 ? !x2 : x0) {\n    coverage.y -= saturate(C1.y + 0.5);\n    weight.y = min(weight.y, abs(C1.y));\n  }\n\n  if (x1 ? !x0 : x2) {\n    coverage.y += saturate(C2.y + 0.5);\n    weight.y = min(weight.y, abs(C2.y));\n  }\n}\n\nvoid main() {\n\n  // calculate the pixel scale based on screen-coordinates\n  pixelScale = hardness / fwidth(vTexCoord);\n\n  // which grid cell is this pixel in?\n  ivec2 gridCoord = ifloor(vTexCoord * vec2(uGridSize));\n\n  // intersect curves in this row\n  {\n    // the index into the row info bitmap\n    int rowIndex = gridCoord.y + uGridOffset.y;\n    // fetch the info texel\n    vec4 rowInfo = getTexel(uSamplerRows, rowIndex, uGridImageSize);\n    // unpack the rowInfo\n    int rowStrokeIndex = getInt16(rowInfo.xy);\n    int rowStrokeCount = getInt16(rowInfo.zw);\n\n    for (int iRowStroke = INT(0); iRowStroke < N; iRowStroke++) {\n      if (iRowStroke >= rowStrokeCount)\n        break;\n\n      // each stroke is made up of 3 points: the start and control point\n      // and the start of the next curve.\n      // fetch the indices of this pair of strokes:\n      vec4 strokeIndices = getTexel(uSamplerRowStrokes, rowStrokeIndex++, uCellsImageSize);\n\n      // unpack the stroke index\n      int strokePos = getInt16(strokeIndices.xy);\n\n      // fetch the two strokes\n      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);\n      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);\n\n      // calculate the coverage\n      coverageX(stroke0.xy, stroke0.zw, stroke1.xy);\n    }\n  }\n\n  // intersect curves in this column\n  {\n    int colIndex = gridCoord.x + uGridOffset.x;\n    vec4 colInfo = getTexel(uSamplerCols, colIndex, uGridImageSize);\n    int colStrokeIndex = getInt16(colInfo.xy);\n    int colStrokeCount = getInt16(colInfo.zw);\n    \n    for (int iColStroke = INT(0); iColStroke < N; iColStroke++) {\n      if (iColStroke >= colStrokeCount)\n        break;\n\n      vec4 strokeIndices = getTexel(uSamplerColStrokes, colStrokeIndex++, uCellsImageSize);\n\n      int strokePos = getInt16(strokeIndices.xy);\n      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);\n      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);\n      coverageY(stroke0.xy, stroke0.zw, stroke1.xy);\n    }\n  }\n\n  weight = saturate(1.0 - weight * 2.0);\n  float distance = max(weight.x + weight.y, minDistance); // manhattan approx.\n  float antialias = abs(dot(coverage, weight) / distance);\n  float cover = min(abs(coverage.x), abs(coverage.y));\n  gl_FragColor = uMaterialColor;\n  gl_FragColor.a *= saturate(max(antialias, cover));\n}",lineVert:"/*\n  Part of the Processing project - http://processing.org\n  Copyright (c) 2012-15 The Processing Foundation\n  Copyright (c) 2004-12 Ben Fry and Casey Reas\n  Copyright (c) 2001-04 Massachusetts Institute of Technology\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation, version 2.1.\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n  You should have received a copy of the GNU Lesser General\n  Public License along with this library; if not, write to the\n  Free Software Foundation, Inc., 59 Temple Place, Suite 330,\n  Boston, MA  02111-1307  USA\n*/\n\n#define PROCESSING_LINE_SHADER\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uStrokeWeight;\n\nuniform vec4 uViewport;\nuniform int uPerspective;\n\nattribute vec4 aPosition;\nattribute vec4 aDirection;\n  \nvoid main() {\n  // using a scale <1 moves the lines towards the camera\n  // in order to prevent popping effects due to half of\n  // the line disappearing behind the geometry faces.\n  vec3 scale = vec3(0.9995);\n\n  vec4 posp = uModelViewMatrix * aPosition;\n  vec4 posq = uModelViewMatrix * (aPosition + vec4(aDirection.xyz, 0));\n\n  // Moving vertices slightly toward the camera\n  // to avoid depth-fighting with the fill triangles.\n  // Discussed here:\n  // http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&Number=252848  \n  posp.xyz = posp.xyz * scale;\n  posq.xyz = posq.xyz * scale;\n\n  vec4 p = uProjectionMatrix * posp;\n  vec4 q = uProjectionMatrix * posq;\n\n  // formula to convert from clip space (range -1..1) to screen space (range 0..[width or height])\n  // screen_p = (p.xy/p.w + <1,1>) * 0.5 * uViewport.zw\n\n  // prevent division by W by transforming the tangent formula (div by 0 causes\n  // the line to disappear, see https://github.com/processing/processing/issues/5183)\n  // t = screen_q - screen_p\n  //\n  // tangent is normalized and we don't care which aDirection it points to (+-)\n  // t = +- normalize( screen_q - screen_p )\n  // t = +- normalize( (q.xy/q.w+<1,1>)*0.5*uViewport.zw - (p.xy/p.w+<1,1>)*0.5*uViewport.zw )\n  //\n  // extract common factor, <1,1> - <1,1> cancels out\n  // t = +- normalize( (q.xy/q.w - p.xy/p.w) * 0.5 * uViewport.zw )\n  //\n  // convert to common divisor\n  // t = +- normalize( ((q.xy*p.w - p.xy*q.w) / (p.w*q.w)) * 0.5 * uViewport.zw )\n  //\n  // remove the common scalar divisor/factor, not needed due to normalize and +-\n  // (keep uViewport - can't remove because it has different components for x and y\n  //  and corrects for aspect ratio, see https://github.com/processing/processing/issues/5181)\n  // t = +- normalize( (q.xy*p.w - p.xy*q.w) * uViewport.zw )\n\n  vec2 tangent = normalize((q.xy*p.w - p.xy*q.w) * uViewport.zw);\n\n  // flip tangent to normal (it's already normalized)\n  vec2 normal = vec2(-tangent.y, tangent.x);\n\n  float thickness = aDirection.w * uStrokeWeight;\n  vec2 offset = normal * thickness / 2.0;\n\n  vec2 curPerspScale;\n\n  if(uPerspective == 1) {\n    // Perspective ---\n    // convert from world to clip by multiplying with projection scaling factor\n    // to get the right thickness (see https://github.com/processing/processing/issues/5182)\n    // invert Y, projections in Processing invert Y\n    curPerspScale = (uProjectionMatrix * vec4(1, -1, 0, 0)).xy;\n  } else {\n    // No Perspective ---\n    // multiply by W (to cancel out division by W later in the pipeline) and\n    // convert from screen to clip (derived from clip to screen above)\n    curPerspScale = p.w / (0.5 * uViewport.zw);\n  }\n\n  gl_Position.xy = p.xy + offset.xy * curPerspScale;\n  gl_Position.zw = p.zw;\n}\n",lineFrag:"precision mediump float;\nprecision mediump int;\n\nuniform vec4 uMaterialColor;\n\nvoid main() {\n  gl_FragColor = uMaterialColor;\n}",pointVert:"attribute vec3 aPosition;\nuniform float uPointSize;\nvarying float vStrokeWeight;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nvoid main() {\n\tvec4 positionVec4 =  vec4(aPosition, 1.0);\n\tgl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n\tgl_PointSize = uPointSize;\n\tvStrokeWeight = uPointSize;\n}",pointFrag:"precision mediump float;\nprecision mediump int;\nuniform vec4 uMaterialColor;\nvarying float vStrokeWeight;\n\nvoid main(){\n\tfloat mask = 0.0;\n\n\t// make a circular mask using the gl_PointCoord (goes from 0 - 1 on a point)\n    // might be able to get a nicer edge on big strokeweights with smoothstep but slightly less performant\n\n\tmask = step(0.98, length(gl_PointCoord * 2.0 - 1.0));\n\n\t// if strokeWeight is 1 or less lets just draw a square\n\t// this prevents weird artifacting from carving circles when our points are really small\n\t// if strokeWeight is larger than 1, we just use it as is\n\n\tmask = mix(0.0, mask, clamp(floor(vStrokeWeight - 0.5),0.0,1.0));\n\n\t// throw away the borders of the mask\n    // otherwise we get weird alpha blending issues\n\n\tif(mask > 0.98){\n      discard;\n  \t}\n\n  \tgl_FragColor = vec4(uMaterialColor.rgb * (1.0 - mask), uMaterialColor.a) ;\n}"};p.default.RendererGL=function(e,t,r,n){return p.default.Renderer.call(this,e,t,r),this._setAttributeDefaults(t),this._initContext(),this.isP3D=!0,this.GL=this.drawingContext,this._pInst._setProperty("drawingContext",this.drawingContext),this._isErasing=!1,this._enableLighting=!1,this.ambientLightColors=[],this.specularColors=[1,1,1],this.directionalLightDirections=[],this.directionalLightDiffuseColors=[],this.directionalLightSpecularColors=[],this.pointLightPositions=[],this.pointLightDiffuseColors=[],this.pointLightSpecularColors=[],this.spotLightPositions=[],this.spotLightDirections=[],this.spotLightDiffuseColors=[],this.spotLightSpecularColors=[],this.spotLightAngle=[],this.spotLightConc=[],this.drawMode=o.FILL,this.curFillColor=this._cachedFillStyle=[1,1,1,1],this.curStrokeColor=this._cachedStrokeStyle=[0,0,0,1],this.curBlendMode=o.BLEND,this._cachedBlendMode=void 0,this.blendExt=this.GL.getExtension("EXT_blend_minmax"),this._isBlending=!1,this._useSpecularMaterial=!1,this._useEmissiveMaterial=!1,this._useNormalMaterial=!1,this._useShininess=1,this._tint=[255,255,255,255],this.constantAttenuation=1,this.linearAttenuation=0,this.quadraticAttenuation=0,this.uMVMatrix=new p.default.Matrix,this.uPMatrix=new p.default.Matrix,this.uNMatrix=new p.default.Matrix("mat3"),this._curCamera=new p.default.Camera(this),this._curCamera._computeCameraDefaultSettings(),this._curCamera._setDefaultCamera(),this._defaultLightShader=void 0,this._defaultImmediateModeShader=void 0,this._defaultNormalShader=void 0,this._defaultColorShader=void 0,this._defaultPointShader=void 0,this.userFillShader=void 0,this.userStrokeShader=void 0,this.userPointShader=void 0,this.retainedMode={geometry:{},buffers:{stroke:[new p.default.RenderBuffer(3,"lineVertices","lineVertexBuffer","aPosition",this,this._flatten),new p.default.RenderBuffer(4,"lineNormals","lineNormalBuffer","aDirection",this,this._flatten)],fill:[new p.default.RenderBuffer(3,"vertices","vertexBuffer","aPosition",this,this._vToNArray),new p.default.RenderBuffer(3,"vertexNormals","normalBuffer","aNormal",this,this._vToNArray),new p.default.RenderBuffer(4,"vertexColors","colorBuffer","aMaterialColor",this),new p.default.RenderBuffer(3,"vertexAmbients","ambientBuffer","aAmbientColor",this),new p.default.RenderBuffer(2,"uvs","uvBuffer","aTexCoord",this,this._flatten)],text:[new p.default.RenderBuffer(3,"vertices","vertexBuffer","aPosition",this,this._vToNArray),new p.default.RenderBuffer(2,"uvs","uvBuffer","aTexCoord",this,this._flatten)]}},this.immediateMode={geometry:new p.default.Geometry,shapeMode:o.TRIANGLE_FAN,_bezierVertex:[],_quadraticVertex:[],_curveVertex:[],buffers:{fill:[new p.default.RenderBuffer(3,"vertices","vertexBuffer","aPosition",this,this._vToNArray),new p.default.RenderBuffer(3,"vertexNormals","normalBuffer","aNormal",this,this._vToNArray),new p.default.RenderBuffer(4,"vertexColors","colorBuffer","aVertexColor",this),new p.default.RenderBuffer(3,"vertexAmbients","ambientBuffer","aAmbientColor",this),new p.default.RenderBuffer(2,"uvs","uvBuffer","aTexCoord",this,this._flatten)],stroke:[new p.default.RenderBuffer(3,"lineVertices","lineVertexBuffer","aPosition",this,this._flatten),new p.default.RenderBuffer(4,"lineNormals","lineNormalBuffer","aDirection",this,this._flatten)],point:this.GL.createBuffer()}},this.pointSize=5,this.curStrokeWeight=1,this.textures=[],this.textureMode=o.IMAGE,this.textureWrapX=o.CLAMP,this.textureWrapY=o.CLAMP,this._tex=null,this._curveTightness=6,this._lookUpTableBezier=[],this._lookUpTableQuadratic=[],this._lutBezierDetail=0,this._lutQuadraticDetail=0,this._tessy=this._initTessy(),this.fontInfos={},this._curShader=void 0,this},p.default.RendererGL.prototype=Object.create(p.default.Renderer.prototype),p.default.RendererGL.prototype._setAttributeDefaults=function(e){var t={alpha:!0,depth:!0,stencil:!0,antialias:navigator.userAgent.toLowerCase().includes("safari"),premultipliedAlpha:!1,preserveDrawingBuffer:!0,perPixelLighting:!0};null===e._glAttributes?e._glAttributes=t:e._glAttributes=Object.assign(t,e._glAttributes);},p.default.RendererGL.prototype._initContext=function(){try{if(this.drawingContext=this.canvas.getContext("webgl",this._pInst._glAttributes)||this.canvas.getContext("experimental-webgl",this._pInst._glAttributes),null===this.drawingContext)throw new Error("Error creating webgl context");var e=this.drawingContext;e.enable(e.DEPTH_TEST),e.depthFunc(e.LEQUAL),e.viewport(0,0,e.drawingBufferWidth,e.drawingBufferHeight),this._viewport=this.drawingContext.getParameter(this.drawingContext.VIEWPORT);}catch(e){throw e}},p.default.RendererGL.prototype._resetContext=function(e,t){var r=this.width,n=this.height,a=this.canvas.id,o=this._pInst instanceof p.default.Graphics;if(o){var i=this._pInst;i.canvas.parentNode.removeChild(i.canvas),i.canvas=document.createElement("canvas"),(i._pInst._userNode||document.body).appendChild(i.canvas),p.default.Element.call(i,i.canvas,i._pInst),i.width=r,i.height=n;}else {var s=this.canvas;s&&s.parentNode.removeChild(s),(s=document.createElement("canvas")).id=a,this._pInst._userNode?this._pInst._userNode.appendChild(s):document.body.appendChild(s),this._pInst.canvas=s;}var l=new p.default.RendererGL(this._pInst.canvas,this._pInst,!o);this._pInst._setProperty("_renderer",l),l.resize(r,n),l._applyDefaults(),o||this._pInst._elements.push(l),"function"==typeof t&&setTimeout(function(){t.apply(window._renderer,e);},0);},p.default.prototype.setAttributes=function(e,t){if(void 0!==this._glAttributes){var r=!0;if(void 0!==t?(null===this._glAttributes&&(this._glAttributes={}),this._glAttributes[e]!==t&&(this._glAttributes[e]=t,r=!1)):e instanceof Object&&this._glAttributes!==e&&(this._glAttributes=e,r=!1),this._renderer.isP3D&&!r){if(!this._setupDone)for(var n in this._renderer.retainedMode.geometry)if(this._renderer.retainedMode.geometry.hasOwnProperty(n))return void console.error("Sorry, Could not set the attributes, you need to call setAttributes() before calling the other drawing methods in setup()");this.push(),this._renderer._resetContext(),this.pop(),this._renderer._curCamera&&(this._renderer._curCamera._renderer=this._renderer);}}else console.log("You are trying to use setAttributes on a p5.Graphics object that does not use a WEBGL renderer.");},p.default.RendererGL.prototype._update=function(){this.uMVMatrix.set(this._curCamera.cameraMatrix.mat4[0],this._curCamera.cameraMatrix.mat4[1],this._curCamera.cameraMatrix.mat4[2],this._curCamera.cameraMatrix.mat4[3],this._curCamera.cameraMatrix.mat4[4],this._curCamera.cameraMatrix.mat4[5],this._curCamera.cameraMatrix.mat4[6],this._curCamera.cameraMatrix.mat4[7],this._curCamera.cameraMatrix.mat4[8],this._curCamera.cameraMatrix.mat4[9],this._curCamera.cameraMatrix.mat4[10],this._curCamera.cameraMatrix.mat4[11],this._curCamera.cameraMatrix.mat4[12],this._curCamera.cameraMatrix.mat4[13],this._curCamera.cameraMatrix.mat4[14],this._curCamera.cameraMatrix.mat4[15]),this.ambientLightColors.length=0,this.specularColors=[1,1,1],this.directionalLightDirections.length=0,this.directionalLightDiffuseColors.length=0,this.directionalLightSpecularColors.length=0,this.pointLightPositions.length=0,this.pointLightDiffuseColors.length=0,this.pointLightSpecularColors.length=0,this.spotLightPositions.length=0,this.spotLightDirections.length=0,this.spotLightDiffuseColors.length=0,this.spotLightSpecularColors.length=0,this.spotLightAngle.length=0,this.spotLightConc.length=0,this._enableLighting=!1,this._tint=[255,255,255,255],this.GL.clear(this.GL.DEPTH_BUFFER_BIT);},p.default.RendererGL.prototype.background=function(){var e,t=(e=this._pInst).color.apply(e,arguments),r=t.levels[0]/255,n=t.levels[1]/255,a=t.levels[2]/255,o=t.levels[3]/255;this.GL.clearColor(r,n,a,o),this.GL.clear(this.GL.COLOR_BUFFER_BIT);},p.default.RendererGL.prototype.fill=function(e,t,r,n){var a=p.default.prototype.color.apply(this._pInst,arguments);this.curFillColor=a._array,this.drawMode=o.FILL,this._useNormalMaterial=!1,this._tex=null;},p.default.RendererGL.prototype.stroke=function(e,t,r,n){arguments[3]=255;var a=p.default.prototype.color.apply(this._pInst,arguments);this.curStrokeColor=a._array;},p.default.RendererGL.prototype.strokeCap=function(e){console.error("Sorry, strokeCap() is not yet implemented in WEBGL mode");},p.default.RendererGL.prototype.strokeJoin=function(e){console.error("Sorry, strokeJoin() is not yet implemented in WEBGL mode");},p.default.RendererGL.prototype.filter=function(e){console.error("filter() does not work in WEBGL mode");},p.default.RendererGL.prototype.blendMode=function(e){e===o.DARKEST||e===o.LIGHTEST||e===o.ADD||e===o.BLEND||e===o.SUBTRACT||e===o.SCREEN||e===o.EXCLUSION||e===o.REPLACE||e===o.MULTIPLY||e===o.REMOVE?this.curBlendMode=e:e!==o.BURN&&e!==o.OVERLAY&&e!==o.HARD_LIGHT&&e!==o.SOFT_LIGHT&&e!==o.DODGE||console.warn("BURN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, and DODGE only work for blendMode in 2D mode.");},p.default.RendererGL.prototype.erase=function(e,t){this._isErasing||(this._applyBlendMode(o.REMOVE),this._isErasing=!0,this._cachedFillStyle=this.curFillColor.slice(),this.curFillColor=[1,1,1,e/255],this._cachedStrokeStyle=this.curStrokeColor.slice(),this.curStrokeColor=[1,1,1,t/255]);},p.default.RendererGL.prototype.noErase=function(){this._isErasing&&(this._isErasing=!1,this.curFillColor=this._cachedFillStyle.slice(),this.curStrokeColor=this._cachedStrokeStyle.slice(),this.blendMode(this._cachedBlendMode));},p.default.RendererGL.prototype.strokeWeight=function(e){this.curStrokeWeight!==e&&(this.pointSize=e,this.curStrokeWeight=e);},p.default.RendererGL.prototype._getPixel=function(e,t){var r;return r=new Uint8Array(4),this.drawingContext.readPixels(e,t,1,1,this.drawingContext.RGBA,this.drawingContext.UNSIGNED_BYTE,r),[r[0],r[1],r[2],r[3]]},p.default.RendererGL.prototype.loadPixels=function(){var e=this._pixelsState;if(!0===this._pInst._glAttributes.preserveDrawingBuffer){var t=e.pixels,r=this.GL.drawingBufferWidth*this.GL.drawingBufferHeight*4;t instanceof Uint8Array&&t.length===r||(t=new Uint8Array(r),this._pixelsState._setProperty("pixels",t));var n=this._pInst._pixelDensity;this.GL.readPixels(0,0,this.width*n,this.height*n,this.GL.RGBA,this.GL.UNSIGNED_BYTE,t);}else console.log("loadPixels only works in WebGL when preserveDrawingBuffer is true.");},p.default.RendererGL.prototype.geometryInHash=function(e){return void 0!==this.retainedMode.geometry[e]},p.default.RendererGL.prototype.resize=function(e,t){p.default.Renderer.prototype.resize.call(this,e,t),this.GL.viewport(0,0,this.GL.drawingBufferWidth,this.GL.drawingBufferHeight),this._viewport=this.GL.getParameter(this.GL.VIEWPORT),this._curCamera._resize();var r=this._pixelsState;void 0!==r.pixels&&r._setProperty("pixels",new Uint8Array(this.GL.drawingBufferWidth*this.GL.drawingBufferHeight*4));},p.default.RendererGL.prototype.clear=function(){var e=(arguments.length<=0?void 0:arguments[0])||0,t=(arguments.length<=1?void 0:arguments[1])||0,r=(arguments.length<=2?void 0:arguments[2])||0,n=(arguments.length<=3?void 0:arguments[3])||0;this.GL.clearColor(e,t,r,n),this.GL.clear(this.GL.COLOR_BUFFER_BIT|this.GL.DEPTH_BUFFER_BIT);},p.default.RendererGL.prototype.applyMatrix=function(e,t,r,n,a,o){16===arguments.length?p.default.Matrix.prototype.apply.apply(this.uMVMatrix,arguments):this.uMVMatrix.apply([e,t,0,0,r,n,0,0,0,0,1,0,a,o,0,1]);},p.default.RendererGL.prototype.translate=function(e,t,r){return e instanceof p.default.Vector&&(r=e.z,t=e.y,e=e.x),this.uMVMatrix.translate([e,t,r]),this},p.default.RendererGL.prototype.scale=function(e,t,r){return this.uMVMatrix.scale(e,t,r),this},p.default.RendererGL.prototype.rotate=function(e,t){return void 0===t?this.rotateZ(e):(p.default.Matrix.prototype.rotate.apply(this.uMVMatrix,arguments),this)},p.default.RendererGL.prototype.rotateX=function(e){return this.rotate(e,1,0,0),this},p.default.RendererGL.prototype.rotateY=function(e){return this.rotate(e,0,1,0),this},p.default.RendererGL.prototype.rotateZ=function(e){return this.rotate(e,0,0,1),this},p.default.RendererGL.prototype.push=function(){var e=p.default.Renderer.prototype.push.apply(this),t=e.properties;return t.uMVMatrix=this.uMVMatrix.copy(),t.uPMatrix=this.uPMatrix.copy(),t._curCamera=this._curCamera,this._curCamera=this._curCamera.copy(),t.ambientLightColors=this.ambientLightColors.slice(),t.specularColors=this.specularColors.slice(),t.directionalLightDirections=this.directionalLightDirections.slice(),t.directionalLightDiffuseColors=this.directionalLightDiffuseColors.slice(),t.directionalLightSpecularColors=this.directionalLightSpecularColors.slice(),t.pointLightPositions=this.pointLightPositions.slice(),t.pointLightDiffuseColors=this.pointLightDiffuseColors.slice(),t.pointLightSpecularColors=this.pointLightSpecularColors.slice(),t.spotLightPositions=this.spotLightPositions.slice(),t.spotLightDirections=this.spotLightDirections.slice(),t.spotLightDiffuseColors=this.spotLightDiffuseColors.slice(),t.spotLightSpecularColors=this.spotLightSpecularColors.slice(),t.spotLightAngle=this.spotLightAngle.slice(),t.spotLightConc=this.spotLightConc.slice(),t.userFillShader=this.userFillShader,t.userStrokeShader=this.userStrokeShader,t.userPointShader=this.userPointShader,t.pointSize=this.pointSize,t.curStrokeWeight=this.curStrokeWeight,t.curStrokeColor=this.curStrokeColor,t.curFillColor=this.curFillColor,t._useSpecularMaterial=this._useSpecularMaterial,t._useEmissiveMaterial=this._useEmissiveMaterial,t._useShininess=this._useShininess,t.constantAttenuation=this.constantAttenuation,t.linearAttenuation=this.linearAttenuation,t.quadraticAttenuation=this.quadraticAttenuation,t._enableLighting=this._enableLighting,t._useNormalMaterial=this._useNormalMaterial,t._tex=this._tex,t.drawMode=this.drawMode,e},p.default.RendererGL.prototype.resetMatrix=function(){return this.uMVMatrix=p.default.Matrix.identity(this._pInst),this},p.default.RendererGL.prototype._getImmediateStrokeShader=function(){var e=this.userStrokeShader;return e&&e.isStrokeShader()?e:this._getLineShader()},p.default.RendererGL.prototype._getRetainedStrokeShader=p.default.RendererGL.prototype._getImmediateStrokeShader,p.default.RendererGL.prototype._getImmediateFillShader=function(){var e=this.userFillShader;if(this._useNormalMaterial&&(!e||!e.isNormalShader()))return this._getNormalShader();if(this._enableLighting){if(!e||!e.isLightShader())return this._getLightShader()}else if(this._tex){if(!e||!e.isTextureShader())return this._getLightShader()}else if(!e)return this._getImmediateModeShader();return e},p.default.RendererGL.prototype._getRetainedFillShader=function(){if(this._useNormalMaterial)return this._getNormalShader();var e=this.userFillShader;if(this._enableLighting){if(!e||!e.isLightShader())return this._getLightShader()}else if(this._tex){if(!e||!e.isTextureShader())return this._getLightShader()}else if(!e)return this._getColorShader();return e},p.default.RendererGL.prototype._getImmediatePointShader=function(){var e=this.userPointShader;return e&&e.isPointShader()?e:this._getPointShader()},p.default.RendererGL.prototype._getRetainedLineShader=p.default.RendererGL.prototype._getImmediateLineShader,p.default.RendererGL.prototype._getLightShader=function(){return this._defaultLightShader||(this._pInst._glAttributes.perPixelLighting?this._defaultLightShader=new p.default.Shader(this,c.phongVert,c.phongFrag):this._defaultLightShader=new p.default.Shader(this,c.lightVert,c.lightTextureFrag)),this._defaultLightShader},p.default.RendererGL.prototype._getImmediateModeShader=function(){return this._defaultImmediateModeShader||(this._defaultImmediateModeShader=new p.default.Shader(this,c.immediateVert,c.vertexColorFrag)),this._defaultImmediateModeShader},p.default.RendererGL.prototype._getNormalShader=function(){return this._defaultNormalShader||(this._defaultNormalShader=new p.default.Shader(this,c.normalVert,c.normalFrag)),this._defaultNormalShader},p.default.RendererGL.prototype._getColorShader=function(){return this._defaultColorShader||(this._defaultColorShader=new p.default.Shader(this,c.normalVert,c.basicFrag)),this._defaultColorShader},p.default.RendererGL.prototype._getPointShader=function(){return this._defaultPointShader||(this._defaultPointShader=new p.default.Shader(this,c.pointVert,c.pointFrag)),this._defaultPointShader},p.default.RendererGL.prototype._getLineShader=function(){return this._defaultLineShader||(this._defaultLineShader=new p.default.Shader(this,c.lineVert,c.lineFrag)),this._defaultLineShader},p.default.RendererGL.prototype._getFontShader=function(){return this._defaultFontShader||(this.GL.getExtension("OES_standard_derivatives"),this._defaultFontShader=new p.default.Shader(this,c.fontVert,c.fontFrag)),this._defaultFontShader},p.default.RendererGL.prototype._getEmptyTexture=function(){if(!this._emptyTexture){var e=new p.default.Image(1,1);e.set(0,0,255),this._emptyTexture=new p.default.Texture(this,e);}return this._emptyTexture},p.default.RendererGL.prototype.getTexture=function(e){var t=this.textures,r=!0,n=!1,a=void 0;try{for(var o,i=t[Symbol.iterator]();!(r=(o=i.next()).done);r=!0){var s=o.value;if(s.src===e)return s}}catch(e){n=!0,a=e;}finally{try{r||null==i.return||i.return();}finally{if(n)throw a}}var l=new p.default.Texture(this,e);return t.push(l),l},p.default.RendererGL.prototype._setStrokeUniforms=function(e){e.bindShader(),e.setUniform("uMaterialColor",this.curStrokeColor),e.setUniform("uStrokeWeight",this.curStrokeWeight);},p.default.RendererGL.prototype._setFillUniforms=function(e){e.bindShader(),e.setUniform("uMaterialColor",this.curFillColor),e.setUniform("isTexture",!!this._tex),this._tex&&e.setUniform("uSampler",this._tex),e.setUniform("uTint",this._tint),e.setUniform("uSpecular",this._useSpecularMaterial),e.setUniform("uEmissive",this._useEmissiveMaterial),e.setUniform("uShininess",this._useShininess),e.setUniform("uUseLighting",this._enableLighting);var t=this.pointLightDiffuseColors.length/3;e.setUniform("uPointLightCount",t),e.setUniform("uPointLightLocation",this.pointLightPositions),e.setUniform("uPointLightDiffuseColors",this.pointLightDiffuseColors),e.setUniform("uPointLightSpecularColors",this.pointLightSpecularColors);var r=this.directionalLightDiffuseColors.length/3;e.setUniform("uDirectionalLightCount",r),e.setUniform("uLightingDirection",this.directionalLightDirections),e.setUniform("uDirectionalDiffuseColors",this.directionalLightDiffuseColors),e.setUniform("uDirectionalSpecularColors",this.directionalLightSpecularColors);var n=this.ambientLightColors.length/3;e.setUniform("uAmbientLightCount",n),e.setUniform("uAmbientColor",this.ambientLightColors);var a=this.spotLightDiffuseColors.length/3;e.setUniform("uSpotLightCount",a),e.setUniform("uSpotLightAngle",this.spotLightAngle),e.setUniform("uSpotLightConc",this.spotLightConc),e.setUniform("uSpotLightDiffuseColors",this.spotLightDiffuseColors),e.setUniform("uSpotLightSpecularColors",this.spotLightSpecularColors),e.setUniform("uSpotLightLocation",this.spotLightPositions),e.setUniform("uSpotLightDirection",this.spotLightDirections),e.setUniform("uConstantAttenuation",this.constantAttenuation),e.setUniform("uLinearAttenuation",this.linearAttenuation),e.setUniform("uQuadraticAttenuation",this.quadraticAttenuation),e.bindTextures();},p.default.RendererGL.prototype._setPointUniforms=function(e){e.bindShader(),e.setUniform("uMaterialColor",this.curStrokeColor),e.setUniform("uPointSize",this.pointSize);},p.default.RendererGL.prototype._bindBuffer=function(e,t,r,n,a){if(t=t||this.GL.ARRAY_BUFFER,this.GL.bindBuffer(t,e),void 0!==r){var o=new(n||Float32Array)(r);this.GL.bufferData(t,o,a||this.GL.STATIC_DRAW);}},p.default.RendererGL.prototype._arraysEqual=function(e,t){var r=e.length;if(r!==t.length)return !1;for(var n=0;n<r;n++)if(e[n]!==t[n])return !1;return !0},p.default.RendererGL.prototype._isTypedArray=function(e){return e instanceof Uint32Array},p.default.RendererGL.prototype._flatten=function(e){if(0===e.length)return [];if(2e4<e.length){var t,r=Object.prototype.toString,n=[],a=e.slice();for(t=a.pop();"[object Array]"===r.call(t)?a.push.apply(a,l(t)):n.push(t),a.length&&void 0!==(t=a.pop()););return n.reverse(),n}var o;return (o=[]).concat.apply(o,l(e))},p.default.RendererGL.prototype._vToNArray=function(e){var t=[],r=!0,n=!1,a=void 0;try{for(var o,i=e[Symbol.iterator]();!(r=(o=i.next()).done);r=!0){var s=o.value;t.push(s.x,s.y,s.z);}}catch(e){n=!0,a=e;}finally{try{r||null==i.return||i.return();}finally{if(n)throw a}}return t},p.default.prototype._assert3d=function(e){if(!this._renderer.isP3D)throw new Error("".concat(e,"() is only supported in WEBGL mode. If you'd like to use 3D graphics and WebGL, see  https://p5js.org/examples/form-3d-primitives.html for more information."))},p.default.RendererGL.prototype._initTessy=function(){var e=new n.default.GluTesselator;return e.gluTessCallback(n.default.gluEnum.GLU_TESS_VERTEX_DATA,function(e,t){t[t.length]=e[0],t[t.length]=e[1],t[t.length]=e[2];}),e.gluTessCallback(n.default.gluEnum.GLU_TESS_BEGIN,function(e){e!==n.default.primitiveType.GL_TRIANGLES&&console.log("expected TRIANGLES but got type: ".concat(e));}),e.gluTessCallback(n.default.gluEnum.GLU_TESS_ERROR,function(e){console.log("error callback"),console.log("error number: ".concat(e));}),e.gluTessCallback(n.default.gluEnum.GLU_TESS_COMBINE,function(e,t,r){return [e[0],e[1],e[2]]}),e.gluTessCallback(n.default.gluEnum.GLU_TESS_EDGE_FLAG,function(e){}),e},p.default.RendererGL.prototype._triangulate=function(e){this._tessy.gluTessNormal(0,0,1);var t=[];this._tessy.gluTessBeginPolygon(t);for(var r=0;r<e.length;r++){this._tessy.gluTessBeginContour();for(var n=e[r],a=0;a<n.length;a+=3){var o=[n[a],n[a+1],n[a+2]];this._tessy.gluTessVertex(o,o);}this._tessy.gluTessEndContour();}return this._tessy.gluTessEndPolygon(),t},p.default.RendererGL.prototype._bezierCoefficients=function(e){var t=e*e,r=1-e,n=r*r;return [n*r,3*n*e,3*r*t,t*e]},p.default.RendererGL.prototype._quadraticCoefficients=function(e){var t=1-e;return [t*t,2*t*e,e*e]},p.default.RendererGL.prototype._bezierToCatmull=function(e){return [e[1],e[1]+(e[2]-e[0])/this._curveTightness,e[2]-(e[3]-e[1])/this._curveTightness,e[2]]};var d=p.default.RendererGL;r.default=d;},{"../core/constants":22,"../core/main":32,"../core/p5.Renderer":35,"./p5.Camera":80,"./p5.Matrix":82,"./p5.Shader":87,libtess:11,path:14}],87:[function(e,t,r){Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n};a.default.Shader=function(e,t,r){this._renderer=e,this._vertSrc=t,this._fragSrc=r,this._vertShader=-1,this._fragShader=-1,this._glProgram=0,this._loadedAttributes=!1,this.attributes={},this._loadedUniforms=!1,this.uniforms={},this._bound=!1,this.samplers=[];},a.default.Shader.prototype.init=function(){if(0===this._glProgram){var e=this._renderer.GL;if(this._vertShader=e.createShader(e.VERTEX_SHADER),e.shaderSource(this._vertShader,this._vertSrc),e.compileShader(this._vertShader),!e.getShaderParameter(this._vertShader,e.COMPILE_STATUS))return console.error("Yikes! An error occurred compiling the vertex shader:".concat(e.getShaderInfoLog(this._vertShader))),null;if(this._fragShader=e.createShader(e.FRAGMENT_SHADER),e.shaderSource(this._fragShader,this._fragSrc),e.compileShader(this._fragShader),!e.getShaderParameter(this._fragShader,e.COMPILE_STATUS))return console.error("Darn! An error occurred compiling the fragment shader:".concat(e.getShaderInfoLog(this._fragShader))),null;this._glProgram=e.createProgram(),e.attachShader(this._glProgram,this._vertShader),e.attachShader(this._glProgram,this._fragShader),e.linkProgram(this._glProgram),e.getProgramParameter(this._glProgram,e.LINK_STATUS)||console.error("Snap! Error linking shader program: ".concat(e.getProgramInfoLog(this._glProgram))),this._loadAttributes(),this._loadUniforms();}return this},a.default.Shader.prototype._loadAttributes=function(){if(!this._loadedAttributes){this.attributes={};for(var e=this._renderer.GL,t=e.getProgramParameter(this._glProgram,e.ACTIVE_ATTRIBUTES),r=0;r<t;++r){var n=e.getActiveAttrib(this._glProgram,r),a=n.name,o=e.getAttribLocation(this._glProgram,a),i={};i.name=a,i.location=o,i.index=r,i.type=n.type,i.size=n.size,this.attributes[a]=i;}this._loadedAttributes=!0;}},a.default.Shader.prototype._loadUniforms=function(){if(!this._loadedUniforms){for(var e=this._renderer.GL,t=e.getProgramParameter(this._glProgram,e.ACTIVE_UNIFORMS),r=0,n=0;n<t;++n){var a=e.getActiveUniform(this._glProgram,n),o={};o.location=e.getUniformLocation(this._glProgram,a.name),o.size=a.size;var i=a.name;1<a.size&&(i=i.substring(0,i.indexOf("[0]"))),o.name=i,o.type=a.type,o._cachedData=void 0,o.type===e.SAMPLER_2D&&(o.samplerIndex=r,r++,this.samplers.push(o)),o.isArray=o.type===e.FLOAT_MAT3||o.type===e.FLOAT_MAT4||o.type===e.FLOAT_VEC2||o.type===e.FLOAT_VEC3||o.type===e.FLOAT_VEC4||o.type===e.INT_VEC2||o.type===e.INT_VEC3||o.type===e.INT_VEC4,this.uniforms[i]=o;}this._loadedUniforms=!0;}},a.default.Shader.prototype.compile=function(){},a.default.Shader.prototype.bindShader=function(){this.init(),this._bound||(this.useProgram(),this._bound=!0,this._setMatrixUniforms(),this.setUniform("uViewport",this._renderer._viewport));},a.default.Shader.prototype.unbindShader=function(){return this._bound&&(this.unbindTextures(),this._bound=!1),this},a.default.Shader.prototype.bindTextures=function(){var e=this._renderer.GL,t=!0,r=!1,n=void 0;try{for(var a,o=this.samplers[Symbol.iterator]();!(t=(a=o.next()).done);t=!0){var i=a.value,s=i.texture;void 0===s&&(s=this._renderer._getEmptyTexture()),e.activeTexture(e.TEXTURE0+i.samplerIndex),s.bindTexture(),s.update(),e.uniform1i(i.location,i.samplerIndex);}}catch(e){r=!0,n=e;}finally{try{t||null==o.return||o.return();}finally{if(r)throw n}}},a.default.Shader.prototype.updateTextures=function(){var e=!0,t=!1,r=void 0;try{for(var n,a=this.samplers[Symbol.iterator]();!(e=(n=a.next()).done);e=!0){var o=n.value.texture;o&&o.update();}}catch(e){t=!0,r=e;}finally{try{e||null==a.return||a.return();}finally{if(t)throw r}}},a.default.Shader.prototype.unbindTextures=function(){},a.default.Shader.prototype._setMatrixUniforms=function(){this.setUniform("uProjectionMatrix",this._renderer.uPMatrix.mat4),this.isStrokeShader()&&("default"===this._renderer._curCamera.cameraType?this.setUniform("uPerspective",1):this.setUniform("uPerspective",0)),this.setUniform("uModelViewMatrix",this._renderer.uMVMatrix.mat4),this.setUniform("uViewMatrix",this._renderer._curCamera.cameraMatrix.mat4),this.uniforms.uNormalMatrix&&(this._renderer.uNMatrix.inverseTranspose(this._renderer.uMVMatrix),this.setUniform("uNormalMatrix",this._renderer.uNMatrix.mat3));},a.default.Shader.prototype.useProgram=function(){var e=this._renderer.GL;return this._renderer._curShader!==this&&(e.useProgram(this._glProgram),this._renderer._curShader=this),this},a.default.Shader.prototype.setUniform=function(e,t){var r=this.uniforms[e];if(r){var n=this._renderer.GL;if(r.isArray){if(r._cachedData&&this._renderer._arraysEqual(r._cachedData,t))return;r._cachedData=t.slice(0);}else {if(r._cachedData&&r._cachedData===t)return;r._cachedData=t;}var a=r.location;switch(this.useProgram(),r.type){case n.BOOL:!0===t?n.uniform1i(a,1):n.uniform1i(a,0);break;case n.INT:1<r.size?t.length&&n.uniform1iv(a,t):n.uniform1i(a,t);break;case n.FLOAT:1<r.size?t.length&&n.uniform1fv(a,t):n.uniform1f(a,t);break;case n.FLOAT_MAT3:n.uniformMatrix3fv(a,!1,t);break;case n.FLOAT_MAT4:n.uniformMatrix4fv(a,!1,t);break;case n.FLOAT_VEC2:1<r.size?t.length&&n.uniform2fv(a,t):n.uniform2f(a,t[0],t[1]);break;case n.FLOAT_VEC3:1<r.size?t.length&&n.uniform3fv(a,t):n.uniform3f(a,t[0],t[1],t[2]);break;case n.FLOAT_VEC4:1<r.size?t.length&&n.uniform4fv(a,t):n.uniform4f(a,t[0],t[1],t[2],t[3]);break;case n.INT_VEC2:1<r.size?t.length&&n.uniform2iv(a,t):n.uniform2i(a,t[0],t[1]);break;case n.INT_VEC3:1<r.size?t.length&&n.uniform3iv(a,t):n.uniform3i(a,t[0],t[1],t[2]);break;case n.INT_VEC4:1<r.size?t.length&&n.uniform4iv(a,t):n.uniform4i(a,t[0],t[1],t[2],t[3]);break;case n.SAMPLER_2D:n.activeTexture(n.TEXTURE0+r.samplerIndex),r.texture=this._renderer.getTexture(t),n.uniform1i(r.location,r.samplerIndex);}return this}},a.default.Shader.prototype.isLightShader=function(){return void 0!==this.attributes.aNormal||void 0!==this.uniforms.uUseLighting||void 0!==this.uniforms.uAmbientLightCount||void 0!==this.uniforms.uDirectionalLightCount||void 0!==this.uniforms.uPointLightCount||void 0!==this.uniforms.uAmbientColor||void 0!==this.uniforms.uDirectionalDiffuseColors||void 0!==this.uniforms.uDirectionalSpecularColors||void 0!==this.uniforms.uPointLightLocation||void 0!==this.uniforms.uPointLightDiffuseColors||void 0!==this.uniforms.uPointLightSpecularColors||void 0!==this.uniforms.uLightingDirection||void 0!==this.uniforms.uSpecular},a.default.Shader.prototype.isNormalShader=function(){return void 0!==this.attributes.aNormal},a.default.Shader.prototype.isTextureShader=function(){return 0<this.samplerIndex},a.default.Shader.prototype.isColorShader=function(){return void 0!==this.attributes.aVertexColor||void 0!==this.uniforms.uMaterialColor},a.default.Shader.prototype.isTexLightShader=function(){return this.isLightShader()&&this.isTextureShader()},a.default.Shader.prototype.isStrokeShader=function(){return void 0!==this.uniforms.uStrokeWeight},a.default.Shader.prototype.enableAttrib=function(e,t,r,n,a,o){if(e){var i=e.location;if(-1!==i){var s=this._renderer.GL;e.enabled||(s.enableVertexAttribArray(i),e.enabled=!0),this._renderer.GL.vertexAttribPointer(i,t,r||s.FLOAT,n||!1,a||0,o||0);}}return this};var o=a.default.Shader;r.default=o;},{"../core/main":32}],88:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(r,"__esModule",{value:!0}),r.default=void 0;var n,a=(n=e("../core/main"))&&n.__esModule?n:{default:n},s=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=l();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants"));function l(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return l=function(){return e},e}a.default.Texture=function(e,t){this._renderer=e;var r=this._renderer.GL;this.src=t,this.glTex=void 0,this.glTarget=r.TEXTURE_2D,this.glFormat=r.RGBA,this.mipmaps=!1,this.glMinFilter=r.LINEAR,this.glMagFilter=r.LINEAR,this.glWrapS=r.CLAMP_TO_EDGE,this.glWrapT=r.CLAMP_TO_EDGE,this.isSrcMediaElement=void 0!==a.default.MediaElement&&t instanceof a.default.MediaElement,this._videoPrevUpdateTime=0,this.isSrcHTMLElement=void 0!==a.default.Element&&t instanceof a.default.Element&&!(t instanceof a.default.Graphics),this.isSrcP5Image=t instanceof a.default.Image,this.isSrcP5Graphics=t instanceof a.default.Graphics,this.isImageData="undefined"!=typeof ImageData&&t instanceof ImageData;var n=this._getTextureDataFromSource();return this.width=n.width,this.height=n.height,this.init(n),this},a.default.Texture.prototype._getTextureDataFromSource=function(){var e;return this.isSrcP5Image?e=this.src.canvas:this.isSrcMediaElement||this.isSrcP5Graphics||this.isSrcHTMLElement?e=this.src.elt:this.isImageData&&(e=this.src),e},a.default.Texture.prototype.init=function(e){var t=this._renderer.GL;if(this.glTex=t.createTexture(),this.glWrapS=this._renderer.textureWrapX,this.glWrapT=this._renderer.textureWrapY,this.setWrapMode(this.glWrapS,this.glWrapT),this.bindTexture(),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,this.glMagFilter),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,this.glMinFilter),0===this.width||0===this.height||this.isSrcMediaElement&&!this.src.loadedmetadata){var r=new Uint8Array([1,1,1,1]);t.texImage2D(this.glTarget,0,t.RGBA,1,1,0,this.glFormat,t.UNSIGNED_BYTE,r);}else t.texImage2D(this.glTarget,0,this.glFormat,this.glFormat,t.UNSIGNED_BYTE,e);},a.default.Texture.prototype.update=function(){var e=this.src;if(0===e.width||0===e.height)return !1;var t=this._getTextureDataFromSource(),r=!1,n=this._renderer.GL;return t.width!==this.width||t.height!==this.height?(r=!0,this.width=t.width,this.height=t.height,this.isSrcP5Image?e.setModified(!1):(this.isSrcMediaElement||this.isSrcHTMLElement)&&e.setModified(!0)):this.isSrcP5Image?e.isModified()&&(r=!0,e.setModified(!1)):this.isSrcMediaElement?e.isModified()?(r=!0,e.setModified(!1)):e.loadedmetadata&&this._videoPrevUpdateTime!==e.time()&&(this._videoPrevUpdateTime=e.time(),r=!0):this.isImageData?e._dirty&&(r=!(e._dirty=!1)):r=!0,r&&(this.bindTexture(),n.texImage2D(this.glTarget,0,this.glFormat,this.glFormat,n.UNSIGNED_BYTE,t)),r},a.default.Texture.prototype.bindTexture=function(){return this._renderer.GL.bindTexture(this.glTarget,this.glTex),this},a.default.Texture.prototype.unbindTexture=function(){this._renderer.GL.bindTexture(this.glTarget,null);},a.default.Texture.prototype.setInterpolation=function(e,t){var r=this._renderer.GL;e===s.NEAREST?this.glMinFilter=r.NEAREST:this.glMinFilter=r.LINEAR,t===s.NEAREST?this.glMagFilter=r.NEAREST:this.glMagFilter=r.LINEAR,this.bindTexture(),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,this.glMinFilter),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,this.glMagFilter),this.unbindTexture();},a.default.Texture.prototype.setWrapMode=function(e,t){function r(e){return 0==(e&e-1)}var n=this._renderer.GL,a=r(this.width),o=r(this.height);e===s.REPEAT?a&&o?this.glWrapS=n.REPEAT:(console.warn("You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead"),this.glWrapS=n.CLAMP_TO_EDGE):e===s.MIRROR?a&&o?this.glWrapS=n.MIRRORED_REPEAT:(console.warn("You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead"),this.glWrapS=n.CLAMP_TO_EDGE):this.glWrapS=n.CLAMP_TO_EDGE,t===s.REPEAT?a&&o?this.glWrapT=n.REPEAT:(console.warn("You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead"),this.glWrapT=n.CLAMP_TO_EDGE):t===s.MIRROR?a&&o?this.glWrapT=n.MIRRORED_REPEAT:(console.warn("You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead"),this.glWrapT=n.CLAMP_TO_EDGE):this.glWrapT=n.CLAMP_TO_EDGE,this.bindTexture(),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,this.glWrapS),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,this.glWrapT),this.unbindTexture();};var o=a.default.Texture;r.default=o;},{"../core/constants":22,"../core/main":32}],89:[function(e,t,r){function i(e){return (i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}var n,j=(n=e("../core/main"))&&n.__esModule?n:{default:n},R=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==i(e)&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=n?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(r,a,o):r[a]=e[a];}r.default=e,t&&t.set(e,r);return r}(e("../core/constants"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}e("./p5.Shader"),e("./p5.RendererGL.Retained"),j.default.RendererGL.prototype._applyTextProperties=function(){},j.default.RendererGL.prototype.textWidth=function(e){return this._isOpenType()?this._textFont._textWidth(e,this._textSize):0};function a(e,t){this.width=e,this.height=t,this.infos=[],this.findImage=function(e){var t,r,n=this.width*this.height;if(n<e)throw new Error("font is too complex to render in 3D");for(var a=this.infos.length-1;0<=a;--a){var o=this.infos[a];if(o.index+e<n){r=(t=o).imageData;break}}if(!t){try{r=new ImageData(this.width,this.height);}catch(e){var i=document.getElementsByTagName("canvas")[0],s=!i;i||((i=document.createElement("canvas")).style.display="none",document.body.appendChild(i));var l=i.getContext("2d");l&&(r=l.createImageData(this.width,this.height)),s&&document.body.removeChild(i);}t={index:0,imageData:r},this.infos.push(t);}var p=t.index;return t.index+=e,r._dirty=!0,{imageData:r,index:p}};}function V(e,t,r,n,a){var o=e.imageData.data,i=4*e.index++;o[i++]=t,o[i++]=r,o[i++]=n,o[i++]=a;}function D(e){this.font=e,this.strokeImageInfos=new a(64,64),this.colDimImageInfos=new a(64,64),this.rowDimImageInfos=new a(64,64),this.colCellImageInfos=new a(64,64),this.rowCellImageInfos=new a(64,64),this.glyphInfos={},this.getGlyphInfo=function(e){var t=this.glyphInfos[e.index];if(t)return t;var r,n=e.getBoundingBox(),a=n.x1,o=n.y1,i=n.x2-a,s=n.y2-o,l=e.path.commands;if(0==i||0==s||!l.length)return this.glyphInfos[e.index]={};var p,u,c,d,h=[],m=[],f=[];for(r=8;0<=r;--r)f.push([]);for(r=8;0<=r;--r)m.push([]);function y(e,t,r){var n=h.length;function a(e,t,r){for(var n=e.length;0<n--;){var a=e[n];a<t&&(t=a),r<a&&(r=a);}return {min:t,max:r}}h.push(r);for(var o=a(e,1,0),i=Math.max(Math.floor(9*o.min),0),s=Math.min(Math.ceil(9*o.max),9),l=i;l<s;++l)f[l].push(n);for(var p=a(t,1,0),u=Math.max(Math.floor(9*p.min),0),c=Math.min(Math.ceil(9*p.max),9),d=u;d<c;++d)m[d].push(n);}function g(e){return (t=(n=255)*e)<(r=0)?r:n<t?n:t;var t,r,n;}function S(e,t,r,n){this.p0=e,this.c0=t,this.c1=r,this.p1=n,this.toQuadratic=function(){return {x:this.p0.x,y:this.p0.y,x1:this.p1.x,y1:this.p1.y,cx:(3*(this.c0.x+this.c1.x)-(this.p0.x+this.p1.x))/4,cy:(3*(this.c0.y+this.c1.y)-(this.p0.y+this.p1.y))/4}},this.quadError=function(){return j.default.Vector.sub(j.default.Vector.sub(this.p1,this.p0),j.default.Vector.mult(j.default.Vector.sub(this.c1,this.c0),3)).mag()/2},this.split=function(e){var t=j.default.Vector.lerp(this.p0,this.c0,e),r=j.default.Vector.lerp(this.c0,this.c1,e),n=j.default.Vector.lerp(t,r,e);this.c1=j.default.Vector.lerp(this.c1,this.p1,e),this.c0=j.default.Vector.lerp(r,this.c1,e);var a=j.default.Vector.lerp(n,this.c0,e),o=new S(this.p0,t,n,a);return this.p0=a,o},this.splitInflections=function(){var e=j.default.Vector.sub(this.c0,this.p0),t=j.default.Vector.sub(j.default.Vector.sub(this.c1,this.c0),e),r=j.default.Vector.sub(j.default.Vector.sub(j.default.Vector.sub(this.p1,this.c1),e),j.default.Vector.mult(t,2)),n=[],a=t.x*r.y-t.y*r.x;if(0!==a){var o=e.x*r.y-e.y*r.x,i=e.x*t.y-e.y*t.x,s=o*o-4*a*i;if(0<=s){a<0&&(a=-a,o=-o,i=-i);var l=Math.sqrt(s),p=(-o-l)/(2*a),u=(-o+l)/(2*a);0<p&&p<1&&(n.push(this.split(p)),u=1-(1-u)/(1-p)),0<u&&u<1&&n.push(this.split(u));}}return n.push(this),n};}function v(e,t,r,n,a,o,i,s){var l=new S(new j.default.Vector(e,t),new j.default.Vector(r,n),new j.default.Vector(a,o),new j.default.Vector(i,s)).splitInflections(),p=[],u=30/z,c=!0,d=!1,h=void 0;try{for(var m,f=l[Symbol.iterator]();!(c=(m=f.next()).done);c=!0){for(var y=m.value,g=[],v=void 0;!(.125<=(v=u/y.quadError()));){var b=Math.pow(v,1/3),_=y.split(b),x=y.split(1-b/(1-b));p.push(_),g.push(y),y=x;}v<1&&p.push(y.split(.5)),p.push(y),Array.prototype.push.apply(p,g.reverse());}}catch(e){d=!0,h=e;}finally{try{c||null==f.return||f.return();}finally{if(d)throw h}}return p}function b(e,t,r,n){y([e,r],[t,n],{x:e,y:t,cx:(e+r)/2,cy:(t+n)/2});}function _(e,t,r,n){return Math.abs(r-e)<1e-5&&Math.abs(n-t)<1e-5}var x=!0,w=!1,M=void 0;try{for(var E,T=l[Symbol.iterator]();!(x=(E=T.next()).done);x=!0){var C=E.value,N=(C.x-a)/i,O=(C.y-o)/s;if(!_(p,u,N,O)){switch(C.type){case"M":c=N,d=O;break;case"L":b(p,u,N,O);break;case"Q":var L=(C.x1-a)/i,I=(C.y1-o)/s;y([p,N,L],[u,O,I],{x:p,y:u,cx:L,cy:I});break;case"Z":_(p,u,c,d)?h.push({x:p,y:u}):(b(p,u,c,d),h.push({x:c,y:d}));break;case"C":for(var P=v(p,u,(C.x1-a)/i,(C.y1-o)/s,(C.x2-a)/i,(C.y2-o)/s,N,O),R=0;R<P.length;R++){var D=P[R].toQuadratic();y([D.x,D.x1,D.cx],[D.y,D.y1,D.cy],D);}break;default:throw new Error("unknown command type: ".concat(C.type))}p=N,u=O;}}}catch(e){w=!0,M=e;}finally{try{x||null==T.return||T.return();}finally{if(w)throw M}}for(var A=h.length,k=this.strokeImageInfos.findImage(A),F=k.index,U=0;U<A;++U){var B=h[U];V(k,g(B.x),g(B.y),g(B.cx),g(B.cy));}function G(e,t,r){for(var n=e.length,a=t.findImage(n),o=a.index,i=0,s=0;s<n;++s)i+=e[s].length;for(var l=r.findImage(i),p=0;p<n;++p){var u=e[p],c=u.length,d=l.index;V(a,d>>7,127&d,c>>7,127&c);for(var h=0;h<c;++h){var m=u[h]+F;V(l,m>>7,127&m,0,0);}}return {cellImageInfo:l,dimOffset:o,dimImageInfo:a}}return (t=this.glyphInfos[e.index]={glyph:e,uGlyphRect:[n.x1,-n.y1,n.x2,-n.y2],strokeImageInfo:k,strokes:h,colInfo:G(f,this.colDimImageInfos,this.colCellImageInfos),rowInfo:G(m,this.rowDimImageInfos,this.rowCellImageInfos)}).uGridOffset=[t.colInfo.dimOffset,t.rowInfo.dimOffset],t};}var z=Math.sqrt(3);j.default.RendererGL.prototype._renderText=function(e,t,r,n,a){if(this._textFont&&"string"!=typeof this._textFont){if(!(a<=n)&&this._doFill){if(!this._isOpenType())return console.log("WEBGL: only Opentype (.otf) and Truetype (.ttf) fonts are supported"),e;e.push();var o=this._doStroke,i=this.drawMode;this._doStroke=!1,this.drawMode=R.TEXTURE;var s=this._textFont.font,l=this._textFont._fontInfo;l=l||(this._textFont._fontInfo=new D(s));var p=this._textFont._handleAlignment(this,t,r,n),u=this._textSize/s.unitsPerEm;this.translate(p.x,p.y,0),this.scale(u,u,1);var c=this.GL,d=!this._defaultFontShader,h=this._getFontShader();h.init(),h.bindShader(),d&&(h.setUniform("uGridImageSize",[64,64]),h.setUniform("uCellsImageSize",[64,64]),h.setUniform("uStrokeImageSize",[64,64]),h.setUniform("uGridSize",[9,9])),this._applyColorBlend(this.curFillColor);var m=this.retainedMode.geometry.glyph;if(!m){var f=this._textGeom=new j.default.Geometry(1,1,function(){for(var e=0;e<=1;e++)for(var t=0;t<=1;t++)this.vertices.push(new j.default.Vector(t,e,0)),this.uvs.push(t,e);});f.computeFaces().computeNormals(),m=this.createBuffers("glyph",f);}var y=!0,g=!1,v=void 0;try{for(var b,_=this.retainedMode.buffers.text[Symbol.iterator]();!(y=(b=_.next()).done);y=!0){b.value._prepareBuffer(m,h);}}catch(e){g=!0,v=e;}finally{try{y||null==_.return||_.return();}finally{if(g)throw v}}this._bindBuffer(m.indexBuffer,c.ELEMENT_ARRAY_BUFFER),h.setUniform("uMaterialColor",this.curFillColor);try{var x=0,S=null,w=s.stringToGlyphs(t),M=!0,E=!1,T=void 0;try{for(var C,N=w[Symbol.iterator]();!(M=(C=N.next()).done);M=!0){var O=C.value;S&&(x+=s.getKerningValue(S,O));var L=l.getGlyphInfo(O);if(L.uGlyphRect){var I=L.rowInfo,P=L.colInfo;h.setUniform("uSamplerStrokes",L.strokeImageInfo.imageData),h.setUniform("uSamplerRowStrokes",I.cellImageInfo.imageData),h.setUniform("uSamplerRows",I.dimImageInfo.imageData),h.setUniform("uSamplerColStrokes",P.cellImageInfo.imageData),h.setUniform("uSamplerCols",P.dimImageInfo.imageData),h.setUniform("uGridOffset",L.uGridOffset),h.setUniform("uGlyphRect",L.uGlyphRect),h.setUniform("uGlyphOffset",x),h.bindTextures(),c.drawElements(c.TRIANGLES,6,this.GL.UNSIGNED_SHORT,0);}x+=O.advanceWidth,S=O;}}catch(e){E=!0,T=e;}finally{try{M||null==N.return||N.return();}finally{if(E)throw T}}}finally{h.unbindShader(),this._doStroke=o,this.drawMode=i,e.pop();}return e}}else console.log("WEBGL: you must load and set a font before drawing text. See `loadFont` and `textFont` for more details.");};},{"../core/constants":22,"../core/main":32,"./p5.RendererGL.Retained":85,"./p5.Shader":87}]},{},[17])(17)});
	});

	var p5 = /*@__PURE__*/unwrapExports(p5_min);

	var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

	var options = function(to, from) {
	  if (to === null || typeof to === 'undefined') {
	    to = {};
	  }

	  for ( var key in from) {
	    if (from.hasOwnProperty(key) && typeof to[key] === 'undefined') {
	      to[key] = from[key];
	    }
	  }

	  if (typeof Object.getOwnPropertySymbols === 'function') {
	    var symbols = Object.getOwnPropertySymbols(from);
	    for (var i = 0; i < symbols.length; i++) {
	      var symbol = symbols[i];
	      if (from.propertyIsEnumerable(symbol) && typeof to[key] === 'undefined') {
	        to[symbol] = from[symbol];
	      }
	    }
	  }
	  return to;
	};

	var _DEBUG$1 = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$1 = typeof ASSERT === 'undefined' ? false : ASSERT;

	var debug = function() {
	  if (!_DEBUG$1) return;
	  console.log.apply(console, arguments);
	};

	var assert = function(statement, err, log) {
	  if (!_ASSERT$1) return;
	  if (statement) return;
	  log && console.log(log);
	  throw new Error(err);
	};

	var common = {
		debug: debug,
		assert: assert
	};

	var create = createCommonjsModule(function (module) {
	if (typeof Object.create == 'function') {
	  module.exports = function(proto, props) {
	    return Object.create.call(Object, proto, props);
	  };
	} else {
	  module.exports = function(proto, props) {
	    if (props)
	      throw Error('Second argument is not supported!');
	    if (typeof proto !== 'object' || proto === null)
	      throw Error('Invalid prototype!');
	    noop.prototype = proto;
	    return new noop;
	  };
	  function noop() {
	  }
	}
	});

	var _Math = createCommonjsModule(function (module) {
	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;



	var native = Math;
	var math = module.exports = create(native);

	math.EPSILON = 1e-9; // TODO

	/**
	 * This function is used to ensure that a floating point number is not a NaN or
	 * infinity.
	 */
	math.isFinite = function(x) {
	  return (typeof x === 'number') && isFinite(x) && !isNaN(x);
	};

	math.assert = function(x) {
	  if (!_ASSERT) return;
	  if (!math.isFinite(x)) {
	    _DEBUG && common.debug(x);
	    throw new Error('Invalid Number!');
	  }
	};

	/**
	 * TODO: This is a approximate yet fast inverse square-root.
	 */
	math.invSqrt = function(x) {
	  // TODO
	  return 1 / native.sqrt(x);
	};

	/**
	 * Next Largest Power of 2 Given a binary integer value x, the next largest
	 * power of 2 can be computed by a SWAR algorithm that recursively "folds" the
	 * upper bits into the lower bits. This process yields a bit vector with the
	 * same most significant 1 as x, but all 1's below it. Adding 1 to that value
	 * yields the next largest power of 2. For a 32-bit value:
	 */
	math.nextPowerOfTwo = function(x) {
	  // TODO
	  x |= (x >> 1);
	  x |= (x >> 2);
	  x |= (x >> 4);
	  x |= (x >> 8);
	  x |= (x >> 16);
	  return x + 1;
	};

	math.isPowerOfTwo = function(x) {
	  return x > 0 && (x & (x - 1)) == 0;
	};

	math.mod = function(num, min, max) {
	  if (typeof min === 'undefined') {
	    max = 1, min = 0;
	  } else if (typeof max === 'undefined') {
	    max = min, min = 0;
	  }
	  if (max > min) {
	    num = (num - min) % (max - min);
	    return num + (num < 0 ? max : min);
	  } else {
	    num = (num - max) % (min - max);
	    return num + (num <= 0 ? min : max);
	  }
	};

	math.clamp = function(num, min, max) {
	  if (num < min) {
	    return min;
	  } else if (num > max) {
	    return max;
	  } else {
	    return num;
	  }
	};

	math.random = function(min, max) {
	  if (typeof min === 'undefined') {
	    max = 1;
	    min = 0;
	  } else if (typeof max === 'undefined') {
	    max = min;
	    min = 0;
	  }
	  return min == max ? min : native.random() * (max - min) + min;
	};
	});

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$2 = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$2 = typeof ASSERT === 'undefined' ? false : ASSERT;

	var Vec2_1 = Vec2;




	function Vec2(x, y) {
	  if (!(this instanceof Vec2)) {
	    return new Vec2(x, y);
	  }
	  if (typeof x === 'undefined') {
	    this.x = 0;
	    this.y = 0;
	  } else if (typeof x === 'object') {
	    this.x = x.x;
	    this.y = x.y;
	  } else {
	    this.x = x;
	    this.y = y;
	  }
	  _ASSERT$2 && Vec2.assert(this);
	}

	Vec2.prototype._serialize = function() {
	  return {
	    x: this.x,
	    y: this.y
	  };
	};

	Vec2._deserialize = function(data) {
	  var obj = Object.create(Vec2.prototype);
	  obj.x = data.x;
	  obj.y = data.y;
	  return obj;
	};

	Vec2.zero = function() {
	  var obj = Object.create(Vec2.prototype);
	  obj.x = 0;
	  obj.y = 0;
	  return obj;
	};

	Vec2.neo = function(x, y) {
	  var obj = Object.create(Vec2.prototype);
	  obj.x = x;
	  obj.y = y;
	  return obj;
	};

	Vec2.clone = function(v) {
	  _ASSERT$2 && Vec2.assert(v);
	  return Vec2.neo(v.x, v.y);
	};

	Vec2.prototype.toString = function() {
	  return JSON.stringify(this);
	};

	/**
	 * Does this vector contain finite coordinates?
	 */
	Vec2.isValid = function(v) {
	  return v && _Math.isFinite(v.x) && _Math.isFinite(v.y);
	};

	Vec2.assert = function(o) {
	  if (!_ASSERT$2) return;
	  if (!Vec2.isValid(o)) {
	    _DEBUG$2 && common.debug(o);
	    throw new Error('Invalid Vec2!');
	  }
	};

	Vec2.prototype.clone = function() {
	  return Vec2.clone(this);
	};

	/**
	 * Set this vector to all zeros.
	 * 
	 * @returns this
	 */
	Vec2.prototype.setZero = function() {
	  this.x = 0.0;
	  this.y = 0.0;
	  return this;
	};

	/**
	 * Set this vector to some specified coordinates.
	 * 
	 * @returns this
	 */
	Vec2.prototype.set = function(x, y) {
	  if (typeof x === 'object') {
	    _ASSERT$2 && Vec2.assert(x);
	    this.x = x.x;
	    this.y = x.y;
	  } else {
	    _ASSERT$2 && _Math.assert(x);
	    _ASSERT$2 && _Math.assert(y);
	    this.x = x;
	    this.y = y;
	  }
	  return this;
	};

	/**
	 * @deprecated Use setCombine or setMul
	 */
	Vec2.prototype.wSet = function(a, v, b, w) {
	  if (typeof b !== 'undefined' || typeof w !== 'undefined') {
	    return this.setCombine(a, v, b, w);
	  } else {
	    return this.setMul(a, v);
	  }
	};

	/**
	 * Set linear combination of v and w: `a * v + b * w`
	 */
	Vec2.prototype.setCombine = function(a, v, b, w) {
	  _ASSERT$2 && _Math.assert(a);
	  _ASSERT$2 && Vec2.assert(v);
	  _ASSERT$2 && _Math.assert(b);
	  _ASSERT$2 && Vec2.assert(w);
	  var x = a * v.x + b * w.x;
	  var y = a * v.y + b * w.y;

	  // `this` may be `w`
	  this.x = x;
	  this.y = y;
	  return this;
	};

	Vec2.prototype.setMul = function(a, v) {
	  _ASSERT$2 && _Math.assert(a);
	  _ASSERT$2 && Vec2.assert(v);
	  var x = a * v.x;
	  var y = a * v.y;

	  this.x = x;
	  this.y = y;
	  return this;
	};

	/**
	 * Add a vector to this vector.
	 * 
	 * @returns this
	 */
	Vec2.prototype.add = function(w) {
	  _ASSERT$2 && Vec2.assert(w);
	  this.x += w.x;
	  this.y += w.y;
	  return this;
	};

	/**
	 * @deprecated Use addCombine or addMul
	 */
	Vec2.prototype.wAdd = function(a, v, b, w) {
	  if (typeof b !== 'undefined' || typeof w !== 'undefined') {
	    return this.addCombine(a, v, b, w);
	  } else {
	    return this.addMul(a, v);
	  }
	};

	/**
	 * Add linear combination of v and w: `a * v + b * w`
	 */
	Vec2.prototype.addCombine = function(a, v, b, w) {
	  _ASSERT$2 && _Math.assert(a);
	  _ASSERT$2 && Vec2.assert(v);
	  _ASSERT$2 && _Math.assert(b);
	  _ASSERT$2 && Vec2.assert(w);

	  var x = a * v.x + b * w.x;
	  var y = a * v.y + b * w.y;

	  // `this` may be `w`
	  this.x += x;
	  this.y += y;
	  return this;
	};

	Vec2.prototype.addMul = function(a, v) {
	  _ASSERT$2 && _Math.assert(a);
	  _ASSERT$2 && Vec2.assert(v);
	  var x = a * v.x;
	  var y = a * v.y;

	  this.x += x;
	  this.y += y;
	  return this;
	};

	/**
	 * @deprecated Use subCombine or subMul
	 */
	Vec2.prototype.wSub = function(a, v, b, w) {
	  if (typeof b !== 'undefined' || typeof w !== 'undefined') {
	    return this.subCombine(a, v, b, w);
	  } else {
	    return this.subMul(a, v);
	  }};

	/**
	 * Subtract linear combination of v and w: `a * v + b * w`
	 */
	Vec2.prototype.subCombine = function(a, v, b, w) {
	  _ASSERT$2 && _Math.assert(a);
	  _ASSERT$2 && Vec2.assert(v);
	  _ASSERT$2 && _Math.assert(b);
	  _ASSERT$2 && Vec2.assert(w);
	  var x = a * v.x + b * w.x;
	  var y = a * v.y + b * w.y;

	  // `this` may be `w`
	  this.x -= x;
	  this.y -= y;
	  return this;
	};

	Vec2.prototype.subMul = function(a, v) {
	  _ASSERT$2 && _Math.assert(a);
	  _ASSERT$2 && Vec2.assert(v);
	  var x = a * v.x;
	  var y = a * v.y;

	  this.x -= x;
	  this.y -= y;
	  return this;
	};

	/**
	 * Subtract a vector from this vector
	 * 
	 * @returns this
	 */
	Vec2.prototype.sub = function(w) {
	  _ASSERT$2 && Vec2.assert(w);
	  this.x -= w.x;
	  this.y -= w.y;
	  return this;
	};

	/**
	 * Multiply this vector by a scalar.
	 * 
	 * @returns this
	 */
	Vec2.prototype.mul = function(m) {
	  _ASSERT$2 && _Math.assert(m);
	  this.x *= m;
	  this.y *= m;
	  return this;
	};

	/**
	 * Get the length of this vector (the norm).
	 * 
	 * For performance, use this instead of lengthSquared (if possible).
	 */
	Vec2.prototype.length = function() {
	  return Vec2.lengthOf(this);
	};

	/**
	 * Get the length squared.
	 */
	Vec2.prototype.lengthSquared = function() {
	  return Vec2.lengthSquared(this);
	};

	/**
	 * Convert this vector into a unit vector.
	 * 
	 * @returns old length
	 */
	Vec2.prototype.normalize = function() {
	  var length = this.length();
	  if (length < _Math.EPSILON) {
	    return 0.0;
	  }
	  var invLength = 1.0 / length;
	  this.x *= invLength;
	  this.y *= invLength;
	  return length;
	};

	/**
	 * Get the length of this vector (the norm).
	 *
	 * For performance, use this instead of lengthSquared (if possible).
	 */
	Vec2.lengthOf = function(v) {
	  _ASSERT$2 && Vec2.assert(v);
	  return _Math.sqrt(v.x * v.x + v.y * v.y);
	};

	/**
	 * Get the length squared.
	 */
	Vec2.lengthSquared = function(v) {
	  _ASSERT$2 && Vec2.assert(v);
	  return v.x * v.x + v.y * v.y;
	};

	Vec2.distance = function(v, w) {
	  _ASSERT$2 && Vec2.assert(v);
	  _ASSERT$2 && Vec2.assert(w);
	  var dx = v.x - w.x, dy = v.y - w.y;
	  return _Math.sqrt(dx * dx + dy * dy);
	};

	Vec2.distanceSquared = function(v, w) {
	  _ASSERT$2 && Vec2.assert(v);
	  _ASSERT$2 && Vec2.assert(w);
	  var dx = v.x - w.x, dy = v.y - w.y;
	  return dx * dx + dy * dy;
	};

	Vec2.areEqual = function(v, w) {
	  _ASSERT$2 && Vec2.assert(v);
	  _ASSERT$2 && Vec2.assert(w);
	  return v == w || typeof w === 'object' && w !== null && v.x === w.x && v.y === w.y;
	};

	/**
	 * Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
	 */
	Vec2.skew = function(v) {
	  _ASSERT$2 && Vec2.assert(v);
	  return Vec2.neo(-v.y, v.x);
	};

	/**
	 * Perform the dot product on two vectors.
	 */
	Vec2.dot = function(v, w) {
	  _ASSERT$2 && Vec2.assert(v);
	  _ASSERT$2 && Vec2.assert(w);
	  return v.x * w.x + v.y * w.y;
	};

	/**
	 * Perform the cross product on two vectors. In 2D this produces a scalar.
	 * 
	 * Perform the cross product on a vector and a scalar. In 2D this produces a
	 * vector.
	 */
	Vec2.cross = function(v, w) {
	  if (typeof w === 'number') {
	    _ASSERT$2 && Vec2.assert(v);
	    _ASSERT$2 && _Math.assert(w);
	    return Vec2.neo(w * v.y, -w * v.x);

	  } else if (typeof v === 'number') {
	    _ASSERT$2 && _Math.assert(v);
	    _ASSERT$2 && Vec2.assert(w);
	    return Vec2.neo(-v * w.y, v * w.x);

	  } else {
	    _ASSERT$2 && Vec2.assert(v);
	    _ASSERT$2 && Vec2.assert(w);
	    return v.x * w.y - v.y * w.x
	  }
	};

	/**
	 * Returns `a + (v x w)`
	 */
	Vec2.addCross = function(a, v, w) {
	  if (typeof w === 'number') {
	    _ASSERT$2 && Vec2.assert(v);
	    _ASSERT$2 && _Math.assert(w);
	    return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);

	  } else if (typeof v === 'number') {
	    _ASSERT$2 && _Math.assert(v);
	    _ASSERT$2 && Vec2.assert(w);
	    return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);
	  }

	  _ASSERT$2 && common.assert(false);
	};

	Vec2.add = function(v, w) {
	  _ASSERT$2 && Vec2.assert(v);
	  _ASSERT$2 && Vec2.assert(w);
	  return Vec2.neo(v.x + w.x, v.y + w.y);
	};

	/**
	 * @deprecated Use combine
	 */
	Vec2.wAdd = function(a, v, b, w) {
	  if (typeof b !== 'undefined' || typeof w !== 'undefined') {
	    return Vec2.combine(a, v, b, w);
	  } else {
	    return Vec2.mul(a, v);
	  }
	};

	Vec2.combine = function(a, v, b, w) {
	  return Vec2.zero().setCombine(a, v, b, w);
	};

	Vec2.sub = function(v, w) {
	  _ASSERT$2 && Vec2.assert(v);
	  _ASSERT$2 && Vec2.assert(w);
	  return Vec2.neo(v.x - w.x, v.y - w.y);
	};

	Vec2.mul = function(a, b) {
	  if (typeof a === 'object') {
	    _ASSERT$2 && Vec2.assert(a);
	    _ASSERT$2 && _Math.assert(b);
	    return Vec2.neo(a.x * b, a.y * b);

	  } else if (typeof b === 'object') {
	    _ASSERT$2 && _Math.assert(a);
	    _ASSERT$2 && Vec2.assert(b);
	    return Vec2.neo(a * b.x, a * b.y);
	  }
	};

	Vec2.prototype.neg = function() {
	  this.x = -this.x;
	  this.y = -this.y;
	  return this;
	};

	Vec2.neg = function(v) {
	  _ASSERT$2 && Vec2.assert(v);
	  return Vec2.neo(-v.x, -v.y);
	};

	Vec2.abs = function(v) {
	  _ASSERT$2 && Vec2.assert(v);
	  return Vec2.neo(_Math.abs(v.x), _Math.abs(v.y));
	};

	Vec2.mid = function(v, w) {
	  _ASSERT$2 && Vec2.assert(v);
	  _ASSERT$2 && Vec2.assert(w);
	  return Vec2.neo((v.x + w.x) * 0.5, (v.y + w.y) * 0.5);
	};

	Vec2.upper = function(v, w) {
	  _ASSERT$2 && Vec2.assert(v);
	  _ASSERT$2 && Vec2.assert(w);
	  return Vec2.neo(_Math.max(v.x, w.x), _Math.max(v.y, w.y));
	};

	Vec2.lower = function(v, w) {
	  _ASSERT$2 && Vec2.assert(v);
	  _ASSERT$2 && Vec2.assert(w);
	  return Vec2.neo(_Math.min(v.x, w.x), _Math.min(v.y, w.y));
	};

	Vec2.prototype.clamp = function(max) {
	  var lengthSqr = this.x * this.x + this.y * this.y;
	  if (lengthSqr > max * max) {
	    var invLength = _Math.invSqrt(lengthSqr);
	    this.x *= invLength * max;
	    this.y *= invLength * max;
	  }
	  return this;
	};

	Vec2.clamp = function(v, max) {
	  v = Vec2.neo(v.x, v.y);
	  v.clamp(max);
	  return v;
	};

	/**
	 * @experimental
	 */
	Vec2.scaleFn = function (x, y) {
	  return function (v) {
	    return Vec2.neo(v.x * x, v.y * y);
	  };
	};

	/**
	 * @experimental
	 */
	Vec2.translateFn = function(x, y) {
	  return function (v) {
	    return Vec2.neo(v.x + x, v.y + y);
	  };
	};

	var Settings_1 = createCommonjsModule(function (module, exports) {
	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

	// TODO merge with World options?

	var Settings = exports;

	/**
	 * Tuning constants based on meters-kilograms-seconds (MKS) units.
	 */

	// Collision
	/**
	 * The maximum number of contact points between two convex shapes. Do not change
	 * this value.
	 */
	Settings.maxManifoldPoints = 2;

	/**
	 * The maximum number of vertices on a convex polygon. You cannot increase this
	 * too much because BlockAllocator has a maximum object size.
	 */
	Settings.maxPolygonVertices = 12;

	/**
	 * This is used to fatten AABBs in the dynamic tree. This allows proxies to move
	 * by a small amount without triggering a tree adjustment. This is in meters.
	 */
	Settings.aabbExtension = 0.1;

	/**
	 * This is used to fatten AABBs in the dynamic tree. This is used to predict the
	 * future position based on the current displacement. This is a dimensionless
	 * multiplier.
	 */
	Settings.aabbMultiplier = 2.0;

	/**
	 * A small length used as a collision and constraint tolerance. Usually it is
	 * chosen to be numerically significant, but visually insignificant.
	 */
	Settings.linearSlop = 0.005;
	Settings.linearSlopSquared = Settings.linearSlop * Settings.linearSlop;

	/**
	 * A small angle used as a collision and constraint tolerance. Usually it is
	 * chosen to be numerically significant, but visually insignificant.
	 */
	Settings.angularSlop = (2.0 / 180.0 * Math.PI);

	/**
	 * The radius of the polygon/edge shape skin. This should not be modified.
	 * Making this smaller means polygons will have an insufficient buffer for
	 * continuous collision. Making it larger may create artifacts for vertex
	 * collision.
	 */
	Settings.polygonRadius = (2.0 * Settings.linearSlop);

	/**
	 * Maximum number of sub-steps per contact in continuous physics simulation.
	 */
	Settings.maxSubSteps = 8;

	// Dynamics

	/**
	 * Maximum number of contacts to be handled to solve a TOI impact.
	 */
	Settings.maxTOIContacts = 32;

	/**
	 * Maximum iterations to solve a TOI.
	 */
	Settings.maxTOIIterations = 20;

	/**
	 * Maximum iterations to find Distance.
	 */
	Settings.maxDistnceIterations = 20;

	/**
	 * A velocity threshold for elastic collisions. Any collision with a relative
	 * linear velocity below this threshold will be treated as inelastic.
	 */
	Settings.velocityThreshold = 1.0;

	/**
	 * The maximum linear position correction used when solving constraints. This
	 * helps to prevent overshoot.
	 */
	Settings.maxLinearCorrection = 0.2;

	/**
	 * The maximum angular position correction used when solving constraints. This
	 * helps to prevent overshoot.
	 */
	Settings.maxAngularCorrection = (8.0 / 180.0 * Math.PI);

	/**
	 * The maximum linear velocity of a body. This limit is very large and is used
	 * to prevent numerical problems. You shouldn't need to adjust this.
	 */
	Settings.maxTranslation = 2.0;
	Settings.maxTranslationSquared = (Settings.maxTranslation * Settings.maxTranslation);

	/**
	 * The maximum angular velocity of a body. This limit is very large and is used
	 * to prevent numerical problems. You shouldn't need to adjust this.
	 */
	Settings.maxRotation = (0.5 * Math.PI);
	Settings.maxRotationSquared = (Settings.maxRotation * Settings.maxRotation);

	/**
	 * This scale factor controls how fast overlap is resolved. Ideally this would
	 * be 1 so that overlap is removed in one time step. However using values close
	 * to 1 often lead to overshoot.
	 */
	Settings.baumgarte = 0.2;
	Settings.toiBaugarte = 0.75;

	// Sleep

	/**
	 * The time that a body must be still before it will go to sleep.
	 */
	Settings.timeToSleep = 0.5;

	/**
	 * A body cannot sleep if its linear velocity is above this tolerance.
	 */
	Settings.linearSleepTolerance = 0.01;

	Settings.linearSleepToleranceSqr = Math.pow(Settings.linearSleepTolerance, 2);

	/**
	 * A body cannot sleep if its angular velocity is above this tolerance.
	 */
	Settings.angularSleepTolerance = (2.0 / 180.0 * Math.PI);

	Settings.angularSleepToleranceSqr = Math.pow(Settings.angularSleepTolerance, 2);
	});

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$3 = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$3 = typeof ASSERT === 'undefined' ? false : ASSERT;






	var AABB_1 = AABB;

	function AABB(lower, upper) {
	  if (!(this instanceof AABB)) {
	    return new AABB(lower, upper);
	  }

	  this.lowerBound = Vec2_1.zero();
	  this.upperBound = Vec2_1.zero();

	  if (typeof lower === 'object') {
	    this.lowerBound.set(lower);
	  }
	  if (typeof upper === 'object') {
	    this.upperBound.set(upper);
	  } else if (typeof lower === 'object') {
	    this.upperBound.set(lower);
	  }
	}
	/**
	 * Verify that the bounds are sorted.
	 */
	AABB.prototype.isValid = function() {
	  return AABB.isValid(this);
	};

	AABB.isValid = function(aabb) {
	  var d = Vec2_1.sub(aabb.upperBound, aabb.lowerBound);
	  var valid = d.x >= 0.0 && d.y >= 0.0 && Vec2_1.isValid(aabb.lowerBound) && Vec2_1.isValid(aabb.upperBound);
	  return valid;
	};

	AABB.assert = function(o) {
	  if (!_ASSERT$3) return;
	  if (!AABB.isValid(o)) {
	    _DEBUG$3 && common.debug(o);
	    throw new Error('Invalid AABB!');
	  }
	};

	/**
	 * Get the center of the AABB.
	 */
	AABB.prototype.getCenter = function() {
	  return Vec2_1.neo((this.lowerBound.x + this.upperBound.x) * 0.5, (this.lowerBound.y + this.upperBound.y) * 0.5);
	};

	/**
	 * Get the extents of the AABB (half-widths).
	 */
	AABB.prototype.getExtents = function() {
	  return Vec2_1.neo((this.upperBound.x - this.lowerBound.x) * 0.5, (this.upperBound.y - this.lowerBound.y) * 0.5);
	};

	/**
	 * Get the perimeter length.
	 */
	AABB.prototype.getPerimeter = function() {
	  return 2.0 * (this.upperBound.x - this.lowerBound.x + this.upperBound.y - this.lowerBound.y);
	};

	/**
	 * Combine one or two AABB into this one.
	 */
	AABB.prototype.combine = function(a, b) {
	  b = b || this;

	  var lowerA = a.lowerBound;
	  var upperA = a.upperBound;
	  var lowerB = b.lowerBound;
	  var upperB = b.upperBound;

	  var lowerX = _Math.min(lowerA.x, lowerB.x);
	  var lowerY = _Math.min(lowerA.y, lowerB.y);
	  var upperX = _Math.max(upperB.x, upperA.x);
	  var upperY = _Math.max(upperB.y, upperA.y);

	  this.lowerBound.set(lowerX, lowerY);
	  this.upperBound.set(upperX, upperY);
	};

	AABB.prototype.combinePoints = function(a, b) {
	  this.lowerBound.set(_Math.min(a.x, b.x), _Math.min(a.y, b.y));
	  this.upperBound.set(_Math.max(a.x, b.x), _Math.max(a.y, b.y));
	};

	AABB.prototype.set = function(aabb) {
	  this.lowerBound.set(aabb.lowerBound.x, aabb.lowerBound.y);
	  this.upperBound.set(aabb.upperBound.x, aabb.upperBound.y);
	};

	AABB.prototype.contains = function(aabb) {
	  var result = true;
	  result = result && this.lowerBound.x <= aabb.lowerBound.x;
	  result = result && this.lowerBound.y <= aabb.lowerBound.y;
	  result = result && aabb.upperBound.x <= this.upperBound.x;
	  result = result && aabb.upperBound.y <= this.upperBound.y;
	  return result;
	};

	AABB.prototype.extend = function(value) {
	  AABB.extend(this, value);
	  return this;
	};

	AABB.extend = function(aabb, value) {
	  aabb.lowerBound.x -= value;
	  aabb.lowerBound.y -= value;
	  aabb.upperBound.x += value;
	  aabb.upperBound.y += value;
	};

	AABB.testOverlap = function(a, b) {
	  var d1x = b.lowerBound.x - a.upperBound.x;
	  var d2x = a.lowerBound.x - b.upperBound.x;

	  var d1y = b.lowerBound.y - a.upperBound.y;
	  var d2y = a.lowerBound.y - b.upperBound.y;

	  if (d1x > 0 || d1y > 0 || d2x > 0 || d2y > 0) {
	    return false;
	  }
	  return true;
	};

	AABB.areEqual = function(a, b) {
	  return Vec2_1.areEqual(a.lowerBound, b.lowerBound) && Vec2_1.areEqual(a.upperBound, b.upperBound);
	};

	AABB.diff = function(a, b) {
	  var wD = _Math.max(0, _Math.min(a.upperBound.x, b.upperBound.x) - _Math.max(b.lowerBound.x, a.lowerBound.x));
	  var hD = _Math.max(0, _Math.min(a.upperBound.y, b.upperBound.y) - _Math.max(b.lowerBound.y, a.lowerBound.y));

	  var wA = a.upperBound.x - a.lowerBound.x;
	  var hA = a.upperBound.y - a.lowerBound.y;

	  var wB = b.upperBound.x - b.lowerBound.x;
	  var hB = b.upperBound.y - b.lowerBound.y;

	  return wA * hA + wB * hB - wD * hD;
	};

	/**
	 * @typedef RayCastInput
	 *
	 * Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
	 *
	 * @prop {Vec2} p1
	 * @prop {Vec2} p2
	 * @prop {number} maxFraction
	 */

	/**
	 * @typedef RayCastInput
	 *
	 * Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and
	 * p2 come from RayCastInput.
	 *
	 * @prop {Vec2} normal
	 * @prop {number} fraction
	 */

	/**
	 * @param {RayCastOutput} output
	 * @param {RayCastInput} input
	 * @returns {boolean}
	 */
	AABB.prototype.rayCast = function(output, input) {
	  // From Real-time Collision Detection, p179.

	  var tmin = -Infinity;
	  var tmax = Infinity;

	  var p = input.p1;
	  var d = Vec2_1.sub(input.p2, input.p1);
	  var absD = Vec2_1.abs(d);

	  var normal = Vec2_1.zero();

	  for (var f = 'x'; f !== null; f = (f === 'x' ? 'y' : null)) {
	    if (absD.x < _Math.EPSILON) {
	      // Parallel.
	      if (p[f] < this.lowerBound[f] || this.upperBound[f] < p[f]) {
	        return false;
	      }
	    } else {
	      var inv_d = 1.0 / d[f];
	      var t1 = (this.lowerBound[f] - p[f]) * inv_d;
	      var t2 = (this.upperBound[f] - p[f]) * inv_d;

	      // Sign of the normal vector.
	      var s = -1.0;

	      if (t1 > t2) {
	        var temp = t1;
	        t1 = t2, t2 = temp;
	        s = 1.0;
	      }

	      // Push the min up
	      if (t1 > tmin) {
	        normal.setZero();
	        normal[f] = s;
	        tmin = t1;
	      }

	      // Pull the max down
	      tmax = _Math.min(tmax, t2);

	      if (tmin > tmax) {
	        return false;
	      }
	    }
	  }

	  // Does the ray start inside the box?
	  // Does the ray intersect beyond the max fraction?
	  if (tmin < 0.0 || input.maxFraction < tmin) {
	    return false;
	  }

	  // Intersection.
	  output.fraction = tmin;
	  output.normal = normal;
	  return true;
	};

	AABB.prototype.toString = function() {
	  return JSON.stringify(this);
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$4 = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$4 = typeof ASSERT === 'undefined' ? false : ASSERT;

	var Pool_1 = Pool;

	function Pool(opts) {
	  var _list = [];
	  var _max = opts.max || Infinity;

	  var _createFn = opts.create;
	  var _outFn = opts.allocate;
	  var _inFn = opts.release;
	  var _discardFn = opts.discard;

	  var _createCount = 0;
	  var _outCount = 0;
	  var _inCount = 0;
	  var _discardCount = 0;

	  this.max = function(n) {
	    if (typeof n === 'number') {
	      _max = n;
	      return this;
	    }
	    return _max;
	  };

	  this.size = function() {
	    return _list.length;
	  };

	  this.allocate = function() {
	    var item;
	    if (_list.length > 0) {
	      item = _list.shift();
	    } else {
	      _createCount++;
	      if (typeof _createFn === 'function') {
	        item = _createFn();
	      } else {
	        item = {};
	      }
	    }
	    _outCount++;
	    if (typeof _outFn === 'function') {
	      _outFn(item);
	    }
	    return item;
	  };

	  this.release = function(item) {
	    if (_list.length < _max) {
	      _inCount++;
	      if (typeof _inFn === 'function') {
	        _inFn(item);
	      }
	      _list.push(item);
	    } else {
	      _discardCount++;
	      if (typeof _discardFn === 'function') {
	        item = _discardFn(item);
	      }
	    }
	  };

	  this.toString = function() {
	    return " +" + _createCount + " >" + _outCount + " <" + _inCount + " -"
	        + _discardCount + " =" + _list.length + "/" + _max;
	  };
	}

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$5 = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$5 = typeof ASSERT === 'undefined' ? false : ASSERT;








	var DynamicTree_1 = DynamicTree;

	/**
	 * A node in the dynamic tree. The client does not interact with this directly.
	 * 
	 * @prop {AABB} aabb Enlarged AABB
	 * @prop {integer} height 0: leaf, -1: free node
	 */
	function TreeNode(id) {
	  this.id = id;
	  this.aabb = new AABB_1();
	  this.userData = null;
	  this.parent = null;
	  this.child1 = null;
	  this.child2 = null;
	  this.height = -1;

	  this.toString = function() {
	    return this.id + ": " + this.userData;
	  };
	}
	TreeNode.prototype.isLeaf = function() {
	  return this.child1 == null;
	};
	/**
	 * A dynamic AABB tree broad-phase, inspired by Nathanael Presson's btDbvt. A
	 * dynamic tree arranges data in a binary tree to accelerate queries such as
	 * volume queries and ray casts. Leafs are proxies with an AABB. In the tree we
	 * expand the proxy AABB by `aabbExtension` so that the proxy AABB is bigger
	 * than the client object. This allows the client object to move by small
	 * amounts without triggering a tree update.
	 * 
	 * Nodes are pooled and relocatable, so we use node indices rather than
	 * pointers.
	 */
	function DynamicTree() {
	  this.m_root = null;
	  this.m_nodes = {};
	  this.m_lastProxyId = 0;

	  this.m_pool = new Pool_1({
	    create : function() {
	      return new TreeNode();
	    }
	  });
	}
	/**
	 * Get proxy user data.
	 * 
	 * @return the proxy user data or 0 if the id is invalid.
	 */
	DynamicTree.prototype.getUserData = function(id) {
	  var node = this.m_nodes[id];
	  _ASSERT$5 && common.assert(!!node);
	  return node.userData;
	};

	/**
	 * Get the fat AABB for a node id.
	 * 
	 * @return the proxy user data or 0 if the id is invalid.
	 */
	DynamicTree.prototype.getFatAABB = function(id) {
	  var node = this.m_nodes[id];
	  _ASSERT$5 && common.assert(!!node);
	  return node.aabb;
	};

	DynamicTree.prototype.allocateNode = function() {
	  var node = this.m_pool.allocate();
	  node.id = ++this.m_lastProxyId;
	  node.userData = null;
	  node.parent = null;
	  node.child1 = null;
	  node.child2 = null;
	  node.height = -1;
	  this.m_nodes[node.id] = node;
	  return node;
	};

	DynamicTree.prototype.freeNode = function(node) {
	  this.m_pool.release(node);
	  node.height = -1;
	  delete this.m_nodes[node.id];
	};

	/**
	 * Create a proxy in the tree as a leaf node. We return the index of the node
	 * instead of a pointer so that we can grow the node pool.
	 * 
	 * Create a proxy. Provide a tight fitting AABB and a userData pointer.
	 */
	DynamicTree.prototype.createProxy = function(aabb, userData) {
	  _ASSERT$5 && common.assert(AABB_1.isValid(aabb));

	  var node = this.allocateNode();

	  node.aabb.set(aabb);

	  // Fatten the aabb.
	  AABB_1.extend(node.aabb, Settings_1.aabbExtension);

	  node.userData = userData;
	  node.height = 0;

	  this.insertLeaf(node);

	  return node.id;
	};

	/**
	 * Destroy a proxy. This asserts if the id is invalid.
	 */
	DynamicTree.prototype.destroyProxy = function(id) {
	  var node = this.m_nodes[id];

	  _ASSERT$5 && common.assert(!!node);
	  _ASSERT$5 && common.assert(node.isLeaf());

	  this.removeLeaf(node);
	  this.freeNode(node);
	};

	/**
	 * Move a proxy with a swepted AABB. If the proxy has moved outside of its
	 * fattened AABB, then the proxy is removed from the tree and re-inserted.
	 * Otherwise the function returns immediately.
	 * 
	 * @param id
	 * @param aabb
	 * @param {Vec2} d Displacement
	 * 
	 * @return true if the proxy was re-inserted.
	 */
	DynamicTree.prototype.moveProxy = function(id, aabb, d) {
	  _ASSERT$5 && common.assert(AABB_1.isValid(aabb));
	  _ASSERT$5 && common.assert(!d || Vec2_1.isValid(d));

	  var node = this.m_nodes[id];

	  _ASSERT$5 && common.assert(!!node);
	  _ASSERT$5 && common.assert(node.isLeaf());

	  if (node.aabb.contains(aabb)) {
	    return false;
	  }

	  this.removeLeaf(node);

	  node.aabb.set(aabb);

	  // Extend AABB.
	  aabb = node.aabb;
	  AABB_1.extend(aabb, Settings_1.aabbExtension);

	  // Predict AABB displacement.
	  // var d = Vec2.mul(Settings.aabbMultiplier, displacement);

	  if (d.x < 0.0) {
	    aabb.lowerBound.x += d.x * Settings_1.aabbMultiplier;
	  } else {
	    aabb.upperBound.x += d.x * Settings_1.aabbMultiplier;
	  }

	  if (d.y < 0.0) {
	    aabb.lowerBound.y += d.y * Settings_1.aabbMultiplier;
	  } else {
	    aabb.upperBound.y += d.y * Settings_1.aabbMultiplier;
	  }

	  this.insertLeaf(node);

	  return true;
	};

	DynamicTree.prototype.insertLeaf = function(leaf) {
	  _ASSERT$5 && common.assert(AABB_1.isValid(leaf.aabb));

	  if (this.m_root == null) {
	    this.m_root = leaf;
	    this.m_root.parent = null;
	    return;
	  }

	  // Find the best sibling for this node
	  var leafAABB = leaf.aabb;
	  var index = this.m_root;
	  while (index.isLeaf() == false) {
	    var child1 = index.child1;
	    var child2 = index.child2;

	    var area = index.aabb.getPerimeter();

	    var combinedAABB = new AABB_1();
	    combinedAABB.combine(index.aabb, leafAABB);
	    var combinedArea = combinedAABB.getPerimeter();

	    // Cost of creating a new parent for this node and the new leaf
	    var cost = 2.0 * combinedArea;

	    // Minimum cost of pushing the leaf further down the tree
	    var inheritanceCost = 2.0 * (combinedArea - area);

	    // Cost of descending into child1
	    var cost1;
	    if (child1.isLeaf()) {
	      var aabb = new AABB_1();
	      aabb.combine(leafAABB, child1.aabb);
	      cost1 = aabb.getPerimeter() + inheritanceCost;
	    } else {
	      var aabb = new AABB_1();
	      aabb.combine(leafAABB, child1.aabb);
	      var oldArea = child1.aabb.getPerimeter();
	      var newArea = aabb.getPerimeter();
	      cost1 = (newArea - oldArea) + inheritanceCost;
	    }

	    // Cost of descending into child2
	    var cost2;
	    if (child2.isLeaf()) {
	      var aabb = new AABB_1();
	      aabb.combine(leafAABB, child2.aabb);
	      cost2 = aabb.getPerimeter() + inheritanceCost;
	    } else {
	      var aabb = new AABB_1();
	      aabb.combine(leafAABB, child2.aabb);
	      var oldArea = child2.aabb.getPerimeter();
	      var newArea = aabb.getPerimeter();
	      cost2 = newArea - oldArea + inheritanceCost;
	    }

	    // Descend according to the minimum cost.
	    if (cost < cost1 && cost < cost2) {
	      break;
	    }

	    // Descend
	    if (cost1 < cost2) {
	      index = child1;
	    } else {
	      index = child2;
	    }
	  }

	  var sibling = index;

	  // Create a new parent.
	  var oldParent = sibling.parent;
	  var newParent = this.allocateNode();
	  newParent.parent = oldParent;
	  newParent.userData = null;
	  newParent.aabb.combine(leafAABB, sibling.aabb);
	  newParent.height = sibling.height + 1;

	  if (oldParent != null) {
	    // The sibling was not the root.
	    if (oldParent.child1 == sibling) {
	      oldParent.child1 = newParent;
	    } else {
	      oldParent.child2 = newParent;
	    }

	    newParent.child1 = sibling;
	    newParent.child2 = leaf;
	    sibling.parent = newParent;
	    leaf.parent = newParent;
	  } else {
	    // The sibling was the root.
	    newParent.child1 = sibling;
	    newParent.child2 = leaf;
	    sibling.parent = newParent;
	    leaf.parent = newParent;
	    this.m_root = newParent;
	  }

	  // Walk back up the tree fixing heights and AABBs
	  index = leaf.parent;
	  while (index != null) {
	    index = this.balance(index);

	    var child1 = index.child1;
	    var child2 = index.child2;

	    _ASSERT$5 && common.assert(child1 != null);
	    _ASSERT$5 && common.assert(child2 != null);

	    index.height = 1 + _Math.max(child1.height, child2.height);
	    index.aabb.combine(child1.aabb, child2.aabb);

	    index = index.parent;
	  }

	  // validate();
	};

	DynamicTree.prototype.removeLeaf = function(leaf) {
	  if (leaf == this.m_root) {
	    this.m_root = null;
	    return;
	  }

	  var parent = leaf.parent;
	  var grandParent = parent.parent;
	  var sibling;
	  if (parent.child1 == leaf) {
	    sibling = parent.child2;
	  } else {
	    sibling = parent.child1;
	  }

	  if (grandParent != null) {
	    // Destroy parent and connect sibling to grandParent.
	    if (grandParent.child1 == parent) {
	      grandParent.child1 = sibling;
	    } else {
	      grandParent.child2 = sibling;
	    }
	    sibling.parent = grandParent;
	    this.freeNode(parent);

	    // Adjust ancestor bounds.
	    var index = grandParent;
	    while (index != null) {
	      index = this.balance(index);

	      var child1 = index.child1;
	      var child2 = index.child2;

	      index.aabb.combine(child1.aabb, child2.aabb);
	      index.height = 1 + _Math.max(child1.height, child2.height);

	      index = index.parent;
	    }
	  } else {
	    this.m_root = sibling;
	    sibling.parent = null;
	    this.freeNode(parent);
	  }

	  // validate();
	};

	/**
	 * Perform a left or right rotation if node A is imbalanced. Returns the new
	 * root index.
	 */
	DynamicTree.prototype.balance = function(iA) {
	  _ASSERT$5 && common.assert(iA != null);

	  var A = iA;
	  if (A.isLeaf() || A.height < 2) {
	    return iA;
	  }

	  var B = A.child1;
	  var C = A.child2;

	  var balance = C.height - B.height;

	  // Rotate C up
	  if (balance > 1) {
	    var F = C.child1;
	    var G = C.child2;

	    // Swap A and C
	    C.child1 = A;
	    C.parent = A.parent;
	    A.parent = C;

	    // A's old parent should point to C
	    if (C.parent != null) {
	      if (C.parent.child1 == iA) {
	        C.parent.child1 = C;
	      } else {
	        C.parent.child2 = C;
	      }
	    } else {
	      this.m_root = C;
	    }

	    // Rotate
	    if (F.height > G.height) {
	      C.child2 = F;
	      A.child2 = G;
	      G.parent = A;
	      A.aabb.combine(B.aabb, G.aabb);
	      C.aabb.combine(A.aabb, F.aabb);

	      A.height = 1 + _Math.max(B.height, G.height);
	      C.height = 1 + _Math.max(A.height, F.height);
	    } else {
	      C.child2 = G;
	      A.child2 = F;
	      F.parent = A;
	      A.aabb.combine(B.aabb, F.aabb);
	      C.aabb.combine(A.aabb, G.aabb);

	      A.height = 1 + _Math.max(B.height, F.height);
	      C.height = 1 + _Math.max(A.height, G.height);
	    }

	    return C;
	  }

	  // Rotate B up
	  if (balance < -1) {
	    var D = B.child1;
	    var E = B.child2;

	    // Swap A and B
	    B.child1 = A;
	    B.parent = A.parent;
	    A.parent = B;

	    // A's old parent should point to B
	    if (B.parent != null) {
	      if (B.parent.child1 == A) {
	        B.parent.child1 = B;
	      } else {
	        B.parent.child2 = B;
	      }
	    } else {
	      this.m_root = B;
	    }

	    // Rotate
	    if (D.height > E.height) {
	      B.child2 = D;
	      A.child1 = E;
	      E.parent = A;
	      A.aabb.combine(C.aabb, E.aabb);
	      B.aabb.combine(A.aabb, D.aabb);

	      A.height = 1 + _Math.max(C.height, E.height);
	      B.height = 1 + _Math.max(A.height, D.height);
	    } else {
	      B.child2 = E;
	      A.child1 = D;
	      D.parent = A;
	      A.aabb.combine(C.aabb, D.aabb);
	      B.aabb.combine(A.aabb, E.aabb);

	      A.height = 1 + _Math.max(C.height, D.height);
	      B.height = 1 + _Math.max(A.height, E.height);
	    }

	    return B;
	  }

	  return A;
	};

	/**
	 * Compute the height of the binary tree in O(N) time. Should not be called
	 * often.
	 */
	DynamicTree.prototype.getHeight = function() {
	  if (this.m_root == null) {
	    return 0;
	  }

	  return this.m_root.height;
	};

	/**
	 * Get the ratio of the sum of the node areas to the root area.
	 */
	DynamicTree.prototype.getAreaRatio = function() {
	  if (this.m_root == null) {
	    return 0.0;
	  }

	  var root = this.m_root;
	  var rootArea = root.aabb.getPerimeter();

	  var totalArea = 0.0;
	  var node, it = iteratorPool.allocate().preorder(this.m_root);
	  while (node = it.next()) {
	    if (node.height < 0) {
	      // Free node in pool
	      continue;
	    }

	    totalArea += node.aabb.getPerimeter();
	  }

	  iteratorPool.release(it);

	  return totalArea / rootArea;
	};

	/**
	 * Compute the height of a sub-tree.
	 */
	DynamicTree.prototype.computeHeight = function(id) {
	  var node;
	  if (typeof id !== 'undefined') {
	    node = this.m_nodes[id];
	  } else {
	    node = this.m_root;
	  }

	  // _ASSERT && common.assert(0 <= id && id < this.m_nodeCapacity);

	  if (node.isLeaf()) {
	    return 0;
	  }

	  var height1 = this.computeHeight(node.child1.id);
	  var height2 = this.computeHeight(node.child2.id);
	  return 1 + _Math.max(height1, height2);
	};

	DynamicTree.prototype.validateStructure = function(node) {
	  if (node == null) {
	    return;
	  }

	  if (node == this.m_root) {
	    _ASSERT$5 && common.assert(node.parent == null);
	  }

	  var child1 = node.child1;
	  var child2 = node.child2;

	  if (node.isLeaf()) {
	    _ASSERT$5 && common.assert(child1 == null);
	    _ASSERT$5 && common.assert(child2 == null);
	    _ASSERT$5 && common.assert(node.height == 0);
	    return;
	  }

	  // _ASSERT && common.assert(0 <= child1 && child1 < this.m_nodeCapacity);
	  // _ASSERT && common.assert(0 <= child2 && child2 < this.m_nodeCapacity);

	  _ASSERT$5 && common.assert(child1.parent == node);
	  _ASSERT$5 && common.assert(child2.parent == node);

	  this.validateStructure(child1);
	  this.validateStructure(child2);
	};

	DynamicTree.prototype.validateMetrics = function(node) {
	  if (node == null) {
	    return;
	  }

	  var child1 = node.child1;
	  var child2 = node.child2;

	  if (node.isLeaf()) {
	    _ASSERT$5 && common.assert(child1 == null);
	    _ASSERT$5 && common.assert(child2 == null);
	    _ASSERT$5 && common.assert(node.height == 0);
	    return;
	  }

	  // _ASSERT && common.assert(0 <= child1 && child1 < this.m_nodeCapacity);
	  // _ASSERT && common.assert(0 <= child2 && child2 < this.m_nodeCapacity);

	  var height1 = child1.height;
	  var height2 = child2.height;
	  var height = 1 + _Math.max(height1, height2);
	  _ASSERT$5 && common.assert(node.height == height);

	  var aabb = new AABB_1();
	  aabb.combine(child1.aabb, child2.aabb);

	  _ASSERT$5 && common.assert(AABB_1.areEqual(aabb, node.aabb));

	  this.validateMetrics(child1);
	  this.validateMetrics(child2);
	};

	// Validate this tree. For testing.
	DynamicTree.prototype.validate = function() {
	  this.validateStructure(this.m_root);
	  this.validateMetrics(this.m_root);

	  _ASSERT$5 && common.assert(this.getHeight() == this.computeHeight());
	};

	/**
	 * Get the maximum balance of an node in the tree. The balance is the difference
	 * in height of the two children of a node.
	 */
	DynamicTree.prototype.getMaxBalance = function() {
	  var maxBalance = 0;
	  var node, it = iteratorPool.allocate().preorder(this.m_root);
	  while (node = it.next()) {
	    if (node.height <= 1) {
	      continue;
	    }

	    _ASSERT$5 && common.assert(node.isLeaf() == false);

	    var balance = _Math.abs(node.child2.height - node.child1.height);
	    maxBalance = _Math.max(maxBalance, balance);
	  }
	  iteratorPool.release(it);

	  return maxBalance;
	};

	/**
	 * Build an optimal tree. Very expensive. For testing.
	 */
	DynamicTree.prototype.rebuildBottomUp = function() {
	  var nodes = [];
	  var count = 0;

	  // Build array of leaves. Free the rest.
	  var node, it = iteratorPool.allocate().preorder(this.m_root);
	  while (node = it.next()) {
	    if (node.height < 0) {
	      // free node in pool
	      continue;
	    }

	    if (node.isLeaf()) {
	      node.parent = null;
	      nodes[count] = node;
	      ++count;
	    } else {
	      this.freeNode(node);
	    }
	  }
	  iteratorPool.release(it);

	  while (count > 1) {
	    var minCost = Infinity;
	    var iMin = -1, jMin = -1;
	    for (var i = 0; i < count; ++i) {
	      var aabbi = nodes[i].aabb;
	      for (var j = i + 1; j < count; ++j) {
	        var aabbj = nodes[j].aabb;
	        var b = new AABB_1();
	        b.combine(aabbi, aabbj);
	        var cost = b.getPerimeter();
	        if (cost < minCost) {
	          iMin = i;
	          jMin = j;
	          minCost = cost;
	        }
	      }
	    }

	    var child1 = nodes[iMin];
	    var child2 = nodes[jMin];

	    var parent = this.allocateNode();
	    parent.child1 = child1;
	    parent.child2 = child2;
	    parent.height = 1 + _Math.max(child1.height, child2.height);
	    parent.aabb.combine(child1.aabb, child2.aabb);
	    parent.parent = null;

	    child1.parent = parent;
	    child2.parent = parent;

	    nodes[jMin] = nodes[count - 1];
	    nodes[iMin] = parent;
	    --count;
	  }

	  this.m_root = nodes[0];

	  this.validate();
	};

	/**
	 * Shift the world origin. Useful for large worlds. The shift formula is:
	 * position -= newOrigin
	 * 
	 * @param newOrigin The new origin with respect to the old origin
	 */
	DynamicTree.prototype.shiftOrigin = function(newOrigin) {
	  // Build array of leaves. Free the rest.
	  var node, it = iteratorPool.allocate().preorder(this.m_root);
	  while (node = it.next()) {
	    var aabb = node.aabb;
	    aabb.lowerBound.x -= newOrigin.x;
	    aabb.lowerBound.y -= newOrigin.y;
	    aabb.upperBound.x -= newOrigin.x;
	    aabb.upperBound.y -= newOrigin.y;
	  }
	  iteratorPool.release(it);
	};

	/**
	 * @function {DynamicTree~queryCallback}
	 * 
	 * @param id Node id.
	 */

	/**
	 * Query an AABB for overlapping proxies. The callback class is called for each
	 * proxy that overlaps the supplied AABB.
	 * 
	 * @param {DynamicTree~queryCallback} queryCallback
	 */
	DynamicTree.prototype.query = function(aabb, queryCallback) {
	  _ASSERT$5 && common.assert(typeof queryCallback === 'function');
	  var stack = stackPool.allocate();

	  stack.push(this.m_root);
	  while (stack.length > 0) {
	    var node = stack.pop();
	    if (node == null) {
	      continue;
	    }

	    if (AABB_1.testOverlap(node.aabb, aabb)) {
	      if (node.isLeaf()) {
	        var proceed = queryCallback(node.id);
	        if (proceed == false) {
	          return;
	        }
	      } else {
	        stack.push(node.child1);
	        stack.push(node.child2);
	      }
	    }
	  }

	  stackPool.release(stack);
	};

	/**
	 * Ray-cast against the proxies in the tree. This relies on the callback to
	 * perform a exact ray-cast in the case were the proxy contains a shape. The
	 * callback also performs the any collision filtering. This has performance
	 * roughly equal to k * log(n), where k is the number of collisions and n is the
	 * number of proxies in the tree.
	 * 
	 * @param input The ray-cast input data. The ray extends from p1 to p1 +
	 *          maxFraction * (p2 - p1).
	 * @param rayCastCallback A function that is called for each proxy that is hit by
	 *          the ray.
	 */
	DynamicTree.prototype.rayCast = function(input, rayCastCallback) { // TODO GC
	  _ASSERT$5 && common.assert(typeof rayCastCallback === 'function');
	  var p1 = input.p1;
	  var p2 = input.p2;
	  var r = Vec2_1.sub(p2, p1);
	  _ASSERT$5 && common.assert(r.lengthSquared() > 0.0);
	  r.normalize();

	  // v is perpendicular to the segment.
	  var v = Vec2_1.cross(1.0, r);
	  var abs_v = Vec2_1.abs(v);

	  // Separating axis for segment (Gino, p80).
	  // |dot(v, p1 - c)| > dot(|v|, h)

	  var maxFraction = input.maxFraction;

	  // Build a bounding box for the segment.
	  var segmentAABB = new AABB_1();
	  var t = Vec2_1.combine((1 - maxFraction), p1, maxFraction, p2);
	  segmentAABB.combinePoints(p1, t);

	  var stack = stackPool.allocate();
	  var subInput = inputPool.allocate();

	  stack.push(this.m_root);
	  while (stack.length > 0) {
	    var node = stack.pop();
	    if (node == null) {
	      continue;
	    }

	    if (AABB_1.testOverlap(node.aabb, segmentAABB) == false) {
	      continue;
	    }

	    // Separating axis for segment (Gino, p80).
	    // |dot(v, p1 - c)| > dot(|v|, h)
	    var c = node.aabb.getCenter();
	    var h = node.aabb.getExtents();
	    var separation = _Math.abs(Vec2_1.dot(v, Vec2_1.sub(p1, c)))
	        - Vec2_1.dot(abs_v, h);
	    if (separation > 0.0) {
	      continue;
	    }

	    if (node.isLeaf()) {
	      subInput.p1 = Vec2_1.clone(input.p1);
	      subInput.p2 = Vec2_1.clone(input.p2);
	      subInput.maxFraction = maxFraction;

	      var value = rayCastCallback(subInput, node.id);

	      if (value == 0.0) {
	        // The client has terminated the ray cast.
	        return;
	      }

	      if (value > 0.0) {
	        // update segment bounding box.
	        maxFraction = value;
	        t = Vec2_1.combine((1 - maxFraction), p1, maxFraction, p2);
	        segmentAABB.combinePoints(p1, t);
	      }
	    } else {
	      stack.push(node.child1);
	      stack.push(node.child2);
	    }
	  }

	  stackPool.release(stack);
	  inputPool.release(subInput);
	};

	var inputPool = new Pool_1({
	  create : function() {
	    return {};
	  },
	  release : function(stack) {
	  }
	});

	var stackPool = new Pool_1({
	  create : function() {
	    return [];
	  },
	  release : function(stack) {
	    stack.length = 0;
	  }
	});

	var iteratorPool = new Pool_1({
	  create : function() {
	    return new Iterator();
	  },
	  release : function(iterator) {
	    iterator.close();
	  }
	});

	function Iterator() {
	  var parents = [];
	  var states = [];
	  return {
	    preorder : function(root) {
	      parents.length = 0;
	      parents.push(root);
	      states.length = 0;
	      states.push(0);
	      return this;
	    },
	    next : function() {
	      while (parents.length > 0) {
	        var i = parents.length - 1;
	        var node = parents[i];
	        if (states[i] === 0) {
	          states[i] = 1;
	          return node;
	        }
	        if (states[i] === 1) {
	          states[i] = 2;
	          if (node.child1) {
	            parents.push(node.child1);
	            states.push(1);
	            return node.child1;
	          }
	        }
	        if (states[i] === 2) {
	          states[i] = 3;
	          if (node.child2) {
	            parents.push(node.child2);
	            states.push(1);
	            return node.child2;
	          }
	        }
	        parents.pop();
	        states.pop();
	      }
	    },
	    close : function() {
	      parents.length = 0;
	    }
	  };
	}

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$6 = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$6 = typeof ASSERT === 'undefined' ? false : ASSERT;







	var BroadPhase_1 = BroadPhase;

	/**
	 * The broad-phase wraps and extends a dynamic-tree to keep track of moved
	 * objects and query them on update.
	 */
	function BroadPhase() {
	  this.m_tree = new DynamicTree_1();
	  this.m_proxyCount = 0;
	  this.m_moveBuffer = [];
	  this.queryCallback = this.queryCallback.bind(this);
	}
	/**
	 * Get user data from a proxy. Returns null if the id is invalid.
	 */
	BroadPhase.prototype.getUserData = function(proxyId) {
	  return this.m_tree.getUserData(proxyId);
	};

	/**
	 * Test overlap of fat AABBs.
	 */
	BroadPhase.prototype.testOverlap = function(proxyIdA, proxyIdB) {
	  var aabbA = this.m_tree.getFatAABB(proxyIdA);
	  var aabbB = this.m_tree.getFatAABB(proxyIdB);
	  return AABB_1.testOverlap(aabbA, aabbB);
	};

	/**
	 * Get the fat AABB for a proxy.
	 */
	BroadPhase.prototype.getFatAABB = function(proxyId) {
	  return this.m_tree.getFatAABB(proxyId);
	};

	/**
	 * Get the number of proxies.
	 */
	BroadPhase.prototype.getProxyCount = function() {
	  return this.m_proxyCount;
	};

	/**
	 * Get the height of the embedded tree.
	 */
	BroadPhase.prototype.getTreeHeight = function() {
	  return this.m_tree.getHeight();
	};

	/**
	 * Get the balance (integer) of the embedded tree.
	 */
	BroadPhase.prototype.getTreeBalance = function() {
	  return this.m_tree.getMaxBalance();
	};

	/**
	 * Get the quality metric of the embedded tree.
	 */
	BroadPhase.prototype.getTreeQuality = function() {
	  return this.m_tree.getAreaRatio();
	};

	/**
	 * Query an AABB for overlapping proxies. The callback class is called for each
	 * proxy that overlaps the supplied AABB.
	 */
	BroadPhase.prototype.query = function(aabb, queryCallback) {
	  this.m_tree.query(aabb, queryCallback);
	};

	/**
	 * Ray-cast against the proxies in the tree. This relies on the callback to
	 * perform a exact ray-cast in the case were the proxy contains a shape. The
	 * callback also performs the any collision filtering. This has performance
	 * roughly equal to k * log(n), where k is the number of collisions and n is the
	 * number of proxies in the tree.
	 * 
	 * @param input The ray-cast input data. The ray extends from p1 to p1 +
	 *          maxFraction * (p2 - p1).
	 * @param rayCastCallback A function that is called for each proxy that is hit by
	 *          the ray.
	 */
	BroadPhase.prototype.rayCast = function(input, rayCastCallback) {
	  this.m_tree.rayCast(input, rayCastCallback);
	};

	/**
	 * Shift the world origin. Useful for large worlds. The shift formula is:
	 * position -= newOrigin
	 * 
	 * @param newOrigin The new origin with respect to the old origin
	 */
	BroadPhase.prototype.shiftOrigin = function(newOrigin) {
	  this.m_tree.shiftOrigin(newOrigin);
	};

	/**
	 * Create a proxy with an initial AABB. Pairs are not reported until UpdatePairs
	 * is called.
	 */
	BroadPhase.prototype.createProxy = function(aabb, userData) {
	  _ASSERT$6 && common.assert(AABB_1.isValid(aabb));
	  var proxyId = this.m_tree.createProxy(aabb, userData);
	  this.m_proxyCount++;
	  this.bufferMove(proxyId);
	  return proxyId;
	};

	/**
	 * Destroy a proxy. It is up to the client to remove any pairs.
	 */
	BroadPhase.prototype.destroyProxy = function(proxyId) {
	  this.unbufferMove(proxyId);
	  this.m_proxyCount--;
	  this.m_tree.destroyProxy(proxyId);
	};

	/**
	 * Call moveProxy as many times as you like, then when you are done call
	 * UpdatePairs to finalized the proxy pairs (for your time step).
	 */
	BroadPhase.prototype.moveProxy = function(proxyId, aabb, displacement) {
	  _ASSERT$6 && common.assert(AABB_1.isValid(aabb));
	  var changed = this.m_tree.moveProxy(proxyId, aabb, displacement);
	  if (changed) {
	    this.bufferMove(proxyId);
	  }
	};

	/**
	 * Call to trigger a re-processing of it's pairs on the next call to
	 * UpdatePairs.
	 */
	BroadPhase.prototype.touchProxy = function(proxyId) {
	  this.bufferMove(proxyId);
	};

	BroadPhase.prototype.bufferMove = function(proxyId) {
	  this.m_moveBuffer.push(proxyId);
	};

	BroadPhase.prototype.unbufferMove = function(proxyId) {
	  for (var i = 0; i < this.m_moveBuffer.length; ++i) {
	    if (this.m_moveBuffer[i] == proxyId) {
	      this.m_moveBuffer[i] = null;
	    }
	  }
	};

	/**
	 * @function BroadPhase~addPair
	 * @param {Object} userDataA
	 * @param {Object} userDataB
	 */

	/**
	 * Update the pairs. This results in pair callbacks. This can only add pairs.
	 * 
	 * @param {BroadPhase~AddPair} addPairCallback
	 */
	BroadPhase.prototype.updatePairs = function(addPairCallback) {
	  _ASSERT$6 && common.assert(typeof addPairCallback === 'function');
	  this.m_callback = addPairCallback;

	  // Perform tree queries for all moving proxies.
	  while (this.m_moveBuffer.length > 0) {
	    this.m_queryProxyId = this.m_moveBuffer.pop();
	    if (this.m_queryProxyId === null) {
	      continue;
	    }

	    // We have to query the tree with the fat AABB so that
	    // we don't fail to create a pair that may touch later.
	    var fatAABB = this.m_tree.getFatAABB(this.m_queryProxyId);

	    // Query tree, create pairs and add them pair buffer.
	    this.m_tree.query(fatAABB, this.queryCallback);
	  }

	  // Try to keep the tree balanced.
	  // this.m_tree.rebalance(4);
	};

	BroadPhase.prototype.queryCallback = function(proxyId) {
	  // A proxy cannot form a pair with itself.
	  if (proxyId == this.m_queryProxyId) {
	    return true;
	  }

	  var proxyIdA = _Math.min(proxyId, this.m_queryProxyId);
	  var proxyIdB = _Math.max(proxyId, this.m_queryProxyId);

	  // TODO: Skip any duplicate pairs.

	  var userDataA = this.m_tree.getUserData(proxyIdA);
	  var userDataB = this.m_tree.getUserData(proxyIdB);

	  // Send the pairs back to the client.
	  this.m_callback(userDataA, userDataB);

	  return true;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$7 = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$7 = typeof ASSERT === 'undefined' ? false : ASSERT;

	var Rot_1 = Rot;





	// TODO merge with Transform

	/**
	 * Initialize from an angle in radians.
	 */
	function Rot(angle) {
	  if (!(this instanceof Rot)) {
	    return new Rot(angle);
	  }
	  if (typeof angle === 'number') {
	    this.setAngle(angle);
	  } else if (typeof angle === 'object') {
	      this.set(angle);
	  } else {
	    this.setIdentity();
	  }
	}

	Rot.neo = function(angle) {
	  var obj = Object.create(Rot.prototype);
	  obj.setAngle(angle);
	  return obj;
	};

	Rot.clone = function(rot) {
	  _ASSERT$7 && Rot.assert(rot);
	  var obj = Object.create(Rot.prototype);
	  obj.s = rot.s;
	  obj.c = rot.c;
	  return obj;
	};

	Rot.identity = function() {
	  var obj = Object.create(Rot.prototype);
	  obj.s = 0.0;
	  obj.c = 1.0;
	  return obj;
	};

	Rot.isValid = function(o) {
	  return o && _Math.isFinite(o.s) && _Math.isFinite(o.c);
	};

	Rot.assert = function(o) {
	  if (!_ASSERT$7) return;
	  if (!Rot.isValid(o)) {
	    _DEBUG$7 && common.debug(o);
	    throw new Error('Invalid Rot!');
	  }
	};

	/**
	 * Set to the identity rotation.
	 */
	Rot.prototype.setIdentity = function() {
	  this.s = 0.0;
	  this.c = 1.0;
	};

	Rot.prototype.set = function(angle) {
	  if (typeof angle === 'object') {
	    _ASSERT$7 && Rot.assert(angle);
	    this.s = angle.s;
	    this.c = angle.c;

	  } else {
	    _ASSERT$7 && _Math.assert(angle);
	    // TODO_ERIN optimize
	    this.s = _Math.sin(angle);
	    this.c = _Math.cos(angle);
	  }
	};

	/**
	 * Set using an angle in radians.
	 */
	Rot.prototype.setAngle = function(angle) {
	  _ASSERT$7 && _Math.assert(angle);
	  // TODO_ERIN optimize
	  this.s = _Math.sin(angle);
	  this.c = _Math.cos(angle);
	};

	/**
	 * Get the angle in radians.
	 */
	Rot.prototype.getAngle = function() {
	  return _Math.atan2(this.s, this.c);
	};

	/**
	 * Get the x-axis.
	 */
	Rot.prototype.getXAxis = function() {
	  return Vec2_1.neo(this.c, this.s);
	};

	/**
	 * Get the u-axis.
	 */
	Rot.prototype.getYAxis = function() {
	  return Vec2_1.neo(-this.s, this.c);
	};

	/**
	 * Multiply two rotations: q * r
	 * 
	 * @returns Rot
	 * 
	 * Rotate a vector
	 * 
	 * @returns Vec2
	 */
	Rot.mul = function(rot, m) {
	  _ASSERT$7 && Rot.assert(rot);
	  if ('c' in m && 's' in m) {
	    _ASSERT$7 && Rot.assert(m);
	    // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
	    // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]
	    // s = qs * rc + qc * rs
	    // c = qc * rc - qs * rs
	    var qr = Rot.identity();
	    qr.s = rot.s * m.c + rot.c * m.s;
	    qr.c = rot.c * m.c - rot.s * m.s;
	    return qr;

	  } else if ('x' in m && 'y' in m) {
	    _ASSERT$7 && Vec2_1.assert(m);
	    return Vec2_1.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);
	  }
	};

	Rot.mulRot = function(rot, m) {
	  _ASSERT$7 && Rot.assert(rot);
	  _ASSERT$7 && Rot.assert(m);
	  // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
	  // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]
	  // s = qs * rc + qc * rs
	  // c = qc * rc - qs * rs
	  var qr = Rot.identity();
	  qr.s = rot.s * m.c + rot.c * m.s;
	  qr.c = rot.c * m.c - rot.s * m.s;
	  return qr;
	};

	Rot.mulVec2 = function(rot, m) {
	  _ASSERT$7 && Rot.assert(rot);
	  _ASSERT$7 && Vec2_1.assert(m);
	  return Vec2_1.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);
	};

	Rot.mulSub = function(rot, v, w) {
	  var x = rot.c * (v.x - w.x) - rot.s * (v.y - w.y);
	  var y = rot.s * (v.x - w.x) + rot.c * (v.y - w.y);
	  return Vec2_1.neo(x, y);
	};

	/**
	 * Transpose multiply two rotations: qT * r
	 * 
	 * @returns Rot
	 * 
	 * Inverse rotate a vector
	 * 
	 * @returns Vec2
	 */
	Rot.mulT = function(rot, m) {
	  if ('c' in m && 's' in m) {
	    _ASSERT$7 && Rot.assert(m);
	    // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
	    // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]
	    // s = qc * rs - qs * rc
	    // c = qc * rc + qs * rs
	    var qr = Rot.identity();
	    qr.s = rot.c * m.s - rot.s * m.c;
	    qr.c = rot.c * m.c + rot.s * m.s;
	    return qr;

	  } else if ('x' in m && 'y' in m) {
	    _ASSERT$7 && Vec2_1.assert(m);
	    return Vec2_1.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);
	  }
	};

	Rot.mulTRot = function(rot, m) {
	  _ASSERT$7 && Rot.assert(m);
	  // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
	  // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]
	  // s = qc * rs - qs * rc
	  // c = qc * rc + qs * rs
	  var qr = Rot.identity();
	  qr.s = rot.c * m.s - rot.s * m.c;
	  qr.c = rot.c * m.c + rot.s * m.s;
	  return qr;
	};

	Rot.mulTVec2 = function(rot, m) {
	  _ASSERT$7 && Vec2_1.assert(m);
	  return Vec2_1.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$8 = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$8 = typeof ASSERT === 'undefined' ? false : ASSERT;

	var Transform_1 = Transform;





	// TODO merge with Rot

	/**
	 * A transform contains translation and rotation. It is used to represent the
	 * position and orientation of rigid frames. Initialize using a position vector
	 * and a rotation.
	 *
	 * @prop {Vec2} position
	 * @prop {Rot} rotation
	 */
	function Transform(position, rotation) {
	  if (!(this instanceof Transform)) {
	    return new Transform(position, rotation);
	  }
	  this.p = Vec2_1.zero();
	  this.q = Rot_1.identity();
	  if (typeof position !== 'undefined') {
	    this.p.set(position);
	  }
	  if (typeof rotation !== 'undefined') {
	    this.q.set(rotation);
	  }
	}
	Transform.clone = function(xf) {
	  var obj = Object.create(Transform.prototype);
	  obj.p = Vec2_1.clone(xf.p);
	  obj.q = Rot_1.clone(xf.q);
	  return obj;
	};

	Transform.neo = function(position, rotation) {
	  var obj = Object.create(Transform.prototype);
	  obj.p = Vec2_1.clone(position);
	  obj.q = Rot_1.clone(rotation);
	  return obj;
	};

	Transform.identity = function() {
	  var obj = Object.create(Transform.prototype);
	  obj.p = Vec2_1.zero();
	  obj.q = Rot_1.identity();
	  return obj;
	};

	/**
	 * Set this to the identity transform.
	 */
	Transform.prototype.setIdentity = function() {
	  this.p.setZero();
	  this.q.setIdentity();
	};

	/**
	 * Set this based on the position and angle.
	 */
	Transform.prototype.set = function(a, b) {
	  if (typeof b === 'undefined') {
	    this.p.set(a.p);
	    this.q.set(a.q);
	  } else {
	    this.p.set(a);
	    this.q.set(b);
	  }
	};

	Transform.isValid = function(o) {
	  return o && Vec2_1.isValid(o.p) && Rot_1.isValid(o.q);
	};

	Transform.assert = function(o) {
	  if (!_ASSERT$8) return;
	  if (!Transform.isValid(o)) {
	    _DEBUG$8 && common.debug(o);
	    throw new Error('Invalid Transform!');
	  }
	};

	/**
	 * @param {Transform} a
	 * @param {Vec2} b
	 * @returns {Vec2}
	 *
	 * @param {Transform} a
	 * @param {Transform} b
	 * @returns {Transform}
	 */
	Transform.mul = function(a, b) {
	  _ASSERT$8 && Transform.assert(a);
	  if (Array.isArray(b)) {
	    var arr = [];
	    for (var i = 0; i < b.length; i++) {
	      arr[i] = Transform.mul(a, b[i]);
	    }
	    return arr;

	  } else if ('x' in b && 'y' in b) {
	    _ASSERT$8 && Vec2_1.assert(b);
	    var x = (a.q.c * b.x - a.q.s * b.y) + a.p.x;
	    var y = (a.q.s * b.x + a.q.c * b.y) + a.p.y;
	    return Vec2_1.neo(x, y);

	  } else if ('p' in b && 'q' in b) {
	    _ASSERT$8 && Transform.assert(b);
	    // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
	    // = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
	    var xf = Transform.identity();
	    xf.q = Rot_1.mulRot(a.q, b.q);
	    xf.p = Vec2_1.add(Rot_1.mulVec2(a.q, b.p), a.p);
	    return xf;
	  }
	};

	/**
	 * @deprecated Use mulFn instead.
	 */
	Transform.mulAll = function(a, b) {
	  _ASSERT$8 && Transform.assert(a);
	  var arr = [];
	  for (var i = 0; i < b.length; i++) {
	    arr[i] = Transform.mul(a, b[i]);
	  }
	  return arr;
	};

	/**
	 * @experimental
	 */
	Transform.mulFn = function(a) {
	  _ASSERT$8 && Transform.assert(a);
	  return function(b) {
	    return Transform.mul(a, b);
	  };
	};

	Transform.mulVec2 = function(a, b) {
	  _ASSERT$8 && Transform.assert(a);
	  _ASSERT$8 && Vec2_1.assert(b);
	  var x = (a.q.c * b.x - a.q.s * b.y) + a.p.x;
	  var y = (a.q.s * b.x + a.q.c * b.y) + a.p.y;
	  return Vec2_1.neo(x, y);
	};

	Transform.mulXf = function(a, b) {
	  _ASSERT$8 && Transform.assert(a);
	  _ASSERT$8 && Transform.assert(b);
	  // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
	  // = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
	  var xf = Transform.identity();
	  xf.q = Rot_1.mulRot(a.q, b.q);
	  xf.p = Vec2_1.add(Rot_1.mulVec2(a.q, b.p), a.p);
	  return xf;
	};

	/**
	 * @param {Transform} a
	 * @param {Vec2} b
	 * @returns {Vec2}
	 *
	 * @param {Transform} a
	 * @param {Transform} b
	 * @returns {Transform}
	 */
	Transform.mulT = function(a, b) {
	  _ASSERT$8 && Transform.assert(a);
	  if ('x' in b && 'y' in b) {
	    _ASSERT$8 && Vec2_1.assert(b);
	    var px = b.x - a.p.x;
	    var py = b.y - a.p.y;
	    var x = (a.q.c * px + a.q.s * py);
	    var y = (-a.q.s * px + a.q.c * py);
	    return Vec2_1.neo(x, y);

	  } else if ('p' in b && 'q' in b) {
	    _ASSERT$8 && Transform.assert(b);
	    // v2 = A.q' * (B.q * v1 + B.p - A.p)
	    // = A.q' * B.q * v1 + A.q' * (B.p - A.p)
	    var xf = Transform.identity();
	    xf.q.set(Rot_1.mulTRot(a.q, b.q));
	    xf.p.set(Rot_1.mulTVec2(a.q, Vec2_1.sub(b.p, a.p)));
	    return xf;
	  }
	};

	Transform.mulTVec2 = function(a, b) {
	  _ASSERT$8 && Transform.assert(a);
	  _ASSERT$8 && Vec2_1.assert(b);
	  var px = b.x - a.p.x;
	  var py = b.y - a.p.y;
	  var x = (a.q.c * px + a.q.s * py);
	  var y = (-a.q.s * px + a.q.c * py);
	  return Vec2_1.neo(x, y);
	};

	Transform.mulTXf = function(a, b) {
	  _ASSERT$8 && Transform.assert(a);
	  _ASSERT$8 && Transform.assert(b);
	  // v2 = A.q' * (B.q * v1 + B.p - A.p)
	  // = A.q' * B.q * v1 + A.q' * (B.p - A.p)
	  var xf = Transform.identity();
	  xf.q.set(Rot_1.mulTRot(a.q, b.q));
	  xf.p.set(Rot_1.mulTVec2(a.q, Vec2_1.sub(b.p, a.p)));
	  return xf;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$9 = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$9 = typeof ASSERT === 'undefined' ? false : ASSERT;

	var Sweep_1 = Sweep;







	/**
	 * This describes the motion of a body/shape for TOI computation. Shapes are
	 * defined with respect to the body origin, which may not coincide with the
	 * center of mass. However, to support dynamics we must interpolate the center
	 * of mass position.
	 * 
	 * @prop {Vec2} localCenter Local center of mass position
	 * @prop {Vec2} c World center position
	 * @prop {float} a World angle
	 * @prop {float} alpha0 Fraction of the current time step in the range [0,1], c0
	 *       and a0 are c and a at alpha0.
	 */
	function Sweep(c, a) {
	  _ASSERT$9 && common.assert(typeof c === 'undefined');
	  _ASSERT$9 && common.assert(typeof a === 'undefined');
	  this.localCenter = Vec2_1.zero();
	  this.c = Vec2_1.zero();
	  this.a = 0;
	  this.alpha0 = 0;
	  this.c0 = Vec2_1.zero();
	  this.a0 = 0;
	}

	Sweep.prototype.setTransform = function(xf) {
	  var c = Transform_1.mulVec2(xf, this.localCenter);
	  this.c.set(c);
	  this.c0.set(c);

	  this.a = xf.q.getAngle();
	  this.a0 = xf.q.getAngle();
	};

	Sweep.prototype.setLocalCenter = function(localCenter, xf) {
	  this.localCenter.set(localCenter);

	  var c = Transform_1.mulVec2(xf, this.localCenter);
	  this.c.set(c);
	  this.c0.set(c);
	};

	/**
	 * Get the interpolated transform at a specific time.
	 * 
	 * @param xf
	 * @param beta A factor in [0,1], where 0 indicates alpha0
	 */
	Sweep.prototype.getTransform = function(xf, beta) {
	  beta = typeof beta === 'undefined' ? 0 : beta;
	  xf.q.setAngle((1.0 - beta) * this.a0 + beta * this.a);
	  xf.p.setCombine((1.0 - beta), this.c0, beta, this.c);

	  // shift to origin
	  xf.p.sub(Rot_1.mulVec2(xf.q, this.localCenter));
	};

	/**
	 * Advance the sweep forward, yielding a new initial state.
	 * 
	 * @param {float} alpha The new initial time
	 */
	Sweep.prototype.advance = function(alpha) {
	  _ASSERT$9 && common.assert(this.alpha0 < 1.0);
	  var beta = (alpha - this.alpha0) / (1.0 - this.alpha0);
	  this.c0.setCombine(beta, this.c, 1 - beta, this.c0);
	  this.a0 = beta * this.a + (1 - beta) * this.a0;
	  this.alpha0 = alpha;
	};

	Sweep.prototype.forward = function() {
	  this.a0 = this.a;
	  this.c0.set(this.c);
	};

	/**
	 * normalize the angles in radians to be between -pi and pi.
	 */
	Sweep.prototype.normalize = function() {
	  var a0 = _Math.mod(this.a0, -_Math.PI, +_Math.PI);
	  this.a -= this.a0 - a0;
	  this.a0 = a0;
	};

	Sweep.prototype.clone = function() {
	  var clone = new Sweep();
	  clone.localCenter.set(this.localCenter);
	  clone.alpha0 = this.alpha0;
	  clone.a0 = this.a0;
	  clone.a = this.a;
	  clone.c0.set(this.c0);
	  clone.c.set(this.c);
	  return clone;
	};

	Sweep.prototype.set = function(that) {
	  this.localCenter.set(that.localCenter);
	  this.alpha0 = that.alpha0;
	  this.a0 = that.a0;
	  this.a = that.a;
	  this.c0.set(that.c0);
	  this.c.set(that.c);
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$a = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$a = typeof ASSERT === 'undefined' ? false : ASSERT;

	var Velocity_1 = Velocity;



	/**
	 * @prop {Vec2} v linear
	 * @prop {float} w angular
	 */
	function Velocity() {
	  this.v = Vec2_1.zero();
	  this.w = 0;
	}

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$b = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$b = typeof ASSERT === 'undefined' ? false : ASSERT;

	var Position_1 = Position;




	/**
	 * @prop {Vec2} c location
	 * @prop {float} a angle
	 */
	function Position() {
	  this.c = Vec2_1.zero();
	  this.a = 0;
	}

	Position.prototype.getTransform = function(xf, p) {
	  xf.q.set(this.a);
	  xf.p.set(Vec2_1.sub(this.c, Rot_1.mulVec2(xf.q, p)));
	  return xf;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$c = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$c = typeof ASSERT === 'undefined' ? false : ASSERT;

	var Shape_1 = Shape;



	/**
	 * A shape is used for collision detection. You can create a shape however you
	 * like. Shapes used for simulation in World are created automatically when a
	 * Fixture is created. Shapes may encapsulate one or more child shapes.
	 */
	function Shape() {
	  this.m_type;
	  this.m_radius;
	}

	Shape.prototype._reset = function() {
	};

	Shape.prototype._serialize = function() {
	  return {};
	};

	Shape.TYPES = {};

	Shape._deserialize = function(data, context, restore) {
	  var clazz = Shape.TYPES[data.type];
	  return clazz && restore(clazz, data);
	};

	Shape.isValid = function(shape) {
	  return !!shape;
	};

	Shape.prototype.getRadius = function() {
	  return this.m_radius;
	};

	/**
	 * Get the type of this shape. You can use this to down cast to the concrete
	 * shape.
	 * 
	 * @return the shape type.
	 */
	Shape.prototype.getType = function() {
	  return this.m_type;
	};

	/**
	 * @deprecated Shapes should be treated as immutable.
	 *
	 * clone the concrete shape.
	 */
	Shape.prototype._clone = function() {
	};

	/**
	 * // Get the number of child primitives.
	 */
	Shape.prototype.getChildCount = function() {
	};

	/**
	 * Test a point for containment in this shape. This only works for convex
	 * shapes.
	 * 
	 * @param {Transform} xf The shape world transform.
	 * @param p A point in world coordinates.
	 */
	Shape.prototype.testPoint = function(xf, p) {
	};

	/**
	 * Cast a ray against a child shape.
	 * 
	 * @param {RayCastOutput} output The ray-cast results.
	 * @param {RayCastInput} input The ray-cast input parameters.
	 * @param {Transform} transform The transform to be applied to the shape.
	 * @param childIndex The child shape index
	 */
	Shape.prototype.rayCast = function(output, input, transform, childIndex) {
	};

	/**
	 * Given a transform, compute the associated axis aligned bounding box for a
	 * child shape.
	 * 
	 * @param {AABB} aabb Returns the axis aligned box.
	 * @param {Transform} xf The world transform of the shape.
	 * @param childIndex The child shape
	 */
	Shape.prototype.computeAABB = function(aabb, xf, childIndex) {
	};

	/**
	 * Compute the mass properties of this shape using its dimensions and density.
	 * The inertia tensor is computed about the local origin.
	 * 
	 * @param {MassData} massData Returns the mass data for this shape.
	 * @param density The density in kilograms per meter squared.
	 */
	Shape.prototype.computeMass = function(massData, density) {
	};

	/**
	 * @param {DistanceProxy} proxy
	 */
	Shape.prototype.computeDistanceProxy = function(proxy) {
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$d = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$d = typeof ASSERT === 'undefined' ? false : ASSERT;

	var Fixture_1 = Fixture;











	/**
	 * @typedef {Object} FixtureDef
	 *
	 * A fixture definition is used to create a fixture. This class defines an
	 * abstract fixture definition. You can reuse fixture definitions safely.
	 * 
	 * @prop friction The friction coefficient, usually in the range [0,1]
	 * @prop restitution The restitution (elasticity) usually in the range [0,1]
	 * @prop density The density, usually in kg/m^2
	 * @prop isSensor A sensor shape collects contact information but never
	 *       generates a collision response
	 * @prop userData
	 * @prop filterGroupIndex Zero, positive or negative collision group. Fixtures with same positive groupIndex always collide and fixtures with same
	 * negative groupIndex never collide.
	 * @prop filterCategoryBits Collision category bit or bits that this fixture belongs
	 *       to. If groupIndex is zero or not matching, then at least one bit in this fixture
	 * categoryBits should match other fixture maskBits and vice versa.
	 * @prop filterMaskBits Collision category bit or bits that this fixture accept for
	 *       collision.
	 */
	var FixtureDef = {
	  userData : null,
	  friction : 0.2,
	  restitution : 0.0,
	  density : 0.0,
	  isSensor : false,

	  filterGroupIndex : 0,
	  filterCategoryBits : 0x0001,
	  filterMaskBits : 0xFFFF
	};

	/**
	 * This proxy is used internally to connect shape children to the broad-phase.
	 */
	function FixtureProxy(fixture, childIndex) {
	  this.aabb = new AABB_1();
	  this.fixture = fixture;
	  this.childIndex = childIndex;
	  this.proxyId;
	}
	/**
	 * A fixture is used to attach a shape to a body for collision detection. A
	 * fixture inherits its transform from its parent. Fixtures hold additional
	 * non-geometric data such as friction, collision filters, etc. Fixtures are
	 * created via Body.createFixture.
	 * 
	 * @param {Body} body
	 * @param {Shape|FixtureDef} shape Shape of fixture definition.
	 * @param {FixtureDef|number} def Fixture definition or number.
	 */
	function Fixture(body, shape, def) {
	  if (shape.shape) {
	    def = shape;
	    shape = shape.shape;

	  } else if (typeof def === 'number') {
	    def = {density : def};
	  }

	  def = options(def, FixtureDef);

	  this.m_body = body;

	  this.m_friction = def.friction;
	  this.m_restitution = def.restitution;
	  this.m_density = def.density;
	  this.m_isSensor = def.isSensor;

	  this.m_filterGroupIndex = def.filterGroupIndex;
	  this.m_filterCategoryBits = def.filterCategoryBits;
	  this.m_filterMaskBits = def.filterMaskBits;

	  // TODO validate shape
	  this.m_shape = shape; //.clone();

	  this.m_next = null;

	  this.m_proxies = [];
	  this.m_proxyCount = 0;

	  var childCount = this.m_shape.getChildCount();
	  for (var i = 0; i < childCount; ++i) {
	    this.m_proxies[i] = new FixtureProxy(this, i);
	  }

	  this.m_userData = def.userData;
	}
	/**
	 * Re-setup fixture.
	 * @private
	 */
	Fixture.prototype._reset = function() {
	  var body = this.getBody();
	  var broadPhase = body.m_world.m_broadPhase;
	  this.destroyProxies(broadPhase);
	  if (this.m_shape._reset) {
	    this.m_shape._reset();
	  }
	  var childCount = this.m_shape.getChildCount();
	  for (var i = 0; i < childCount; ++i) {
	    this.m_proxies[i] = new FixtureProxy(this, i);
	  }
	  this.createProxies(broadPhase, body.m_xf);
	  body.resetMassData();
	};

	Fixture.prototype._serialize = function() {
	  return {
	    friction: this.m_friction,
	    restitution: this.m_restitution,
	    density: this.m_density,
	    isSensor: this.m_isSensor,

	    filterGroupIndex: this.m_filterGroupIndex,
	    filterCategoryBits: this.m_filterCategoryBits,
	    filterMaskBits: this.m_filterMaskBits,

	    shape: this.m_shape,
	  };
	};

	Fixture._deserialize = function(data, body, restore) {
	  var shape = restore(Shape_1, data.shape);
	  var fixture = shape && new Fixture(body, shape, data);
	  return fixture;
	};

	/**
	 * Get the type of the child shape. You can use this to down cast to the
	 * concrete shape.
	 */
	Fixture.prototype.getType = function() {
	  return this.m_shape.getType();
	};

	/**
	 * Get the child shape. You can modify the child shape, however you should not
	 * change the number of vertices because this will crash some collision caching
	 * mechanisms. Manipulating the shape may lead to non-physical behavior.
	 */
	Fixture.prototype.getShape = function() {
	  return this.m_shape;
	};
	/**
	 * A sensor shape collects contact information but never generates a collision
	 * response.
	 */
	Fixture.prototype.isSensor = function() {
	  return this.m_isSensor;
	};

	/**
	 * Set if this fixture is a sensor.
	 */
	Fixture.prototype.setSensor = function(sensor) {
	  if (sensor != this.m_isSensor) {
	    this.m_body.setAwake(true);
	    this.m_isSensor = sensor;
	  }
	};

	/**
	 * Get the contact filtering data.
	 */
	// Fixture.prototype.getFilterData = function() {
	//   return this.m_filter;
	// }

	/**
	 * Get the user data that was assigned in the fixture definition. Use this to
	 * store your application specific data.
	 */
	Fixture.prototype.getUserData = function() {
	  return this.m_userData;
	};

	/**
	 * Set the user data. Use this to store your application specific data.
	 */
	Fixture.prototype.setUserData = function(data) {
	  this.m_userData = data;
	};

	/**
	 * Get the parent body of this fixture. This is null if the fixture is not
	 * attached.
	 */
	Fixture.prototype.getBody = function() {
	  return this.m_body;
	};

	/**
	 * Get the next fixture in the parent body's fixture list.
	 */
	Fixture.prototype.getNext = function() {
	  return this.m_next;
	};

	/**
	 * Get the density of this fixture.
	 */
	Fixture.prototype.getDensity = function() {
	  return this.m_density;
	};

	/**
	 * Set the density of this fixture. This will _not_ automatically adjust the
	 * mass of the body. You must call Body.resetMassData to update the body's mass.
	 */
	Fixture.prototype.setDensity = function(density) {
	  _ASSERT$d && common.assert(_Math.isFinite(density) && density >= 0.0);
	  this.m_density = density;
	};

	/**
	 * Get the coefficient of friction, usually in the range [0,1].
	 */
	Fixture.prototype.getFriction = function() {
	  return this.m_friction;
	};

	/**
	 * Set the coefficient of friction. This will not change the friction of
	 * existing contacts.
	 */
	Fixture.prototype.setFriction = function(friction) {
	  this.m_friction = friction;
	};

	/**
	 * Get the coefficient of restitution.
	 */
	Fixture.prototype.getRestitution = function() {
	  return this.m_restitution;
	};

	/**
	 * Set the coefficient of restitution. This will not change the restitution of
	 * existing contacts.
	 */
	Fixture.prototype.setRestitution = function(restitution) {
	  this.m_restitution = restitution;
	};

	/**
	 * Test a point in world coordinates for containment in this fixture.
	 */
	Fixture.prototype.testPoint = function(p) {
	  return this.m_shape.testPoint(this.m_body.getTransform(), p);
	};

	/**
	 * Cast a ray against this shape.
	 */
	Fixture.prototype.rayCast = function(output, input, childIndex) {
	  return this.m_shape.rayCast(output, input, this.m_body.getTransform(), childIndex);
	};

	/**
	 * Get the mass data for this fixture. The mass data is based on the density and
	 * the shape. The rotational inertia is about the shape's origin. This operation
	 * may be expensive.
	 */
	Fixture.prototype.getMassData = function(massData) {
	  this.m_shape.computeMass(massData, this.m_density);
	};

	/**
	 * Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a
	 * more accurate AABB, compute it using the shape and the body transform.
	 */
	Fixture.prototype.getAABB = function(childIndex) {
	  _ASSERT$d && common.assert(0 <= childIndex && childIndex < this.m_proxyCount);
	  return this.m_proxies[childIndex].aabb;
	};

	/**
	 * These support body activation/deactivation.
	 */
	Fixture.prototype.createProxies = function(broadPhase, xf) {
	  _ASSERT$d && common.assert(this.m_proxyCount == 0);

	  // Create proxies in the broad-phase.
	  this.m_proxyCount = this.m_shape.getChildCount();

	  for (var i = 0; i < this.m_proxyCount; ++i) {
	    var proxy = this.m_proxies[i];
	    this.m_shape.computeAABB(proxy.aabb, xf, i);
	    proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);
	  }
	};

	Fixture.prototype.destroyProxies = function(broadPhase) {
	  // Destroy proxies in the broad-phase.
	  for (var i = 0; i < this.m_proxyCount; ++i) {
	    var proxy = this.m_proxies[i];
	    broadPhase.destroyProxy(proxy.proxyId);
	    proxy.proxyId = null;
	  }

	  this.m_proxyCount = 0;
	};

	/**
	 * Updates this fixture proxy in broad-phase (with combined AABB of current and
	 * next transformation).
	 */
	Fixture.prototype.synchronize = function(broadPhase, xf1, xf2) {
	  for (var i = 0; i < this.m_proxyCount; ++i) {
	    var proxy = this.m_proxies[i];
	    // Compute an AABB that covers the swept shape (may miss some rotation
	    // effect).
	    var aabb1 = new AABB_1();
	    var aabb2 = new AABB_1();
	    this.m_shape.computeAABB(aabb1, xf1, proxy.childIndex);
	    this.m_shape.computeAABB(aabb2, xf2, proxy.childIndex);

	    proxy.aabb.combine(aabb1, aabb2);

	    var displacement = Vec2_1.sub(xf2.p, xf1.p);

	    broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);
	  }
	};

	/**
	 * Set the contact filtering data. This will not update contacts until the next
	 * time step when either parent body is active and awake. This automatically
	 * calls refilter.
	 */
	Fixture.prototype.setFilterData = function(filter) {
	  this.m_filterGroupIndex = filter.groupIndex;
	  this.m_filterCategoryBits = filter.categoryBits;
	  this.m_filterMaskBits = filter.maskBits;
	  this.refilter();
	};

	Fixture.prototype.getFilterGroupIndex = function() {
	  return this.m_filterGroupIndex;
	};

	Fixture.prototype.setFilterGroupIndex = function(groupIndex) {
	  return this.m_filterGroupIndex = groupIndex;
	};

	Fixture.prototype.getFilterCategoryBits = function() {
	  return this.m_filterCategoryBits;
	};

	Fixture.prototype.setFilterCategoryBits = function(categoryBits) {
	  this.m_filterCategoryBits = categoryBits;
	};

	Fixture.prototype.getFilterMaskBits = function() {
	  return this.m_filterMaskBits;
	};

	Fixture.prototype.setFilterMaskBits = function(maskBits) {
	  this.m_filterMaskBits = maskBits;
	};

	/**
	 * Call this if you want to establish collision that was previously disabled by
	 * ContactFilter.
	 */
	Fixture.prototype.refilter = function() {
	  if (this.m_body == null) {
	    return;
	  }

	  // Flag associated contacts for filtering.
	  var edge = this.m_body.getContactList();
	  while (edge) {
	    var contact = edge.contact;
	    var fixtureA = contact.getFixtureA();
	    var fixtureB = contact.getFixtureB();
	    if (fixtureA == this || fixtureB == this) {
	      contact.flagForFiltering();
	    }

	    edge = edge.next;
	  }

	  var world = this.m_body.getWorld();

	  if (world == null) {
	    return;
	  }

	  // Touch each proxy so that new pairs may be created
	  var broadPhase = world.m_broadPhase;
	  for (var i = 0; i < this.m_proxyCount; ++i) {
	    broadPhase.touchProxy(this.m_proxies[i].proxyId);
	  }
	};

	/**
	 * Implement this method to provide collision filtering, if you want finer
	 * control over contact creation.
	 * 
	 * Return true if contact calculations should be performed between these two
	 * fixtures.
	 * 
	 * Warning: for performance reasons this is only called when the AABBs begin to
	 * overlap.
	 * 
	 * @param {Fixture} fixtureA
	 * @param {Fixture} fixtureB
	 */
	Fixture.prototype.shouldCollide = function(that) {

	  if (that.m_filterGroupIndex == this.m_filterGroupIndex && that.m_filterGroupIndex != 0) {
	    return that.m_filterGroupIndex > 0;
	  }

	  var collide = (that.m_filterMaskBits & this.m_filterCategoryBits) != 0
	      && (that.m_filterCategoryBits & this.m_filterMaskBits) != 0;
	  return collide;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$e = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$e = typeof ASSERT === 'undefined' ? false : ASSERT;

	var Body_1 = Body;















	var staticBody = Body.STATIC = 'static';
	var kinematicBody = Body.KINEMATIC = 'kinematic';
	var dynamicBody = Body.DYNAMIC = 'dynamic';

	/**
	 * @typedef {Object} BodyDef
	 *
	 * @prop type Body types are static, kinematic, or dynamic. Note: if a dynamic
	 *       body would have zero mass, the mass is set to one.
	 *
	 * @prop position The world position of the body. Avoid creating bodies at the
	 *       origin since this can lead to many overlapping shapes.
	 *
	 * @prop angle The world angle of the body in radians.
	 *
	 * @prop linearVelocity The linear velocity of the body's origin in world
	 *       co-ordinates.
	 *
	 * @prop angularVelocity
	 *
	 * @prop linearDamping Linear damping is use to reduce the linear velocity. The
	 *       damping parameter can be larger than 1.0 but the damping effect becomes
	 *       sensitive to the time step when the damping parameter is large.
	 *
	 * @prop angularDamping Angular damping is use to reduce the angular velocity.
	 *       The damping parameter can be larger than 1.0 but the damping effect
	 *       becomes sensitive to the time step when the damping parameter is large.
	 *
	 * @prop fixedRotation Should this body be prevented from rotating? Useful for
	 *       characters.
	 *
	 * @prop bullet Is this a fast moving body that should be prevented from
	 *       tunneling through other moving bodies? Note that all bodies are
	 *       prevented from tunneling through kinematic and static bodies. This
	 *       setting is only considered on dynamic bodies. Warning: You should use
	 *       this flag sparingly since it increases processing time.
	 *
	 * @prop active Does this body start out active?
	 *
	 * @prop awake Is this body initially awake or sleeping?
	 *
	 * @prop allowSleep Set this flag to false if this body should never fall
	 *       asleep. Note that this increases CPU usage.
	 */
	var BodyDef = {
	  type : staticBody,
	  position : Vec2_1.zero(),
	  angle : 0.0,

	  linearVelocity : Vec2_1.zero(),
	  angularVelocity : 0.0,

	  linearDamping : 0.0,
	  angularDamping : 0.0,

	  fixedRotation : false,
	  bullet : false,
	  gravityScale : 1.0,

	  allowSleep : true,
	  awake : true,
	  active : true,

	  userData : null
	};

	/**
	 * @class
	 * 
	 * A rigid body composed of one or more fixtures.
	 * 
	 * @param {World} world
	 * @param {BodyDef} def
	 */
	function Body(world, def) {

	  def = options(def, BodyDef);

	  _ASSERT$e && common.assert(Vec2_1.isValid(def.position));
	  _ASSERT$e && common.assert(Vec2_1.isValid(def.linearVelocity));
	  _ASSERT$e && common.assert(_Math.isFinite(def.angle));
	  _ASSERT$e && common.assert(_Math.isFinite(def.angularVelocity));
	  _ASSERT$e && common.assert(_Math.isFinite(def.angularDamping) && def.angularDamping >= 0.0);
	  _ASSERT$e && common.assert(_Math.isFinite(def.linearDamping) && def.linearDamping >= 0.0);

	  this.m_world = world;

	  this.m_awakeFlag = def.awake;
	  this.m_autoSleepFlag = def.allowSleep;
	  this.m_bulletFlag = def.bullet;
	  this.m_fixedRotationFlag = def.fixedRotation;
	  this.m_activeFlag = def.active;

	  this.m_islandFlag = false;
	  this.m_toiFlag = false;

	  this.m_userData = def.userData;
	  this.m_type = def.type;

	  if (this.m_type == dynamicBody) {
	    this.m_mass = 1.0;
	    this.m_invMass = 1.0;
	  } else {
	    this.m_mass = 0.0;
	    this.m_invMass = 0.0;
	  }

	  // Rotational inertia about the center of mass.
	  this.m_I = 0.0;
	  this.m_invI = 0.0;

	  // the body origin transform
	  this.m_xf = Transform_1.identity();
	  this.m_xf.p = Vec2_1.clone(def.position);
	  this.m_xf.q.setAngle(def.angle);

	  // the swept motion for CCD
	  this.m_sweep = new Sweep_1();
	  this.m_sweep.setTransform(this.m_xf);

	  // position and velocity correction
	  this.c_velocity = new Velocity_1();
	  this.c_position = new Position_1();

	  this.m_force = Vec2_1.zero();
	  this.m_torque = 0.0;

	  this.m_linearVelocity = Vec2_1.clone(def.linearVelocity);
	  this.m_angularVelocity = def.angularVelocity;

	  this.m_linearDamping = def.linearDamping;
	  this.m_angularDamping = def.angularDamping;
	  this.m_gravityScale = def.gravityScale;

	  this.m_sleepTime = 0.0;

	  this.m_jointList = null;
	  this.m_contactList = null;
	  this.m_fixtureList = null;

	  this.m_prev = null;
	  this.m_next = null;

	  this.m_destroyed = false;
	}

	Body.prototype._serialize = function() {
	  var fixtures = [];
	  for (var f = this.m_fixtureList; f; f = f.m_next) {
	    fixtures.push(f);
	  }
	  return {
	    type: this.m_type,
	    position: this.m_xf.p,
	    angle: this.m_xf.q.getAngle(),
	    linearVelocity: this.m_linearVelocity,
	    angularVelocity: this.m_angularVelocity,
	    fixtures: fixtures,
	  };
	};

	Body._deserialize = function(data, world, restore) {
	  var body = new Body(world, data);

	  data.fixtures.forEach(function(data) {
	    var fixture = restore(Fixture_1, data, body);
	    body._addFixture(fixture);
	  });

	  return body;
	};

	Body.prototype.isWorldLocked = function() {
	  return this.m_world && this.m_world.isLocked() ? true : false;
	};

	Body.prototype.getWorld = function() {
	  return this.m_world;
	};

	Body.prototype.getNext = function() {
	  return this.m_next;
	};

	Body.prototype.setUserData = function(data) {
	  this.m_userData = data;
	};

	Body.prototype.getUserData = function() {
	  return this.m_userData;
	};

	Body.prototype.getFixtureList = function() {
	  return this.m_fixtureList;
	};

	Body.prototype.getJointList = function() {
	  return this.m_jointList;
	};

	/**
	 * Warning: this list changes during the time step and you may miss some
	 * collisions if you don't use ContactListener.
	 */
	Body.prototype.getContactList = function() {
	  return this.m_contactList;
	};

	Body.prototype.isStatic = function() {
	  return this.m_type == staticBody;
	};

	Body.prototype.isDynamic = function() {
	  return this.m_type == dynamicBody;
	};

	Body.prototype.isKinematic = function() {
	  return this.m_type == kinematicBody;
	};

	/**
	 * This will alter the mass and velocity.
	 */
	Body.prototype.setStatic = function() {
	  this.setType(staticBody);
	  return this;
	};

	Body.prototype.setDynamic = function() {
	  this.setType(dynamicBody);
	  return this;
	};

	Body.prototype.setKinematic = function() {
	  this.setType(kinematicBody);
	  return this;
	};

	/**
	 * @private
	 */
	Body.prototype.getType = function() {
	  return this.m_type;
	};

	/**
	 * 
	 * @private
	 */
	Body.prototype.setType = function(type) {
	  _ASSERT$e && common.assert(type === staticBody || type === kinematicBody || type === dynamicBody);
	  _ASSERT$e && common.assert(this.isWorldLocked() == false);

	  if (this.isWorldLocked() == true) {
	    return;
	  }

	  if (this.m_type == type) {
	    return;
	  }

	  this.m_type = type;

	  this.resetMassData();

	  if (this.m_type == staticBody) {
	    this.m_linearVelocity.setZero();
	    this.m_angularVelocity = 0.0;
	    this.m_sweep.forward();
	    this.synchronizeFixtures();
	  }

	  this.setAwake(true);

	  this.m_force.setZero();
	  this.m_torque = 0.0;

	  // Delete the attached contacts.
	  var ce = this.m_contactList;
	  while (ce) {
	    var ce0 = ce;
	    ce = ce.next;
	    this.m_world.destroyContact(ce0.contact);
	  }
	  this.m_contactList = null;

	  // Touch the proxies so that new contacts will be created (when appropriate)
	  var broadPhase = this.m_world.m_broadPhase;
	  for (var f = this.m_fixtureList; f; f = f.m_next) {
	    var proxyCount = f.m_proxyCount;
	    for (var i = 0; i < proxyCount; ++i) {
	      broadPhase.touchProxy(f.m_proxies[i].proxyId);
	    }
	  }
	};

	Body.prototype.isBullet = function() {
	  return this.m_bulletFlag;
	};

	/**
	 * Should this body be treated like a bullet for continuous collision detection?
	 */
	Body.prototype.setBullet = function(flag) {
	  this.m_bulletFlag = !!flag;
	};

	Body.prototype.isSleepingAllowed = function() {
	  return this.m_autoSleepFlag;
	};

	Body.prototype.setSleepingAllowed = function(flag) {
	  this.m_autoSleepFlag = !!flag;
	  if (this.m_autoSleepFlag == false) {
	    this.setAwake(true);
	  }
	};

	Body.prototype.isAwake = function() {
	  return this.m_awakeFlag;
	};

	/**
	 * Set the sleep state of the body. A sleeping body has very low CPU cost.
	 * 
	 * @param flag Set to true to wake the body, false to put it to sleep.
	 */
	Body.prototype.setAwake = function(flag) {
	  if (flag) {
	    if (this.m_awakeFlag == false) {
	      this.m_awakeFlag = true;
	      this.m_sleepTime = 0.0;
	    }
	  } else {
	    this.m_awakeFlag = false;
	    this.m_sleepTime = 0.0;
	    this.m_linearVelocity.setZero();
	    this.m_angularVelocity = 0.0;
	    this.m_force.setZero();
	    this.m_torque = 0.0;
	  }
	};

	Body.prototype.isActive = function() {
	  return this.m_activeFlag;
	};

	/**
	 * Set the active state of the body. An inactive body is not simulated and
	 * cannot be collided with or woken up. If you pass a flag of true, all fixtures
	 * will be added to the broad-phase. If you pass a flag of false, all fixtures
	 * will be removed from the broad-phase and all contacts will be destroyed.
	 * Fixtures and joints are otherwise unaffected.
	 * 
	 * You may continue to create/destroy fixtures and joints on inactive bodies.
	 * Fixtures on an inactive body are implicitly inactive and will not participate
	 * in collisions, ray-casts, or queries. Joints connected to an inactive body
	 * are implicitly inactive. An inactive body is still owned by a World object
	 * and remains
	 */
	Body.prototype.setActive = function(flag) {
	  _ASSERT$e && common.assert(this.isWorldLocked() == false);

	  if (flag == this.m_activeFlag) {
	    return;
	  }

	  this.m_activeFlag = !!flag;

	  if (this.m_activeFlag) {
	    // Create all proxies.
	    var broadPhase = this.m_world.m_broadPhase;
	    for (var f = this.m_fixtureList; f; f = f.m_next) {
	      f.createProxies(broadPhase, this.m_xf);
	    }
	    // Contacts are created the next time step.

	  } else {
	    // Destroy all proxies.
	    var broadPhase = this.m_world.m_broadPhase;
	    for (var f = this.m_fixtureList; f; f = f.m_next) {
	      f.destroyProxies(broadPhase);
	    }

	    // Destroy the attached contacts.
	    var ce = this.m_contactList;
	    while (ce) {
	      var ce0 = ce;
	      ce = ce.next;
	      this.m_world.destroyContact(ce0.contact);
	    }
	    this.m_contactList = null;
	  }
	};

	Body.prototype.isFixedRotation = function() {
	  return this.m_fixedRotationFlag;
	};

	/**
	 * Set this body to have fixed rotation. This causes the mass to be reset.
	 */
	Body.prototype.setFixedRotation = function(flag) {
	  if (this.m_fixedRotationFlag == flag) {
	    return;
	  }

	  this.m_fixedRotationFlag = !!flag;

	  this.m_angularVelocity = 0.0;

	  this.resetMassData();
	};

	/**
	 * Get the world transform for the body's origin.
	 */
	Body.prototype.getTransform = function() {
	  return this.m_xf;
	};

	/**
	 * Set the position of the body's origin and rotation. Manipulating a body's
	 * transform may cause non-physical behavior. Note: contacts are updated on the
	 * next call to World.step.
	 * 
	 * @param position The world position of the body's local origin.
	 * @param angle The world rotation in radians.
	 */
	Body.prototype.setTransform = function(position, angle) {
	  _ASSERT$e && common.assert(this.isWorldLocked() == false);
	  if (this.isWorldLocked() == true) {
	    return;
	  }

	  this.m_xf.set(position, angle);
	  this.m_sweep.setTransform(this.m_xf);

	  var broadPhase = this.m_world.m_broadPhase;
	  for (var f = this.m_fixtureList; f; f = f.m_next) {
	    f.synchronize(broadPhase, this.m_xf, this.m_xf);
	  }
	};

	Body.prototype.synchronizeTransform = function() {
	  this.m_sweep.getTransform(this.m_xf, 1);
	};

	/**
	 * Update fixtures in broad-phase.
	 */
	Body.prototype.synchronizeFixtures = function() {
	  var xf = Transform_1.identity();

	  this.m_sweep.getTransform(xf, 0);

	  var broadPhase = this.m_world.m_broadPhase;
	  for (var f = this.m_fixtureList; f; f = f.m_next) {
	    f.synchronize(broadPhase, xf, this.m_xf);
	  }
	};

	/**
	 * Used in TOI.
	 */
	Body.prototype.advance = function(alpha) {
	  // Advance to the new safe time. This doesn't sync the broad-phase.
	  this.m_sweep.advance(alpha);
	  this.m_sweep.c.set(this.m_sweep.c0);
	  this.m_sweep.a = this.m_sweep.a0;
	  this.m_sweep.getTransform(this.m_xf, 1);
	};

	/**
	 * Get the world position for the body's origin.
	 */
	Body.prototype.getPosition = function() {
	  return this.m_xf.p;
	};

	Body.prototype.setPosition = function(p) {
	  this.setTransform(p, this.m_sweep.a);
	};

	/**
	 * Get the current world rotation angle in radians.
	 */
	Body.prototype.getAngle = function() {
	  return this.m_sweep.a;
	};

	Body.prototype.setAngle = function(angle) {
	  this.setTransform(this.m_xf.p, angle);
	};

	/**
	 * Get the world position of the center of mass.
	 */
	Body.prototype.getWorldCenter = function() {
	  return this.m_sweep.c;
	};

	/**
	 * Get the local position of the center of mass.
	 */
	Body.prototype.getLocalCenter = function() {
	  return this.m_sweep.localCenter;
	};

	/**
	 * Get the linear velocity of the center of mass.
	 * 
	 * @return the linear velocity of the center of mass.
	 */
	Body.prototype.getLinearVelocity = function() {
	  return this.m_linearVelocity;
	};

	/**
	 * Get the world linear velocity of a world point attached to this body.
	 * 
	 * @param worldPoint A point in world coordinates.
	 */
	Body.prototype.getLinearVelocityFromWorldPoint = function(worldPoint) {
	  var localCenter = Vec2_1.sub(worldPoint, this.m_sweep.c);
	  return Vec2_1.add(this.m_linearVelocity, Vec2_1.cross(this.m_angularVelocity,
	      localCenter));
	};

	/**
	 * Get the world velocity of a local point.
	 * 
	 * @param localPoint A point in local coordinates.
	 */
	Body.prototype.getLinearVelocityFromLocalPoint = function(localPoint) {
	  return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(localPoint));
	};

	/**
	 * Set the linear velocity of the center of mass.
	 * 
	 * @param v The new linear velocity of the center of mass.
	 */
	Body.prototype.setLinearVelocity = function(v) {
	  if (this.m_type == staticBody) {
	    return;
	  }
	  if (Vec2_1.dot(v, v) > 0.0) {
	    this.setAwake(true);
	  }
	  this.m_linearVelocity.set(v);
	};

	/**
	 * Get the angular velocity.
	 * 
	 * @returns the angular velocity in radians/second.
	 */
	Body.prototype.getAngularVelocity = function() {
	  return this.m_angularVelocity;
	};

	/**
	 * Set the angular velocity.
	 * 
	 * @param omega The new angular velocity in radians/second.
	 */
	Body.prototype.setAngularVelocity = function(w) {
	  if (this.m_type == staticBody) {
	    return;
	  }
	  if (w * w > 0.0) {
	    this.setAwake(true);
	  }
	  this.m_angularVelocity = w;
	};

	Body.prototype.getLinearDamping = function() {
	  return this.m_linearDamping;
	};

	Body.prototype.setLinearDamping = function(linearDamping) {
	  this.m_linearDamping = linearDamping;
	};

	Body.prototype.getAngularDamping = function() {
	  return this.m_angularDamping;
	};

	Body.prototype.setAngularDamping = function(angularDamping) {
	  this.m_angularDamping = angularDamping;
	};

	Body.prototype.getGravityScale = function() {
	  return this.m_gravityScale;
	};

	/**
	 * Scale the gravity applied to this body.
	 */
	Body.prototype.setGravityScale = function(scale) {
	  this.m_gravityScale = scale;
	};

	/**
	 * Get the total mass of the body.
	 * 
	 * @returns The mass, usually in kilograms (kg).
	 */
	Body.prototype.getMass = function() {
	  return this.m_mass;
	};

	/**
	 * Get the rotational inertia of the body about the local origin.
	 * 
	 * @return the rotational inertia, usually in kg-m^2.
	 */
	Body.prototype.getInertia = function() {
	  return this.m_I + this.m_mass
	      * Vec2_1.dot(this.m_sweep.localCenter, this.m_sweep.localCenter);
	};

	/**
	 * @typedef {Object} MassData This holds the mass data computed for a shape.
	 * 
	 * @prop mass The mass of the shape, usually in kilograms.
	 * @prop center The position of the shape's centroid relative to the shape's
	 *       origin.
	 * @prop I The rotational inertia of the shape about the local origin.
	 */
	function MassData() {
	  this.mass = 0;
	  this.center = Vec2_1.zero();
	  this.I = 0;
	}
	/**
	 * Copy the mass data of the body to data.
	 */
	Body.prototype.getMassData = function(data) {
	  data.mass = this.m_mass;
	  data.I = this.getInertia();
	  data.center.set(this.m_sweep.localCenter);
	};

	/**
	 * This resets the mass properties to the sum of the mass properties of the
	 * fixtures. This normally does not need to be called unless you called
	 * SetMassData to override the mass and you later want to reset the mass.
	 */
	Body.prototype.resetMassData = function() {
	  // Compute mass data from shapes. Each shape has its own density.
	  this.m_mass = 0.0;
	  this.m_invMass = 0.0;
	  this.m_I = 0.0;
	  this.m_invI = 0.0;
	  this.m_sweep.localCenter.setZero();

	  // Static and kinematic bodies have zero mass.
	  if (this.isStatic() || this.isKinematic()) {
	    this.m_sweep.c0.set(this.m_xf.p);
	    this.m_sweep.c.set(this.m_xf.p);
	    this.m_sweep.a0 = this.m_sweep.a;
	    return;
	  }

	  _ASSERT$e && common.assert(this.isDynamic());

	  // Accumulate mass over all fixtures.
	  var localCenter = Vec2_1.zero();
	  for (var f = this.m_fixtureList; f; f = f.m_next) {
	    if (f.m_density == 0.0) {
	      continue;
	    }

	    var massData = new MassData();
	    f.getMassData(massData);
	    this.m_mass += massData.mass;
	    localCenter.addMul(massData.mass, massData.center);
	    this.m_I += massData.I;
	  }

	  // Compute center of mass.
	  if (this.m_mass > 0.0) {
	    this.m_invMass = 1.0 / this.m_mass;
	    localCenter.mul(this.m_invMass);

	  } else {
	    // Force all dynamic bodies to have a positive mass.
	    this.m_mass = 1.0;
	    this.m_invMass = 1.0;
	  }

	  if (this.m_I > 0.0 && this.m_fixedRotationFlag == false) {
	    // Center the inertia about the center of mass.
	    this.m_I -= this.m_mass * Vec2_1.dot(localCenter, localCenter);
	    _ASSERT$e && common.assert(this.m_I > 0.0);
	    this.m_invI = 1.0 / this.m_I;

	  } else {
	    this.m_I = 0.0;
	    this.m_invI = 0.0;
	  }

	  // Move center of mass.
	  var oldCenter = Vec2_1.clone(this.m_sweep.c);
	  this.m_sweep.setLocalCenter(localCenter, this.m_xf);

	  // Update center of mass velocity.
	  this.m_linearVelocity.add(Vec2_1.cross(this.m_angularVelocity, Vec2_1.sub(
	      this.m_sweep.c, oldCenter)));
	};

	/**
	 * Set the mass properties to override the mass properties of the fixtures. Note
	 * that this changes the center of mass position. Note that creating or
	 * destroying fixtures can also alter the mass. This function has no effect if
	 * the body isn't dynamic.
	 * 
	 * @param massData The mass properties.
	 */
	Body.prototype.setMassData = function(massData) {
	  _ASSERT$e && common.assert(this.isWorldLocked() == false);
	  if (this.isWorldLocked() == true) {
	    return;
	  }

	  if (this.m_type != dynamicBody) {
	    return;
	  }

	  this.m_invMass = 0.0;
	  this.m_I = 0.0;
	  this.m_invI = 0.0;

	  this.m_mass = massData.mass;
	  if (this.m_mass <= 0.0) {
	    this.m_mass = 1.0;
	  }

	  this.m_invMass = 1.0 / this.m_mass;

	  if (massData.I > 0.0 && this.m_fixedRotationFlag == false) {
	    this.m_I = massData.I - this.m_mass
	        * Vec2_1.dot(massData.center, massData.center);
	    _ASSERT$e && common.assert(this.m_I > 0.0);
	    this.m_invI = 1.0 / this.m_I;
	  }

	  // Move center of mass.
	  var oldCenter = Vec2_1.clone(this.m_sweep.c);
	  this.m_sweep.setLocalCenter(massData.center, this.m_xf);

	  // Update center of mass velocity.
	  this.m_linearVelocity.add(Vec2_1.cross(this.m_angularVelocity, Vec2_1.sub(
	      this.m_sweep.c, oldCenter)));
	};

	/**
	 * Apply a force at a world point. If the force is not applied at the center of
	 * mass, it will generate a torque and affect the angular velocity. This wakes
	 * up the body.
	 * 
	 * @param force The world force vector, usually in Newtons (N).
	 * @param point The world position of the point of application.
	 * @param wake Also wake up the body
	 */
	Body.prototype.applyForce = function(force, point, wake) {
	  if (this.m_type != dynamicBody) {
	    return;
	  }
	  if (wake && this.m_awakeFlag == false) {
	    this.setAwake(true);
	  }
	  // Don't accumulate a force if the body is sleeping.
	  if (this.m_awakeFlag) {
	    this.m_force.add(force);
	    this.m_torque += Vec2_1.cross(Vec2_1.sub(point, this.m_sweep.c), force);
	  }
	};

	/**
	 * Apply a force to the center of mass. This wakes up the body.
	 * 
	 * @param force The world force vector, usually in Newtons (N).
	 * @param wake Also wake up the body
	 */
	Body.prototype.applyForceToCenter = function(force, wake) {
	  if (this.m_type != dynamicBody) {
	    return;
	  }
	  if (wake && this.m_awakeFlag == false) {
	    this.setAwake(true);
	  }
	  // Don't accumulate a force if the body is sleeping
	  if (this.m_awakeFlag) {
	    this.m_force.add(force);
	  }
	};

	/**
	 * Apply a torque. This affects the angular velocity without affecting the
	 * linear velocity of the center of mass. This wakes up the body.
	 * 
	 * @param torque About the z-axis (out of the screen), usually in N-m.
	 * @param wake Also wake up the body
	 */
	Body.prototype.applyTorque = function(torque, wake) {
	  if (this.m_type != dynamicBody) {
	    return;
	  }
	  if (wake && this.m_awakeFlag == false) {
	    this.setAwake(true);
	  }
	  // Don't accumulate a force if the body is sleeping
	  if (this.m_awakeFlag) {
	    this.m_torque += torque;
	  }
	};

	/**
	 * Apply an impulse at a point. This immediately modifies the velocity. It also
	 * modifies the angular velocity if the point of application is not at the
	 * center of mass. This wakes up the body.
	 * 
	 * @param impulse The world impulse vector, usually in N-seconds or kg-m/s.
	 * @param point The world position of the point of application.
	 * @param wake Also wake up the body
	 */
	Body.prototype.applyLinearImpulse = function(impulse, point, wake) {
	  if (this.m_type != dynamicBody) {
	    return;
	  }
	  if (wake && this.m_awakeFlag == false) {
	    this.setAwake(true);
	  }

	  // Don't accumulate velocity if the body is sleeping
	  if (this.m_awakeFlag) {
	    this.m_linearVelocity.addMul(this.m_invMass, impulse);
	    this.m_angularVelocity += this.m_invI * Vec2_1.cross(Vec2_1.sub(point, this.m_sweep.c), impulse);
	  }
	};

	/**
	 * Apply an angular impulse.
	 * 
	 * @param impulse The angular impulse in units of kg*m*m/s
	 * @param wake Also wake up the body
	 */
	Body.prototype.applyAngularImpulse = function(impulse, wake) {
	  if (this.m_type != dynamicBody) {
	    return;
	  }

	  if (wake && this.m_awakeFlag == false) {
	    this.setAwake(true);
	  }
	  // Don't accumulate velocity if the body is sleeping
	  if (this.m_awakeFlag) {
	    this.m_angularVelocity += this.m_invI * impulse;
	  }
	};

	/**
	 * This is used to prevent connected bodies (by joints) from colliding,
	 * depending on the joint's collideConnected flag.
	 */
	Body.prototype.shouldCollide = function(that) {
	  // At least one body should be dynamic.
	  if (this.m_type != dynamicBody && that.m_type != dynamicBody) {
	    return false;
	  }
	  // Does a joint prevent collision?
	  for (var jn = this.m_jointList; jn; jn = jn.next) {
	    if (jn.other == that) {
	      if (jn.joint.m_collideConnected == false) {
	        return false;
	      }
	    }
	  }
	  return true;
	};

	/**
	 * @internal Used for deserialize.
	 */
	Body.prototype._addFixture = function(fixture) {
	  _ASSERT$e && common.assert(this.isWorldLocked() == false);

	  if (this.isWorldLocked() == true) {
	    return null;
	  }

	  if (this.m_activeFlag) {
	    var broadPhase = this.m_world.m_broadPhase;
	    fixture.createProxies(broadPhase, this.m_xf);
	  }

	  fixture.m_next = this.m_fixtureList;
	  this.m_fixtureList = fixture;

	  // Adjust mass properties if needed.
	  if (fixture.m_density > 0.0) {
	    this.resetMassData();
	  }

	  // Let the world know we have a new fixture. This will cause new contacts
	  // to be created at the beginning of the next time step.
	  this.m_world.m_newFixture = true;

	  return fixture
	};

	/**
	 * Creates a fixture and attach it to this body.
	 * 
	 * If the density is non-zero, this function automatically updates the mass of
	 * the body.
	 * 
	 * Contacts are not created until the next time step.
	 * 
	 * Warning: This function is locked during callbacks.

	 * @param {Shape|FixtureDef} shape Shape or fixture definition.
	 * @param {FixtureDef|number} fixdef Fixture definition or just density.
	 */
	Body.prototype.createFixture = function(shape, fixdef) {
	  _ASSERT$e && common.assert(this.isWorldLocked() == false);

	  if (this.isWorldLocked() == true) {
	    return null;
	  }

	  var fixture = new Fixture_1(this, shape, fixdef);
	  this._addFixture(fixture);
	  return fixture
	};

	/**
	 * Destroy a fixture. This removes the fixture from the broad-phase and destroys
	 * all contacts associated with this fixture. This will automatically adjust the
	 * mass of the body if the body is dynamic and the fixture has positive density.
	 * All fixtures attached to a body are implicitly destroyed when the body is
	 * destroyed.
	 * 
	 * Warning: This function is locked during callbacks.
	 * 
	 * @param fixture The fixture to be removed.
	 */
	Body.prototype.destroyFixture = function(fixture) {
	  _ASSERT$e && common.assert(this.isWorldLocked() == false);

	  if (this.isWorldLocked() == true) {
	    return;
	  }

	  _ASSERT$e && common.assert(fixture.m_body == this);

	  // Remove the fixture from this body's singly linked list.
	  var found = false;
	  if (this.m_fixtureList === fixture) {
	    this.m_fixtureList = fixture.m_next;
	    found = true;

	  } else {
	    var node = this.m_fixtureList;
	    while (node != null) {
	      if (node.m_next === fixture) {
	        node.m_next = fixture.m_next;
	        found = true;
	        break;
	      }
	      node = node.m_next;
	    }
	  }

	  // You tried to remove a shape that is not attached to this body.
	  _ASSERT$e && common.assert(found);

	  // Destroy any contacts associated with the fixture.
	  var edge = this.m_contactList;
	  while (edge) {
	    var c = edge.contact;
	    edge = edge.next;

	    var fixtureA = c.getFixtureA();
	    var fixtureB = c.getFixtureB();

	    if (fixture == fixtureA || fixture == fixtureB) {
	      // This destroys the contact and removes it from
	      // this body's contact list.
	      this.m_world.destroyContact(c);
	    }
	  }

	  if (this.m_activeFlag) {
	    var broadPhase = this.m_world.m_broadPhase;
	    fixture.destroyProxies(broadPhase);
	  }

	  fixture.m_body = null;
	  fixture.m_next = null;

	  this.m_world.publish('remove-fixture', fixture);

	  // Reset the mass data.
	  this.resetMassData();
	};

	/**
	 * Get the corresponding world point of a local point.
	 */
	Body.prototype.getWorldPoint = function(localPoint) {
	  return Transform_1.mulVec2(this.m_xf, localPoint);
	};

	/**
	 * Get the corresponding world vector of a local vector.
	 */
	Body.prototype.getWorldVector = function(localVector) {
	  return Rot_1.mulVec2(this.m_xf.q, localVector);
	};

	/**
	 * Gets the corresponding local point of a world point.
	 */
	Body.prototype.getLocalPoint = function(worldPoint) {
	  return Transform_1.mulTVec2(this.m_xf, worldPoint);
	};

	/**
	 * 
	 * Gets the corresponding local vector of a world vector.
	 */
	Body.prototype.getLocalVector = function(worldVector) {
	  return Rot_1.mulTVec2(this.m_xf.q, worldVector);
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$f = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$f = typeof ASSERT === 'undefined' ? false : ASSERT;

	var Mat22_1 = Mat22;





	/**
	 * A 2-by-2 matrix. Stored in column-major order.
	 */
	function Mat22(a, b, c, d) {
	  if (typeof a === 'object' && a !== null) {
	    this.ex = Vec2_1.clone(a);
	    this.ey = Vec2_1.clone(b);
	  } else if (typeof a === 'number') {
	    this.ex = Vec2_1.neo(a, c);
	    this.ey = Vec2_1.neo(b, d);
	  } else {
	    this.ex = Vec2_1.zero();
	    this.ey = Vec2_1.zero();
	  }
	}
	Mat22.prototype.toString = function() {
	  return JSON.stringify(this);
	};

	Mat22.isValid = function(o) {
	  return o && Vec2_1.isValid(o.ex) && Vec2_1.isValid(o.ey);
	};

	Mat22.assert = function(o) {
	  if (!_ASSERT$f) return;
	  if (!Mat22.isValid(o)) {
	    _DEBUG$f && common.debug(o);
	    throw new Error('Invalid Mat22!');
	  }
	};

	Mat22.prototype.set = function(a, b, c, d) {
	  if (typeof a === 'number' && typeof b === 'number' && typeof c === 'number'
	      && typeof d === 'number') {
	    this.ex.set(a, c);
	    this.ey.set(b, d);

	  } else if (typeof a === 'object' && typeof b === 'object') {
	    this.ex.set(a);
	    this.ey.set(b);

	  } else if (typeof a === 'object') {
	    _ASSERT$f && Mat22.assert(a);
	    this.ex.set(a.ex);
	    this.ey.set(a.ey);

	  } else {
	    _ASSERT$f && common.assert(false);
	  }
	};

	Mat22.prototype.setIdentity = function() {
	  this.ex.x = 1.0;
	  this.ey.x = 0.0;
	  this.ex.y = 0.0;
	  this.ey.y = 1.0;
	};

	Mat22.prototype.setZero = function() {
	  this.ex.x = 0.0;
	  this.ey.x = 0.0;
	  this.ex.y = 0.0;
	  this.ey.y = 0.0;
	};

	Mat22.prototype.getInverse = function() {
	  var a = this.ex.x;
	  var b = this.ey.x;
	  var c = this.ex.y;
	  var d = this.ey.y;
	  var det = a * d - b * c;
	  if (det != 0.0) {
	    det = 1.0 / det;
	  }
	  var imx = new Mat22();
	  imx.ex.x = det * d;
	  imx.ey.x = -det * b;
	  imx.ex.y = -det * c;
	  imx.ey.y = det * a;
	  return imx;
	};

	/**
	 * Solve A * x = b, where b is a column vector. This is more efficient than
	 * computing the inverse in one-shot cases.
	 */
	Mat22.prototype.solve = function(v) {
	  _ASSERT$f && Vec2_1.assert(v);
	  var a = this.ex.x;
	  var b = this.ey.x;
	  var c = this.ex.y;
	  var d = this.ey.y;
	  var det = a * d - b * c;
	  if (det != 0.0) {
	    det = 1.0 / det;
	  }
	  var w = Vec2_1.zero();
	  w.x = det * (d * v.x - b * v.y);
	  w.y = det * (a * v.y - c * v.x);
	  return w;
	};

	/**
	 * Multiply a matrix times a vector. If a rotation matrix is provided, then this
	 * transforms the vector from one frame to another.
	 */
	Mat22.mul = function(mx, v) {
	  if (v && 'x' in v && 'y' in v) {
	    _ASSERT$f && Vec2_1.assert(v);
	    var x = mx.ex.x * v.x + mx.ey.x * v.y;
	    var y = mx.ex.y * v.x + mx.ey.y * v.y;
	    return Vec2_1.neo(x, y);

	  } else if (v && 'ex' in v && 'ey' in v) { // Mat22
	    _ASSERT$f && Mat22.assert(v);
	    // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));
	    var a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;
	    var b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;
	    var c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;
	    var d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;
	    return new Mat22(a, b, c, d);
	  }

	  _ASSERT$f && common.assert(false);
	};

	Mat22.mulVec2 = function(mx, v) {
	  _ASSERT$f && Vec2_1.assert(v);
	  var x = mx.ex.x * v.x + mx.ey.x * v.y;
	  var y = mx.ex.y * v.x + mx.ey.y * v.y;
	  return Vec2_1.neo(x, y);
	};

	Mat22.mulMat22 = function(mx, v) {
	  _ASSERT$f && Mat22.assert(v);
	  // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));
	  var a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;
	  var b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;
	  var c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;
	  var d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;
	  return new Mat22(a, b, c, d);
	};

	/**
	 * Multiply a matrix transpose times a vector. If a rotation matrix is provided,
	 * then this transforms the vector from one frame to another (inverse
	 * transform).
	 */
	Mat22.mulT = function(mx, v) {
	  if (v && 'x' in v && 'y' in v) { // Vec2
	    _ASSERT$f && Vec2_1.assert(v);
	    return Vec2_1.neo(Vec2_1.dot(v, mx.ex), Vec2_1.dot(v, mx.ey));

	  } else if (v && 'ex' in v && 'ey' in v) { // Mat22
	    _ASSERT$f && Mat22.assert(v);
	    var c1 = Vec2_1.neo(Vec2_1.dot(mx.ex, v.ex), Vec2_1.dot(mx.ey, v.ex));
	    var c2 = Vec2_1.neo(Vec2_1.dot(mx.ex, v.ey), Vec2_1.dot(mx.ey, v.ey));
	    return new Mat22(c1, c2);
	  }

	  _ASSERT$f && common.assert(false);
	};

	Mat22.mulTVec2 = function(mx, v) {
	  _ASSERT$f && Mat22.assert(mx);
	  _ASSERT$f && Vec2_1.assert(v);
	  return Vec2_1.neo(Vec2_1.dot(v, mx.ex), Vec2_1.dot(v, mx.ey));
	};

	Mat22.mulTMat22 = function(mx, v) {
	  _ASSERT$f && Mat22.assert(mx);
	  _ASSERT$f && Mat22.assert(v);
	  var c1 = Vec2_1.neo(Vec2_1.dot(mx.ex, v.ex), Vec2_1.dot(mx.ey, v.ex));
	  var c2 = Vec2_1.neo(Vec2_1.dot(mx.ex, v.ey), Vec2_1.dot(mx.ey, v.ey));
	  return new Mat22(c1, c2);
	};

	Mat22.abs = function(mx) {
	  _ASSERT$f && Mat22.assert(mx);
	  return new Mat22(Vec2_1.abs(mx.ex), Vec2_1.abs(mx.ey));
	};

	Mat22.add = function(mx1, mx2) {
	  _ASSERT$f && Mat22.assert(mx1);
	  _ASSERT$f && Mat22.assert(mx2);
	  return new Mat22(Vec2_1.add(mx1.ex, mx2.ex), Vec2_1.add(mx1.ey, mx2.ey));
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$g = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$g = typeof ASSERT === 'undefined' ? false : ASSERT;








	var Manifold_1 = Manifold;
	var clipSegmentToLine_1 = clipSegmentToLine;
	var clipVertex = ClipVertex;
	var getPointStates_1 = getPointStates;
	var PointState_1 = PointState;

	// Manifold Type
	Manifold.e_circles = 0;
	Manifold.e_faceA = 1;
	Manifold.e_faceB = 2;

	// ContactFeature Type
	Manifold.e_vertex = 0;
	Manifold.e_face = 1;

	/**
	 * A manifold for two touching convex shapes. Manifolds are created in `evaluate`
	 * method of Contact subclasses.
	 * 
	 * Supported manifold types are e_faceA or e_faceB for clip point versus plane
	 * with radius and e_circles point versus point with radius.
	 * 
	 * We store contacts in this way so that position correction can account for
	 * movement, which is critical for continuous physics. All contact scenarios
	 * must be expressed in one of these types. This structure is stored across time
	 * steps, so we keep it small.
	 * 
	 * @prop type e_circle, e_faceA, e_faceB
	 * @prop localPoint Usage depends on manifold type:<br>
	 *       e_circles: the local center of circleA <br>
	 *       e_faceA: the center of faceA <br>
	 *       e_faceB: the center of faceB
	 * @prop localNormal Usage depends on manifold type:<br>
	 *       e_circles: not used <br>
	 *       e_faceA: the normal on polygonA <br>
	 *       e_faceB: the normal on polygonB
	 * @prop points The points of contact {ManifoldPoint[]}
	 * @prop pointCount The number of manifold points
	 */
	function Manifold() {
	  this.type;
	  this.localNormal = Vec2_1.zero();
	  this.localPoint = Vec2_1.zero();
	  this.points = [ new ManifoldPoint(), new ManifoldPoint() ];
	  this.pointCount = 0;
	}
	/**
	 * A manifold point is a contact point belonging to a contact manifold. It holds
	 * details related to the geometry and dynamics of the contact points.
	 * 
	 * This structure is stored across time steps, so we keep it small.
	 * 
	 * Note: impulses are used for internal caching and may not provide reliable
	 * contact forces, especially for high speed collisions.
	 * 
	 * @prop {Vec2} localPoint Usage depends on manifold type:<br>
	 *       e_circles: the local center of circleB<br>
	 *       e_faceA: the local center of cirlceB or the clip point of polygonB<br>
	 *       e_faceB: the clip point of polygonA.
	 * @prop normalImpulse The non-penetration impulse
	 * @prop tangentImpulse The friction impulse
	 * @prop {ContactID} id Uniquely identifies a contact point between two shapes
	 *       to facilatate warm starting
	 */
	function ManifoldPoint() {
	  this.localPoint = Vec2_1.zero();
	  this.normalImpulse = 0;
	  this.tangentImpulse = 0;
	  this.id = new ContactID();
	}
	/**
	 * Contact ids to facilitate warm starting.
	 * 
	 * @prop {ContactFeature} cf
	 * @prop key Used to quickly compare contact ids.
	 * 
	 */
	function ContactID() {
	  this.cf = new ContactFeature();
	}
	Object.defineProperty(ContactID.prototype, 'key', {
	  get: function() {
	    return this.cf.indexA + this.cf.indexB * 4 + this.cf.typeA * 16 + this.cf.typeB * 64;
	  },
	  enumerable: true,
	  configurable: true
	});

	ContactID.prototype.set = function(o) {
	  // this.key = o.key;
	  this.cf.set(o.cf);
	};

	/**
	 * The features that intersect to form the contact point.
	 * 
	 * @prop indexA Feature index on shapeA
	 * @prop indexB Feature index on shapeB
	 * @prop typeA The feature type on shapeA
	 * @prop typeB The feature type on shapeB
	 */
	function ContactFeature() {
	  this.indexA;
	  this.indexB;
	  this.typeA;
	  this.typeB;
	}
	ContactFeature.prototype.set = function(o) {
	  this.indexA = o.indexA;
	  this.indexB = o.indexB;
	  this.typeA = o.typeA;
	  this.typeB = o.typeB;
	};

	/**
	 * This is used to compute the current state of a contact manifold.
	 * 
	 * @prop normal World vector pointing from A to B
	 * @prop points World contact point (point of intersection)
	 * @prop separations A negative value indicates overlap, in meters
	 */
	function WorldManifold() {
	  this.normal;
	  this.points = []; // [maxManifoldPoints]
	  this.separations = []; // float[maxManifoldPoints]
	}
	/**
	 * Evaluate the manifold with supplied transforms. This assumes modest motion
	 * from the original state. This does not change the point count, impulses, etc.
	 * The radii must come from the shapes that generated the manifold.
	 * 
	 * @param {WorldManifold} [wm]
	 */
	Manifold.prototype.getWorldManifold = function(wm, xfA, radiusA, xfB, radiusB) {
	  if (this.pointCount == 0) {
	    return;
	  }

	  wm = wm || new WorldManifold();

	  var normal = wm.normal;
	  var points = wm.points;
	  var separations = wm.separations;

	  // TODO: improve
	  switch (this.type) {
	  case Manifold.e_circles:
	    normal = Vec2_1.neo(1.0, 0.0);
	    var pointA = Transform_1.mulVec2(xfA, this.localPoint);
	    var pointB = Transform_1.mulVec2(xfB, this.points[0].localPoint);
	    var dist = Vec2_1.sub(pointB, pointA);
	    if (Vec2_1.lengthSquared(dist) > _Math.EPSILON * _Math.EPSILON) {
	      normal.set(dist);
	      normal.normalize();
	    }
	    var cA = pointA.clone().addMul(radiusA, normal);
	    var cB = pointB.clone().addMul(-radiusB, normal);
	    points[0] = Vec2_1.mid(cA, cB);
	    separations[0] = Vec2_1.dot(Vec2_1.sub(cB, cA), normal);
	    points.length = 1;
	    separations.length = 1;
	    break;

	  case Manifold.e_faceA:
	    normal = Rot_1.mulVec2(xfA.q, this.localNormal);
	    var planePoint = Transform_1.mulVec2(xfA, this.localPoint);

	    for (var i = 0; i < this.pointCount; ++i) {
	      var clipPoint = Transform_1.mulVec2(xfB, this.points[i].localPoint);
	      var cA = Vec2_1.clone(clipPoint).addMul(radiusA - Vec2_1.dot(Vec2_1.sub(clipPoint, planePoint), normal), normal);
	      var cB = Vec2_1.clone(clipPoint).subMul(radiusB, normal);
	      points[i] = Vec2_1.mid(cA, cB);
	      separations[i] = Vec2_1.dot(Vec2_1.sub(cB, cA), normal);
	    }
	    points.length = this.pointCount;
	    separations.length = this.pointCount;
	    break;

	  case Manifold.e_faceB:
	    normal = Rot_1.mulVec2(xfB.q, this.localNormal);
	    var planePoint = Transform_1.mulVec2(xfB, this.localPoint);

	    for (var i = 0; i < this.pointCount; ++i) {
	      var clipPoint = Transform_1.mulVec2(xfA, this.points[i].localPoint);
	      var cB = Vec2_1.combine(1, clipPoint, radiusB - Vec2_1.dot(Vec2_1.sub(clipPoint, planePoint), normal), normal);
	      var cA = Vec2_1.combine(1, clipPoint, -radiusA, normal);
	      points[i] = Vec2_1.mid(cA, cB);
	      separations[i] = Vec2_1.dot(Vec2_1.sub(cA, cB), normal);
	    }
	    points.length = this.pointCount;
	    separations.length = this.pointCount;
	    // Ensure normal points from A to B.
	    normal.mul(-1);
	    break;
	  }

	  wm.normal = normal;
	  wm.points = points;
	  wm.separations = separations;
	  return wm;
	};

	/**
	 * This is used for determining the state of contact points.
	 * 
	 * @prop {0} nullState Point does not exist
	 * @prop {1} addState Point was added in the update
	 * @prop {2} persistState Point persisted across the update
	 * @prop {3} removeState Point was removed in the update
	 */
	var PointState = {
	  // TODO: use constants
	  nullState : 0,
	  addState : 1,
	  persistState : 2,
	  removeState : 3
	};

	/**
	 * Compute the point states given two manifolds. The states pertain to the
	 * transition from manifold1 to manifold2. So state1 is either persist or remove
	 * while state2 is either add or persist.
	 * 
	 * @param {PointState[Settings.maxManifoldPoints]} state1
	 * @param {PointState[Settings.maxManifoldPoints]} state2
	 */
	function getPointStates(state1, state2, manifold1, manifold2) {
	  // for (var i = 0; i < Settings.maxManifoldPoints; ++i) {
	  // state1[i] = PointState.nullState;
	  // state2[i] = PointState.nullState;
	  // }

	  // Detect persists and removes.
	  for (var i = 0; i < manifold1.pointCount; ++i) {
	    var id = manifold1.points[i].id;// ContactID

	    state1[i] = PointState.removeState;

	    for (var j = 0; j < manifold2.pointCount; ++j) {
	      if (manifold2.points[j].id.key == id.key) {
	        state1[i] = PointState.persistState;
	        break;
	      }
	    }
	  }

	  // Detect persists and adds.
	  for (var i = 0; i < manifold2.pointCount; ++i) {
	    var id = manifold2.points[i].id;// ContactID

	    state2[i] = PointState.addState;

	    for (var j = 0; j < manifold1.pointCount; ++j) {
	      if (manifold1.points[j].id.key == id.key) {
	        state2[i] = PointState.persistState;
	        break;
	      }
	    }
	  }
	}

	/**
	 * Used for computing contact manifolds.
	 * 
	 * @prop {Vec2} v
	 * @prop {ContactID} id
	 */
	function ClipVertex() {
	  this.v = Vec2_1.zero();
	  this.id = new ContactID();
	}
	ClipVertex.prototype.set = function(o) {
	  this.v.set(o.v);
	  this.id.set(o.id);
	};

	/**
	 * Clipping for contact manifolds. Sutherland-Hodgman clipping.
	 * 
	 * @param {ClipVertex[2]} vOut
	 * @param {ClipVertex[2]} vIn
	 */
	function clipSegmentToLine(vOut, vIn, normal, offset, vertexIndexA) {
	  // Start with no output points
	  var numOut = 0;

	  // Calculate the distance of end points to the line
	  var distance0 = Vec2_1.dot(normal, vIn[0].v) - offset;
	  var distance1 = Vec2_1.dot(normal, vIn[1].v) - offset;

	  // If the points are behind the plane
	  if (distance0 <= 0.0)
	    vOut[numOut++].set(vIn[0]);
	  if (distance1 <= 0.0)
	    vOut[numOut++].set(vIn[1]);

	  // If the points are on different sides of the plane
	  if (distance0 * distance1 < 0.0) {
	    // Find intersection point of edge and plane
	    var interp = distance0 / (distance0 - distance1);
	    vOut[numOut].v.setCombine(1 - interp, vIn[0].v, interp, vIn[1].v);

	    // VertexA is hitting edgeB.
	    vOut[numOut].id.cf.indexA = vertexIndexA;
	    vOut[numOut].id.cf.indexB = vIn[0].id.cf.indexB;
	    vOut[numOut].id.cf.typeA = Manifold.e_vertex;
	    vOut[numOut].id.cf.typeB = Manifold.e_face;
	    ++numOut;
	  }

	  return numOut;
	}
	Manifold_1.clipSegmentToLine = clipSegmentToLine_1;
	Manifold_1.clipVertex = clipVertex;
	Manifold_1.getPointStates = getPointStates_1;
	Manifold_1.PointState = PointState_1;

	var _DEBUG$h = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$h = typeof ASSERT === 'undefined' ? false : ASSERT;

	var toString_1 = function(newline) {
	  newline = typeof newline === 'string' ? newline : '\n';
	  var string = "";
	  for (var name in this) {
	    if (typeof this[name] !== 'function' && typeof this[name] !== 'object') {
	      string += name + ': ' + this[name] + newline;
	    }
	  }
	  return string;
	};

	var stats = {
		toString: toString_1
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$i = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$i = typeof ASSERT === 'undefined' ? false : ASSERT;

	var Vec3_1 = Vec3;




	function Vec3(x, y, z) {
	  if (!(this instanceof Vec3)) {
	    return new Vec3(x, y, z);
	  }
	  if (typeof x === 'undefined') {
	    this.x = 0, this.y = 0, this.z = 0;
	  } else if (typeof x === 'object') {
	    this.x = x.x, this.y = x.y, this.z = x.z;
	  } else {
	    this.x = x, this.y = y, this.z = z;
	  }
	  _ASSERT$i && Vec3.assert(this);
	}
	Vec3.prototype._serialize = function() {
	  return {
	    x: this.x,
	    y: this.y,
	    z: this.z
	  };
	};

	Vec3._deserialize = function(data) {
	  var obj = Object.create(Vec3.prototype);
	  obj.x = data.x;
	  obj.y = data.y;
	  obj.z = data.z;
	  return obj;
	};

	Vec3.neo = function(x, y, z) {
	  var obj = Object.create(Vec3.prototype);
	  obj.x = x;
	  obj.y = y;
	  obj.z = z;
	  return obj;
	};

	Vec3.clone = function(v) {
	  _ASSERT$i && Vec3.assert(v);
	  return Vec3.neo(v.x, v.y, v.z);
	};

	Vec3.prototype.toString = function() {
	  return JSON.stringify(this);
	};

	/**
	 * Does this vector contain finite coordinates?
	 */
	Vec3.isValid = function(v) {
	  return v && _Math.isFinite(v.x) && _Math.isFinite(v.y) && _Math.isFinite(v.z);
	};

	Vec3.assert = function(o) {
	  if (!_ASSERT$i) return;
	  if (!Vec3.isValid(o)) {
	    _DEBUG$i && common.debug(o);
	    throw new Error('Invalid Vec3!');
	  }
	};

	Vec3.prototype.setZero = function() {
	  this.x = 0.0;
	  this.y = 0.0;
	  this.z = 0.0;
	  return this;
	};

	Vec3.prototype.set = function(x, y, z) {
	  this.x = x;
	  this.y = y;
	  this.z = z;
	  return this;
	};

	Vec3.prototype.add = function(w) {
	  this.x += w.x;
	  this.y += w.y;
	  this.z += w.z;
	  return this;
	};

	Vec3.prototype.sub = function(w) {
	  this.x -= w.x;
	  this.y -= w.y;
	  this.z -= w.z;
	  return this;
	};

	Vec3.prototype.mul = function(m) {
	  this.x *= m;
	  this.y *= m;
	  this.z *= m;
	  return this;
	};

	Vec3.areEqual = function(v, w) {
	  _ASSERT$i && Vec3.assert(v);
	  _ASSERT$i && Vec3.assert(w);
	  return v == w ||
	    typeof v === 'object' && v !== null &&
	    typeof w === 'object' && w !== null &&
	    v.x === w.x && v.y === w.y && v.z === w.z;
	};

	/**
	 * Perform the dot product on two vectors.
	 */
	Vec3.dot = function(v, w) {
	  return v.x * w.x + v.y * w.y + v.z * w.z;
	};

	/**
	 * Perform the cross product on two vectors. In 2D this produces a scalar.
	 */
	Vec3.cross = function(v, w) {
	  return new Vec3(
	    v.y * w.z - v.z * w.y,
	    v.z * w.x - v.x * w.z,
	    v.x * w.y - v.y * w.x
	  );
	};

	Vec3.add = function(v, w) {
	  return new Vec3(v.x + w.x, v.y + w.y, v.z + w.z);
	};

	Vec3.sub = function(v, w) {
	  return new Vec3(v.x - w.x, v.y - w.y, v.z - w.z);
	};

	Vec3.mul = function(v, m) {
	  return new Vec3(m * v.x, m * v.y, m * v.z);
	};

	Vec3.prototype.neg = function() {
	  this.x = -this.x;
	  this.y = -this.y;
	  this.z = -this.z;
	  return this;
	};

	Vec3.neg = function(v) {
	  return new Vec3(-v.x, -v.y, -v.z);
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$j = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$j = typeof ASSERT === 'undefined' ? false : ASSERT;

	var Mat33_1 = Mat33;






	/**
	 * A 3-by-3 matrix. Stored in column-major order.
	 */
	function Mat33(a, b, c) {
	  if (typeof a === 'object' && a !== null) {
	    this.ex = Vec3_1.clone(a);
	    this.ey = Vec3_1.clone(b);
	    this.ez = Vec3_1.clone(c);
	  } else {
	    this.ex = Vec3_1();
	    this.ey = Vec3_1();
	    this.ez = Vec3_1();
	  }
	}
	Mat33.prototype.toString = function() {
	  return JSON.stringify(this);
	};

	Mat33.isValid = function(o) {
	  return o && Vec3_1.isValid(o.ex) && Vec3_1.isValid(o.ey) && Vec3_1.isValid(o.ez);
	};

	Mat33.assert = function(o) {
	  if (!_ASSERT$j) return;
	  if (!Mat33.isValid(o)) {
	    _DEBUG$j && common.debug(o);
	    throw new Error('Invalid Mat33!');
	  }
	};

	/**
	 * Set this matrix to all zeros.
	 */
	Mat33.prototype.setZero = function() {
	  this.ex.setZero();
	  this.ey.setZero();
	  this.ez.setZero();
	  return this;
	};

	/**
	 * Solve A * x = b, where b is a column vector. This is more efficient than
	 * computing the inverse in one-shot cases.
	 * 
	 * @param {Vec3} v
	 * @returns {Vec3}
	 */
	Mat33.prototype.solve33 = function(v) {
	  var det = Vec3_1.dot(this.ex, Vec3_1.cross(this.ey, this.ez));
	  if (det != 0.0) {
	    det = 1.0 / det;
	  }
	  var r = new Vec3_1();
	  r.x = det * Vec3_1.dot(v, Vec3_1.cross(this.ey, this.ez));
	  r.y = det * Vec3_1.dot(this.ex, Vec3_1.cross(v, this.ez));
	  r.z = det * Vec3_1.dot(this.ex, Vec3_1.cross(this.ey, v));
	  return r;
	};

	/**
	 * Solve A * x = b, where b is a column vector. This is more efficient than
	 * computing the inverse in one-shot cases. Solve only the upper 2-by-2 matrix
	 * equation.
	 * 
	 * @param {Vec2} v
	 * 
	 * @returns {Vec2}
	 */
	Mat33.prototype.solve22 = function(v) {
	  var a11 = this.ex.x;
	  var a12 = this.ey.x;
	  var a21 = this.ex.y;
	  var a22 = this.ey.y;
	  var det = a11 * a22 - a12 * a21;
	  if (det != 0.0) {
	    det = 1.0 / det;
	  }
	  var r = Vec2_1.zero();
	  r.x = det * (a22 * v.x - a12 * v.y);
	  r.y = det * (a11 * v.y - a21 * v.x);
	  return r;
	};

	/**
	 * Get the inverse of this matrix as a 2-by-2. Returns the zero matrix if
	 * singular.
	 * 
	 * @param {Mat33} M
	 */
	Mat33.prototype.getInverse22 = function(M) {
	  var a = this.ex.x;
	  var b = this.ey.x;
	  var c = this.ex.y;
	  var d = this.ey.y;
	  var det = a * d - b * c;
	  if (det != 0.0) {
	    det = 1.0 / det;
	  }
	  M.ex.x = det * d;
	  M.ey.x = -det * b;
	  M.ex.z = 0.0;
	  M.ex.y = -det * c;
	  M.ey.y = det * a;
	  M.ey.z = 0.0;
	  M.ez.x = 0.0;
	  M.ez.y = 0.0;
	  M.ez.z = 0.0;
	};

	/**
	 * Get the symmetric inverse of this matrix as a 3-by-3. Returns the zero matrix
	 * if singular.
	 * 
	 * @param {Mat33} M
	 */
	Mat33.prototype.getSymInverse33 = function(M) {
	  var det = Vec3_1.dot(this.ex, Vec3_1.cross(this.ey, this.ez));
	  if (det != 0.0) {
	    det = 1.0 / det;
	  }
	  var a11 = this.ex.x;
	  var a12 = this.ey.x;
	  var a13 = this.ez.x;
	  var a22 = this.ey.y;
	  var a23 = this.ez.y;
	  var a33 = this.ez.z;

	  M.ex.x = det * (a22 * a33 - a23 * a23);
	  M.ex.y = det * (a13 * a23 - a12 * a33);
	  M.ex.z = det * (a12 * a23 - a13 * a22);

	  M.ey.x = M.ex.y;
	  M.ey.y = det * (a11 * a33 - a13 * a13);
	  M.ey.z = det * (a13 * a12 - a11 * a23);

	  M.ez.x = M.ex.z;
	  M.ez.y = M.ey.z;
	  M.ez.z = det * (a11 * a22 - a12 * a12);
	};

	/**
	 * Multiply a matrix times a vector.
	 * 
	 * @param {Mat33} a
	 * @param {Vec3|Vec2} b
	 * 
	 * @returns {Vec3|Vec2}
	 */
	Mat33.mul = function(a, b) {
	  _ASSERT$j && Mat33.assert(a);
	  if (b && 'z' in b && 'y' in b && 'x' in b) {
	    _ASSERT$j && Vec3_1.assert(b);
	    var x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;
	    var y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;
	    var z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;
	    return new Vec3_1(x, y, z);

	  } else if (b && 'y' in b && 'x' in b) {
	    _ASSERT$j && Vec2_1.assert(b);
	    var x = a.ex.x * b.x + a.ey.x * b.y;
	    var y = a.ex.y * b.x + a.ey.y * b.y;
	    return Vec2_1.neo(x, y);
	  }

	  _ASSERT$j && common.assert(false);
	};

	Mat33.mulVec3 = function(a, b) {
	  _ASSERT$j && Mat33.assert(a);
	  _ASSERT$j && Vec3_1.assert(b);
	  var x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;
	  var y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;
	  var z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;
	  return new Vec3_1(x, y, z);
	};

	Mat33.mulVec2 = function(a, b) {
	  _ASSERT$j && Mat33.assert(a);
	  _ASSERT$j && Vec2_1.assert(b);
	  var x = a.ex.x * b.x + a.ey.x * b.y;
	  var y = a.ex.y * b.x + a.ey.y * b.y;
	  return Vec2_1.neo(x, y);
	};

	Mat33.add = function(a, b) {
	  _ASSERT$j && Mat33.assert(a);
	  _ASSERT$j && Mat33.assert(b);
	  return new Mat33(
	    Vec3_1.add(a.ex, b.ex),
	    Vec3_1.add(a.ey, b.ey),
	    Vec3_1.add(a.ez, b.ez)
	  );
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$k = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$k = typeof ASSERT === 'undefined' ? false : ASSERT;

	var Distance_1 = Distance;

	var Input = DistanceInput;
	var Output = DistanceOutput;
	var _Proxy = DistanceProxy;
	var Cache = SimplexCache;

















	/**
	 * GJK using Voronoi regions (Christer Ericson) and Barycentric coordinates.
	 */

	stats.gjkCalls = 0;
	stats.gjkIters = 0;
	stats.gjkMaxIters = 0;

	/**
	 * Input for Distance. You have to option to use the shape radii in the
	 * computation. Even
	 */
	function DistanceInput() {
	  this.proxyA = new DistanceProxy();
	  this.proxyB = new DistanceProxy();
	  this.transformA = null;
	  this.transformB = null;
	  this.useRadii = false;
	}
	/**
	 * Output for Distance.
	 *
	 * @prop {Vec2} pointA closest point on shapeA
	 * @prop {Vec2} pointB closest point on shapeB
	 * @prop distance
	 * @prop iterations number of GJK iterations used
	 */
	function DistanceOutput() {
	  this.pointA = Vec2_1.zero();
	  this.pointB = Vec2_1.zero();
	  this.distance;
	  this.iterations;
	}

	/**
	 * Used to warm start Distance. Set count to zero on first call.
	 *
	 * @prop {number} metric length or area
	 * @prop {array} indexA vertices on shape A
	 * @prop {array} indexB vertices on shape B
	 * @prop {number} count
	 */
	function SimplexCache() {
	  this.metric = 0;
	  this.indexA = [];
	  this.indexB = [];
	  this.count = 0;
	}
	/**
	 * Compute the closest points between two shapes. Supports any combination of:
	 * CircleShape, PolygonShape, EdgeShape. The simplex cache is input/output. On
	 * the first call set SimplexCache.count to zero.
	 *
	 * @param {DistanceOutput} output
	 * @param {SimplexCache} cache
	 * @param {DistanceInput} input
	 */
	function Distance(output, cache, input) {
	  ++stats.gjkCalls;

	  var proxyA = input.proxyA;
	  var proxyB = input.proxyB;
	  var xfA = input.transformA;
	  var xfB = input.transformB;

	  // Initialize the simplex.
	  var simplex = new Simplex();
	  simplex.readCache(cache, proxyA, xfA, proxyB, xfB);

	  // Get simplex vertices as an array.
	  var vertices = simplex.m_v;// SimplexVertex
	  var k_maxIters = Settings_1.maxDistnceIterations;

	  // These store the vertices of the last simplex so that we
	  // can check for duplicates and prevent cycling.
	  var saveA = [];
	  var saveB = []; // int[3]
	  var saveCount = 0;
	  var distanceSqr2 = Infinity;

	  // Main iteration loop.
	  var iter = 0;
	  while (iter < k_maxIters) {
	    // Copy simplex so we can identify duplicates.
	    saveCount = simplex.m_count;
	    for (var i = 0; i < saveCount; ++i) {
	      saveA[i] = vertices[i].indexA;
	      saveB[i] = vertices[i].indexB;
	    }

	    simplex.solve();

	    // If we have 3 points, then the origin is in the corresponding triangle.
	    if (simplex.m_count == 3) {
	      break;
	    }

	    // Compute closest point.
	    var p = simplex.getClosestPoint();
	    distanceSqr2 = p.lengthSquared();

	    // Get search direction.
	    var d = simplex.getSearchDirection();

	    // Ensure the search direction is numerically fit.
	    if (d.lengthSquared() < _Math.EPSILON * _Math.EPSILON) {
	      // The origin is probably contained by a line segment
	      // or triangle. Thus the shapes are overlapped.

	      // We can't return zero here even though there may be overlap.
	      // In case the simplex is a point, segment, or triangle it is difficult
	      // to determine if the origin is contained in the CSO or very close to it.
	      break;
	    }

	    // Compute a tentative new simplex vertex using support points.
	    var vertex = vertices[simplex.m_count]; // SimplexVertex

	    vertex.indexA = proxyA.getSupport(Rot_1.mulTVec2(xfA.q, Vec2_1.neg(d)));
	    vertex.wA = Transform_1.mulVec2(xfA, proxyA.getVertex(vertex.indexA));

	    vertex.indexB = proxyB.getSupport(Rot_1.mulTVec2(xfB.q, d));
	    vertex.wB = Transform_1.mulVec2(xfB, proxyB.getVertex(vertex.indexB));

	    vertex.w = Vec2_1.sub(vertex.wB, vertex.wA);

	    // Iteration count is equated to the number of support point calls.
	    ++iter;
	    ++stats.gjkIters;

	    // Check for duplicate support points. This is the main termination
	    // criteria.
	    var duplicate = false;
	    for (var i = 0; i < saveCount; ++i) {
	      if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
	        duplicate = true;
	        break;
	      }
	    }

	    // If we found a duplicate support point we must exit to avoid cycling.
	    if (duplicate) {
	      break;
	    }

	    // New vertex is ok and needed.
	    ++simplex.m_count;
	  }

	  stats.gjkMaxIters = _Math.max(stats.gjkMaxIters, iter);

	  // Prepare output.
	  simplex.getWitnessPoints(output.pointA, output.pointB);
	  output.distance = Vec2_1.distance(output.pointA, output.pointB);
	  output.iterations = iter;

	  // Cache the simplex.
	  simplex.writeCache(cache);

	  // Apply radii if requested.
	  if (input.useRadii) {
	    var rA = proxyA.m_radius;
	    var rB = proxyB.m_radius;

	    if (output.distance > rA + rB && output.distance > _Math.EPSILON) {
	      // Shapes are still no overlapped.
	      // Move the witness points to the outer surface.
	      output.distance -= rA + rB;
	      var normal = Vec2_1.sub(output.pointB, output.pointA);
	      normal.normalize();
	      output.pointA.addMul(rA, normal);
	      output.pointB.subMul(rB, normal);
	    } else {
	      // Shapes are overlapped when radii are considered.
	      // Move the witness points to the middle.
	      var p = Vec2_1.mid(output.pointA, output.pointB);
	      output.pointA.set(p);
	      output.pointB.set(p);
	      output.distance = 0.0;
	    }
	  }
	}

	/**
	 * A distance proxy is used by the GJK algorithm. It encapsulates any shape.
	 */
	function DistanceProxy() {
	  this.m_buffer = []; // Vec2[2]
	  this.m_vertices = []; // Vec2[]
	  this.m_count = 0;
	  this.m_radius = 0;
	}
	/**
	 * Get the vertex count.
	 */
	DistanceProxy.prototype.getVertexCount = function() {
	  return this.m_count;
	};

	/**
	 * Get a vertex by index. Used by Distance.
	 */
	DistanceProxy.prototype.getVertex = function(index) {
	  _ASSERT$k && common.assert(0 <= index && index < this.m_count);
	  return this.m_vertices[index];
	};

	/**
	 * Get the supporting vertex index in the given direction.
	 */
	DistanceProxy.prototype.getSupport = function(d) {
	  var bestIndex = 0;
	  var bestValue = Vec2_1.dot(this.m_vertices[0], d);
	  for (var i = 0; i < this.m_count; ++i) {
	    var value = Vec2_1.dot(this.m_vertices[i], d);
	    if (value > bestValue) {
	      bestIndex = i;
	      bestValue = value;
	    }
	  }
	  return bestIndex;
	};

	/**
	 * Get the supporting vertex in the given direction.
	 */
	DistanceProxy.prototype.getSupportVertex = function(d) {
	  return this.m_vertices[this.getSupport(d)];
	};

	/**
	 * Initialize the proxy using the given shape. The shape must remain in scope
	 * while the proxy is in use.
	 */
	DistanceProxy.prototype.set = function(shape, index) {
	  // TODO remove, use shape instead
	  _ASSERT$k && common.assert(typeof shape.computeDistanceProxy === 'function');
	  shape.computeDistanceProxy(this, index);
	};

	function SimplexVertex() {
	  this.indexA; // wA index
	  this.indexB; // wB index
	  this.wA = Vec2_1.zero(); // support point in proxyA
	  this.wB = Vec2_1.zero(); // support point in proxyB
	  this.w = Vec2_1.zero(); // wB - wA
	  this.a; // barycentric coordinate for closest point
	}
	SimplexVertex.prototype.set = function(v) {
	  this.indexA = v.indexA;
	  this.indexB = v.indexB;
	  this.wA = Vec2_1.clone(v.wA);
	  this.wB = Vec2_1.clone(v.wB);
	  this.w = Vec2_1.clone(v.w);
	  this.a = v.a;
	};

	function Simplex() {
	  this.m_v1 = new SimplexVertex();
	  this.m_v2 = new SimplexVertex();
	  this.m_v3 = new SimplexVertex();
	  this.m_v = [ this.m_v1, this.m_v2, this.m_v3 ];
	  this.m_count;
	}
	Simplex.prototype.print = function() {
	  if (this.m_count == 3) {
	    return ["+" + this.m_count,
	      this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,
	      this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y,
	      this.m_v3.a, this.m_v3.wA.x, this.m_v3.wA.y, this.m_v3.wB.x, this.m_v3.wB.y
	    ].toString();

	  } else if (this.m_count == 2) {
	    return ["+" + this.m_count,
	      this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,
	      this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y
	    ].toString();

	  } else if (this.m_count == 1) {
	    return ["+" + this.m_count,
	      this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y
	    ].toString();

	  } else {
	    return "+" + this.m_count;
	  }
	};

	// (SimplexCache, DistanceProxy, ...)
	Simplex.prototype.readCache = function(cache, proxyA, transformA, proxyB, transformB) {
	  _ASSERT$k && common.assert(cache.count <= 3);

	  // Copy data from cache.
	  this.m_count = cache.count;
	  for (var i = 0; i < this.m_count; ++i) {
	    var v = this.m_v[i];
	    v.indexA = cache.indexA[i];
	    v.indexB = cache.indexB[i];
	    var wALocal = proxyA.getVertex(v.indexA);
	    var wBLocal = proxyB.getVertex(v.indexB);
	    v.wA = Transform_1.mulVec2(transformA, wALocal);
	    v.wB = Transform_1.mulVec2(transformB, wBLocal);
	    v.w = Vec2_1.sub(v.wB, v.wA);
	    v.a = 0.0;
	  }

	  // Compute the new simplex metric, if it is substantially different than
	  // old metric then flush the simplex.
	  if (this.m_count > 1) {
	    var metric1 = cache.metric;
	    var metric2 = this.getMetric();
	    if (metric2 < 0.5 * metric1 || 2.0 * metric1 < metric2
	        || metric2 < _Math.EPSILON) {
	      // Reset the simplex.
	      this.m_count = 0;
	    }
	  }

	  // If the cache is empty or invalid...
	  if (this.m_count == 0) {
	    var v = this.m_v[0];// SimplexVertex
	    v.indexA = 0;
	    v.indexB = 0;
	    var wALocal = proxyA.getVertex(0);
	    var wBLocal = proxyB.getVertex(0);
	    v.wA = Transform_1.mulVec2(transformA, wALocal);
	    v.wB = Transform_1.mulVec2(transformB, wBLocal);
	    v.w = Vec2_1.sub(v.wB, v.wA);
	    v.a = 1.0;
	    this.m_count = 1;
	  }
	};

	// (SimplexCache)
	Simplex.prototype.writeCache = function(cache) {
	  cache.metric = this.getMetric();
	  cache.count = this.m_count;
	  for (var i = 0; i < this.m_count; ++i) {
	    cache.indexA[i] = this.m_v[i].indexA;
	    cache.indexB[i] = this.m_v[i].indexB;
	  }
	};

	Simplex.prototype.getSearchDirection = function() {
	  switch (this.m_count) {
	  case 1:
	    return Vec2_1.neg(this.m_v1.w);

	  case 2: {
	    var e12 = Vec2_1.sub(this.m_v2.w, this.m_v1.w);
	    var sgn = Vec2_1.cross(e12, Vec2_1.neg(this.m_v1.w));
	    if (sgn > 0.0) {
	      // Origin is left of e12.
	      return Vec2_1.cross(1.0, e12);
	    } else {
	      // Origin is right of e12.
	      return Vec2_1.cross(e12, 1.0);
	    }
	  }

	  default:
	    _ASSERT$k && common.assert(false);
	    return Vec2_1.zero();
	  }
	};

	Simplex.prototype.getClosestPoint = function() {
	  switch (this.m_count) {
	  case 0:
	    _ASSERT$k && common.assert(false);
	    return Vec2_1.zero();

	  case 1:
	    return Vec2_1.clone(this.m_v1.w);

	  case 2:
	    return Vec2_1.combine(this.m_v1.a, this.m_v1.w, this.m_v2.a, this.m_v2.w);

	  case 3:
	    return Vec2_1.zero();

	  default:
	    _ASSERT$k && common.assert(false);
	    return Vec2_1.zero();
	  }
	};

	Simplex.prototype.getWitnessPoints = function(pA, pB) {
	  switch (this.m_count) {
	  case 0:
	    _ASSERT$k && common.assert(false);
	    break;

	  case 1:
	    pA.set(this.m_v1.wA);
	    pB.set(this.m_v1.wB);
	    break;

	  case 2:
	    pA.setCombine(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);
	    pB.setCombine(this.m_v1.a, this.m_v1.wB, this.m_v2.a, this.m_v2.wB);
	    break;

	  case 3:
	    pA.setCombine(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);
	    pA.addMul(this.m_v3.a, this.m_v3.wA);
	    pB.set(pA);
	    break;

	  default:
	    _ASSERT$k && common.assert(false);
	    break;
	  }
	};

	Simplex.prototype.getMetric = function() {
	  switch (this.m_count) {
	  case 0:
	    _ASSERT$k && common.assert(false);
	    return 0.0;

	  case 1:
	    return 0.0;

	  case 2:
	    return Vec2_1.distance(this.m_v1.w, this.m_v2.w);

	  case 3:
	    return Vec2_1.cross(Vec2_1.sub(this.m_v2.w, this.m_v1.w), Vec2_1.sub(this.m_v3.w,
	        this.m_v1.w));

	  default:
	    _ASSERT$k && common.assert(false);
	    return 0.0;
	  }
	};

	Simplex.prototype.solve = function() {
	  switch (this.m_count) {
	  case 1:
	    break;

	  case 2:
	    this.solve2();
	    break;

	  case 3:
	    this.solve3();
	    break;

	  default:
	    _ASSERT$k && common.assert(false);
	  }
	};

	// Solve a line segment using barycentric coordinates.
	//
	// p = a1 * w1 + a2 * w2
	// a1 + a2 = 1
	//
	// The vector from the origin to the closest point on the line is
	// perpendicular to the line.
	// e12 = w2 - w1
	// dot(p, e) = 0
	// a1 * dot(w1, e) + a2 * dot(w2, e) = 0
	//
	// 2-by-2 linear system
	// [1 1 ][a1] = [1]
	// [w1.e12 w2.e12][a2] = [0]
	//
	// Define
	// d12_1 = dot(w2, e12)
	// d12_2 = -dot(w1, e12)
	// d12 = d12_1 + d12_2
	//
	// Solution
	// a1 = d12_1 / d12
	// a2 = d12_2 / d12
	Simplex.prototype.solve2 = function() {
	  var w1 = this.m_v1.w;
	  var w2 = this.m_v2.w;
	  var e12 = Vec2_1.sub(w2, w1);

	  // w1 region
	  var d12_2 = -Vec2_1.dot(w1, e12);
	  if (d12_2 <= 0.0) {
	    // a2 <= 0, so we clamp it to 0
	    this.m_v1.a = 1.0;
	    this.m_count = 1;
	    return;
	  }

	  // w2 region
	  var d12_1 = Vec2_1.dot(w2, e12);
	  if (d12_1 <= 0.0) {
	    // a1 <= 0, so we clamp it to 0
	    this.m_v2.a = 1.0;
	    this.m_count = 1;
	    this.m_v1.set(this.m_v2);
	    return;
	  }

	  // Must be in e12 region.
	  var inv_d12 = 1.0 / (d12_1 + d12_2);
	  this.m_v1.a = d12_1 * inv_d12;
	  this.m_v2.a = d12_2 * inv_d12;
	  this.m_count = 2;
	};

	// Possible regions:
	// - points[2]
	// - edge points[0]-points[2]
	// - edge points[1]-points[2]
	// - inside the triangle
	Simplex.prototype.solve3 = function() {
	  var w1 = this.m_v1.w;
	  var w2 = this.m_v2.w;
	  var w3 = this.m_v3.w;

	  // Edge12
	  // [1 1 ][a1] = [1]
	  // [w1.e12 w2.e12][a2] = [0]
	  // a3 = 0
	  var e12 = Vec2_1.sub(w2, w1);
	  var w1e12 = Vec2_1.dot(w1, e12);
	  var w2e12 = Vec2_1.dot(w2, e12);
	  var d12_1 = w2e12;
	  var d12_2 = -w1e12;

	  // Edge13
	  // [1 1 ][a1] = [1]
	  // [w1.e13 w3.e13][a3] = [0]
	  // a2 = 0
	  var e13 = Vec2_1.sub(w3, w1);
	  var w1e13 = Vec2_1.dot(w1, e13);
	  var w3e13 = Vec2_1.dot(w3, e13);
	  var d13_1 = w3e13;
	  var d13_2 = -w1e13;

	  // Edge23
	  // [1 1 ][a2] = [1]
	  // [w2.e23 w3.e23][a3] = [0]
	  // a1 = 0
	  var e23 = Vec2_1.sub(w3, w2);// Vec2
	  var w2e23 = Vec2_1.dot(w2, e23);
	  var w3e23 = Vec2_1.dot(w3, e23);
	  var d23_1 = w3e23;
	  var d23_2 = -w2e23;

	  // Triangle123
	  var n123 = Vec2_1.cross(e12, e13);

	  var d123_1 = n123 * Vec2_1.cross(w2, w3);
	  var d123_2 = n123 * Vec2_1.cross(w3, w1);
	  var d123_3 = n123 * Vec2_1.cross(w1, w2);

	  // w1 region
	  if (d12_2 <= 0.0 && d13_2 <= 0.0) {
	    this.m_v1.a = 1.0;
	    this.m_count = 1;
	    return;
	  }

	  // e12
	  if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
	    var inv_d12 = 1.0 / (d12_1 + d12_2);
	    this.m_v1.a = d12_1 * inv_d12;
	    this.m_v2.a = d12_2 * inv_d12;
	    this.m_count = 2;
	    return;
	  }

	  // e13
	  if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
	    var inv_d13 = 1.0 / (d13_1 + d13_2);
	    this.m_v1.a = d13_1 * inv_d13;
	    this.m_v3.a = d13_2 * inv_d13;
	    this.m_count = 2;
	    this.m_v2.set(this.m_v3);
	    return;
	  }

	  // w2 region
	  if (d12_1 <= 0.0 && d23_2 <= 0.0) {
	    this.m_v2.a = 1.0;
	    this.m_count = 1;
	    this.m_v1.set(this.m_v2);
	    return;
	  }

	  // w3 region
	  if (d13_1 <= 0.0 && d23_1 <= 0.0) {
	    this.m_v3.a = 1.0;
	    this.m_count = 1;
	    this.m_v1.set(this.m_v3);
	    return;
	  }

	  // e23
	  if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
	    var inv_d23 = 1.0 / (d23_1 + d23_2);
	    this.m_v2.a = d23_1 * inv_d23;
	    this.m_v3.a = d23_2 * inv_d23;
	    this.m_count = 2;
	    this.m_v1.set(this.m_v3);
	    return;
	  }

	  // Must be in triangle123
	  var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
	  this.m_v1.a = d123_1 * inv_d123;
	  this.m_v2.a = d123_2 * inv_d123;
	  this.m_v3.a = d123_3 * inv_d123;
	  this.m_count = 3;
	};

	/**
	 * Determine if two generic shapes overlap.
	 */
	Distance.testOverlap = function(shapeA, indexA, shapeB, indexB, xfA, xfB) {
	  var input = new DistanceInput();
	  input.proxyA.set(shapeA, indexA);
	  input.proxyB.set(shapeB, indexB);
	  input.transformA = xfA;
	  input.transformB = xfB;
	  input.useRadii = true;

	  var cache = new SimplexCache();

	  var output = new DistanceOutput();
	  Distance(output, cache, input);

	  return output.distance < 10.0 * _Math.EPSILON;
	};
	Distance_1.Input = Input;
	Distance_1.Output = Output;
	Distance_1.Proxy = _Proxy;
	Distance_1.Cache = Cache;

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$l = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$l = typeof ASSERT === 'undefined' ? false : ASSERT;













	var Contact_1 = Contact;

	/**
	 * A contact edge is used to connect bodies and contacts together in a contact
	 * graph where each body is a node and each contact is an edge. A contact edge
	 * belongs to a doubly linked list maintained in each attached body. Each
	 * contact has two contact nodes, one for each attached body.
	 * 
	 * @prop {Contact} contact The contact
	 * @prop {ContactEdge} prev The previous contact edge in the body's contact list
	 * @prop {ContactEdge} next The next contact edge in the body's contact list
	 * @prop {Body} other Provides quick access to the other body attached.
	 */
	function ContactEdge(contact) {
	  this.contact = contact;
	  this.prev;
	  this.next;
	  this.other;
	}
	/**
	 * @function Contact~evaluate
	 * 
	 * @param manifold
	 * @param xfA
	 * @param fixtureA
	 * @param indexA
	 * @param xfB
	 * @param fixtureB
	 * @param indexB
	 */

	/**
	 * The class manages contact between two shapes. A contact exists for each
	 * overlapping AABB in the broad-phase (except if filtered). Therefore a contact
	 * object may exist that has no contact points.
	 * 
	 * @param {Fixture} fA
	 * @param {int} indexA
	 * @param {Fixture} fB
	 * @param {int} indexB
	 * @param {Contact~evaluate} evaluateFcn
	 */
	function Contact(fA, indexA, fB, indexB, evaluateFcn) {
	  // Nodes for connecting bodies.
	  this.m_nodeA = new ContactEdge(this);
	  this.m_nodeB = new ContactEdge(this);

	  this.m_fixtureA = fA;
	  this.m_fixtureB = fB;

	  this.m_indexA = indexA;
	  this.m_indexB = indexB;

	  this.m_evaluateFcn = evaluateFcn;

	  this.m_manifold = new Manifold_1();

	  this.m_prev = null;
	  this.m_next = null;

	  this.m_toi = 1.0;
	  this.m_toiCount = 0;
	  // This contact has a valid TOI in m_toi
	  this.m_toiFlag = false;

	  this.m_friction = mixFriction(this.m_fixtureA.m_friction,
	      this.m_fixtureB.m_friction);
	  this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution,
	      this.m_fixtureB.m_restitution);

	  this.m_tangentSpeed = 0.0;

	  // This contact can be disabled (by user)
	  this.m_enabledFlag = true;

	  // Used when crawling contact graph when forming islands.
	  this.m_islandFlag = false;

	  // Set when the shapes are touching.
	  this.m_touchingFlag = false;

	  // This contact needs filtering because a fixture filter was changed.
	  this.m_filterFlag = false;

	  // This bullet contact had a TOI event
	  this.m_bulletHitFlag = false;

	  this.v_points = []; // VelocityConstraintPoint[maxManifoldPoints]
	  this.v_normal = Vec2_1.zero();
	  this.v_normalMass = new Mat22_1();
	  this.v_K = new Mat22_1();
	  this.v_pointCount;

	  this.v_tangentSpeed;
	  this.v_friction;
	  this.v_restitution;

	  this.v_invMassA;
	  this.v_invMassB;
	  this.v_invIA;
	  this.v_invIB;

	  this.p_localPoints = []; // Vec2[maxManifoldPoints];
	  this.p_localNormal = Vec2_1.zero();
	  this.p_localPoint = Vec2_1.zero();
	  this.p_localCenterA = Vec2_1.zero();
	  this.p_localCenterB = Vec2_1.zero();
	  this.p_type; // Manifold.Type
	  this.p_radiusA;
	  this.p_radiusB;
	  this.p_pointCount;

	  this.p_invMassA;
	  this.p_invMassB;
	  this.p_invIA;
	  this.p_invIB;
	}

	Contact.prototype.initConstraint = function(step) {
	  var fixtureA = this.m_fixtureA;
	  var fixtureB = this.m_fixtureB;

	  var shapeA = fixtureA.getShape();
	  var shapeB = fixtureB.getShape();

	  var bodyA = fixtureA.getBody();
	  var bodyB = fixtureB.getBody();

	  var manifold = this.getManifold();

	  var pointCount = manifold.pointCount;
	  _ASSERT$l && common.assert(pointCount > 0);

	  this.v_invMassA = bodyA.m_invMass;
	  this.v_invMassB = bodyB.m_invMass;
	  this.v_invIA = bodyA.m_invI;
	  this.v_invIB = bodyB.m_invI;

	  this.v_friction = this.m_friction;
	  this.v_restitution = this.m_restitution;
	  this.v_tangentSpeed = this.m_tangentSpeed;

	  this.v_pointCount = pointCount;

	  this.v_K.setZero();
	  this.v_normalMass.setZero();

	  this.p_invMassA = bodyA.m_invMass;
	  this.p_invMassB = bodyB.m_invMass;
	  this.p_invIA = bodyA.m_invI;
	  this.p_invIB = bodyB.m_invI;
	  this.p_localCenterA = Vec2_1.clone(bodyA.m_sweep.localCenter);
	  this.p_localCenterB = Vec2_1.clone(bodyB.m_sweep.localCenter);

	  this.p_radiusA = shapeA.m_radius;
	  this.p_radiusB = shapeB.m_radius;

	  this.p_type = manifold.type;
	  this.p_localNormal = Vec2_1.clone(manifold.localNormal);
	  this.p_localPoint = Vec2_1.clone(manifold.localPoint);
	  this.p_pointCount = pointCount;

	  for (var j = 0; j < pointCount; ++j) {
	    var cp = manifold.points[j]; // ManifoldPoint
	    var vcp = this.v_points[j] = new VelocityConstraintPoint();

	    if (step.warmStarting) {
	      vcp.normalImpulse = step.dtRatio * cp.normalImpulse;
	      vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;

	    } else {
	      vcp.normalImpulse = 0.0;
	      vcp.tangentImpulse = 0.0;
	    }

	    vcp.rA.setZero();
	    vcp.rB.setZero();
	    vcp.normalMass = 0.0;
	    vcp.tangentMass = 0.0;
	    vcp.velocityBias = 0.0;

	    this.p_localPoints[j] = Vec2_1.clone(cp.localPoint);

	  }
	};

	/**
	 * Get the contact manifold. Do not modify the manifold unless you understand
	 * the internals of the library.
	 */
	Contact.prototype.getManifold = function() {
	  return this.m_manifold;
	};

	/**
	 * Get the world manifold.
	 * 
	 * @param {WorldManifold} [worldManifold]
	 */
	Contact.prototype.getWorldManifold = function(worldManifold) {
	  var bodyA = this.m_fixtureA.getBody();
	  var bodyB = this.m_fixtureB.getBody();
	  var shapeA = this.m_fixtureA.getShape();
	  var shapeB = this.m_fixtureB.getShape();

	  return this.m_manifold.getWorldManifold(worldManifold, bodyA.getTransform(),
	      shapeA.m_radius, bodyB.getTransform(), shapeB.m_radius);
	};

	/**
	 * Enable/disable this contact. This can be used inside the pre-solve contact
	 * listener. The contact is only disabled for the current time step (or sub-step
	 * in continuous collisions).
	 */
	Contact.prototype.setEnabled = function(flag) {
	  this.m_enabledFlag = !!flag;
	};

	/**
	 * Has this contact been disabled?
	 */
	Contact.prototype.isEnabled = function() {
	  return this.m_enabledFlag;
	};

	/**
	 * Is this contact touching?
	 */
	Contact.prototype.isTouching = function() {
	  return this.m_touchingFlag;
	};

	/**
	 * Get the next contact in the world's contact list.
	 */
	Contact.prototype.getNext = function() {
	  return this.m_next;
	};

	/**
	 * Get fixture A in this contact.
	 */
	Contact.prototype.getFixtureA = function() {
	  return this.m_fixtureA;
	};

	/**
	 * Get fixture B in this contact.
	 */
	Contact.prototype.getFixtureB = function() {
	  return this.m_fixtureB;
	};

	/**
	 * Get the child primitive index for fixture A.
	 */
	Contact.prototype.getChildIndexA = function() {
	  return this.m_indexA;
	};

	/**
	 * Get the child primitive index for fixture B.
	 */
	Contact.prototype.getChildIndexB = function() {
	  return this.m_indexB;
	};

	/**
	 * Flag this contact for filtering. Filtering will occur the next time step.
	 */
	Contact.prototype.flagForFiltering = function() {
	  this.m_filterFlag = true;
	};

	/**
	 * Override the default friction mixture. You can call this in
	 * ContactListener.preSolve. This value persists until set or reset.
	 */
	Contact.prototype.setFriction = function(friction) {
	  this.m_friction = friction;
	};

	/**
	 * Get the friction.
	 */
	Contact.prototype.getFriction = function() {
	  return this.m_friction;
	};

	/**
	 * Reset the friction mixture to the default value.
	 */
	Contact.prototype.resetFriction = function() {
	  this.m_friction = mixFriction(this.m_fixtureA.m_friction,
	      this.m_fixtureB.m_friction);
	};

	/**
	 * Override the default restitution mixture. You can call this in
	 * ContactListener.preSolve. The value persists until you set or reset.
	 */
	Contact.prototype.setRestitution = function(restitution) {
	  this.m_restitution = restitution;
	};

	/**
	 * Get the restitution.
	 */
	Contact.prototype.getRestitution = function() {
	  return this.m_restitution;
	};

	/**
	 * Reset the restitution to the default value.
	 */
	Contact.prototype.resetRestitution = function() {
	  this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution,
	      this.m_fixtureB.m_restitution);
	};

	/**
	 * Set the desired tangent speed for a conveyor belt behavior. In meters per
	 * second.
	 */
	Contact.prototype.setTangentSpeed = function(speed) {
	  this.m_tangentSpeed = speed;
	};

	/**
	 * Get the desired tangent speed. In meters per second.
	 */
	Contact.prototype.getTangentSpeed = function() {
	  return this.m_tangentSpeed;
	};

	/**
	 * Called by Update method, and implemented by subclasses.
	 */
	Contact.prototype.evaluate = function(manifold, xfA, xfB) {
	  this.m_evaluateFcn(manifold, xfA, this.m_fixtureA, this.m_indexA, xfB,
	      this.m_fixtureB, this.m_indexB);
	};

	/**
	 * Updates the contact manifold and touching status.
	 * 
	 * Note: do not assume the fixture AABBs are overlapping or are valid.
	 * 
	 * @param {function} listener.beginContact
	 * @param {function} listener.endContact
	 * @param {function} listener.preSolve
	 */
	Contact.prototype.update = function(listener) {

	  // Re-enable this contact.
	  this.m_enabledFlag = true;

	  var touching = false;
	  var wasTouching = this.m_touchingFlag;

	  var sensorA = this.m_fixtureA.isSensor();
	  var sensorB = this.m_fixtureB.isSensor();
	  var sensor = sensorA || sensorB;

	  var bodyA = this.m_fixtureA.getBody();
	  var bodyB = this.m_fixtureB.getBody();
	  var xfA = bodyA.getTransform();
	  var xfB = bodyB.getTransform();

	  // Is this contact a sensor?
	  if (sensor) {
	    var shapeA = this.m_fixtureA.getShape();
	    var shapeB = this.m_fixtureB.getShape();
	    touching = Distance_1.testOverlap(shapeA, this.m_indexA, shapeB,
	        this.m_indexB, xfA, xfB);

	    // Sensors don't generate manifolds.
	    this.m_manifold.pointCount = 0;
	  } else {

	    // TODO reuse manifold
	    var oldManifold = this.m_manifold;
	    this.m_manifold = new Manifold_1();

	    this.evaluate(this.m_manifold, xfA, xfB);
	    touching = this.m_manifold.pointCount > 0;

	    // Match old contact ids to new contact ids and copy the
	    // stored impulses to warm start the solver.
	    for (var i = 0; i < this.m_manifold.pointCount; ++i) {
	      var nmp = this.m_manifold.points[i];
	      nmp.normalImpulse = 0.0;
	      nmp.tangentImpulse = 0.0;

	      for (var j = 0; j < oldManifold.pointCount; ++j) {
	        var omp = oldManifold.points[j];
	        if (omp.id.key == nmp.id.key) { // ContactID.key
	          nmp.normalImpulse = omp.normalImpulse;
	          nmp.tangentImpulse = omp.tangentImpulse;
	          break;
	        }
	      }
	    }

	    if (touching != wasTouching) {
	      bodyA.setAwake(true);
	      bodyB.setAwake(true);
	    }
	  }

	  this.m_touchingFlag = touching;

	  if (wasTouching == false && touching == true && listener) {
	    listener.beginContact(this);
	  }

	  if (wasTouching == true && touching == false && listener) {
	    listener.endContact(this);
	  }

	  if (sensor == false && touching && listener) {
	    listener.preSolve(this, oldManifold);
	  }
	};

	Contact.prototype.solvePositionConstraint = function(step) {
	  return this._solvePositionConstraint(step, false);
	};

	Contact.prototype.solvePositionConstraintTOI = function(step, toiA, toiB) {
	  return this._solvePositionConstraint(step, true, toiA, toiB);
	};

	Contact.prototype._solvePositionConstraint = function(step, toi, toiA, toiB) {

	  var fixtureA = this.m_fixtureA;
	  var fixtureB = this.m_fixtureB;

	  var bodyA = fixtureA.getBody();
	  var bodyB = fixtureB.getBody();

	  var velocityA = bodyA.c_velocity;
	  var velocityB = bodyB.c_velocity;
	  var positionA = bodyA.c_position;
	  var positionB = bodyB.c_position;

	  var localCenterA = Vec2_1.clone(this.p_localCenterA);
	  var localCenterB = Vec2_1.clone(this.p_localCenterB);

	  var mA = 0.0;
	  var iA = 0.0;
	  if (!toi || (bodyA == toiA || bodyA == toiB)) {
	    mA = this.p_invMassA;
	    iA = this.p_invIA;
	  }

	  var mB = 0.0;
	  var iB = 0.0;
	  if (!toi || (bodyB == toiA || bodyB == toiB)) {
	    mB = this.p_invMassB;
	    iB = this.p_invIB;
	  }

	  var cA = Vec2_1.clone(positionA.c);
	  var aA = positionA.a;

	  var cB = Vec2_1.clone(positionB.c);
	  var aB = positionB.a;

	  var minSeparation = 0.0;

	  // Solve normal constraints
	  for (var j = 0; j < this.p_pointCount; ++j) {
	    var xfA = Transform_1.identity();
	    var xfB = Transform_1.identity();
	    xfA.q.set(aA);
	    xfB.q.set(aB);
	    xfA.p = Vec2_1.sub(cA, Rot_1.mulVec2(xfA.q, localCenterA));
	    xfB.p = Vec2_1.sub(cB, Rot_1.mulVec2(xfB.q, localCenterB));

	    // PositionSolverManifold
	    var normal, point, separation;
	    switch (this.p_type) {
	    case Manifold_1.e_circles:
	      var pointA = Transform_1.mulVec2(xfA, this.p_localPoint);
	      var pointB = Transform_1.mulVec2(xfB, this.p_localPoints[0]);
	      normal = Vec2_1.sub(pointB, pointA);
	      normal.normalize();
	      point = Vec2_1.combine(0.5, pointA, 0.5, pointB);
	      separation = Vec2_1.dot(Vec2_1.sub(pointB, pointA), normal) - this.p_radiusA
	          - this.p_radiusB;
	      break;

	    case Manifold_1.e_faceA:
	      normal = Rot_1.mulVec2(xfA.q, this.p_localNormal);
	      var planePoint = Transform_1.mulVec2(xfA, this.p_localPoint);
	      var clipPoint = Transform_1.mulVec2(xfB, this.p_localPoints[j]);
	      separation = Vec2_1.dot(Vec2_1.sub(clipPoint, planePoint), normal)
	          - this.p_radiusA - this.p_radiusB;
	      point = clipPoint;
	      break;

	    case Manifold_1.e_faceB:
	      normal = Rot_1.mulVec2(xfB.q, this.p_localNormal);
	      var planePoint = Transform_1.mulVec2(xfB, this.p_localPoint);
	      var clipPoint = Transform_1.mulVec2(xfA, this.p_localPoints[j]);
	      separation = Vec2_1.dot(Vec2_1.sub(clipPoint, planePoint), normal)
	          - this.p_radiusA - this.p_radiusB;
	      point = clipPoint;

	      // Ensure normal points from A to B
	      normal.mul(-1);
	      break;
	    }

	    var rA = Vec2_1.sub(point, cA);
	    var rB = Vec2_1.sub(point, cB);

	    // Track max constraint error.
	    minSeparation = _Math.min(minSeparation, separation);

	    var baumgarte = toi ? Settings_1.toiBaugarte : Settings_1.baumgarte;
	    var linearSlop = Settings_1.linearSlop;
	    var maxLinearCorrection = Settings_1.maxLinearCorrection;

	    // Prevent large corrections and allow slop.
	    var C = _Math.clamp(baumgarte * (separation + linearSlop),
	        -maxLinearCorrection, 0.0);

	    // Compute the effective mass.
	    var rnA = Vec2_1.cross(rA, normal);
	    var rnB = Vec2_1.cross(rB, normal);
	    var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;

	    // Compute normal impulse
	    var impulse = K > 0.0 ? -C / K : 0.0;

	    var P = Vec2_1.mul(impulse, normal);

	    cA.subMul(mA, P);
	    aA -= iA * Vec2_1.cross(rA, P);

	    cB.addMul(mB, P);
	    aB += iB * Vec2_1.cross(rB, P);
	  }

	  positionA.c.set(cA);
	  positionA.a = aA;

	  positionB.c.set(cB);
	  positionB.a = aB;

	  return minSeparation;
	};

	// TODO merge with ManifoldPoint
	function VelocityConstraintPoint() {
	  this.rA = Vec2_1.zero();
	  this.rB = Vec2_1.zero();
	  this.normalImpulse = 0;
	  this.tangentImpulse = 0;
	  this.normalMass = 0;
	  this.tangentMass = 0;
	  this.velocityBias = 0;
	}

	Contact.prototype.initVelocityConstraint = function(step) {
	  var fixtureA = this.m_fixtureA;
	  var fixtureB = this.m_fixtureB;

	  var bodyA = fixtureA.getBody();
	  var bodyB = fixtureB.getBody();

	  var velocityA = bodyA.c_velocity;
	  var velocityB = bodyB.c_velocity;

	  var positionA = bodyA.c_position;
	  var positionB = bodyB.c_position;

	  var radiusA = this.p_radiusA;
	  var radiusB = this.p_radiusB;
	  var manifold = this.getManifold();

	  var mA = this.v_invMassA;
	  var mB = this.v_invMassB;
	  var iA = this.v_invIA;
	  var iB = this.v_invIB;
	  var localCenterA = Vec2_1.clone(this.p_localCenterA);
	  var localCenterB = Vec2_1.clone(this.p_localCenterB);

	  var cA = Vec2_1.clone(positionA.c);
	  var aA = positionA.a;
	  var vA = Vec2_1.clone(velocityA.v);
	  var wA = velocityA.w;

	  var cB = Vec2_1.clone(positionB.c);
	  var aB = positionB.a;
	  var vB = Vec2_1.clone(velocityB.v);
	  var wB = velocityB.w;

	  _ASSERT$l && common.assert(manifold.pointCount > 0);

	  var xfA = Transform_1.identity();
	  var xfB = Transform_1.identity();
	  xfA.q.set(aA);
	  xfB.q.set(aB);
	  xfA.p.setCombine(1, cA, -1, Rot_1.mulVec2(xfA.q, localCenterA));
	  xfB.p.setCombine(1, cB, -1, Rot_1.mulVec2(xfB.q, localCenterB));

	  var worldManifold = manifold.getWorldManifold(null, xfA, radiusA, xfB, radiusB);

	  this.v_normal.set(worldManifold.normal);

	  for (var j = 0; j < this.v_pointCount; ++j) {
	    var vcp = this.v_points[j]; // VelocityConstraintPoint

	    vcp.rA.set(Vec2_1.sub(worldManifold.points[j], cA));
	    vcp.rB.set(Vec2_1.sub(worldManifold.points[j], cB));

	    var rnA = Vec2_1.cross(vcp.rA, this.v_normal);
	    var rnB = Vec2_1.cross(vcp.rB, this.v_normal);

	    var kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;

	    vcp.normalMass = kNormal > 0.0 ? 1.0 / kNormal : 0.0;

	    var tangent = Vec2_1.cross(this.v_normal, 1.0);

	    var rtA = Vec2_1.cross(vcp.rA, tangent);
	    var rtB = Vec2_1.cross(vcp.rB, tangent);

	    var kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;

	    vcp.tangentMass = kTangent > 0.0 ? 1.0 / kTangent : 0.0;

	    // Setup a velocity bias for restitution.
	    vcp.velocityBias = 0.0;
	    var vRel = Vec2_1.dot(this.v_normal, vB)
	        + Vec2_1.dot(this.v_normal, Vec2_1.cross(wB, vcp.rB))
	        - Vec2_1.dot(this.v_normal, vA)
	        - Vec2_1.dot(this.v_normal, Vec2_1.cross(wA, vcp.rA));
	    if (vRel < -Settings_1.velocityThreshold) {
	      vcp.velocityBias = -this.v_restitution * vRel;
	    }
	  }

	  // If we have two points, then prepare the block solver.
	  if (this.v_pointCount == 2 && step.blockSolve) {
	    var vcp1 = this.v_points[0]; // VelocityConstraintPoint
	    var vcp2 = this.v_points[1]; // VelocityConstraintPoint

	    var rn1A = Vec2_1.cross(vcp1.rA, this.v_normal);
	    var rn1B = Vec2_1.cross(vcp1.rB, this.v_normal);
	    var rn2A = Vec2_1.cross(vcp2.rA, this.v_normal);
	    var rn2B = Vec2_1.cross(vcp2.rB, this.v_normal);

	    var k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;
	    var k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;
	    var k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;

	    // Ensure a reasonable condition number.
	    var k_maxConditionNumber = 1000.0;
	    if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
	      // K is safe to invert.
	      this.v_K.ex.set(k11, k12);
	      this.v_K.ey.set(k12, k22);
	      this.v_normalMass.set(this.v_K.getInverse());
	    } else {
	      // The constraints are redundant, just use one.
	      // TODO_ERIN use deepest?
	      this.v_pointCount = 1;
	    }
	  }

	  positionA.c.set(cA);
	  positionA.a = aA;
	  velocityA.v.set(vA);
	  velocityA.w = wA;

	  positionB.c.set(cB);
	  positionB.a = aB;
	  velocityB.v.set(vB);
	  velocityB.w = wB;
	};

	Contact.prototype.warmStartConstraint = function(step) {
	  var fixtureA = this.m_fixtureA;
	  var fixtureB = this.m_fixtureB;

	  var bodyA = fixtureA.getBody();
	  var bodyB = fixtureB.getBody();

	  var velocityA = bodyA.c_velocity;
	  var velocityB = bodyB.c_velocity;
	  var positionA = bodyA.c_position;
	  var positionB = bodyB.c_position;

	  var mA = this.v_invMassA;
	  var iA = this.v_invIA;
	  var mB = this.v_invMassB;
	  var iB = this.v_invIB;

	  var vA = Vec2_1.clone(velocityA.v);
	  var wA = velocityA.w;
	  var vB = Vec2_1.clone(velocityB.v);
	  var wB = velocityB.w;

	  var normal = this.v_normal;
	  var tangent = Vec2_1.cross(normal, 1.0);

	  for (var j = 0; j < this.v_pointCount; ++j) {
	    var vcp = this.v_points[j]; // VelocityConstraintPoint

	    var P = Vec2_1.combine(vcp.normalImpulse, normal, vcp.tangentImpulse, tangent);
	    wA -= iA * Vec2_1.cross(vcp.rA, P);
	    vA.subMul(mA, P);
	    wB += iB * Vec2_1.cross(vcp.rB, P);
	    vB.addMul(mB, P);
	  }

	  velocityA.v.set(vA);
	  velocityA.w = wA;
	  velocityB.v.set(vB);
	  velocityB.w = wB;
	};

	Contact.prototype.storeConstraintImpulses = function(step) {
	  var manifold = this.m_manifold;
	  for (var j = 0; j < this.v_pointCount; ++j) {
	    manifold.points[j].normalImpulse = this.v_points[j].normalImpulse;
	    manifold.points[j].tangentImpulse = this.v_points[j].tangentImpulse;
	  }
	};

	Contact.prototype.solveVelocityConstraint = function(step) {
	  var bodyA = this.m_fixtureA.m_body;
	  var bodyB = this.m_fixtureB.m_body;

	  var velocityA = bodyA.c_velocity;
	  var positionA = bodyA.c_position;

	  var velocityB = bodyB.c_velocity;
	  var positionB = bodyB.c_position;

	  var mA = this.v_invMassA;
	  var iA = this.v_invIA;
	  var mB = this.v_invMassB;
	  var iB = this.v_invIB;

	  var vA = Vec2_1.clone(velocityA.v);
	  var wA = velocityA.w;
	  var vB = Vec2_1.clone(velocityB.v);
	  var wB = velocityB.w;

	  var normal = this.v_normal;
	  var tangent = Vec2_1.cross(normal, 1.0);
	  var friction = this.v_friction;

	  _ASSERT$l && common.assert(this.v_pointCount == 1 || this.v_pointCount == 2);

	  // Solve tangent constraints first because non-penetration is more important
	  // than friction.
	  for (var j = 0; j < this.v_pointCount; ++j) {
	    var vcp = this.v_points[j]; // VelocityConstraintPoint

	    // Relative velocity at contact
	    var dv = Vec2_1.zero();
	    dv.addCombine(1, vB, 1, Vec2_1.cross(wB, vcp.rB));
	    dv.subCombine(1, vA, 1, Vec2_1.cross(wA, vcp.rA));

	    // Compute tangent force
	    var vt = Vec2_1.dot(dv, tangent) - this.v_tangentSpeed;
	    var lambda = vcp.tangentMass * (-vt);

	    // Clamp the accumulated force
	    var maxFriction = friction * vcp.normalImpulse;
	    var newImpulse = _Math.clamp(vcp.tangentImpulse + lambda, -maxFriction,
	        maxFriction);
	    lambda = newImpulse - vcp.tangentImpulse;
	    vcp.tangentImpulse = newImpulse;

	    // Apply contact impulse
	    var P = Vec2_1.mul(lambda, tangent);

	    vA.subMul(mA, P);
	    wA -= iA * Vec2_1.cross(vcp.rA, P);

	    vB.addMul(mB, P);
	    wB += iB * Vec2_1.cross(vcp.rB, P);
	  }

	  // Solve normal constraints
	  if (this.v_pointCount == 1 || step.blockSolve == false) {
	    for (var i = 0; i < this.v_pointCount; ++i) {
	      var vcp = this.v_points[i]; // VelocityConstraintPoint

	      // Relative velocity at contact
	      var dv = Vec2_1.zero();
	      dv.addCombine(1, vB, 1, Vec2_1.cross(wB, vcp.rB));
	      dv.subCombine(1, vA, 1, Vec2_1.cross(wA, vcp.rA));

	      // Compute normal impulse
	      var vn = Vec2_1.dot(dv, normal);
	      var lambda = -vcp.normalMass * (vn - vcp.velocityBias);

	      // Clamp the accumulated impulse
	      var newImpulse = _Math.max(vcp.normalImpulse + lambda, 0.0);
	      lambda = newImpulse - vcp.normalImpulse;
	      vcp.normalImpulse = newImpulse;

	      // Apply contact impulse
	      var P = Vec2_1.mul(lambda, normal);

	      vA.subMul(mA, P);
	      wA -= iA * Vec2_1.cross(vcp.rA, P);

	      vB.addMul(mB, P);
	      wB += iB * Vec2_1.cross(vcp.rB, P);
	    }
	  } else {
	    // Block solver developed in collaboration with Dirk Gregorius (back in
	    // 01/07 on Box2D_Lite).
	    // Build the mini LCP for this contact patch
	    //
	    // vn = A * x + b, vn >= 0, , vn >= 0, x >= 0 and vn_i * x_i = 0 with i =
	    // 1..2
	    //
	    // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )
	    // b = vn0 - velocityBias
	    //
	    // The system is solved using the "Total enumeration method" (s. Murty).
	    // The complementary constraint vn_i * x_i
	    // implies that we must have in any solution either vn_i = 0 or x_i = 0.
	    // So for the 2D contact problem the cases
	    // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and
	    // vn1 = 0 need to be tested. The first valid
	    // solution that satisfies the problem is chosen.
	    // 
	    // In order to account of the accumulated impulse 'a' (because of the
	    // iterative nature of the solver which only requires
	    // that the accumulated impulse is clamped and not the incremental
	    // impulse) we change the impulse variable (x_i).
	    //
	    // Substitute:
	    // 
	    // x = a + d
	    // 
	    // a := old total impulse
	    // x := new total impulse
	    // d := incremental impulse
	    //
	    // For the current iteration we extend the formula for the incremental
	    // impulse
	    // to compute the new total impulse:
	    //
	    // vn = A * d + b
	    // = A * (x - a) + b
	    // = A * x + b - A * a
	    // = A * x + b'
	    // b' = b - A * a;

	    var vcp1 = this.v_points[0]; // VelocityConstraintPoint
	    var vcp2 = this.v_points[1]; // VelocityConstraintPoint

	    var a = Vec2_1.neo(vcp1.normalImpulse, vcp2.normalImpulse);
	    _ASSERT$l && common.assert(a.x >= 0.0 && a.y >= 0.0);

	    // Relative velocity at contact
	    var dv1 = Vec2_1.zero().add(vB).add(Vec2_1.cross(wB, vcp1.rB)).sub(vA).sub(Vec2_1.cross(wA, vcp1.rA));
	    var dv2 = Vec2_1.zero().add(vB).add(Vec2_1.cross(wB, vcp2.rB)).sub(vA).sub(Vec2_1.cross(wA, vcp2.rA));

	    // Compute normal velocity
	    var vn1 = Vec2_1.dot(dv1, normal);
	    var vn2 = Vec2_1.dot(dv2, normal);

	    var b = Vec2_1.neo(vn1 - vcp1.velocityBias, vn2 - vcp2.velocityBias);

	    // Compute b'
	    b.sub(Mat22_1.mulVec2(this.v_K, a));
	    // NOT_USED(k_errorTol);

	    for (;;) {
	      //
	      // Case 1: vn = 0
	      //
	      // 0 = A * x + b'
	      //
	      // Solve for x:
	      //
	      // x = - inv(A) * b'
	      //
	      var x = Mat22_1.mulVec2(this.v_normalMass, b).neg();

	      if (x.x >= 0.0 && x.y >= 0.0) {
	        // Get the incremental impulse
	        var d = Vec2_1.sub(x, a);

	        // Apply incremental impulse
	        var P1 = Vec2_1.mul(d.x, normal);
	        var P2 = Vec2_1.mul(d.y, normal);

	        vA.subCombine(mA, P1, mA, P2);
	        wA -= iA * (Vec2_1.cross(vcp1.rA, P1) + Vec2_1.cross(vcp2.rA, P2));

	        vB.addCombine(mB, P1, mB, P2);
	        wB += iB * (Vec2_1.cross(vcp1.rB, P1) + Vec2_1.cross(vcp2.rB, P2));

	        // Accumulate
	        vcp1.normalImpulse = x.x;
	        vcp2.normalImpulse = x.y;
	        break;
	      }

	      //
	      // Case 2: vn1 = 0 and x2 = 0
	      //
	      // 0 = a11 * x1 + a12 * 0 + b1'
	      // vn2 = a21 * x1 + a22 * 0 + b2'
	      //
	      x.x = -vcp1.normalMass * b.x;
	      x.y = 0.0;
	      vn1 = 0.0;
	      vn2 = this.v_K.ex.y * x.x + b.y;

	      if (x.x >= 0.0 && vn2 >= 0.0) {
	        // Get the incremental impulse
	        var d = Vec2_1.sub(x, a);

	        // Apply incremental impulse
	        var P1 = Vec2_1.mul(d.x, normal);
	        var P2 = Vec2_1.mul(d.y, normal);
	        vA.subCombine(mA, P1, mA, P2);
	        wA -= iA * (Vec2_1.cross(vcp1.rA, P1) + Vec2_1.cross(vcp2.rA, P2));

	        vB.addCombine(mB, P1, mB, P2);
	        wB += iB * (Vec2_1.cross(vcp1.rB, P1) + Vec2_1.cross(vcp2.rB, P2));

	        // Accumulate
	        vcp1.normalImpulse = x.x;
	        vcp2.normalImpulse = x.y;

	        if (false) {
	          var dv1;
	        }
	        break;
	      }

	      //
	      // Case 3: vn2 = 0 and x1 = 0
	      //
	      // vn1 = a11 * 0 + a12 * x2 + b1'
	      // 0 = a21 * 0 + a22 * x2 + b2'
	      //
	      x.x = 0.0;
	      x.y = -vcp2.normalMass * b.y;
	      vn1 = this.v_K.ey.x * x.y + b.x;
	      vn2 = 0.0;

	      if (x.y >= 0.0 && vn1 >= 0.0) {
	        // Resubstitute for the incremental impulse
	        var d = Vec2_1.sub(x, a);

	        // Apply incremental impulse
	        var P1 = Vec2_1.mul(d.x, normal);
	        var P2 = Vec2_1.mul(d.y, normal);
	        vA.subCombine(mA, P1, mA, P2);
	        wA -= iA * (Vec2_1.cross(vcp1.rA, P1) + Vec2_1.cross(vcp2.rA, P2));

	        vB.addCombine(mB, P1, mB, P2);
	        wB += iB * (Vec2_1.cross(vcp1.rB, P1) + Vec2_1.cross(vcp2.rB, P2));

	        // Accumulate
	        vcp1.normalImpulse = x.x;
	        vcp2.normalImpulse = x.y;

	        if (false) {
	          var dv1;
	        }
	        break;
	      }

	      //
	      // Case 4: x1 = 0 and x2 = 0
	      // 
	      // vn1 = b1
	      // vn2 = b2;
	      //
	      x.x = 0.0;
	      x.y = 0.0;
	      vn1 = b.x;
	      vn2 = b.y;

	      if (vn1 >= 0.0 && vn2 >= 0.0) {
	        // Resubstitute for the incremental impulse
	        var d = Vec2_1.sub(x, a);

	        // Apply incremental impulse
	        var P1 = Vec2_1.mul(d.x, normal);
	        var P2 = Vec2_1.mul(d.y, normal);
	        vA.subCombine(mA, P1, mA, P2);
	        wA -= iA * (Vec2_1.cross(vcp1.rA, P1) + Vec2_1.cross(vcp2.rA, P2));

	        vB.addCombine(mB, P1, mB, P2);
	        wB += iB * (Vec2_1.cross(vcp1.rB, P1) + Vec2_1.cross(vcp2.rB, P2));

	        // Accumulate
	        vcp1.normalImpulse = x.x;
	        vcp2.normalImpulse = x.y;

	        break;
	      }

	      // No solution, give up. This is hit sometimes, but it doesn't seem to
	      // matter.
	      break;
	    }
	  }

	  velocityA.v.set(vA);
	  velocityA.w = wA;

	  velocityB.v.set(vB);
	  velocityB.w = wB;
	};

	/**
	 * Friction mixing law. The idea is to allow either fixture to drive the
	 * restitution to zero. For example, anything slides on ice.
	 */
	function mixFriction(friction1, friction2) {
	  return _Math.sqrt(friction1 * friction2);
	}

	/**
	 * Restitution mixing law. The idea is allow for anything to bounce off an
	 * inelastic surface. For example, a superball bounces on anything.
	 */
	function mixRestitution(restitution1, restitution2) {
	  return restitution1 > restitution2 ? restitution1 : restitution2;
	}

	var s_registers = [];

	/**
	 * @param fn function(fixtureA, indexA, fixtureB, indexB) Contact
	 */
	Contact.addType = function(type1, type2, callback) {

	  s_registers[type1] = s_registers[type1] || {};
	  s_registers[type1][type2] = callback;
	};

	Contact.create = function(fixtureA, indexA, fixtureB, indexB) {
	  var typeA = fixtureA.getType(); // Shape.Type
	  var typeB = fixtureB.getType(); // Shape.Type

	  // TODO: pool contacts
	  var contact, evaluateFcn;
	  if (evaluateFcn = s_registers[typeA] && s_registers[typeA][typeB]) {
	    contact = new Contact(fixtureA, indexA, fixtureB, indexB, evaluateFcn);
	  } else if (evaluateFcn = s_registers[typeB] && s_registers[typeB][typeA]) {
	    contact = new Contact(fixtureB, indexB, fixtureA, indexA, evaluateFcn);
	  } else {
	    return null;
	  }

	  // Contact creation may swap fixtures.
	  fixtureA = contact.getFixtureA();
	  fixtureB = contact.getFixtureB();
	  indexA = contact.getChildIndexA();
	  indexB = contact.getChildIndexB();
	  var bodyA = fixtureA.getBody();
	  var bodyB = fixtureB.getBody();

	  // Connect to body A
	  contact.m_nodeA.contact = contact;
	  contact.m_nodeA.other = bodyB;

	  contact.m_nodeA.prev = null;
	  contact.m_nodeA.next = bodyA.m_contactList;
	  if (bodyA.m_contactList != null) {
	    bodyA.m_contactList.prev = contact.m_nodeA;
	  }
	  bodyA.m_contactList = contact.m_nodeA;

	  // Connect to body B
	  contact.m_nodeB.contact = contact;
	  contact.m_nodeB.other = bodyA;

	  contact.m_nodeB.prev = null;
	  contact.m_nodeB.next = bodyB.m_contactList;
	  if (bodyB.m_contactList != null) {
	    bodyB.m_contactList.prev = contact.m_nodeB;
	  }
	  bodyB.m_contactList = contact.m_nodeB;

	  // Wake up the bodies
	  if (fixtureA.isSensor() == false && fixtureB.isSensor() == false) {
	    bodyA.setAwake(true);
	    bodyB.setAwake(true);
	  }

	  return contact;
	};

	Contact.destroy = function(contact, listener) {
	  var fixtureA = contact.m_fixtureA;
	  var fixtureB = contact.m_fixtureB;

	  var bodyA = fixtureA.getBody();
	  var bodyB = fixtureB.getBody();

	  if (contact.isTouching()) {
	    listener.endContact(contact);
	  }

	  // Remove from body 1
	  if (contact.m_nodeA.prev) {
	    contact.m_nodeA.prev.next = contact.m_nodeA.next;
	  }

	  if (contact.m_nodeA.next) {
	    contact.m_nodeA.next.prev = contact.m_nodeA.prev;
	  }

	  if (contact.m_nodeA == bodyA.m_contactList) {
	    bodyA.m_contactList = contact.m_nodeA.next;
	  }

	  // Remove from body 2
	  if (contact.m_nodeB.prev) {
	    contact.m_nodeB.prev.next = contact.m_nodeB.next;
	  }

	  if (contact.m_nodeB.next) {
	    contact.m_nodeB.next.prev = contact.m_nodeB.prev;
	  }

	  if (contact.m_nodeB == bodyB.m_contactList) {
	    bodyB.m_contactList = contact.m_nodeB.next;
	  }

	  if (contact.m_manifold.pointCount > 0 && fixtureA.isSensor() == false
	      && fixtureB.isSensor() == false) {
	    bodyA.setAwake(true);
	    bodyB.setAwake(true);
	  }

	  var typeA = fixtureA.getType(); // Shape.Type
	  var typeB = fixtureB.getType(); // Shape.Type

	  var destroyFcn = s_registers[typeA][typeB].destroyFcn;
	  if (typeof destroyFcn === 'function') {
	    destroyFcn(contact);
	  }
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$m = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$m = typeof ASSERT === 'undefined' ? false : ASSERT;

	var Joint_1 = Joint;



	/**
	 * A joint edge is used to connect bodies and joints together in a joint graph
	 * where each body is a node and each joint is an edge. A joint edge belongs to
	 * a doubly linked list maintained in each attached body. Each joint has two
	 * joint nodes, one for each attached body.
	 * 
	 * @prop {Body} other provides quick access to the other body attached.
	 * @prop {Joint} joint the joint
	 * @prop {JointEdge} prev the previous joint edge in the body's joint list
	 * @prop {JointEdge} next the next joint edge in the body's joint list
	 */
	function JointEdge() {
	  this.other = null;
	  this.joint = null;
	  this.prev = null;
	  this.next = null;
	}
	/**
	 * The base joint class. Joints are used to constraint two bodies together in
	 * various fashions. Some joints also feature limits and motors.
	 * 
	 * @param {JointDef} def
	 */
	function Joint(def, bodyA, bodyB) {
	  bodyA = def.bodyA || bodyA;
	  bodyB = def.bodyB || bodyB;

	  _ASSERT$m && common.assert(bodyA);
	  _ASSERT$m && common.assert(bodyB);
	  _ASSERT$m && common.assert(bodyA != bodyB);

	  this.m_type = 'unknown-joint';

	  this.m_bodyA = bodyA;
	  this.m_bodyB = bodyB;

	  this.m_index = 0;
	  this.m_collideConnected = !!def.collideConnected;

	  this.m_prev = null;
	  this.m_next = null;

	  this.m_edgeA = new JointEdge();
	  this.m_edgeB = new JointEdge();

	  this.m_islandFlag = false;
	  this.m_userData = def.userData;
	}
	Joint.TYPES = {};

	Joint._deserialize = function(data, context, restore) {
	  var clazz = Joint.TYPES[data.type];
	  return clazz && restore(clazz, data);
	};

	/**
	 * Short-cut function to determine if either body is inactive.
	 * 
	 * @returns {boolean}
	 */
	Joint.prototype.isActive = function() {
	  return this.m_bodyA.isActive() && this.m_bodyB.isActive();
	};

	/**
	 * Get the type of the concrete joint.
	 * 
	 * @returns JointType
	 */
	Joint.prototype.getType = function() {
	  return this.m_type;
	};

	/**
	 * Get the first body attached to this joint.
	 * 
	 * @returns Body
	 */
	Joint.prototype.getBodyA = function() {
	  return this.m_bodyA;
	};

	/**
	 * Get the second body attached to this joint.
	 * 
	 * @returns Body
	 */
	Joint.prototype.getBodyB = function() {
	  return this.m_bodyB;
	};

	/**
	 * Get the next joint the world joint list.
	 * 
	 * @returns Joint
	 */
	Joint.prototype.getNext = function() {
	  return this.m_next;
	};

	Joint.prototype.getUserData = function() {
	  return this.m_userData;
	};

	Joint.prototype.setUserData = function(data) {
	  this.m_userData = data;
	};

	/**
	 * Get collide connected. Note: modifying the collide connect flag won't work
	 * correctly because the flag is only checked when fixture AABBs begin to
	 * overlap.
	 * 
	 * @returns {boolean}
	 */
	Joint.prototype.getCollideConnected = function() {
	  return this.m_collideConnected;
	};

	/**
	 * Get the anchor point on bodyA in world coordinates.
	 * 
	 * @return {Vec2}
	 */
	Joint.prototype.getAnchorA = function() {
	};

	/**
	 * Get the anchor point on bodyB in world coordinates.
	 * 
	 * @return {Vec2}
	 */
	Joint.prototype.getAnchorB = function() {
	};

	/**
	 * Get the reaction force on bodyB at the joint anchor in Newtons.
	 * 
	 * @param {float} inv_dt
	 * @return {Vec2}
	 */
	Joint.prototype.getReactionForce = function(inv_dt) {
	};

	/**
	 * Get the reaction torque on bodyB in N*m.
	 * 
	 * @param {float} inv_dt
	 * @return {float}
	 */
	Joint.prototype.getReactionTorque = function(inv_dt) {
	};

	/**
	 * Shift the origin for any points stored in world coordinates.
	 * 
	 * @param {Vec2} newOrigin
	 */
	Joint.prototype.shiftOrigin = function(newOrigin) {
	};

	/**
	 */
	Joint.prototype.initVelocityConstraints = function(step) {
	};

	/**
	 */
	Joint.prototype.solveVelocityConstraints = function(step) {
	};

	/**
	 * This returns true if the position errors are within tolerance.
	 */
	Joint.prototype.solvePositionConstraints = function(step) {
	};

	var _DEBUG$n = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$n = typeof ASSERT === 'undefined' ? false : ASSERT;

	var now = function() {
	  return Date.now();
	};

	var diff = function(time) {
	  return Date.now() - time;
	};

	var Timer = {
		now: now,
		diff: diff
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$o = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$o = typeof ASSERT === 'undefined' ? false : ASSERT;

	var TimeOfImpact_1 = TimeOfImpact;
	var Input$1 = TOIInput;
	var Output$1 = TOIOutput;




















	var DistanceInput$1 = Distance_1.Input;
	var DistanceOutput$1 = Distance_1.Output;
	var DistanceProxy$1 = Distance_1.Proxy;
	var SimplexCache$1 = Distance_1.Cache;

	/**
	 * Input parameters for TimeOfImpact.
	 * 
	 * @prop {DistanceProxy} proxyA
	 * @prop {DistanceProxy} proxyB
	 * @prop {Sweep} sweepA
	 * @prop {Sweep} sweepB
	 * @prop tMax defines sweep interval [0, tMax]
	 */
	function TOIInput() {
	  this.proxyA = new DistanceProxy$1();
	  this.proxyB = new DistanceProxy$1();
	  this.sweepA = new Sweep_1();
	  this.sweepB = new Sweep_1();
	  this.tMax;
	}
	// TOIOutput State
	TOIOutput.e_unknown = 0;
	TOIOutput.e_failed = 1;
	TOIOutput.e_overlapped = 2;
	TOIOutput.e_touching = 3;
	TOIOutput.e_separated = 4;

	/**
	 * Output parameters for TimeOfImpact.
	 * 
	 * @prop state
	 * @prop t
	 */
	function TOIOutput() {
	  this.state;
	  this.t;
	}
	stats.toiTime = 0;
	stats.toiMaxTime = 0;
	stats.toiCalls = 0;
	stats.toiIters = 0;
	stats.toiMaxIters = 0;
	stats.toiRootIters = 0;
	stats.toiMaxRootIters = 0;

	/**
	 * Compute the upper bound on time before two shapes penetrate. Time is
	 * represented as a fraction between [0,tMax]. This uses a swept separating axis
	 * and may miss some intermediate, non-tunneling collision. If you change the
	 * time interval, you should call this function again.
	 * 
	 * Note: use Distance to compute the contact point and normal at the time of
	 * impact.
	 * 
	 * CCD via the local separating axis method. This seeks progression by computing
	 * the largest time at which separation is maintained.
	 */
	function TimeOfImpact(output, input) {
	  var timer = Timer.now();

	  ++stats.toiCalls;

	  output.state = TOIOutput.e_unknown;
	  output.t = input.tMax;

	  var proxyA = input.proxyA; // DistanceProxy
	  var proxyB = input.proxyB; // DistanceProxy

	  var sweepA = input.sweepA; // Sweep
	  var sweepB = input.sweepB; // Sweep

	  // Large rotations can make the root finder fail, so we normalize the
	  // sweep angles.
	  sweepA.normalize();
	  sweepB.normalize();

	  var tMax = input.tMax;

	  var totalRadius = proxyA.m_radius + proxyB.m_radius;
	  var target = _Math.max(Settings_1.linearSlop, totalRadius - 3.0 * Settings_1.linearSlop);
	  var tolerance = 0.25 * Settings_1.linearSlop;
	  _ASSERT$o && common.assert(target > tolerance);

	  var t1 = 0.0;
	  var k_maxIterations = Settings_1.maxTOIIterations;
	  var iter = 0;

	  // Prepare input for distance query.
	  var cache = new SimplexCache$1();

	  var distanceInput = new DistanceInput$1();
	  distanceInput.proxyA = input.proxyA;
	  distanceInput.proxyB = input.proxyB;
	  distanceInput.useRadii = false;

	  // The outer loop progressively attempts to compute new separating axes.
	  // This loop terminates when an axis is repeated (no progress is made).
	  for (;;) {
	    var xfA = Transform_1.identity();
	    var xfB = Transform_1.identity();
	    sweepA.getTransform(xfA, t1);
	    sweepB.getTransform(xfB, t1);

	    // Get the distance between shapes. We can also use the results
	    // to get a separating axis.
	    distanceInput.transformA = xfA;
	    distanceInput.transformB = xfB;
	    var distanceOutput = new DistanceOutput$1();
	    Distance_1(distanceOutput, cache, distanceInput);

	    // If the shapes are overlapped, we give up on continuous collision.
	    if (distanceOutput.distance <= 0.0) {
	      // Failure!
	      output.state = TOIOutput.e_overlapped;
	      output.t = 0.0;
	      break;
	    }

	    if (distanceOutput.distance < target + tolerance) {
	      // Victory!
	      output.state = TOIOutput.e_touching;
	      output.t = t1;
	      break;
	    }

	    // Initialize the separating axis.
	    var fcn = new SeparationFunction();
	    fcn.initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);

	    // if (false) {
	    //   // Dump the curve seen by the root finder
	    //   var N = 100;
	    //   var dx = 1.0 / N;
	    //   var xs = []; // [ N + 1 ];
	    //   var fs = []; // [ N + 1 ];
	    //   var x = 0.0;
	    //   for (var i = 0; i <= N; ++i) {
	    //     sweepA.getTransform(xfA, x);
	    //     sweepB.getTransform(xfB, x);
	    //     var f = fcn.evaluate(xfA, xfB) - target;
	    //     printf("%g %g\n", x, f);
	    //     xs[i] = x;
	    //     fs[i] = f;
	    //     x += dx;
	    //   }
	    // }

	    // Compute the TOI on the separating axis. We do this by successively
	    // resolving the deepest point. This loop is bounded by the number of
	    // vertices.
	    var done = false;
	    var t2 = tMax;
	    var pushBackIter = 0;
	    for (;;) {
	      // Find the deepest point at t2. Store the witness point indices.
	      var s2 = fcn.findMinSeparation(t2);
	      var indexA = fcn.indexA;
	      var indexB = fcn.indexB;

	      // Is the final configuration separated?
	      if (s2 > target + tolerance) {
	        // Victory!
	        output.state = TOIOutput.e_separated;
	        output.t = tMax;
	        done = true;
	        break;
	      }

	      // Has the separation reached tolerance?
	      if (s2 > target - tolerance) {
	        // Advance the sweeps
	        t1 = t2;
	        break;
	      }

	      // Compute the initial separation of the witness points.
	      var s1 = fcn.evaluate(t1);
	      var indexA = fcn.indexA;
	      var indexB = fcn.indexB;

	      // Check for initial overlap. This might happen if the root finder
	      // runs out of iterations.
	      if (s1 < target - tolerance) {
	        output.state = TOIOutput.e_failed;
	        output.t = t1;
	        done = true;
	        break;
	      }

	      // Check for touching
	      if (s1 <= target + tolerance) {
	        // Victory! t1 should hold the TOI (could be 0.0).
	        output.state = TOIOutput.e_touching;
	        output.t = t1;
	        done = true;
	        break;
	      }

	      // Compute 1D root of: f(x) - target = 0
	      var rootIterCount = 0;
	      var a1 = t1, a2 = t2;
	      for (;;) {
	        // Use a mix of the secant rule and bisection.
	        var t;
	        if (rootIterCount & 1) {
	          // Secant rule to improve convergence.
	          t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);
	        } else {
	          // Bisection to guarantee progress.
	          t = 0.5 * (a1 + a2);
	        }

	        ++rootIterCount;
	        ++stats.toiRootIters;

	        var s = fcn.evaluate(t);
	        var indexA = fcn.indexA;
	        var indexB = fcn.indexB;

	        if (_Math.abs(s - target) < tolerance) {
	          // t2 holds a tentative value for t1
	          t2 = t;
	          break;
	        }

	        // Ensure we continue to bracket the root.
	        if (s > target) {
	          a1 = t;
	          s1 = s;
	        } else {
	          a2 = t;
	          s2 = s;
	        }

	        if (rootIterCount == 50) {
	          break;
	        }
	      }

	      stats.toiMaxRootIters = _Math.max(stats.toiMaxRootIters, rootIterCount);

	      ++pushBackIter;

	      if (pushBackIter == Settings_1.maxPolygonVertices) {
	        break;
	      }
	    }

	    ++iter;
	    ++stats.toiIters;

	    if (done) {
	      break;
	    }

	    if (iter == k_maxIterations) {
	      // Root finder got stuck. Semi-victory.
	      output.state = TOIOutput.e_failed;
	      output.t = t1;
	      break;
	    }
	  }

	  stats.toiMaxIters = _Math.max(stats.toiMaxIters, iter);

	  var time = Timer.diff(timer);
	  stats.toiMaxTime = _Math.max(stats.toiMaxTime, time);
	  stats.toiTime += time;
	}

	// SeparationFunction Type
	var e_points = 1;
	var e_faceA = 2;
	var e_faceB = 3;

	function SeparationFunction() {
	  this.m_proxyA = new DistanceProxy$1();
	  this.m_proxyB = new DistanceProxy$1();
	  this.m_sweepA;// Sweep
	  this.m_sweepB;// Sweep
	  this.indexA;// integer
	  this.indexB;// integer
	  this.m_type;
	  this.m_localPoint = Vec2_1.zero();
	  this.m_axis = Vec2_1.zero();
	}
	// TODO_ERIN might not need to return the separation

	/**
	 * @param {SimplexCache} cache
	 * @param {DistanceProxy} proxyA
	 * @param {Sweep} sweepA
	 * @param {DistanceProxy} proxyB
	 * @param {Sweep} sweepB
	 * @param {float} t1
	 */
	SeparationFunction.prototype.initialize = function(cache, proxyA, sweepA, proxyB, sweepB, t1) {
	  this.m_proxyA = proxyA;
	  this.m_proxyB = proxyB;
	  var count = cache.count;
	  _ASSERT$o && common.assert(0 < count && count < 3);

	  this.m_sweepA = sweepA;
	  this.m_sweepB = sweepB;

	  var xfA = Transform_1.identity();
	  var xfB = Transform_1.identity();
	  this.m_sweepA.getTransform(xfA, t1);
	  this.m_sweepB.getTransform(xfB, t1);

	  if (count == 1) {
	    this.m_type = e_points;
	    var localPointA = this.m_proxyA.getVertex(cache.indexA[0]);
	    var localPointB = this.m_proxyB.getVertex(cache.indexB[0]);
	    var pointA = Transform_1.mulVec2(xfA, localPointA);
	    var pointB = Transform_1.mulVec2(xfB, localPointB);
	    this.m_axis.setCombine(1, pointB, -1, pointA);
	    var s = this.m_axis.normalize();
	    return s;

	  } else if (cache.indexA[0] == cache.indexA[1]) {
	    // Two points on B and one on A.
	    this.m_type = e_faceB;
	    var localPointB1 = proxyB.getVertex(cache.indexB[0]);
	    var localPointB2 = proxyB.getVertex(cache.indexB[1]);

	    this.m_axis = Vec2_1.cross(Vec2_1.sub(localPointB2, localPointB1), 1.0);
	    this.m_axis.normalize();
	    var normal = Rot_1.mulVec2(xfB.q, this.m_axis);

	    this.m_localPoint = Vec2_1.mid(localPointB1, localPointB2);
	    var pointB = Transform_1.mulVec2(xfB, this.m_localPoint);

	    var localPointA = proxyA.getVertex(cache.indexA[0]);
	    var pointA = Transform_1.mulVec2(xfA, localPointA);

	    var s = Vec2_1.dot(pointA, normal) - Vec2_1.dot(pointB, normal);
	    if (s < 0.0) {
	      this.m_axis = Vec2_1.neg(this.m_axis);
	      s = -s;
	    }
	    return s;

	  } else {
	    // Two points on A and one or two points on B.
	    this.m_type = e_faceA;
	    var localPointA1 = this.m_proxyA.getVertex(cache.indexA[0]);
	    var localPointA2 = this.m_proxyA.getVertex(cache.indexA[1]);

	    this.m_axis = Vec2_1.cross(Vec2_1.sub(localPointA2, localPointA1), 1.0);
	    this.m_axis.normalize();
	    var normal = Rot_1.mulVec2(xfA.q, this.m_axis);

	    this.m_localPoint = Vec2_1.mid(localPointA1, localPointA2);
	    var pointA = Transform_1.mulVec2(xfA, this.m_localPoint);

	    var localPointB = this.m_proxyB.getVertex(cache.indexB[0]);
	    var pointB = Transform_1.mulVec2(xfB, localPointB);

	    var s = Vec2_1.dot(pointB, normal) - Vec2_1.dot(pointA, normal);
	    if (s < 0.0) {
	      this.m_axis = Vec2_1.neg(this.m_axis);
	      s = -s;
	    }
	    return s;
	  }
	};

	SeparationFunction.prototype.compute = function(find, t) {
	  // It was findMinSeparation and evaluate
	  var xfA = Transform_1.identity();
	  var xfB = Transform_1.identity();
	  this.m_sweepA.getTransform(xfA, t);
	  this.m_sweepB.getTransform(xfB, t);

	  switch (this.m_type) {
	  case e_points: {
	    if (find) {
	      var axisA = Rot_1.mulTVec2(xfA.q, this.m_axis);
	      var axisB = Rot_1.mulTVec2(xfB.q, Vec2_1.neg(this.m_axis));

	      this.indexA = this.m_proxyA.getSupport(axisA);
	      this.indexB = this.m_proxyB.getSupport(axisB);
	    }

	    var localPointA = this.m_proxyA.getVertex(this.indexA);
	    var localPointB = this.m_proxyB.getVertex(this.indexB);

	    var pointA = Transform_1.mulVec2(xfA, localPointA);
	    var pointB = Transform_1.mulVec2(xfB, localPointB);

	    var sep = Vec2_1.dot(pointB, this.m_axis) - Vec2_1.dot(pointA, this.m_axis);
	    return sep;
	  }

	  case e_faceA: {
	    var normal = Rot_1.mulVec2(xfA.q, this.m_axis);
	    var pointA = Transform_1.mulVec2(xfA, this.m_localPoint);

	    if (find) {
	      var axisB = Rot_1.mulTVec2(xfB.q, Vec2_1.neg(normal));

	      this.indexA = -1;
	      this.indexB = this.m_proxyB.getSupport(axisB);
	    }

	    var localPointB = this.m_proxyB.getVertex(this.indexB);
	    var pointB = Transform_1.mulVec2(xfB, localPointB);

	    var sep = Vec2_1.dot(pointB, normal) - Vec2_1.dot(pointA, normal);
	    return sep;
	  }

	  case e_faceB: {
	    var normal = Rot_1.mulVec2(xfB.q, this.m_axis);
	    var pointB = Transform_1.mulVec2(xfB, this.m_localPoint);

	    if (find) {
	      var axisA = Rot_1.mulTVec2(xfA.q, Vec2_1.neg(normal));

	      this.indexB = -1;
	      this.indexA = this.m_proxyA.getSupport(axisA);
	    }

	    var localPointA = this.m_proxyA.getVertex(this.indexA);
	    var pointA = Transform_1.mulVec2(xfA, localPointA);

	    var sep = Vec2_1.dot(pointA, normal) - Vec2_1.dot(pointB, normal);
	    return sep;
	  }

	  default:
	    _ASSERT$o && common.assert(false);
	    if (find) {
	      this.indexA = -1;
	      this.indexB = -1;
	    }
	    return 0.0;
	  }
	};

	SeparationFunction.prototype.findMinSeparation = function(t) {
	  return this.compute(true, t);
	};

	SeparationFunction.prototype.evaluate = function(t) {
	  return this.compute(false, t);
	};
	TimeOfImpact_1.Input = Input$1;
	TimeOfImpact_1.Output = Output$1;

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$p = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$p = typeof ASSERT === 'undefined' ? false : ASSERT;

	var Solver_1 = Solver;
	var TimeStep_1 = TimeStep;












	var TOIInput$1 = TimeOfImpact_1.Input;
	var TOIOutput$1 = TimeOfImpact_1.Output;

	function TimeStep(dt) {
	  this.dt = 0; // time step
	  this.inv_dt = 0; // inverse time step (0 if dt == 0)
	  this.velocityIterations = 0;
	  this.positionIterations = 0;
	  this.warmStarting = false;
	  this.blockSolve = true;

	  // timestep ratio for variable timestep
	  this.inv_dt0 = 0.0;
	  this.dtRatio = 1; // dt * inv_dt0
	}

	TimeStep.prototype.reset = function(dt) {
	  if (this.dt > 0.0) {
	    this.inv_dt0 = this.inv_dt;
	  }
	  this.dt = dt;
	  this.inv_dt = dt == 0 ? 0 : 1 / dt;
	  this.dtRatio = dt * this.inv_dt0;
	};

	/**
	 * Finds and solves islands. An island is a connected subset of the world.
	 * 
	 * @param {World} world
	 */
	function Solver(world) {
	  this.m_world = world;
	  this.m_stack = [];
	  this.m_bodies = [];
	  this.m_contacts = [];
	  this.m_joints = [];
	}

	Solver.prototype.clear = function() {
	  this.m_stack.length = 0;
	  this.m_bodies.length = 0;
	  this.m_contacts.length = 0;
	  this.m_joints.length = 0;
	};

	Solver.prototype.addBody = function(body) {
	  _ASSERT$p && common.assert(body instanceof Body_1, 'Not a Body!', body);
	  this.m_bodies.push(body);
	  // why?
	//  body.c_position.c.setZero();
	//  body.c_position.a = 0;
	//  body.c_velocity.v.setZero();
	//  body.c_velocity.w = 0;
	};

	Solver.prototype.addContact = function(contact) {
	  _ASSERT$p && common.assert(contact instanceof Contact_1, 'Not a Contact!', contact);
	  this.m_contacts.push(contact);
	};

	Solver.prototype.addJoint = function(joint) {
	  _ASSERT$p && common.assert(joint instanceof Joint_1, 'Not a Joint!', joint);
	  this.m_joints.push(joint);
	};

	/**
	 * @param {TimeStep} step
	 */
	Solver.prototype.solveWorld = function(step) {
	  var world = this.m_world;

	  // Clear all the island flags.
	  for (var b = world.m_bodyList; b; b = b.m_next) {
	    b.m_islandFlag = false;
	  }
	  for (var c = world.m_contactList; c; c = c.m_next) {
	    c.m_islandFlag = false;
	  }
	  for (var j = world.m_jointList; j; j = j.m_next) {
	    j.m_islandFlag = false;
	  }

	  // Build and simulate all awake islands.
	  var stack = this.m_stack;
	  for (var seed = world.m_bodyList; seed; seed = seed.m_next) {
	    if (seed.m_islandFlag) {
	      continue;
	    }

	    if (seed.isAwake() == false || seed.isActive() == false) {
	      continue;
	    }

	    // The seed can be dynamic or kinematic.
	    if (seed.isStatic()) {
	      continue;
	    }

	    // Reset island and stack.
	    this.clear();

	    stack.push(seed);

	    seed.m_islandFlag = true;

	    // Perform a depth first search (DFS) on the constraint graph.
	    while (stack.length > 0) {
	      // Grab the next body off the stack and add it to the island.
	      var b = stack.pop();
	      _ASSERT$p && common.assert(b.isActive() == true);
	      this.addBody(b);

	      // Make sure the body is awake.
	      b.setAwake(true);

	      // To keep islands as small as possible, we don't
	      // propagate islands across static bodies.
	      if (b.isStatic()) {
	        continue;
	      }
	      
	      // Search all contacts connected to this body.
	      for (var ce = b.m_contactList; ce; ce = ce.next) {
	        var contact = ce.contact;

	        // Has this contact already been added to an island?
	        if (contact.m_islandFlag) {
	          continue;
	        }

	        // Is this contact solid and touching?
	        if (contact.isEnabled() == false || contact.isTouching() == false) {
	          continue;
	        }

	        // Skip sensors.
	        var sensorA = contact.m_fixtureA.m_isSensor;
	        var sensorB = contact.m_fixtureB.m_isSensor;
	        if (sensorA || sensorB) {
	          continue;
	        }

	        this.addContact(contact);
	        contact.m_islandFlag = true;

	        var other = ce.other;

	        // Was the other body already added to this island?
	        if (other.m_islandFlag) {
	          continue;
	        }

	        // _ASSERT && common.assert(stack.length < world.m_bodyCount);
	        stack.push(other);
	        other.m_islandFlag = true;
	      }

	      // Search all joints connect to this body.
	      for (var je = b.m_jointList; je; je = je.next) {
	        if (je.joint.m_islandFlag == true) {
	          continue;
	        }

	        var other = je.other;

	        // Don't simulate joints connected to inactive bodies.
	        if (other.isActive() == false) {
	          continue;
	        }

	        this.addJoint(je.joint);
	        je.joint.m_islandFlag = true;

	        if (other.m_islandFlag) {
	          continue;
	        }

	        // _ASSERT && common.assert(stack.length < world.m_bodyCount);
	        stack.push(other);
	        other.m_islandFlag = true;
	      }
	    }

	    this.solveIsland(step);

	    // Post solve cleanup.
	    for (var i = 0; i < this.m_bodies.length; ++i) {
	      // Allow static bodies to participate in other islands.
	      // TODO: are they added at all?
	      var b = this.m_bodies[i];
	      if (b.isStatic()) {
	        b.m_islandFlag = false;
	      }
	    }
	  }
	};

	/**
	 * @param {TimeStep} step
	 */
	Solver.prototype.solveIsland = function(step) {
	  // B2: Island Solve
	  var world = this.m_world;
	  var gravity = world.m_gravity;
	  var allowSleep = world.m_allowSleep;

	  var h = step.dt;

	  // Integrate velocities and apply damping. Initialize the body state.
	  for (var i = 0; i < this.m_bodies.length; ++i) {
	    var body = this.m_bodies[i];

	    var c = Vec2_1.clone(body.m_sweep.c);
	    var a = body.m_sweep.a;
	    var v = Vec2_1.clone(body.m_linearVelocity);
	    var w = body.m_angularVelocity;

	    // Store positions for continuous collision.
	    body.m_sweep.c0.set(body.m_sweep.c);
	    body.m_sweep.a0 = body.m_sweep.a;

	    if (body.isDynamic()) {
	      // Integrate velocities.
	      v.addMul(h * body.m_gravityScale, gravity);
	      v.addMul(h * body.m_invMass, body.m_force);
	      w += h * body.m_invI * body.m_torque;
	      /**
	       * <pre>
	       * Apply damping.
	       * ODE: dv/dt + c * v = 0
	       * Solution: v(t) = v0 * exp(-c * t)
	       * Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)
	       * v2 = exp(-c * dt) * v1
	       * Pade approximation:
	       * v2 = v1 * 1 / (1 + c * dt)
	       * </pre>
	       */
	      v.mul(1.0 / (1.0 + h * body.m_linearDamping));
	      w *= 1.0 / (1.0 + h * body.m_angularDamping);
	    }

	    body.c_position.c = c;
	    body.c_position.a = a;
	    body.c_velocity.v = v;
	    body.c_velocity.w = w;
	  }

	  for (var i = 0; i < this.m_contacts.length; ++i) {
	    var contact = this.m_contacts[i];
	    contact.initConstraint(step);
	  }

	  _DEBUG$p && this.printBodies('M: ');

	  for (var i = 0; i < this.m_contacts.length; ++i) {
	    var contact = this.m_contacts[i];
	    contact.initVelocityConstraint(step);
	  }

	  _DEBUG$p && this.printBodies('R: ');

	  if (step.warmStarting) {
	    // Warm start.
	    for (var i = 0; i < this.m_contacts.length; ++i) {
	      var contact = this.m_contacts[i];
	      contact.warmStartConstraint(step);
	    }
	  }

	  _DEBUG$p && this.printBodies('Q: ');
	  
	  for (var i = 0; i < this.m_joints.length; ++i) {
	    var joint = this.m_joints[i];
	    joint.initVelocityConstraints(step);
	  }

	  _DEBUG$p && this.printBodies('E: ');

	  // Solve velocity constraints
	  for (var i = 0; i < step.velocityIterations; ++i) {
	    for (var j = 0; j < this.m_joints.length; ++j) {
	      var joint = this.m_joints[j];
	      joint.solveVelocityConstraints(step);
	    }

	    for (var j = 0; j < this.m_contacts.length; ++j) {
	      var contact = this.m_contacts[j];
	      contact.solveVelocityConstraint(step);
	    }
	  }

	  _DEBUG$p && this.printBodies('D: ');

	  // Store impulses for warm starting
	  for (var i = 0; i < this.m_contacts.length; ++i) {
	    var contact = this.m_contacts[i];
	    contact.storeConstraintImpulses(step);
	  }

	  _DEBUG$p && this.printBodies('C: ');

	  // Integrate positions
	  for (var i = 0; i < this.m_bodies.length; ++i) {
	    var body = this.m_bodies[i];

	    var c = Vec2_1.clone(body.c_position.c);
	    var a = body.c_position.a;
	    var v = Vec2_1.clone(body.c_velocity.v);
	    var w = body.c_velocity.w;

	    // Check for large velocities
	    var translation = Vec2_1.mul(h, v);
	    if (Vec2_1.lengthSquared(translation) > Settings_1.maxTranslationSquared) {
	      var ratio = Settings_1.maxTranslation / translation.length();
	      v.mul(ratio);
	    }

	    var rotation = h * w;
	    if (rotation * rotation > Settings_1.maxRotationSquared) {
	      var ratio = Settings_1.maxRotation / _Math.abs(rotation);
	      w *= ratio;
	    }

	    // Integrate
	    c.addMul(h, v);
	    a += h * w;

	    body.c_position.c.set(c);
	    body.c_position.a = a;
	    body.c_velocity.v.set(v);
	    body.c_velocity.w = w;
	  }

	  _DEBUG$p && this.printBodies('B: ');

	  // Solve position constraints
	  var positionSolved = false;
	  for (var i = 0; i < step.positionIterations; ++i) {
	    var minSeparation = 0.0;
	    for (var j = 0; j < this.m_contacts.length; ++j) {
	      var contact = this.m_contacts[j];
	      var separation = contact.solvePositionConstraint(step);
	      minSeparation = _Math.min(minSeparation, separation);
	    }
	    // We can't expect minSpeparation >= -Settings.linearSlop because we don't
	    // push the separation above -Settings.linearSlop.
	    var contactsOkay = minSeparation >= -3.0 * Settings_1.linearSlop;

	    var jointsOkay = true;
	    for (var j = 0; j < this.m_joints.length; ++j) {
	      var joint = this.m_joints[j];
	      var jointOkay = joint.solvePositionConstraints(step);
	      jointsOkay = jointsOkay && jointOkay;
	    }

	    if (contactsOkay && jointsOkay) {
	      // Exit early if the position errors are small.
	      positionSolved = true;
	      break;
	    }
	  }

	  _DEBUG$p && this.printBodies('L: ');

	  // Copy state buffers back to the bodies
	  for (var i = 0; i < this.m_bodies.length; ++i) {
	    var body = this.m_bodies[i];

	    body.m_sweep.c.set(body.c_position.c);
	    body.m_sweep.a = body.c_position.a;
	    body.m_linearVelocity.set(body.c_velocity.v);
	    body.m_angularVelocity = body.c_velocity.w;
	    body.synchronizeTransform();
	  }

	  this.postSolveIsland();

	  if (allowSleep) {
	    var minSleepTime = Infinity;

	    var linTolSqr = Settings_1.linearSleepToleranceSqr;
	    var angTolSqr = Settings_1.angularSleepToleranceSqr;

	    for (var i = 0; i < this.m_bodies.length; ++i) {
	      var body = this.m_bodies[i];
	      if (body.isStatic()) {
	        continue;
	      }

	      if ((body.m_autoSleepFlag == false)
	          || (body.m_angularVelocity * body.m_angularVelocity > angTolSqr)
	          || (Vec2_1.lengthSquared(body.m_linearVelocity) > linTolSqr)) {
	        body.m_sleepTime = 0.0;
	        minSleepTime = 0.0;
	      } else {
	        body.m_sleepTime += h;
	        minSleepTime = _Math.min(minSleepTime, body.m_sleepTime);
	      }
	    }

	    if (minSleepTime >= Settings_1.timeToSleep && positionSolved) {
	      for (var i = 0; i < this.m_bodies.length; ++i) {
	        var body = this.m_bodies[i];
	        body.setAwake(false);
	      }
	    }
	  }
	};

	Solver.prototype.printBodies = function(tag) {
	  for (var i = 0; i < this.m_bodies.length; ++i) {
	    var b = this.m_bodies[i];
	    common.debug(tag, b.c_position.a, b.c_position.c.x, b.c_position.c.y, b.c_velocity.w, b.c_velocity.v.x, b.c_velocity.v.y);
	  }
	};

	var s_subStep = new TimeStep(); // reuse

	/**
	 * Find TOI contacts and solve them.
	 *
	 * @param {TimeStep} step
	 */
	Solver.prototype.solveWorldTOI = function(step) {
	  var world = this.m_world;

	  if (world.m_stepComplete) {
	    for (var b = world.m_bodyList; b; b = b.m_next) {
	      b.m_islandFlag = false;
	      b.m_sweep.alpha0 = 0.0;
	    }

	    for (var c = world.m_contactList; c; c = c.m_next) {
	      // Invalidate TOI
	      c.m_toiFlag = false;
	      c.m_islandFlag = false;
	      c.m_toiCount = 0;
	      c.m_toi = 1.0;
	    }
	  }

	  // Find TOI events and solve them.
	  for (;;) {
	    // Find the first TOI.
	    var minContact = null; // Contact
	    var minAlpha = 1.0;

	    for (var c = world.m_contactList; c; c = c.m_next) {
	      // Is this contact disabled?
	      if (c.isEnabled() == false) {
	        continue;
	      }

	      // Prevent excessive sub-stepping.
	      if (c.m_toiCount > Settings_1.maxSubSteps) {
	        continue;
	      }

	      var alpha = 1.0;
	      if (c.m_toiFlag) {
	        // This contact has a valid cached TOI.
	        alpha = c.m_toi;
	      } else {
	        var fA = c.getFixtureA();
	        var fB = c.getFixtureB();

	        // Is there a sensor?
	        if (fA.isSensor() || fB.isSensor()) {
	          continue;
	        }

	        var bA = fA.getBody();
	        var bB = fB.getBody();

	        _ASSERT$p && common.assert(bA.isDynamic() || bB.isDynamic());

	        var activeA = bA.isAwake() && !bA.isStatic();
	        var activeB = bB.isAwake() && !bB.isStatic();

	        // Is at least one body active (awake and dynamic or kinematic)?
	        if (activeA == false && activeB == false) {
	          continue;
	        }

	        var collideA = bA.isBullet() || !bA.isDynamic();
	        var collideB = bB.isBullet() || !bB.isDynamic();

	        // Are these two non-bullet dynamic bodies?
	        if (collideA == false && collideB == false) {
	          continue;
	        }

	        // Compute the TOI for this contact.
	        // Put the sweeps onto the same time interval.
	        var alpha0 = bA.m_sweep.alpha0;

	        if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {
	          alpha0 = bB.m_sweep.alpha0;
	          bA.m_sweep.advance(alpha0);
	        } else if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {
	          alpha0 = bA.m_sweep.alpha0;
	          bB.m_sweep.advance(alpha0);
	        }

	        _ASSERT$p && common.assert(alpha0 < 1.0);

	        var indexA = c.getChildIndexA();
	        var indexB = c.getChildIndexB();

	        var sweepA = bA.m_sweep;
	        var sweepB = bB.m_sweep;

	        // Compute the time of impact in interval [0, minTOI]
	        var input = new TOIInput$1(); // TODO: reuse
	        input.proxyA.set(fA.getShape(), indexA);
	        input.proxyB.set(fB.getShape(), indexB);
	        input.sweepA.set(bA.m_sweep);
	        input.sweepB.set(bB.m_sweep);
	        input.tMax = 1.0;

	        var output = new TOIOutput$1(); // TODO: reuse
	        TimeOfImpact_1(output, input);

	        // Beta is the fraction of the remaining portion of the [time?].
	        var beta = output.t;
	        if (output.state == TOIOutput$1.e_touching) {
	          alpha = _Math.min(alpha0 + (1.0 - alpha0) * beta, 1.0);
	        } else {
	          alpha = 1.0;
	        }

	        c.m_toi = alpha;
	        c.m_toiFlag = true;
	      }

	      if (alpha < minAlpha) {
	        // This is the minimum TOI found so far.
	        minContact = c;
	        minAlpha = alpha;
	      }
	    }

	    if (minContact == null || 1.0 - 10.0 * _Math.EPSILON < minAlpha) {
	      // No more TOI events. Done!
	      world.m_stepComplete = true;
	      break;
	    }

	    // Advance the bodies to the TOI.
	    var fA = minContact.getFixtureA();
	    var fB = minContact.getFixtureB();
	    var bA = fA.getBody();
	    var bB = fB.getBody();

	    var backup1 = bA.m_sweep.clone();
	    var backup2 = bB.m_sweep.clone();

	    bA.advance(minAlpha);
	    bB.advance(minAlpha);

	    // The TOI contact likely has some new contact points.
	    minContact.update(world);
	    minContact.m_toiFlag = false;
	    ++minContact.m_toiCount;

	    // Is the contact solid?
	    if (minContact.isEnabled() == false || minContact.isTouching() == false) {
	      // Restore the sweeps.
	      minContact.setEnabled(false);
	      bA.m_sweep.set(backup1);
	      bB.m_sweep.set(backup2);
	      bA.synchronizeTransform();
	      bB.synchronizeTransform();
	      continue;
	    }

	    bA.setAwake(true);
	    bB.setAwake(true);

	    // Build the island
	    this.clear();
	    this.addBody(bA);
	    this.addBody(bB);
	    this.addContact(minContact);

	    bA.m_islandFlag = true;
	    bB.m_islandFlag = true;
	    minContact.m_islandFlag = true;

	    // Get contacts on bodyA and bodyB.
	    var bodies = [ bA, bB ];
	    for (var i = 0; i < bodies.length; ++i) {
	      var body = bodies[i];
	      if (body.isDynamic()) {
	        for (var ce = body.m_contactList; ce; ce = ce.next) {
	          // if (this.m_bodyCount == this.m_bodyCapacity) { break; }
	          // if (this.m_contactCount == this.m_contactCapacity) { break; }

	          var contact = ce.contact;

	          // Has this contact already been added to the island?
	          if (contact.m_islandFlag) {
	            continue;
	          }

	          // Only add if either is static, kinematic or bullet.
	          var other = ce.other;
	          if (other.isDynamic() && !body.isBullet() && !other.isBullet()) {
	            continue;
	          }

	          // Skip sensors.
	          var sensorA = contact.m_fixtureA.m_isSensor;
	          var sensorB = contact.m_fixtureB.m_isSensor;
	          if (sensorA || sensorB) {
	            continue;
	          }

	          // Tentatively advance the body to the TOI.
	          var backup = other.m_sweep.clone();
	          if (other.m_islandFlag == false) {
	            other.advance(minAlpha);
	          }

	          // Update the contact points
	          contact.update(world);

	          // Was the contact disabled by the user?
	          // Are there contact points?
	          if (contact.isEnabled() == false || contact.isTouching() == false) {
	            other.m_sweep.set(backup);
	            other.synchronizeTransform();
	            continue;
	          }

	          // Add the contact to the island
	          contact.m_islandFlag = true;
	          this.addContact(contact);

	          // Has the other body already been added to the island?
	          if (other.m_islandFlag) {
	            continue;
	          }

	          // Add the other body to the island.
	          other.m_islandFlag = true;

	          if (!other.isStatic()) {
	            other.setAwake(true);
	          }

	          this.addBody(other);
	        }
	      }
	    }

	    s_subStep.reset((1.0 - minAlpha) * step.dt);
	    s_subStep.dtRatio = 1.0;
	    s_subStep.positionIterations = 20;
	    s_subStep.velocityIterations = step.velocityIterations;
	    s_subStep.warmStarting = false;

	    this.solveIslandTOI(s_subStep, bA, bB);

	    // Reset island flags and synchronize broad-phase proxies.
	    for (var i = 0; i < this.m_bodies.length; ++i) {
	      var body = this.m_bodies[i];
	      body.m_islandFlag = false;

	      if (!body.isDynamic()) {
	        continue;
	      }

	      body.synchronizeFixtures();

	      // Invalidate all contact TOIs on this displaced body.
	      for (var ce = body.m_contactList; ce; ce = ce.next) {
	        ce.contact.m_toiFlag = false;
	        ce.contact.m_islandFlag = false;
	      }
	    }

	    // Commit fixture proxy movements to the broad-phase so that new contacts
	    // are created.
	    // Also, some contacts can be destroyed.
	    world.findNewContacts();

	    if (world.m_subStepping) {
	      world.m_stepComplete = false;
	      break;
	    }
	  }

	  if (_DEBUG$p) for (var b = world.m_bodyList; b; b = b.m_next) {
	    var c = b.m_sweep.c;
	    var a = b.m_sweep.a;
	    var v = b.m_linearVelocity;
	    var w = b.m_angularVelocity;
	  }
	};

	/**
	 * @param {TimeStep} subStep
	 * @param toiA
	 * @param toiB
	 */
	Solver.prototype.solveIslandTOI = function(subStep, toiA, toiB) {
	  var world = this.m_world;

	  // Initialize the body state.
	  for (var i = 0; i < this.m_bodies.length; ++i) {
	    var body = this.m_bodies[i];
	    body.c_position.c.set(body.m_sweep.c);
	    body.c_position.a = body.m_sweep.a;
	    body.c_velocity.v.set(body.m_linearVelocity);
	    body.c_velocity.w = body.m_angularVelocity;
	  }

	  for (var i = 0; i < this.m_contacts.length; ++i) {
	    var contact = this.m_contacts[i];
	    contact.initConstraint(subStep);
	  }

	  // Solve position constraints.
	  for (var i = 0; i < subStep.positionIterations; ++i) {
	    var minSeparation = 0.0;
	    for (var j = 0; j < this.m_contacts.length; ++j) {
	      var contact = this.m_contacts[j];
	      var separation = contact.solvePositionConstraintTOI(subStep, toiA, toiB);
	      minSeparation = _Math.min(minSeparation, separation);
	    }
	    // We can't expect minSpeparation >= -Settings.linearSlop because we don't
	    // push the separation above -Settings.linearSlop.
	    var contactsOkay = minSeparation >= -1.5 * Settings_1.linearSlop;
	    if (contactsOkay) {
	      break;
	    }
	  }

	  if (false) {
	    // Is the new position really safe?
	    for (var i; i < this.m_contacts.length; ++i) {
	      var c;
	    }
	  }

	  // Leap of faith to new safe state.
	  toiA.m_sweep.c0.set(toiA.c_position.c);
	  toiA.m_sweep.a0 = toiA.c_position.a;
	  toiB.m_sweep.c0.set(toiB.c_position.c);
	  toiB.m_sweep.a0 = toiB.c_position.a;

	  // No warm starting is needed for TOI events because warm
	  // starting impulses were applied in the discrete solver.
	  for (var i = 0; i < this.m_contacts.length; ++i) {
	    var contact = this.m_contacts[i];
	    contact.initVelocityConstraint(subStep);
	  }

	  // Solve velocity constraints.
	  for (var i = 0; i < subStep.velocityIterations; ++i) {
	    for (var j = 0; j < this.m_contacts.length; ++j) {
	      var contact = this.m_contacts[j];
	      contact.solveVelocityConstraint(subStep);
	    }
	  }

	  // Don't store the TOI contact forces for warm starting
	  // because they can be quite large.

	  var h = subStep.dt;

	  // Integrate positions
	  for (var i = 0; i < this.m_bodies.length; ++i) {
	    var body = this.m_bodies[i];

	    var c = Vec2_1.clone(body.c_position.c);
	    var a = body.c_position.a;
	    var v = Vec2_1.clone(body.c_velocity.v);
	    var w = body.c_velocity.w;

	    // Check for large velocities
	    var translation = Vec2_1.mul(h, v);
	    if (Vec2_1.dot(translation, translation) > Settings_1.maxTranslationSquared) {
	      var ratio = Settings_1.maxTranslation / translation.length();
	      v.mul(ratio);
	    }

	    var rotation = h * w;
	    if (rotation * rotation > Settings_1.maxRotationSquared) {
	      var ratio = Settings_1.maxRotation / _Math.abs(rotation);
	      w *= ratio;
	    }

	    // Integrate
	    c.addMul(h, v);
	    a += h * w;

	    body.c_position.c = c;
	    body.c_position.a = a;
	    body.c_velocity.v = v;
	    body.c_velocity.w = w;

	    // Sync bodies
	    body.m_sweep.c = c;
	    body.m_sweep.a = a;
	    body.m_linearVelocity = v;
	    body.m_angularVelocity = w;
	    body.synchronizeTransform();
	  }

	  this.postSolveIsland();
	};

	/**
	 * Contact impulses for reporting. Impulses are used instead of forces because
	 * sub-step forces may approach infinity for rigid body collisions. These match
	 * up one-to-one with the contact points in Manifold.
	 */
	function ContactImpulse() {
	  this.normalImpulses = [];
	  this.tangentImpulses = [];
	}
	Solver.prototype.postSolveIsland = function() {
	  // TODO: report contact.v_points instead of new object?
	  var impulse = new ContactImpulse();
	  for (var c = 0; c < this.m_contacts.length; ++c) {
	    var contact = this.m_contacts[c];
	    for (var p = 0; p < contact.v_points.length; ++p) {
	      impulse.normalImpulses.push(contact.v_points[p].normalImpulse);
	      impulse.tangentImpulses.push(contact.v_points[p].tangentImpulse);
	    }
	    this.m_world.postSolve(contact, impulse);
	  }
	};
	Solver_1.TimeStep = TimeStep_1;

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$q = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$q = typeof ASSERT === 'undefined' ? false : ASSERT;

	var World_1 = World;










	/**
	 * @typedef {Object} WorldDef
	 *
	 * @prop {Vec2} [gravity = { x : 0, y : 0}]
	 * @prop {boolean} [allowSleep = true]
	 * @prop {boolean} [warmStarting = true]
	 * @prop {boolean} [continuousPhysics = true]
	 * @prop {boolean} [subStepping = false]
	 * @prop {boolean} [blockSolve = true]
	 * @prop {int} [velocityIterations = 8] For the velocity constraint solver.
	 * @prop {int} [positionIterations = 3] For the position constraint solver.
	 */
	var WorldDef = {
	  gravity : Vec2_1.zero(),
	  allowSleep : true,
	  warmStarting : true,
	  continuousPhysics : true,
	  subStepping : false,
	  blockSolve : true,
	  velocityIterations : 8,
	  positionIterations : 3
	};

	/**
	 * @param {WordDef|Vec2} def World definition or gravity vector.
	 */
	function World(def) {
	  if (!(this instanceof World)) {
	    return new World(def);
	  }

	  if (def && Vec2_1.isValid(def)) {
	    def = {gravity : def};
	  }

	  def = options(def, WorldDef);

	  this.m_solver = new Solver_1(this);

	  this.m_broadPhase = new BroadPhase_1();

	  this.m_contactList = null;
	  this.m_contactCount = 0;

	  this.m_bodyList = null;
	  this.m_bodyCount = 0;

	  this.m_jointList = null;
	  this.m_jointCount = 0;

	  this.m_stepComplete = true;

	  this.m_allowSleep = def.allowSleep;
	  this.m_gravity = Vec2_1.clone(def.gravity);

	  this.m_clearForces = true;
	  this.m_newFixture = false;
	  this.m_locked = false;

	  // These are for debugging the solver.
	  this.m_warmStarting = def.warmStarting;
	  this.m_continuousPhysics = def.continuousPhysics;
	  this.m_subStepping = def.subStepping;

	  this.m_blockSolve = def.blockSolve;
	  this.m_velocityIterations = def.velocityIterations;
	  this.m_positionIterations = def.positionIterations;

	  this.m_t = 0;

	  this.m_stepCount = 0;

	  // Broad-phase callback.
	  this.addPair = this.createContact.bind(this);
	}

	World.prototype._serialize = function() {
	  var bodies = [];
	  var joints = [];

	  for (var b = this.getBodyList(); b; b = b.getNext()) {
	    bodies.push(b);
	  }

	  for (var j = this.getJointList(); j; j = j.getNext()) {
	    if (typeof j._serialize === 'function') {
	      joints.push(j);
	    }
	  }

	  return {
	    gravity: this.m_gravity,
	    bodies: bodies,
	    joints: joints,
	  };
	};

	World._deserialize = function(data, context, restore) {
	  if (!data) {
	    return new World();
	  }

	  var world = new World(data.gravity);

	  data.bodies && data.bodies.reverse().forEach(function(data) {
	    world._addBody(restore(Body_1, data, world));
	  });

	  data.joints && data.joints.reverse().forEach(function(data) {
	    world.createJoint(restore(Joint_1, data, world));
	  });

	  return world;
	};

	/**
	 * Get the world body list. With the returned body, use Body.getNext to get the
	 * next body in the world list. A null body indicates the end of the list.
	 *
	 * @return the head of the world body list.
	 */
	World.prototype.getBodyList = function() {
	  return this.m_bodyList;
	};

	/**
	 * Get the world joint list. With the returned joint, use Joint.getNext to get
	 * the next joint in the world list. A null joint indicates the end of the list.
	 *
	 * @return the head of the world joint list.
	 */
	World.prototype.getJointList = function() {
	  return this.m_jointList;
	};

	/**
	 * Get the world contact list. With the returned contact, use Contact.getNext to
	 * get the next contact in the world list. A null contact indicates the end of
	 * the list.
	 *
	 * @return the head of the world contact list. Warning: contacts are created and
	 *         destroyed in the middle of a time step. Use ContactListener to avoid
	 *         missing contacts.
	 */
	World.prototype.getContactList = function() {
	  return this.m_contactList;
	};

	World.prototype.getBodyCount = function() {
	  return this.m_bodyCount;
	};

	World.prototype.getJointCount = function() {
	  return this.m_jointCount;
	};

	/**
	 * Get the number of contacts (each may have 0 or more contact points).
	 */
	World.prototype.getContactCount = function() {
	  return this.m_contactCount;
	};

	/**
	 * Change the global gravity vector.
	 */
	World.prototype.setGravity = function(gravity) {
	  this.m_gravity = gravity;
	};

	/**
	 * Get the global gravity vector.
	 */
	World.prototype.getGravity = function() {
	  return this.m_gravity;
	};

	/**
	 * Is the world locked (in the middle of a time step).
	 */
	World.prototype.isLocked = function() {
	  return this.m_locked;
	};

	/**
	 * Enable/disable sleep.
	 */
	World.prototype.setAllowSleeping = function(flag) {
	  if (flag == this.m_allowSleep) {
	    return;
	  }

	  this.m_allowSleep = flag;
	  if (this.m_allowSleep == false) {
	    for (var b = this.m_bodyList; b; b = b.m_next) {
	      b.setAwake(true);
	    }
	  }
	};

	World.prototype.getAllowSleeping = function() {
	  return this.m_allowSleep;
	};

	/**
	 * Enable/disable warm starting. For testing.
	 */
	World.prototype.setWarmStarting = function(flag) {
	  this.m_warmStarting = flag;
	};

	World.prototype.getWarmStarting = function() {
	  return this.m_warmStarting;
	};

	/**
	 * Enable/disable continuous physics. For testing.
	 */
	World.prototype.setContinuousPhysics = function(flag) {
	  this.m_continuousPhysics = flag;
	};

	World.prototype.getContinuousPhysics = function() {
	  return this.m_continuousPhysics;
	};

	/**
	 * Enable/disable single stepped continuous physics. For testing.
	 */
	World.prototype.setSubStepping = function(flag) {
	  this.m_subStepping = flag;
	};

	World.prototype.getSubStepping = function() {
	  return this.m_subStepping;
	};

	/**
	 * Set flag to control automatic clearing of forces after each time step.
	 */
	World.prototype.setAutoClearForces = function(flag) {
	  this.m_clearForces = flag;
	};

	/**
	 * Get the flag that controls automatic clearing of forces after each time step.
	 */
	World.prototype.getAutoClearForces = function() {
	  return this.m_clearForces;
	};

	/**
	 * Manually clear the force buffer on all bodies. By default, forces are cleared
	 * automatically after each call to step. The default behavior is modified by
	 * calling setAutoClearForces. The purpose of this function is to support
	 * sub-stepping. Sub-stepping is often used to maintain a fixed sized time step
	 * under a variable frame-rate. When you perform sub-stepping you will disable
	 * auto clearing of forces and instead call clearForces after all sub-steps are
	 * complete in one pass of your game loop.
	 *
	 * @see setAutoClearForces
	 */
	World.prototype.clearForces = function() {
	  for (var body = this.m_bodyList; body; body = body.getNext()) {
	    body.m_force.setZero();
	    body.m_torque = 0.0;
	  }
	};

	/**
	 * @function World~rayCastCallback
	 *
	 * @param fixture
	 */

	/**
	 * Query the world for all fixtures that potentially overlap the provided AABB.
	 *
	 * @param {World~queryCallback} queryCallback Called for each fixture
	 *          found in the query AABB. It may return `false` to terminate the
	 *          query.
	 *
	 * @param aabb The query box.
	 */
	World.prototype.queryAABB = function(aabb, queryCallback) {
	  _ASSERT$q && common.assert(typeof queryCallback === 'function');
	  var broadPhase = this.m_broadPhase;
	  this.m_broadPhase.query(aabb, function(proxyId) { //TODO GC
	    var proxy = broadPhase.getUserData(proxyId); // FixtureProxy
	    return queryCallback(proxy.fixture);
	  });
	};

	/**
	 * @function World~rayCastCallback
	 *
	 * Callback class for ray casts. See World.rayCast
	 *
	 * Called for each fixture found in the query. You control how the ray cast
	 * proceeds by returning a float: return -1: ignore this fixture and continue
	 * return 0: terminate the ray cast return fraction: clip the ray to this point
	 * return 1: don't clip the ray and continue
	 *
	 * @param fixture The fixture hit by the ray
	 * @param point The point of initial intersection
	 * @param normal The normal vector at the point of intersection
	 * @param fraction
	 *
	 * @return {float} -1 to filter, 0 to terminate, fraction to clip the ray for
	 *         closest hit, 1 to continue
	 */

	/**
	 *
	 * Ray-cast the world for all fixtures in the path of the ray. Your callback
	 * controls whether you get the closest point, any point, or n-points. The
	 * ray-cast ignores shapes that contain the starting point.
	 *
	 * @param {World~RayCastCallback} reportFixtureCallback A user implemented
	 *          callback function.
	 * @param point1 The ray starting point
	 * @param point2 The ray ending point
	 */
	World.prototype.rayCast = function(point1, point2, reportFixtureCallback) {
	  _ASSERT$q && common.assert(typeof reportFixtureCallback === 'function');
	  var broadPhase = this.m_broadPhase;

	  this.m_broadPhase.rayCast({
	    maxFraction : 1.0,
	    p1 : point1,
	    p2 : point2
	  }, function(input, proxyId) { // TODO GC
	    var proxy = broadPhase.getUserData(proxyId); // FixtureProxy
	    var fixture = proxy.fixture;
	    var index = proxy.childIndex;
	    var output = {}; // TODO GC
	    var hit = fixture.rayCast(output, input, index);
	    if (hit) {
	      var fraction = output.fraction;
	      var point = Vec2_1.add(Vec2_1.mul((1.0 - fraction), input.p1), Vec2_1.mul(fraction, input.p2));
	      return reportFixtureCallback(fixture, point, output.normal, fraction);
	    }
	    return input.maxFraction;
	  });
	};

	/**
	 * Get the number of broad-phase proxies.
	 */
	World.prototype.getProxyCount = function() {
	  return this.m_broadPhase.getProxyCount();
	};

	/**
	 * Get the height of broad-phase dynamic tree.
	 */
	World.prototype.getTreeHeight = function() {
	  return this.m_broadPhase.getTreeHeight();
	};

	/**
	 * Get the balance of broad-phase dynamic tree.
	 *
	 * @returns {int}
	 */
	World.prototype.getTreeBalance = function() {
	  return this.m_broadPhase.getTreeBalance();
	};

	/**
	 * Get the quality metric of broad-phase dynamic tree. The smaller the better.
	 * The minimum is 1.
	 *
	 * @returns {float}
	 */
	World.prototype.getTreeQuality = function() {
	  return this.m_broadPhase.getTreeQuality();
	};

	/**
	 * Shift the world origin. Useful for large worlds. The body shift formula is:
	 * position -= newOrigin
	 *
	 * @param {Vec2} newOrigin The new origin with respect to the old origin
	 */
	World.prototype.shiftOrigin = function(newOrigin) {
	  _ASSERT$q && common.assert(this.m_locked == false);
	  if (this.m_locked) {
	    return;
	  }

	  for (var b = this.m_bodyList; b; b = b.m_next) {
	    b.m_xf.p.sub(newOrigin);
	    b.m_sweep.c0.sub(newOrigin);
	    b.m_sweep.c.sub(newOrigin);
	  }

	  for (var j = this.m_jointList; j; j = j.m_next) {
	    j.shiftOrigin(newOrigin);
	  }

	  this.m_broadPhase.shiftOrigin(newOrigin);
	};

	/**
	 * @internal Used for deserialize.
	 */
	World.prototype._addBody = function(body) {
	  _ASSERT$q && common.assert(this.isLocked() === false);
	  if (this.isLocked()) {
	    return;
	  }

	  // Add to world doubly linked list.
	  body.m_prev = null;
	  body.m_next = this.m_bodyList;
	  if (this.m_bodyList) {
	    this.m_bodyList.m_prev = body;
	  }
	  this.m_bodyList = body;
	  ++this.m_bodyCount;
	};

	/**
	 * Create a rigid body given a definition. No reference to the definition is
	 * retained.
	 *
	 * Warning: This function is locked during callbacks.
	 *
	 * @param {BodyDef|Vec2} def Body definition or position.
	 * @param {float} angle Body angle if def is position.
	 */
	World.prototype.createBody = function(def, angle) {
	  _ASSERT$q && common.assert(this.isLocked() == false);
	  if (this.isLocked()) {
	    return null;
	  }

	  if (def && Vec2_1.isValid(def)) {
	    def = {
	      position : def,
	      angle : angle
	    };
	  }

	  var body = new Body_1(this, def);

	  this._addBody(body);

	  return body;
	};

	World.prototype.createDynamicBody = function(def, angle) {
	  if (!def) {
	    def = {};
	  } else if (Vec2_1.isValid(def)) {
	    def = { position : def, angle : angle };
	  }
	  def.type = 'dynamic';
	  return this.createBody(def);
	};

	World.prototype.createKinematicBody = function(def, angle) {
	  if (!def) {
	    def = {};
	  } else if (Vec2_1.isValid(def)) {
	    def = { position : def, angle : angle };
	  }
	  def.type = 'kinematic';
	  return this.createBody(def);
	};

	/**
	 * Destroy a rigid body given a definition. No reference to the definition is
	 * retained.
	 *
	 * Warning: This automatically deletes all associated shapes and joints.
	 *
	 * Warning: This function is locked during callbacks.
	 *
	 * @param {Body} b
	 */
	World.prototype.destroyBody = function(b) {
	  _ASSERT$q && common.assert(this.m_bodyCount > 0);
	  _ASSERT$q && common.assert(this.isLocked() == false);
	  if (this.isLocked()) {
	    return;
	  }

	  if (b.m_destroyed) {
	    return false;
	  }

	  // Delete the attached joints.
	  var je = b.m_jointList;
	  while (je) {
	    var je0 = je;
	    je = je.next;

	    this.publish('remove-joint', je0.joint);
	    this.destroyJoint(je0.joint);

	    b.m_jointList = je;
	  }
	  b.m_jointList = null;

	  // Delete the attached contacts.
	  var ce = b.m_contactList;
	  while (ce) {
	    var ce0 = ce;
	    ce = ce.next;

	    this.destroyContact(ce0.contact);

	    b.m_contactList = ce;
	  }
	  b.m_contactList = null;

	  // Delete the attached fixtures. This destroys broad-phase proxies.
	  var f = b.m_fixtureList;
	  while (f) {
	    var f0 = f;
	    f = f.m_next;

	    this.publish('remove-fixture', f0);
	    f0.destroyProxies(this.m_broadPhase);

	    b.m_fixtureList = f;
	  }
	  b.m_fixtureList = null;

	  // Remove world body list.
	  if (b.m_prev) {
	    b.m_prev.m_next = b.m_next;
	  }

	  if (b.m_next) {
	    b.m_next.m_prev = b.m_prev;
	  }

	  if (b == this.m_bodyList) {
	    this.m_bodyList = b.m_next;
	  }

	  b.m_destroyed = true;

	  --this.m_bodyCount;

	  this.publish('remove-body', b);

	  return true;
	};

	/**
	 * Create a joint to constrain bodies together. No reference to the definition
	 * is retained. This may cause the connected bodies to cease colliding.
	 *
	 * Warning: This function is locked during callbacks.
	 *
	 * @param {Joint} join
	 * @param {Body} bodyB
	 * @param {Body} bodyA
	 */
	World.prototype.createJoint = function(joint) {
	  _ASSERT$q && common.assert(!!joint.m_bodyA);
	  _ASSERT$q && common.assert(!!joint.m_bodyB);
	  _ASSERT$q && common.assert(this.isLocked() == false);
	  if (this.isLocked()) {
	    return null;
	  }

	  // Connect to the world list.
	  joint.m_prev = null;
	  joint.m_next = this.m_jointList;
	  if (this.m_jointList) {
	    this.m_jointList.m_prev = joint;
	  }
	  this.m_jointList = joint;
	  ++this.m_jointCount;

	  // Connect to the bodies' doubly linked lists.
	  joint.m_edgeA.joint = joint;
	  joint.m_edgeA.other = joint.m_bodyB;
	  joint.m_edgeA.prev = null;
	  joint.m_edgeA.next = joint.m_bodyA.m_jointList;
	  if (joint.m_bodyA.m_jointList)
	    joint.m_bodyA.m_jointList.prev = joint.m_edgeA;
	  joint.m_bodyA.m_jointList = joint.m_edgeA;

	  joint.m_edgeB.joint = joint;
	  joint.m_edgeB.other = joint.m_bodyA;
	  joint.m_edgeB.prev = null;
	  joint.m_edgeB.next = joint.m_bodyB.m_jointList;
	  if (joint.m_bodyB.m_jointList)
	    joint.m_bodyB.m_jointList.prev = joint.m_edgeB;
	  joint.m_bodyB.m_jointList = joint.m_edgeB;

	  // If the joint prevents collisions, then flag any contacts for filtering.
	  if (joint.m_collideConnected == false) {
	    for (var edge = joint.m_bodyB.getContactList(); edge; edge = edge.next) {
	      if (edge.other == joint.m_bodyA) {
	        // Flag the contact for filtering at the next time step (where either
	        // body is awake).
	        edge.contact.flagForFiltering();
	      }
	    }
	  }

	  // Note: creating a joint doesn't wake the bodies.

	  return joint;
	};

	/**
	 * Destroy a joint. This may cause the connected bodies to begin colliding.
	 * Warning: This function is locked during callbacks.
	 *
	 * @param {Joint} join
	 */
	World.prototype.destroyJoint = function(joint) {
	  _ASSERT$q && common.assert(this.isLocked() == false);
	  if (this.isLocked()) {
	    return;
	  }

	  // Remove from the doubly linked list.
	  if (joint.m_prev) {
	    joint.m_prev.m_next = joint.m_next;
	  }

	  if (joint.m_next) {
	    joint.m_next.m_prev = joint.m_prev;
	  }

	  if (joint == this.m_jointList) {
	    this.m_jointList = joint.m_next;
	  }

	  // Disconnect from bodies.
	  var bodyA = joint.m_bodyA;
	  var bodyB = joint.m_bodyB;

	  // Wake up connected bodies.
	  bodyA.setAwake(true);
	  bodyB.setAwake(true);

	  // Remove from body 1.
	  if (joint.m_edgeA.prev) {
	    joint.m_edgeA.prev.next = joint.m_edgeA.next;
	  }

	  if (joint.m_edgeA.next) {
	    joint.m_edgeA.next.prev = joint.m_edgeA.prev;
	  }

	  if (joint.m_edgeA == bodyA.m_jointList) {
	    bodyA.m_jointList = joint.m_edgeA.next;
	  }

	  joint.m_edgeA.prev = null;
	  joint.m_edgeA.next = null;

	  // Remove from body 2
	  if (joint.m_edgeB.prev) {
	    joint.m_edgeB.prev.next = joint.m_edgeB.next;
	  }

	  if (joint.m_edgeB.next) {
	    joint.m_edgeB.next.prev = joint.m_edgeB.prev;
	  }

	  if (joint.m_edgeB == bodyB.m_jointList) {
	    bodyB.m_jointList = joint.m_edgeB.next;
	  }

	  joint.m_edgeB.prev = null;
	  joint.m_edgeB.next = null;

	  _ASSERT$q && common.assert(this.m_jointCount > 0);
	  --this.m_jointCount;

	  // If the joint prevents collisions, then flag any contacts for filtering.
	  if (joint.m_collideConnected == false) {
	    var edge = bodyB.getContactList();
	    while (edge) {
	      if (edge.other == bodyA) {
	        // Flag the contact for filtering at the next time step (where either
	        // body is awake).
	        edge.contact.flagForFiltering();
	      }

	      edge = edge.next;
	    }
	  }

	  this.publish('remove-joint', joint);
	};

	var s_step = new Solver_1.TimeStep(); // reuse

	/**
	 * Take a time step. This performs collision detection, integration, and
	 * constraint solution.
	 *
	 * Broad-phase, narrow-phase, solve and solve time of impacts.
	 *
	 * @param {float} timeStep Time step, this should not vary.
	 * @param {int} velocityIterations
	 * @param {int} positionIterations
	 */
	World.prototype.step = function(timeStep, velocityIterations, positionIterations) {

	  if ((velocityIterations | 0) !== velocityIterations) {
	    // TODO: remove this in future
	    velocityIterations = 0;
	  }

	  velocityIterations = velocityIterations || this.m_velocityIterations;
	  positionIterations = positionIterations || this.m_positionIterations;

	  // TODO: move this to testbed
	  this.m_stepCount++;

	  // If new fixtures were added, we need to find the new contacts.
	  if (this.m_newFixture) {
	    this.findNewContacts();
	    this.m_newFixture = false;
	  }

	  this.m_locked = true;

	  s_step.reset(timeStep);
	  s_step.velocityIterations = velocityIterations;
	  s_step.positionIterations = positionIterations;
	  s_step.warmStarting = this.m_warmStarting;
	  s_step.blockSolve = this.m_blockSolve;

	  // Update contacts. This is where some contacts are destroyed.
	  this.updateContacts();

	  // Integrate velocities, solve velocity constraints, and integrate positions.
	  if (this.m_stepComplete && timeStep > 0.0) {
	    this.m_solver.solveWorld(s_step);

	    // Synchronize fixtures, check for out of range bodies.
	    for (var b = this.m_bodyList; b; b = b.getNext()) {
	      // If a body was not in an island then it did not move.
	      if (b.m_islandFlag == false) {
	        continue;
	      }

	      if (b.isStatic()) {
	        continue;
	      }

	      // Update fixtures (for broad-phase).
	      b.synchronizeFixtures();
	    }
	    // Look for new contacts.
	    this.findNewContacts();
	  }

	  // Handle TOI events.
	  if (this.m_continuousPhysics && timeStep > 0.0) {
	    this.m_solver.solveWorldTOI(s_step);
	  }

	  if (this.m_clearForces) {
	    this.clearForces();
	  }

	  this.m_locked = false;
	};

	/**
	 * Call this method to find new contacts.
	 */
	World.prototype.findNewContacts = function() {
	  this.m_broadPhase.updatePairs(this.addPair);
	};

	/**
	 * @private
	 *
	 * @param {FixtureProxy} proxyA
	 * @param {FixtureProxy} proxyB
	 */
	World.prototype.createContact = function(proxyA, proxyB) {
	  var fixtureA = proxyA.fixture;
	  var fixtureB = proxyB.fixture;

	  var indexA = proxyA.childIndex;
	  var indexB = proxyB.childIndex;

	  var bodyA = fixtureA.getBody();
	  var bodyB = fixtureB.getBody();

	  // Are the fixtures on the same body?
	  if (bodyA == bodyB) {
	    return;
	  }

	  // TODO_ERIN use a hash table to remove a potential bottleneck when both
	  // bodies have a lot of contacts.
	  // Does a contact already exist?
	  var edge = bodyB.getContactList(); // ContactEdge
	  while (edge) {
	    if (edge.other == bodyA) {
	      var fA = edge.contact.getFixtureA();
	      var fB = edge.contact.getFixtureB();
	      var iA = edge.contact.getChildIndexA();
	      var iB = edge.contact.getChildIndexB();

	      if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) {
	        // A contact already exists.
	        return;
	      }

	      if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) {
	        // A contact already exists.
	        return;
	      }
	    }

	    edge = edge.next;
	  }

	  if (bodyB.shouldCollide(bodyA) == false) {
	    return;
	  }
	  if (fixtureB.shouldCollide(fixtureA) == false) {
	    return;
	  }

	  // Call the factory.
	  var contact = Contact_1.create(fixtureA, indexA, fixtureB, indexB);
	  if (contact == null) {
	    return;
	  }

	  // Insert into the world.
	  contact.m_prev = null;
	  if (this.m_contactList != null) {
	    contact.m_next = this.m_contactList;
	    this.m_contactList.m_prev = contact;
	  }
	  this.m_contactList = contact;

	  ++this.m_contactCount;
	};

	/**
	 * Removes old non-overlapping contacts, applies filters and updates contacts.
	 */
	World.prototype.updateContacts = function() {
	  // Update awake contacts.
	  var c, next_c = this.m_contactList;
	  while (c = next_c) {
	    next_c = c.getNext();
	    var fixtureA = c.getFixtureA();
	    var fixtureB = c.getFixtureB();
	    var indexA = c.getChildIndexA();
	    var indexB = c.getChildIndexB();
	    var bodyA = fixtureA.getBody();
	    var bodyB = fixtureB.getBody();

	    // Is this contact flagged for filtering?
	    if (c.m_filterFlag) {
	      if (bodyB.shouldCollide(bodyA) == false) {
	        this.destroyContact(c);
	        continue;
	      }

	      if (fixtureB.shouldCollide(fixtureA) == false) {
	        this.destroyContact(c);
	        continue;
	      }

	      // Clear the filtering flag.
	      c.m_filterFlag = false;
	    }

	    var activeA = bodyA.isAwake() && !bodyA.isStatic();
	    var activeB = bodyB.isAwake() && !bodyB.isStatic();

	    // At least one body must be awake and it must be dynamic or kinematic.
	    if (activeA == false && activeB == false) {
	      continue;
	    }

	    var proxyIdA = fixtureA.m_proxies[indexA].proxyId;
	    var proxyIdB = fixtureB.m_proxies[indexB].proxyId;
	    var overlap = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);

	    // Here we destroy contacts that cease to overlap in the broad-phase.
	    if (overlap == false) {
	      this.destroyContact(c);
	      continue;
	    }

	    // The contact persists.
	    c.update(this);
	  }
	};

	/**
	 * @param {Contact} contact
	 */
	World.prototype.destroyContact = function(contact) {
	  Contact_1.destroy(contact, this);

	  // Remove from the world.
	  if (contact.m_prev) {
	    contact.m_prev.m_next = contact.m_next;
	  }
	  if (contact.m_next) {
	    contact.m_next.m_prev = contact.m_prev;
	  }
	  if (contact == this.m_contactList) {
	    this.m_contactList = contact.m_next;
	  }

	  --this.m_contactCount;
	};

	World.prototype._listeners = null;

	/**
	 * Register an event listener.
	 *
	 * @param {string} name
	 * @param {function} listener
	 */
	World.prototype.on = function(name, listener) {
	  if (typeof name !== 'string' || typeof listener !== 'function') {
	    return this;
	  }
	  if (!this._listeners) {
	    this._listeners = {};
	  }
	  if (!this._listeners[name]) {
	    this._listeners[name] = [];
	  }
	  this._listeners[name].push(listener);
	  return this;
	};

	/**
	 * Remove an event listener.
	 *
	 * @param {string} name
	 * @param {function} listener
	 */
	World.prototype.off = function(name, listener) {
	  if (typeof name !== 'string' || typeof listener !== 'function') {
	    return this;
	  }
	  var listeners = this._listeners && this._listeners[name];
	  if (!listeners || !listeners.length) {
	    return this;
	  }
	  var index = listeners.indexOf(listener);
	  if (index >= 0) {
	    listeners.splice(index, 1);
	  }
	  return this;
	};

	World.prototype.publish = function(name, arg1, arg2, arg3) {
	  var listeners = this._listeners && this._listeners[name];
	  if (!listeners || !listeners.length) {
	    return 0;
	  }
	  for (var l = 0; l < listeners.length; l++) {
	    listeners[l].call(this, arg1, arg2, arg3);
	  }
	  return listeners.length;
	};

	/**
	 * @event World#remove-body
	 * @event World#remove-joint
	 * @event World#remove-fixture
	 *
	 * Joints and fixtures are destroyed when their associated body is destroyed.
	 * Register a destruction listener so that you may nullify references to these
	 * joints and shapes.
	 *
	 * `function(object)` is called when any joint or fixture is about to
	 * be destroyed due to the destruction of one of its attached or parent bodies.
	 */

	/**
	 * @private
	 * @param {Contact} contact
	 */
	World.prototype.beginContact = function(contact) {
	  this.publish('begin-contact', contact);
	};

	/**
	 * @event World#begin-contact
	 *
	 * Called when two fixtures begin to touch.
	 *
	 * Implement contact callbacks to get contact information. You can use these
	 * results for things like sounds and game logic. You can also get contact
	 * results by traversing the contact lists after the time step. However, you
	 * might miss some contacts because continuous physics leads to sub-stepping.
	 * Additionally you may receive multiple callbacks for the same contact in a
	 * single time step. You should strive to make your callbacks efficient because
	 * there may be many callbacks per time step.
	 *
	 * Warning: You cannot create/destroy world entities inside these callbacks.
	 */

	/**
	 * @private
	 * @param {Contact} contact
	 */
	World.prototype.endContact = function(contact) {
	  this.publish('end-contact', contact);
	};

	/**
	 * @event World#end-contact
	 *
	 * Called when two fixtures cease to touch.
	 *
	 * Implement contact callbacks to get contact information. You can use these
	 * results for things like sounds and game logic. You can also get contact
	 * results by traversing the contact lists after the time step. However, you
	 * might miss some contacts because continuous physics leads to sub-stepping.
	 * Additionally you may receive multiple callbacks for the same contact in a
	 * single time step. You should strive to make your callbacks efficient because
	 * there may be many callbacks per time step.
	 *
	 * Warning: You cannot create/destroy world entities inside these callbacks.
	 */

	/**
	 * @private
	 * @param {Contact} contact
	 * @param {Manifold} oldManifold
	 */
	World.prototype.preSolve = function(contact, oldManifold) {
	  this.publish('pre-solve', contact, oldManifold);
	};

	/**
	 * @event World#pre-solve
	 *
	 * This is called after a contact is updated. This allows you to inspect a
	 * contact before it goes to the solver. If you are careful, you can modify the
	 * contact manifold (e.g. disable contact). A copy of the old manifold is
	 * provided so that you can detect changes. Note: this is called only for awake
	 * bodies. Note: this is called even when the number of contact points is zero.
	 * Note: this is not called for sensors. Note: if you set the number of contact
	 * points to zero, you will not get an endContact callback. However, you may get
	 * a beginContact callback the next step.
	 *
	 * Warning: You cannot create/destroy world entities inside these callbacks.
	 */

	/**
	 * @private
	 * @param {Contact} contact
	 * @param {ContactImpulse} impulse
	 */
	World.prototype.postSolve = function(contact, impulse) {
	  this.publish('post-solve', contact, impulse);
	};

	var SID = 0;

	function Serializer(opts) {
	  opts = opts || {};

	  var stringify = opts.stringify || JSON.stringify;
	  var parse = opts.parse || JSON.parse;

	  var rootClass = opts.rootClass || World_1;

	  var preSerialize = opts.preSerialize || function (obj) { return obj; };
	  var postSerialize = opts.postSerialize || function (data, obj) { return data; };

	  var preDeserialize = opts.preDeserialize || function (data) { return data; };
	  var postDeserialize = opts.postDeserialize || function (obj, data) { return obj; };

	  var refTypes = {
	    'World': World_1,
	    'Body': Body_1,
	    'Joint': Joint_1,
	  };

	  this.toJson = function (root) {
	    var flat = [];
	    var queue = [root];
	    var refMap = {};

	    function storeRef(value, typeName) {
	      value.__sid = value.__sid || ++SID;
	      if (!refMap[value.__sid]) {
	        queue.push(value);
	        var index = flat.length + queue.length;
	        var ref = {
	          refIndex: index,
	          refType: typeName
	        };
	        refMap[value.__sid] = ref;
	      }
	      return refMap[value.__sid];
	    }

	    function serialize(obj) {
	      obj = preSerialize(obj);
	      var data = obj._serialize();
	      data = postSerialize(data, obj);
	      return data;
	    }

	    while (queue.length) {
	      var obj = queue.shift();
	      var str = stringify(obj, function(key, value) {
	        if (typeof value !== 'object' || value === null) {
	          return value;
	        }
	        if (typeof value._serialize !== 'function') {
	          return value;
	        }
	        if (value === obj) {
	          return serialize(value);
	        }
	        for (var typeName in refTypes) {
	          if (value instanceof refTypes[typeName]) {
	            return storeRef(value, typeName);
	          }
	        }
	        return serialize(value);
	      }, '  ');
	      flat.push(str);
	    }

	    var result = '[' + flat.join(',') + ']';
	    return result;
	  };

	  this.fromJson = function (string) {
	    var flat = parse(string);
	    var refMap = {};

	    function deserialize(cls, data, ctx) {
	      data = preDeserialize(data);
	      var obj = cls._deserialize(data, ctx, restoreRef);
	      obj = postDeserialize(obj, data);
	      return obj;
	    }

	    function restoreRef(cls, ref, ctx) {
	      if (!ref.refIndex) {
	        return cls && cls._deserialize && deserialize(cls, ref, ctx);
	      }
	      cls = refTypes[ref.refType] || cls;
	      var index = ref.refIndex;
	      if (!refMap[index]) {
	        var data = flat[index];
	        var obj = deserialize(cls, data, ctx);
	        refMap[index] = obj;
	      }
	      return refMap[index];
	    }

	    var root = rootClass._deserialize(flat[0], null, restoreRef);

	    return root;
	  };
	}

	var serializer_1 = Serializer;

	var serializer = new Serializer();
	var toJson = serializer.toJson;
	var fromJson = serializer.fromJson;
	serializer_1.toJson = toJson;
	serializer_1.fromJson = fromJson;

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$r = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$r = typeof ASSERT === 'undefined' ? false : ASSERT;

	var CircleShape_1 = CircleShape;












	CircleShape._super = Shape_1;
	CircleShape.prototype = create(CircleShape._super.prototype);

	CircleShape.TYPE = 'circle';
	Shape_1.TYPES[CircleShape.TYPE] = CircleShape;

	function CircleShape(a, b) {
	  if (!(this instanceof CircleShape)) {
	    return new CircleShape(a, b);
	  }

	  CircleShape._super.call(this);

	  this.m_type = CircleShape.TYPE;
	  this.m_p = Vec2_1.zero();
	  this.m_radius = 1;

	  if (typeof a === 'object' && Vec2_1.isValid(a)) {
	    this.m_p.set(a);

	    if (typeof b === 'number') {
	      this.m_radius = b;
	    }

	  } else if (typeof a === 'number') {
	    this.m_radius = a;
	  }
	}

	CircleShape.prototype._serialize = function() {
	  return {
	    type: this.m_type,

	    p: this.m_p,
	    radius: this.m_radius,
	  };
	};

	CircleShape._deserialize = function(data) {
	  return new CircleShape(data.p, data.radius);
	};

	CircleShape.prototype.getRadius = function() {
	  return this.m_radius;
	};

	CircleShape.prototype.getCenter = function() {
	  return this.m_p;
	};

	CircleShape.prototype.getVertex = function(index) {
	  _ASSERT$r && common.assert(index == 0);
	  return this.m_p;
	};

	CircleShape.prototype.getVertexCount = function(index) {
	  return 1;
	};

	/**
	 * @deprecated
	 */
	CircleShape.prototype._clone = function() {
	  var clone = new CircleShape();
	  clone.m_type = this.m_type;
	  clone.m_radius = this.m_radius;
	  clone.m_p = this.m_p.clone();
	  return clone;
	};

	CircleShape.prototype.getChildCount = function() {
	  return 1;
	};

	CircleShape.prototype.testPoint = function(xf, p) {
	  var center = Vec2_1.add(xf.p, Rot_1.mulVec2(xf.q, this.m_p));
	  var d = Vec2_1.sub(p, center);
	  return Vec2_1.dot(d, d) <= this.m_radius * this.m_radius;
	};

	// Collision Detection in Interactive 3D Environments by Gino van den Bergen
	// From Section 3.1.2
	// x = s + a * r
	// norm(x) = radius
	CircleShape.prototype.rayCast = function(output, input, xf, childIndex) {

	  var position = Vec2_1.add(xf.p, Rot_1.mulVec2(xf.q, this.m_p));
	  var s = Vec2_1.sub(input.p1, position);
	  var b = Vec2_1.dot(s, s) - this.m_radius * this.m_radius;

	  // Solve quadratic equation.
	  var r = Vec2_1.sub(input.p2, input.p1);
	  var c = Vec2_1.dot(s, r);
	  var rr = Vec2_1.dot(r, r);
	  var sigma = c * c - rr * b;

	  // Check for negative discriminant and short segment.
	  if (sigma < 0.0 || rr < _Math.EPSILON) {
	    return false;
	  }

	  // Find the point of intersection of the line with the circle.
	  var a = -(c + _Math.sqrt(sigma));

	  // Is the intersection point on the segment?
	  if (0.0 <= a && a <= input.maxFraction * rr) {
	    a /= rr;
	    output.fraction = a;
	    output.normal = Vec2_1.add(s, Vec2_1.mul(a, r));
	    output.normal.normalize();
	    return true;
	  }

	  return false;
	};

	CircleShape.prototype.computeAABB = function(aabb, xf, childIndex) {
	  var p = Vec2_1.add(xf.p, Rot_1.mulVec2(xf.q, this.m_p));
	  aabb.lowerBound.set(p.x - this.m_radius, p.y - this.m_radius);
	  aabb.upperBound.set(p.x + this.m_radius, p.y + this.m_radius);
	};

	CircleShape.prototype.computeMass = function(massData, density) {
	  massData.mass = density * _Math.PI * this.m_radius * this.m_radius;
	  massData.center = this.m_p;
	  // inertia about the local origin
	  massData.I = massData.mass
	      * (0.5 * this.m_radius * this.m_radius + Vec2_1.dot(this.m_p, this.m_p));
	};

	CircleShape.prototype.computeDistanceProxy = function(proxy) {
	  proxy.m_vertices.push(this.m_p);
	  proxy.m_count = 1;
	  proxy.m_radius = this.m_radius;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$s = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$s = typeof ASSERT === 'undefined' ? false : ASSERT;

	var EdgeShape_1 = EdgeShape;











	EdgeShape._super = Shape_1;
	EdgeShape.prototype = create(EdgeShape._super.prototype);

	EdgeShape.TYPE = 'edge';
	Shape_1.TYPES[EdgeShape.TYPE] = EdgeShape;

	/**
	 * A line segment (edge) shape. These can be connected in chains or loops to
	 * other edge shapes. The connectivity information is used to ensure correct
	 * contact normals.
	 */
	function EdgeShape(v1, v2) {
	  if (!(this instanceof EdgeShape)) {
	    return new EdgeShape(v1, v2);
	  }

	  EdgeShape._super.call(this);

	  this.m_type = EdgeShape.TYPE;
	  this.m_radius = Settings_1.polygonRadius;

	  // These are the edge vertices
	  this.m_vertex1 = v1 ? Vec2_1.clone(v1) : Vec2_1.zero();
	  this.m_vertex2 = v2 ? Vec2_1.clone(v2) : Vec2_1.zero();

	  // Optional adjacent vertices. These are used for smooth collision.
	  // Used by chain shape.
	  this.m_vertex0 = Vec2_1.zero();
	  this.m_vertex3 = Vec2_1.zero();
	  this.m_hasVertex0 = false;
	  this.m_hasVertex3 = false;
	}

	EdgeShape.prototype._serialize = function() {
	  return {
	    type: this.m_type,

	    vertex1: this.m_vertex1,
	    vertex2: this.m_vertex2,

	    vertex0: this.m_vertex0,
	    vertex3: this.m_vertex3,
	    hasVertex0: this.m_hasVertex0,
	    hasVertex3: this.m_hasVertex3,
	  };
	};

	EdgeShape._deserialize = function(data) {
	  var shape = new EdgeShape(data.vertex1, data.vertex2);
	  if (shape.hasVertex0) {
	    shape.setPrev(data.vertex0);
	  }
	  if (shape.hasVertex3) {
	    shape.setNext(data.vertex3);
	  }
	  return shape;
	};

	EdgeShape.prototype.setNext = function(v3) {
	  if (v3) {
	    this.m_vertex3.set(v3);
	    this.m_hasVertex3 = true;
	  } else {
	    this.m_vertex3.setZero();
	    this.m_hasVertex3 = false;
	  }
	  return this;
	};

	EdgeShape.prototype.setPrev = function(v0) {
	  if (v0) {
	    this.m_vertex0.set(v0);
	    this.m_hasVertex0 = true;
	  } else {
	    this.m_vertex0.setZero();
	    this.m_hasVertex0 = false;
	  }
	  return this;
	};

	/**
	 * Set this as an isolated edge.
	 */
	EdgeShape.prototype._set = function(v1, v2) {
	  this.m_vertex1.set(v1);
	  this.m_vertex2.set(v2);
	  this.m_hasVertex0 = false;
	  this.m_hasVertex3 = false;
	  return this;
	};

	/**
	 * @deprecated
	 */
	EdgeShape.prototype._clone = function() {
	  var clone = new EdgeShape();
	  clone.m_type = this.m_type;
	  clone.m_radius = this.m_radius;
	  clone.m_vertex1.set(this.m_vertex1);
	  clone.m_vertex2.set(this.m_vertex2);
	  clone.m_vertex0.set(this.m_vertex0);
	  clone.m_vertex3.set(this.m_vertex3);
	  clone.m_hasVertex0 = this.m_hasVertex0;
	  clone.m_hasVertex3 = this.m_hasVertex3;
	  return clone;
	};

	EdgeShape.prototype.getChildCount = function() {
	  return 1;
	};

	EdgeShape.prototype.testPoint = function(xf, p) {
	  return false;
	};

	// p = p1 + t * d
	// v = v1 + s * e
	// p1 + t * d = v1 + s * e
	// s * e - t * d = p1 - v1
	EdgeShape.prototype.rayCast = function(output, input, xf, childIndex) {
	  // NOT_USED(childIndex);

	  // Put the ray into the edge's frame of reference.
	  var p1 = Rot_1.mulTVec2(xf.q, Vec2_1.sub(input.p1, xf.p));
	  var p2 = Rot_1.mulTVec2(xf.q, Vec2_1.sub(input.p2, xf.p));
	  var d = Vec2_1.sub(p2, p1);

	  var v1 = this.m_vertex1;
	  var v2 = this.m_vertex2;
	  var e = Vec2_1.sub(v2, v1);
	  var normal = Vec2_1.neo(e.y, -e.x);
	  normal.normalize();

	  // q = p1 + t * d
	  // dot(normal, q - v1) = 0
	  // dot(normal, p1 - v1) + t * dot(normal, d) = 0
	  var numerator = Vec2_1.dot(normal, Vec2_1.sub(v1, p1));
	  var denominator = Vec2_1.dot(normal, d);

	  if (denominator == 0.0) {
	    return false;
	  }

	  var t = numerator / denominator;
	  if (t < 0.0 || input.maxFraction < t) {
	    return false;
	  }

	  var q = Vec2_1.add(p1, Vec2_1.mul(t, d));

	  // q = v1 + s * r
	  // s = dot(q - v1, r) / dot(r, r)
	  var r = Vec2_1.sub(v2, v1);
	  var rr = Vec2_1.dot(r, r);
	  if (rr == 0.0) {
	    return false;
	  }

	  var s = Vec2_1.dot(Vec2_1.sub(q, v1), r) / rr;
	  if (s < 0.0 || 1.0 < s) {
	    return false;
	  }

	  output.fraction = t;
	  if (numerator > 0.0) {
	    output.normal = Rot_1.mulVec2(xf.q, normal).neg();
	  } else {
	    output.normal = Rot_1.mulVec2(xf.q, normal);
	  }
	  return true;
	};

	EdgeShape.prototype.computeAABB = function(aabb, xf, childIndex) {
	  var v1 = Transform_1.mulVec2(xf, this.m_vertex1);
	  var v2 = Transform_1.mulVec2(xf, this.m_vertex2);

	  aabb.combinePoints(v1, v2);
	  aabb.extend(this.m_radius);
	};

	EdgeShape.prototype.computeMass = function(massData, density) {
	  massData.mass = 0.0;
	  massData.center.setCombine(0.5, this.m_vertex1, 0.5, this.m_vertex2);
	  massData.I = 0.0;
	};

	EdgeShape.prototype.computeDistanceProxy = function(proxy) {
	  proxy.m_vertices.push(this.m_vertex1);
	  proxy.m_vertices.push(this.m_vertex2);
	  proxy.m_count = 2;
	  proxy.m_radius = this.m_radius;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$t = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$t = typeof ASSERT === 'undefined' ? false : ASSERT;

	var PolygonShape_1 = PolygonShape;












	PolygonShape._super = Shape_1;
	PolygonShape.prototype = create(PolygonShape._super.prototype);

	PolygonShape.TYPE = 'polygon';
	Shape_1.TYPES[PolygonShape.TYPE] = PolygonShape;

	/**
	 * A convex polygon. It is assumed that the interior of the polygon is to the
	 * left of each edge. Polygons have a maximum number of vertices equal to
	 * Settings.maxPolygonVertices. In most cases you should not need many vertices
	 * for a convex polygon. extends Shape
	 */
	function PolygonShape(vertices) {
	  if (!(this instanceof PolygonShape)) {
	    return new PolygonShape(vertices);
	  }

	  PolygonShape._super.call(this);

	  this.m_type = PolygonShape.TYPE;
	  this.m_radius = Settings_1.polygonRadius;
	  this.m_centroid = Vec2_1.zero();
	  this.m_vertices = []; // Vec2[Settings.maxPolygonVertices]
	  this.m_normals = []; // Vec2[Settings.maxPolygonVertices]
	  this.m_count = 0;

	  if (vertices && vertices.length) {
	    this._set(vertices);
	  }
	}

	PolygonShape.prototype._serialize = function() {
	  return {
	    type: this.m_type,

	    vertices: this.m_vertices,
	  };
	};

	PolygonShape._deserialize = function(data, fixture, restore) {
	  var vertices = data.vertices && data.vertices.map(v => Vec2_1._deserialize(v));
	  var shape = new PolygonShape(vertices);
	  return shape;
	};

	PolygonShape.prototype.getVertex = function(index) {
	  _ASSERT$t && common.assert(0 <= index && index < this.m_count);
	  return this.m_vertices[index];
	};

	/**
	 * @deprecated
	 */
	PolygonShape.prototype._clone = function() {
	  var clone = new PolygonShape();
	  clone.m_type = this.m_type;
	  clone.m_radius = this.m_radius;
	  clone.m_count = this.m_count;
	  clone.m_centroid.set(this.m_centroid);
	  for (var i = 0; i < this.m_count; i++) {
	    clone.m_vertices.push(this.m_vertices[i].clone());
	  }
	  for (var i = 0; i < this.m_normals.length; i++) {
	    clone.m_normals.push(this.m_normals[i].clone());
	  }
	  return clone;
	};

	PolygonShape.prototype.getChildCount = function() {
	  return 1;
	};

	function ComputeCentroid(vs, count) {
	  _ASSERT$t && common.assert(count >= 3);

	  var c = Vec2_1.zero();
	  var area = 0.0;

	  // pRef is the reference point for forming triangles.
	  // It's location doesn't change the result (except for rounding error).
	  var pRef = Vec2_1.zero();
	  if (false) {
	    // This code would put the reference point inside the polygon.
	    for (var i; i < count; ++i) {
	    }
	  }

	  var inv3 = 1.0 / 3.0;

	  for (var i = 0; i < count; ++i) {
	    // Triangle vertices.
	    var p1 = pRef;
	    var p2 = vs[i];
	    var p3 = i + 1 < count ? vs[i + 1] : vs[0];

	    var e1 = Vec2_1.sub(p2, p1);
	    var e2 = Vec2_1.sub(p3, p1);

	    var D = Vec2_1.cross(e1, e2);

	    var triangleArea = 0.5 * D;
	    area += triangleArea;

	    // Area weighted centroid
	    c.addMul(triangleArea * inv3, p1);
	    c.addMul(triangleArea * inv3, p2);
	    c.addMul(triangleArea * inv3, p3);
	  }

	  // Centroid
	  _ASSERT$t && common.assert(area > _Math.EPSILON);
	  c.mul(1.0 / area);
	  return c;
	}

	PolygonShape.prototype._reset = function() {
	  this._set(this.m_vertices);
	};

	/**
	 * @private
	 *
	 * Create a convex hull from the given array of local points. The count must be
	 * in the range [3, Settings.maxPolygonVertices].
	 *
	 * Warning: the points may be re-ordered, even if they form a convex polygon
	 * Warning: collinear points are handled but not removed. Collinear points may
	 * lead to poor stacking behavior.
	 */
	PolygonShape.prototype._set = function(vertices) {
	  _ASSERT$t && common.assert(3 <= vertices.length && vertices.length <= Settings_1.maxPolygonVertices);
	  if (vertices.length < 3) {
	    this._setAsBox(1.0, 1.0);
	    return;
	  }

	  var n = _Math.min(vertices.length, Settings_1.maxPolygonVertices);

	  // Perform welding and copy vertices into local buffer.
	  var ps = []; // [Settings.maxPolygonVertices];
	  for (var i = 0; i < n; ++i) {
	    var v = vertices[i];

	    var unique = true;
	    for (var j = 0; j < ps.length; ++j) {
	      if (Vec2_1.distanceSquared(v, ps[j]) < 0.25 * Settings_1.linearSlopSquared) {
	        unique = false;
	        break;
	      }
	    }

	    if (unique) {
	      ps.push(v);
	    }
	  }

	  n = ps.length;
	  if (n < 3) {
	    // Polygon is degenerate.
	    _ASSERT$t && common.assert(false);
	    this._setAsBox(1.0, 1.0);
	    return;
	  }

	  // Create the convex hull using the Gift wrapping algorithm
	  // http://en.wikipedia.org/wiki/Gift_wrapping_algorithm

	  // Find the right most point on the hull (in case of multiple points bottom most is used)
	  var i0 = 0;
	  var x0 = ps[0].x;
	  for (var i = 1; i < n; ++i) {
	    var x = ps[i].x;
	    if (x > x0 || (x === x0 && ps[i].y < ps[i0].y)) {
	      i0 = i;
	      x0 = x;
	    }
	  }

	  var hull = []; // [Settings.maxPolygonVertices];
	  var m = 0;
	  var ih = i0;

	  for (;;) {
	    hull[m] = ih;

	    var ie = 0;
	    for (var j = 1; j < n; ++j) {
	      if (ie === ih) {
	        ie = j;
	        continue;
	      }

	      var r = Vec2_1.sub(ps[ie], ps[hull[m]]);
	      var v = Vec2_1.sub(ps[j], ps[hull[m]]);
	      var c = Vec2_1.cross(r, v);
	      // c < 0 means counter-clockwise wrapping, c > 0 means clockwise wrapping
	      if (c < 0.0) {
	        ie = j;
	      }

	      // Collinearity check
	      if (c === 0.0 && v.lengthSquared() > r.lengthSquared()) {
	        ie = j;
	      }
	    }

	    ++m;
	    ih = ie;

	    if (ie === i0) {
	      break;
	    }
	  }

	  if (m < 3) {
	    // Polygon is degenerate.
	    _ASSERT$t && common.assert(false);
	    this._setAsBox(1.0, 1.0);
	    return;
	  }

	  this.m_count = m;

	  // Copy vertices.
	  this.m_vertices = [];
	  for (var i = 0; i < m; ++i) {
	    this.m_vertices[i] = ps[hull[i]];
	  }

	  // Compute normals. Ensure the edges have non-zero length.
	  for (var i = 0; i < m; ++i) {
	    var i1 = i;
	    var i2 = i + 1 < m ? i + 1 : 0;
	    var edge = Vec2_1.sub(this.m_vertices[i2], this.m_vertices[i1]);
	    _ASSERT$t && common.assert(edge.lengthSquared() > _Math.EPSILON * _Math.EPSILON);
	    this.m_normals[i] = Vec2_1.cross(edge, 1.0);
	    this.m_normals[i].normalize();
	  }

	  // Compute the polygon centroid.
	  this.m_centroid = ComputeCentroid(this.m_vertices, m);
	};

	/**
	 * @private
	 */
	PolygonShape.prototype._setAsBox = function(hx, hy, center, angle) {
	  // start with right-bottom, counter-clockwise, as in Gift wrapping algorithm in PolygonShape._set()
	  this.m_vertices[0] = Vec2_1.neo(hx, -hy);
	  this.m_vertices[1] = Vec2_1.neo(hx, hy);
	  this.m_vertices[2] = Vec2_1.neo(-hx, hy);
	  this.m_vertices[3] = Vec2_1.neo(-hx, -hy);

	  this.m_normals[0] = Vec2_1.neo(1.0, 0.0);
	  this.m_normals[1] = Vec2_1.neo(0.0, 1.0);
	  this.m_normals[2] = Vec2_1.neo(-1.0, 0.0);
	  this.m_normals[3] = Vec2_1.neo(0.0, -1.0);

	  this.m_count = 4;

	  if (Vec2_1.isValid(center)) {
	    angle = angle || 0;

	    this.m_centroid.set(center);

	    var xf = Transform_1.identity();
	    xf.p.set(center);
	    xf.q.set(angle);

	    // Transform vertices and normals.
	    for (var i = 0; i < this.m_count; ++i) {
	      this.m_vertices[i] = Transform_1.mulVec2(xf, this.m_vertices[i]);
	      this.m_normals[i] = Rot_1.mulVec2(xf.q, this.m_normals[i]);
	    }
	  }
	};

	PolygonShape.prototype.testPoint = function(xf, p) {
	  var pLocal = Rot_1.mulTVec2(xf.q, Vec2_1.sub(p, xf.p));

	  for (var i = 0; i < this.m_count; ++i) {
	    var dot = Vec2_1.dot(this.m_normals[i], Vec2_1.sub(pLocal, this.m_vertices[i]));
	    if (dot > 0.0) {
	      return false;
	    }
	  }

	  return true;
	};

	PolygonShape.prototype.rayCast = function(output, input, xf, childIndex) {

	  // Put the ray into the polygon's frame of reference.
	  var p1 = Rot_1.mulTVec2(xf.q, Vec2_1.sub(input.p1, xf.p));
	  var p2 = Rot_1.mulTVec2(xf.q, Vec2_1.sub(input.p2, xf.p));
	  var d = Vec2_1.sub(p2, p1);

	  var lower = 0.0;
	  var upper = input.maxFraction;

	  var index = -1;

	  for (var i = 0; i < this.m_count; ++i) {
	    // p = p1 + a * d
	    // dot(normal, p - v) = 0
	    // dot(normal, p1 - v) + a * dot(normal, d) = 0
	    var numerator = Vec2_1.dot(this.m_normals[i], Vec2_1.sub(this.m_vertices[i], p1));
	    var denominator = Vec2_1.dot(this.m_normals[i], d);

	    if (denominator == 0.0) {
	      if (numerator < 0.0) {
	        return false;
	      }
	    } else {
	      // Note: we want this predicate without division:
	      // lower < numerator / denominator, where denominator < 0
	      // Since denominator < 0, we have to flip the inequality:
	      // lower < numerator / denominator <==> denominator * lower > numerator.
	      if (denominator < 0.0 && numerator < lower * denominator) {
	        // Increase lower.
	        // The segment enters this half-space.
	        lower = numerator / denominator;
	        index = i;
	      } else if (denominator > 0.0 && numerator < upper * denominator) {
	        // Decrease upper.
	        // The segment exits this half-space.
	        upper = numerator / denominator;
	      }
	    }

	    // The use of epsilon here causes the assert on lower to trip
	    // in some cases. Apparently the use of epsilon was to make edge
	    // shapes work, but now those are handled separately.
	    // if (upper < lower - Math.EPSILON)
	    if (upper < lower) {
	      return false;
	    }
	  }

	  _ASSERT$t && common.assert(0.0 <= lower && lower <= input.maxFraction);

	  if (index >= 0) {
	    output.fraction = lower;
	    output.normal = Rot_1.mulVec2(xf.q, this.m_normals[index]);
	    return true;
	  }

	  return false;
	};

	PolygonShape.prototype.computeAABB = function(aabb, xf, childIndex) {
	  var minX = Infinity, minY = Infinity;
	  var maxX = -Infinity, maxY = -Infinity;
	  for (var i = 0; i < this.m_count; ++i) {
	    var v = Transform_1.mulVec2(xf, this.m_vertices[i]);
	    minX = _Math.min(minX, v.x);
	    maxX = _Math.max(maxX, v.x);
	    minY = _Math.min(minY, v.y);
	    maxY = _Math.max(maxY, v.y);
	  }

	  aabb.lowerBound.set(minX, minY);
	  aabb.upperBound.set(maxX, maxY);
	  aabb.extend(this.m_radius);
	};

	PolygonShape.prototype.computeMass = function(massData, density) {
	  // Polygon mass, centroid, and inertia.
	  // Let rho be the polygon density in mass per unit area.
	  // Then:
	  // mass = rho * int(dA)
	  // centroid.x = (1/mass) * rho * int(x * dA)
	  // centroid.y = (1/mass) * rho * int(y * dA)
	  // I = rho * int((x*x + y*y) * dA)
	  //
	  // We can compute these integrals by summing all the integrals
	  // for each triangle of the polygon. To evaluate the integral
	  // for a single triangle, we make a change of variables to
	  // the (u,v) coordinates of the triangle:
	  // x = x0 + e1x * u + e2x * v
	  // y = y0 + e1y * u + e2y * v
	  // where 0 <= u && 0 <= v && u + v <= 1.
	  //
	  // We integrate u from [0,1-v] and then v from [0,1].
	  // We also need to use the Jacobian of the transformation:
	  // D = cross(e1, e2)
	  //
	  // Simplification: triangle centroid = (1/3) * (p1 + p2 + p3)
	  //
	  // The rest of the derivation is handled by computer algebra.

	  _ASSERT$t && common.assert(this.m_count >= 3);

	  var center = Vec2_1.zero();
	  var area = 0.0;
	  var I = 0.0;

	  // s is the reference point for forming triangles.
	  // It's location doesn't change the result (except for rounding error).
	  var s = Vec2_1.zero();

	  // This code would put the reference point inside the polygon.
	  for (var i = 0; i < this.m_count; ++i) {
	    s.add(this.m_vertices[i]);
	  }
	  s.mul(1.0 / this.m_count);

	  var k_inv3 = 1.0 / 3.0;

	  for (var i = 0; i < this.m_count; ++i) {
	    // Triangle vertices.
	    var e1 = Vec2_1.sub(this.m_vertices[i], s);
	    var e2 = i + 1 < this.m_count ? Vec2_1.sub(this.m_vertices[i + 1], s) : Vec2_1
	        .sub(this.m_vertices[0], s);

	    var D = Vec2_1.cross(e1, e2);

	    var triangleArea = 0.5 * D;
	    area += triangleArea;

	    // Area weighted centroid
	    center.addCombine(triangleArea * k_inv3, e1, triangleArea * k_inv3, e2);

	    var ex1 = e1.x;
	    var ey1 = e1.y;
	    var ex2 = e2.x;
	    var ey2 = e2.y;

	    var intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;
	    var inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;

	    I += (0.25 * k_inv3 * D) * (intx2 + inty2);
	  }

	  // Total mass
	  massData.mass = density * area;

	  // Center of mass
	  _ASSERT$t && common.assert(area > _Math.EPSILON);
	  center.mul(1.0 / area);
	  massData.center.setCombine(1, center, 1, s);

	  // Inertia tensor relative to the local origin (point s).
	  massData.I = density * I;

	  // Shift to center of mass then to original body origin.
	  massData.I += massData.mass
	      * (Vec2_1.dot(massData.center, massData.center) - Vec2_1.dot(center, center));
	};

	// Validate convexity. This is a very time consuming operation.
	// @returns true if valid
	PolygonShape.prototype.validate = function() {
	  for (var i = 0; i < this.m_count; ++i) {
	    var i1 = i;
	    var i2 = i < this.m_count - 1 ? i1 + 1 : 0;
	    var p = this.m_vertices[i1];
	    var e = Vec2_1.sub(this.m_vertices[i2], p);

	    for (var j = 0; j < this.m_count; ++j) {
	      if (j == i1 || j == i2) {
	        continue;
	      }

	      var v = Vec2_1.sub(this.m_vertices[j], p);
	      var c = Vec2_1.cross(e, v);
	      if (c < 0.0) {
	        return false;
	      }
	    }
	  }

	  return true;
	};

	PolygonShape.prototype.computeDistanceProxy = function(proxy) {
	  proxy.m_vertices = this.m_vertices;
	  proxy.m_count = this.m_count;
	  proxy.m_radius = this.m_radius;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$u = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$u = typeof ASSERT === 'undefined' ? false : ASSERT;

	var ChainShape_1 = ChainShape;













	ChainShape._super = Shape_1;
	ChainShape.prototype = create(ChainShape._super.prototype);

	ChainShape.TYPE = 'chain';
	Shape_1.TYPES[ChainShape.TYPE] = ChainShape;

	/**
	 * A chain shape is a free form sequence of line segments. The chain has
	 * two-sided collision, so you can use inside and outside collision. Therefore,
	 * you may use any winding order. Connectivity information is used to create
	 * smooth collisions.
	 *
	 * WARNING: The chain will not collide properly if there are self-intersections.
	 */
	function ChainShape(vertices, loop) {
	  if (!(this instanceof ChainShape)) {
	    return new ChainShape(vertices, loop);
	  }

	  ChainShape._super.call(this);

	  this.m_type = ChainShape.TYPE;
	  this.m_radius = Settings_1.polygonRadius;
	  this.m_vertices = [];
	  this.m_count = 0;
	  this.m_prevVertex = null;
	  this.m_nextVertex = null;
	  this.m_hasPrevVertex = false;
	  this.m_hasNextVertex = false;

	  this.m_isLoop = loop;

	  if (vertices && vertices.length) {
	    if (loop) {
	      this._createLoop(vertices);
	    } else {
	      this._createChain(vertices);
	    }
	  }
	}

	ChainShape.prototype._serialize = function() {
	  const data = {
	    type: this.m_type,
	    vertices: this.m_vertices,
	    isLoop: this.m_isLoop,
	    hasPrevVertex: this.m_hasPrevVertex,
	    hasNextVertex: this.m_hasNextVertex,
	  };
	  if (this.m_prevVertex) {
	    data.prevVertex = this.m_prevVertex;
	  }
	  if (this.m_nextVertex) {
	    data.nextVertex = this.m_nextVertex;
	  }
	  return data;
	};

	ChainShape._deserialize = function(data) {
	  var shape = new ChainShape(data.vertices.map(Vec2_1._deserialize), data.isLoop);
	  if (data.prevVertex) {
	    shape._setPrevVertex(data.prevVertex);
	  }
	  if (data.nextVertex) {
	    shape._setNextVertex(data.nextVertex);
	  }
	  return shape;
	};

	// ChainShape.clear = function() {
	// this.m_vertices.length = 0;
	// this.m_count = 0;
	// }

	/**
	 * Create a loop. This automatically adjusts connectivity.
	 *
	 * @param vertices an array of vertices, these are copied
	 * @param count the vertex count
	 */
	ChainShape.prototype._createLoop = function(vertices) {
	  _ASSERT$u && common.assert(this.m_vertices.length == 0 && this.m_count == 0);
	  _ASSERT$u && common.assert(vertices.length >= 3);
	  for (var i = 1; i < vertices.length; ++i) {
	    var v1 = vertices[i - 1];
	    var v2 = vertices[i];
	    // If the code crashes here, it means your vertices are too close together.
	    _ASSERT$u && common.assert(Vec2_1.distanceSquared(v1, v2) > Settings_1.linearSlopSquared);
	  }

	  this.m_vertices.length = 0;
	  this.m_count = vertices.length + 1;
	  for (var i = 0; i < vertices.length; ++i) {
	    this.m_vertices[i] = vertices[i].clone();
	  }
	  this.m_vertices[vertices.length] = vertices[0].clone();

	  this.m_prevVertex = this.m_vertices[this.m_count - 2];
	  this.m_nextVertex = this.m_vertices[1];
	  this.m_hasPrevVertex = true;
	  this.m_hasNextVertex = true;
	  return this;
	};

	/**
	 * Create a chain with isolated end vertices.
	 *
	 * @param vertices an array of vertices, these are copied
	 * @param count the vertex count
	 */
	ChainShape.prototype._createChain = function(vertices) {
	  _ASSERT$u && common.assert(this.m_vertices.length == 0 && this.m_count == 0);
	  _ASSERT$u && common.assert(vertices.length >= 2);
	  for (var i = 1; i < vertices.length; ++i) {
	    // If the code crashes here, it means your vertices are too close together.
	    var v1 = vertices[i - 1];
	    var v2 = vertices[i];
	    _ASSERT$u && common.assert(Vec2_1.distanceSquared(v1, v2) > Settings_1.linearSlopSquared);
	  }

	  this.m_count = vertices.length;
	  for (var i = 0; i < vertices.length; ++i) {
	    this.m_vertices[i] = vertices[i].clone();
	  }

	  this.m_hasPrevVertex = false;
	  this.m_hasNextVertex = false;
	  this.m_prevVertex = null;
	  this.m_nextVertex = null;
	  return this;
	};

	/**
	 * Establish connectivity to a vertex that precedes the first vertex. Don't call
	 * this for loops.
	 */
	ChainShape.prototype._setPrevVertex = function(prevVertex) {
	  this.m_prevVertex = prevVertex;
	  this.m_hasPrevVertex = true;
	};

	/**
	 * Establish connectivity to a vertex that follows the last vertex. Don't call
	 * this for loops.
	 */
	ChainShape.prototype._setNextVertex = function(nextVertex) {
	  this.m_nextVertex = nextVertex;
	  this.m_hasNextVertex = true;
	};

	/**
	 * @deprecated
	 */
	ChainShape.prototype._clone = function() {
	  var clone = new ChainShape();
	  clone.createChain(this.m_vertices);
	  clone.m_type = this.m_type;
	  clone.m_radius = this.m_radius;
	  clone.m_prevVertex = this.m_prevVertex;
	  clone.m_nextVertex = this.m_nextVertex;
	  clone.m_hasPrevVertex = this.m_hasPrevVertex;
	  clone.m_hasNextVertex = this.m_hasNextVertex;
	  return clone;
	};

	ChainShape.prototype.getChildCount = function() {
	  // edge count = vertex count - 1
	  return this.m_count - 1;
	};

	// Get a child edge.
	ChainShape.prototype.getChildEdge = function(edge, childIndex) {
	  _ASSERT$u && common.assert(0 <= childIndex && childIndex < this.m_count - 1);
	  edge.m_type = EdgeShape_1.TYPE;
	  edge.m_radius = this.m_radius;

	  edge.m_vertex1 = this.m_vertices[childIndex];
	  edge.m_vertex2 = this.m_vertices[childIndex + 1];

	  if (childIndex > 0) {
	    edge.m_vertex0 = this.m_vertices[childIndex - 1];
	    edge.m_hasVertex0 = true;
	  } else {
	    edge.m_vertex0 = this.m_prevVertex;
	    edge.m_hasVertex0 = this.m_hasPrevVertex;
	  }

	  if (childIndex < this.m_count - 2) {
	    edge.m_vertex3 = this.m_vertices[childIndex + 2];
	    edge.m_hasVertex3 = true;
	  } else {
	    edge.m_vertex3 = this.m_nextVertex;
	    edge.m_hasVertex3 = this.m_hasNextVertex;
	  }
	};

	ChainShape.prototype.getVertex = function(index) {
	  _ASSERT$u && common.assert(0 <= index && index <= this.m_count);
	  if (index < this.m_count) {
	    return this.m_vertices[index];
	  } else {
	    return this.m_vertices[0];
	  }
	};

	/**
	 * This always return false.
	 */
	ChainShape.prototype.testPoint = function(xf, p) {
	  return false;
	};

	ChainShape.prototype.rayCast = function(output, input, xf, childIndex) {
	  _ASSERT$u && common.assert(0 <= childIndex && childIndex < this.m_count);

	  var edgeShape = new EdgeShape_1(this.getVertex(childIndex), this.getVertex(childIndex + 1));
	  return edgeShape.rayCast(output, input, xf, 0);
	};

	ChainShape.prototype.computeAABB = function(aabb, xf, childIndex) {
	  _ASSERT$u && common.assert(0 <= childIndex && childIndex < this.m_count);

	  var v1 = Transform_1.mulVec2(xf, this.getVertex(childIndex));
	  var v2 = Transform_1.mulVec2(xf, this.getVertex(childIndex + 1));

	  aabb.combinePoints(v1, v2);
	};

	/**
	 * Chains have zero mass.
	 */
	ChainShape.prototype.computeMass = function(massData, density) {
	  massData.mass = 0.0;
	  massData.center = Vec2_1.neo();
	  massData.I = 0.0;
	};

	ChainShape.prototype.computeDistanceProxy = function(proxy, childIndex) {
	  _ASSERT$u && common.assert(0 <= childIndex && childIndex < this.m_count);
	  proxy.m_buffer[0] = this.getVertex(childIndex);
	  proxy.m_buffer[1] = this.getVertex(childIndex + 1);
	  proxy.m_vertices = proxy.m_buffer;
	  proxy.m_count = 2;
	  proxy.m_radius = this.m_radius;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$v = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$v = typeof ASSERT === 'undefined' ? false : ASSERT;

	var BoxShape_1 = BoxShape;





	BoxShape._super = PolygonShape_1;
	BoxShape.prototype = create(BoxShape._super.prototype);

	BoxShape.TYPE = 'polygon';

	/**
	 * A rectangle polygon which extend PolygonShape.
	 */
	function BoxShape(hx, hy, center, angle) {
	  if (!(this instanceof BoxShape)) {
	    return new BoxShape(hx, hy, center, angle);
	  }

	  BoxShape._super.call(this);

	  this._setAsBox(hx, hy, center, angle);
	}

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$w = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$w = typeof ASSERT === 'undefined' ? false : ASSERT;












	Contact_1.addType(CircleShape_1.TYPE, CircleShape_1.TYPE, CircleCircleContact);

	function CircleCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
	  _ASSERT$w && common.assert(fixtureA.getType() == CircleShape_1.TYPE);
	  _ASSERT$w && common.assert(fixtureB.getType() == CircleShape_1.TYPE);
	  CollideCircles(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);
	}

	function CollideCircles(manifold, circleA, xfA, circleB, xfB) {
	  manifold.pointCount = 0;

	  var pA = Transform_1.mulVec2(xfA, circleA.m_p);
	  var pB = Transform_1.mulVec2(xfB, circleB.m_p);

	  var distSqr = Vec2_1.distanceSquared(pB, pA);
	  var rA = circleA.m_radius;
	  var rB = circleB.m_radius;
	  var radius = rA + rB;
	  if (distSqr > radius * radius) {
	    return;
	  }

	  manifold.type = Manifold_1.e_circles;
	  manifold.localPoint.set(circleA.m_p);
	  manifold.localNormal.setZero();
	  manifold.pointCount = 1;
	  manifold.points[0].localPoint.set(circleB.m_p);

	  // manifold.points[0].id.key = 0;
	  manifold.points[0].id.cf.indexA = 0;
	  manifold.points[0].id.cf.typeA = Manifold_1.e_vertex;
	  manifold.points[0].id.cf.indexB = 0;
	  manifold.points[0].id.cf.typeB = Manifold_1.e_vertex;
	}

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$x = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$x = typeof ASSERT === 'undefined' ? false : ASSERT;















	Contact_1.addType(EdgeShape_1.TYPE, CircleShape_1.TYPE, EdgeCircleContact);
	Contact_1.addType(ChainShape_1.TYPE, CircleShape_1.TYPE, ChainCircleContact);

	function EdgeCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB,
	    indexB) {
	  _ASSERT$x && common.assert(fixtureA.getType() == EdgeShape_1.TYPE);
	  _ASSERT$x && common.assert(fixtureB.getType() == CircleShape_1.TYPE);

	  var shapeA = fixtureA.getShape();
	  var shapeB = fixtureB.getShape();

	  CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);
	}

	function ChainCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB,
	    indexB) {
	  _ASSERT$x && common.assert(fixtureA.getType() == ChainShape_1.TYPE);
	  _ASSERT$x && common.assert(fixtureB.getType() == CircleShape_1.TYPE);

	  var chain = fixtureA.getShape();
	  var edge = new EdgeShape_1();
	  chain.getChildEdge(edge, indexA);

	  var shapeA = edge;
	  var shapeB = fixtureB.getShape();

	  CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);
	}

	// Compute contact points for edge versus circle.
	// This accounts for edge connectivity.
	function CollideEdgeCircle(manifold, edgeA, xfA, circleB, xfB) {
	  manifold.pointCount = 0;

	  // Compute circle in frame of edge
	  var Q = Transform_1.mulTVec2(xfA, Transform_1.mulVec2(xfB, circleB.m_p));

	  var A = edgeA.m_vertex1;
	  var B = edgeA.m_vertex2;
	  var e = Vec2_1.sub(B, A);

	  // Barycentric coordinates
	  var u = Vec2_1.dot(e, Vec2_1.sub(B, Q));
	  var v = Vec2_1.dot(e, Vec2_1.sub(Q, A));

	  var radius = edgeA.m_radius + circleB.m_radius;

	  // Region A
	  if (v <= 0.0) {
	    var P = Vec2_1.clone(A);
	    var d = Vec2_1.sub(Q, P);
	    var dd = Vec2_1.dot(d, d);
	    if (dd > radius * radius) {
	      return;
	    }

	    // Is there an edge connected to A?
	    if (edgeA.m_hasVertex0) {
	      var A1 = edgeA.m_vertex0;
	      var B1 = A;
	      var e1 = Vec2_1.sub(B1, A1);
	      var u1 = Vec2_1.dot(e1, Vec2_1.sub(B1, Q));

	      // Is the circle in Region AB of the previous edge?
	      if (u1 > 0.0) {
	        return;
	      }
	    }

	    manifold.type = Manifold_1.e_circles;
	    manifold.localNormal.setZero();
	    manifold.localPoint.set(P);
	    manifold.pointCount = 1;
	    manifold.points[0].localPoint.set(circleB.m_p);

	    // manifold.points[0].id.key = 0;
	    manifold.points[0].id.cf.indexA = 0;
	    manifold.points[0].id.cf.typeA = Manifold_1.e_vertex;
	    manifold.points[0].id.cf.indexB = 0;
	    manifold.points[0].id.cf.typeB = Manifold_1.e_vertex;
	    return;
	  }

	  // Region B
	  if (u <= 0.0) {
	    var P = Vec2_1.clone(B);
	    var d = Vec2_1.sub(Q, P);
	    var dd = Vec2_1.dot(d, d);
	    if (dd > radius * radius) {
	      return;
	    }

	    // Is there an edge connected to B?
	    if (edgeA.m_hasVertex3) {
	      var B2 = edgeA.m_vertex3;
	      var A2 = B;
	      var e2 = Vec2_1.sub(B2, A2);
	      var v2 = Vec2_1.dot(e2, Vec2_1.sub(Q, A2));

	      // Is the circle in Region AB of the next edge?
	      if (v2 > 0.0) {
	        return;
	      }
	    }

	    manifold.type = Manifold_1.e_circles;
	    manifold.localNormal.setZero();
	    manifold.localPoint.set(P);
	    manifold.pointCount = 1;
	    manifold.points[0].localPoint.set(circleB.m_p);

	    // manifold.points[0].id.key = 0;
	    manifold.points[0].id.cf.indexA = 1;
	    manifold.points[0].id.cf.typeA = Manifold_1.e_vertex;
	    manifold.points[0].id.cf.indexB = 0;
	    manifold.points[0].id.cf.typeB = Manifold_1.e_vertex;
	    return;
	  }

	  // Region AB
	  var den = Vec2_1.dot(e, e);
	  _ASSERT$x && common.assert(den > 0.0);
	  var P = Vec2_1.combine(u / den, A, v / den, B);
	  var d = Vec2_1.sub(Q, P);
	  var dd = Vec2_1.dot(d, d);
	  if (dd > radius * radius) {
	    return;
	  }

	  var n = Vec2_1.neo(-e.y, e.x);
	  if (Vec2_1.dot(n, Vec2_1.sub(Q, A)) < 0.0) {
	    n.set(-n.x, -n.y);
	  }
	  n.normalize();

	  manifold.type = Manifold_1.e_faceA;
	  manifold.localNormal = n;
	  manifold.localPoint.set(A);
	  manifold.pointCount = 1;
	  manifold.points[0].localPoint.set(circleB.m_p);

	  // manifold.points[0].id.key = 0;
	  manifold.points[0].id.cf.indexA = 0;
	  manifold.points[0].id.cf.typeA = Manifold_1.e_face;
	  manifold.points[0].id.cf.indexB = 0;
	  manifold.points[0].id.cf.typeB = Manifold_1.e_vertex;
	}

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$y = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$y = typeof ASSERT === 'undefined' ? false : ASSERT;













	var CollidePolygon = CollidePolygons;

	Contact_1.addType(PolygonShape_1.TYPE, PolygonShape_1.TYPE, PolygonContact);

	function PolygonContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
	  _ASSERT$y && common.assert(fixtureA.getType() == PolygonShape_1.TYPE);
	  _ASSERT$y && common.assert(fixtureB.getType() == PolygonShape_1.TYPE);
	  CollidePolygons(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);
	}

	/**
	 * Find the max separation between poly1 and poly2 using edge normals from
	 * poly1.
	 */
	function FindMaxSeparation(poly1, xf1, poly2, xf2) {
	  var count1 = poly1.m_count;
	  var count2 = poly2.m_count;
	  var n1s = poly1.m_normals;
	  var v1s = poly1.m_vertices;
	  var v2s = poly2.m_vertices;
	  var xf = Transform_1.mulTXf(xf2, xf1);

	  var bestIndex = 0;
	  var maxSeparation = -Infinity;
	  for (var i = 0; i < count1; ++i) {
	    // Get poly1 normal in frame2.
	    var n = Rot_1.mulVec2(xf.q, n1s[i]);
	    var v1 = Transform_1.mulVec2(xf, v1s[i]);

	    // Find deepest point for normal i.
	    var si = Infinity;
	    for (var j = 0; j < count2; ++j) {
	      var sij = Vec2_1.dot(n, v2s[j]) - Vec2_1.dot(n, v1);
	      if (sij < si) {
	        si = sij;
	      }
	    }

	    if (si > maxSeparation) {
	      maxSeparation = si;
	      bestIndex = i;
	    }
	  }

	  // used to keep last FindMaxSeparation call values
	  FindMaxSeparation._maxSeparation = maxSeparation;
	  FindMaxSeparation._bestIndex = bestIndex;
	}

	/**
	 * @param {ClipVertex[2]} c
	 * @param {int} edge1
	 */
	function FindIncidentEdge(c, poly1, xf1, edge1, poly2, xf2) {
	  var normals1 = poly1.m_normals;

	  var count2 = poly2.m_count;
	  var vertices2 = poly2.m_vertices;
	  var normals2 = poly2.m_normals;

	  _ASSERT$y && common.assert(0 <= edge1 && edge1 < poly1.m_count);

	  // Get the normal of the reference edge in poly2's frame.
	  var normal1 = Rot_1.mulT(xf2.q, Rot_1.mulVec2(xf1.q, normals1[edge1]));

	  // Find the incident edge on poly2.
	  var index = 0;
	  var minDot = Infinity;
	  for (var i = 0; i < count2; ++i) {
	    var dot = Vec2_1.dot(normal1, normals2[i]);
	    if (dot < minDot) {
	      minDot = dot;
	      index = i;
	    }
	  }

	  // Build the clip vertices for the incident edge.
	  var i1 = index;
	  var i2 = i1 + 1 < count2 ? i1 + 1 : 0;

	  c[0].v = Transform_1.mulVec2(xf2, vertices2[i1]);
	  c[0].id.cf.indexA = edge1;
	  c[0].id.cf.indexB = i1;
	  c[0].id.cf.typeA = Manifold_1.e_face;
	  c[0].id.cf.typeB = Manifold_1.e_vertex;

	  c[1].v = Transform_1.mulVec2(xf2, vertices2[i2]);
	  c[1].id.cf.indexA = edge1;
	  c[1].id.cf.indexB = i2;
	  c[1].id.cf.typeA = Manifold_1.e_face;
	  c[1].id.cf.typeB = Manifold_1.e_vertex;
	}

	/**
	 * 
	 * Find edge normal of max separation on A - return if separating axis is found<br>
	 * Find edge normal of max separation on B - return if separation axis is found<br>
	 * Choose reference edge as min(minA, minB)<br>
	 * Find incident edge<br>
	 * Clip
	 * 
	 * The normal points from 1 to 2
	 */
	function CollidePolygons(manifold, polyA, xfA, polyB, xfB) {
	  manifold.pointCount = 0;
	  var totalRadius = polyA.m_radius + polyB.m_radius;

	  FindMaxSeparation(polyA, xfA, polyB, xfB);
	  var edgeA = FindMaxSeparation._bestIndex;
	  var separationA = FindMaxSeparation._maxSeparation;
	  if (separationA > totalRadius)
	    return;

	  FindMaxSeparation(polyB, xfB, polyA, xfA);
	  var edgeB = FindMaxSeparation._bestIndex;
	  var separationB = FindMaxSeparation._maxSeparation;
	  if (separationB > totalRadius)
	    return;

	  var poly1; // reference polygon
	  var poly2; // incident polygon
	  var xf1;
	  var xf2;
	  var edge1; // reference edge
	  var flip;
	  var k_tol = 0.1 * Settings_1.linearSlop;

	  if (separationB > separationA + k_tol) {
	    poly1 = polyB;
	    poly2 = polyA;
	    xf1 = xfB;
	    xf2 = xfA;
	    edge1 = edgeB;
	    manifold.type = Manifold_1.e_faceB;
	    flip = 1;
	  } else {
	    poly1 = polyA;
	    poly2 = polyB;
	    xf1 = xfA;
	    xf2 = xfB;
	    edge1 = edgeA;
	    manifold.type = Manifold_1.e_faceA;
	    flip = 0;
	  }

	  var incidentEdge = [ new Manifold_1.clipVertex(), new Manifold_1.clipVertex() ];
	  FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);

	  var count1 = poly1.m_count;
	  var vertices1 = poly1.m_vertices;

	  var iv1 = edge1;
	  var iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;

	  var v11 = vertices1[iv1];
	  var v12 = vertices1[iv2];

	  var localTangent = Vec2_1.sub(v12, v11);
	  localTangent.normalize();

	  var localNormal = Vec2_1.cross(localTangent, 1.0);
	  var planePoint = Vec2_1.combine(0.5, v11, 0.5, v12);

	  var tangent = Rot_1.mulVec2(xf1.q, localTangent);
	  var normal = Vec2_1.cross(tangent, 1.0);

	  v11 = Transform_1.mulVec2(xf1, v11);
	  v12 = Transform_1.mulVec2(xf1, v12);

	  // Face offset.
	  var frontOffset = Vec2_1.dot(normal, v11);

	  // Side offsets, extended by polytope skin thickness.
	  var sideOffset1 = -Vec2_1.dot(tangent, v11) + totalRadius;
	  var sideOffset2 = Vec2_1.dot(tangent, v12) + totalRadius;

	  // Clip incident edge against extruded edge1 side edges.
	  var clipPoints1 = [ new Manifold_1.clipVertex(), new Manifold_1.clipVertex() ];
	  var clipPoints2 = [ new Manifold_1.clipVertex(), new Manifold_1.clipVertex() ];
	  var np;

	  // Clip to box side 1
	  np = Manifold_1.clipSegmentToLine(clipPoints1, incidentEdge, Vec2_1.neg(tangent),
	      sideOffset1, iv1);

	  if (np < 2) {
	    return;
	  }

	  // Clip to negative box side 1
	  np = Manifold_1.clipSegmentToLine(clipPoints2, clipPoints1, tangent,
	      sideOffset2, iv2);

	  if (np < 2) {
	    return;
	  }

	  // Now clipPoints2 contains the clipped points.
	  manifold.localNormal = localNormal;
	  manifold.localPoint = planePoint;

	  var pointCount = 0;
	  for (var i = 0; i < clipPoints2.length/* maxManifoldPoints */; ++i) {
	    var separation = Vec2_1.dot(normal, clipPoints2[i].v) - frontOffset;

	    if (separation <= totalRadius) {
	      var cp = manifold.points[pointCount]; // ManifoldPoint
	      cp.localPoint.set(Transform_1.mulTVec2(xf2, clipPoints2[i].v));
	      cp.id = clipPoints2[i].id;
	      if (flip) {
	        // Swap features
	        var cf = cp.id.cf; // ContactFeature
	        var indexA = cf.indexA;
	        var indexB = cf.indexB;
	        var typeA = cf.typeA;
	        var typeB = cf.typeB;
	        cf.indexA = indexB;
	        cf.indexB = indexA;
	        cf.typeA = typeB;
	        cf.typeB = typeA;
	      }
	      ++pointCount;
	    }
	  }

	  manifold.pointCount = pointCount;
	}

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$z = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$z = typeof ASSERT === 'undefined' ? false : ASSERT;














	Contact_1.addType(PolygonShape_1.TYPE, CircleShape_1.TYPE, PolygonCircleContact);

	function PolygonCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
	  _ASSERT$z && common.assert(fixtureA.getType() == PolygonShape_1.TYPE);
	  _ASSERT$z && common.assert(fixtureB.getType() == CircleShape_1.TYPE);
	  CollidePolygonCircle(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(),
	      xfB);
	}

	function CollidePolygonCircle(manifold, polygonA, xfA, circleB, xfB) {
	  manifold.pointCount = 0;

	  // Compute circle position in the frame of the polygon.
	  var c = Transform_1.mulVec2(xfB, circleB.m_p);
	  var cLocal = Transform_1.mulTVec2(xfA, c);

	  // Find the min separating edge.
	  var normalIndex = 0;
	  var separation = -Infinity;
	  var radius = polygonA.m_radius + circleB.m_radius;
	  var vertexCount = polygonA.m_count;
	  var vertices = polygonA.m_vertices;
	  var normals = polygonA.m_normals;

	  for (var i = 0; i < vertexCount; ++i) {
	    var s = Vec2_1.dot(normals[i], Vec2_1.sub(cLocal, vertices[i]));

	    if (s > radius) {
	      // Early out.
	      return;
	    }

	    if (s > separation) {
	      separation = s;
	      normalIndex = i;
	    }
	  }

	  // Vertices that subtend the incident face.
	  var vertIndex1 = normalIndex;
	  var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
	  var v1 = vertices[vertIndex1];
	  var v2 = vertices[vertIndex2];

	  // If the center is inside the polygon ...
	  if (separation < _Math.EPSILON) {
	    manifold.pointCount = 1;
	    manifold.type = Manifold_1.e_faceA;
	    manifold.localNormal.set(normals[normalIndex]);
	    manifold.localPoint.setCombine(0.5, v1, 0.5, v2);
	    manifold.points[0].localPoint = circleB.m_p;

	    // manifold.points[0].id.key = 0;
	    manifold.points[0].id.cf.indexA = 0;
	    manifold.points[0].id.cf.typeA = Manifold_1.e_vertex;
	    manifold.points[0].id.cf.indexB = 0;
	    manifold.points[0].id.cf.typeB = Manifold_1.e_vertex;
	    return;
	  }

	  // Compute barycentric coordinates
	  var u1 = Vec2_1.dot(Vec2_1.sub(cLocal, v1), Vec2_1.sub(v2, v1));
	  var u2 = Vec2_1.dot(Vec2_1.sub(cLocal, v2), Vec2_1.sub(v1, v2));
	  if (u1 <= 0.0) {
	    if (Vec2_1.distanceSquared(cLocal, v1) > radius * radius) {
	      return;
	    }

	    manifold.pointCount = 1;
	    manifold.type = Manifold_1.e_faceA;
	    manifold.localNormal.setCombine(1, cLocal, -1, v1);
	    manifold.localNormal.normalize();
	    manifold.localPoint = v1;
	    manifold.points[0].localPoint.set(circleB.m_p);

	    // manifold.points[0].id.key = 0;
	    manifold.points[0].id.cf.indexA = 0;
	    manifold.points[0].id.cf.typeA = Manifold_1.e_vertex;
	    manifold.points[0].id.cf.indexB = 0;
	    manifold.points[0].id.cf.typeB = Manifold_1.e_vertex;
	  } else if (u2 <= 0.0) {
	    if (Vec2_1.distanceSquared(cLocal, v2) > radius * radius) {
	      return;
	    }

	    manifold.pointCount = 1;
	    manifold.type = Manifold_1.e_faceA;
	    manifold.localNormal.setCombine(1, cLocal, -1, v2);
	    manifold.localNormal.normalize();
	    manifold.localPoint.set(v2);
	    manifold.points[0].localPoint.set(circleB.m_p);

	    // manifold.points[0].id.key = 0;
	    manifold.points[0].id.cf.indexA = 0;
	    manifold.points[0].id.cf.typeA = Manifold_1.e_vertex;
	    manifold.points[0].id.cf.indexB = 0;
	    manifold.points[0].id.cf.typeB = Manifold_1.e_vertex;
	  } else {
	    var faceCenter = Vec2_1.mid(v1, v2);
	    var separation = Vec2_1.dot(cLocal, normals[vertIndex1])
	        - Vec2_1.dot(faceCenter, normals[vertIndex1]);
	    if (separation > radius) {
	      return;
	    }

	    manifold.pointCount = 1;
	    manifold.type = Manifold_1.e_faceA;
	    manifold.localNormal.set(normals[vertIndex1]);
	    manifold.localPoint.set(faceCenter);
	    manifold.points[0].localPoint.set(circleB.m_p);

	    // manifold.points[0].id.key = 0;
	    manifold.points[0].id.cf.indexA = 0;
	    manifold.points[0].id.cf.typeA = Manifold_1.e_vertex;
	    manifold.points[0].id.cf.indexB = 0;
	    manifold.points[0].id.cf.typeB = Manifold_1.e_vertex;
	  }
	}

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$A = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$A = typeof ASSERT === 'undefined' ? false : ASSERT;















	Contact_1.addType(EdgeShape_1.TYPE, PolygonShape_1.TYPE, EdgePolygonContact);
	Contact_1.addType(ChainShape_1.TYPE, PolygonShape_1.TYPE, ChainPolygonContact);

	function EdgePolygonContact(manifold, xfA, fA, indexA, xfB, fB, indexB) {
	  _ASSERT$A && common.assert(fA.getType() == EdgeShape_1.TYPE);
	  _ASSERT$A && common.assert(fB.getType() == PolygonShape_1.TYPE);

	  CollideEdgePolygon(manifold, fA.getShape(), xfA, fB.getShape(), xfB);
	}

	function ChainPolygonContact(manifold, xfA, fA, indexA, xfB, fB, indexB) {
	  _ASSERT$A && common.assert(fA.getType() == ChainShape_1.TYPE);
	  _ASSERT$A && common.assert(fB.getType() == PolygonShape_1.TYPE);

	  var chain = fA.getShape();
	  var edge = new EdgeShape_1();
	  chain.getChildEdge(edge, indexA);

	  CollideEdgePolygon(manifold, edge, xfA, fB.getShape(), xfB);
	}

	// EPAxis Type
	var e_unknown = -1;
	var e_edgeA = 1;
	var e_edgeB = 2;

	// This structure is used to keep track of the best separating axis.
	function EPAxis() {
	  this.type; // Type
	  this.index;
	  this.separation;
	}
	// This holds polygon B expressed in frame A.
	function TempPolygon() {
	  this.vertices = []; // Vec2[Settings.maxPolygonVertices]
	  this.normals = []; // Vec2[Settings.maxPolygonVertices];
	  this.count = 0;
	}
	// Reference face used for clipping
	function ReferenceFace() {
	  this.i1, this.i2; // int
	  this.v1, this.v2; // v
	  this.normal = Vec2_1.zero();
	  this.sideNormal1 = Vec2_1.zero();
	  this.sideOffset1; // float
	  this.sideNormal2 = Vec2_1.zero();
	  this.sideOffset2; // float
	}
	// reused
	var edgeAxis = new EPAxis();
	var polygonAxis = new EPAxis();
	var polygonBA = new TempPolygon();
	var rf = new ReferenceFace();

	/**
	 * This function collides and edge and a polygon, taking into account edge
	 * adjacency.
	 */
	function CollideEdgePolygon(manifold, edgeA, xfA, polygonB, xfB) {

	  var xf = Transform_1.mulTXf(xfA, xfB);

	  var centroidB = Transform_1.mulVec2(xf, polygonB.m_centroid);

	  var v0 = edgeA.m_vertex0;
	  var v1 = edgeA.m_vertex1;
	  var v2 = edgeA.m_vertex2;
	  var v3 = edgeA.m_vertex3;

	  var hasVertex0 = edgeA.m_hasVertex0;
	  var hasVertex3 = edgeA.m_hasVertex3;

	  var edge1 = Vec2_1.sub(v2, v1);
	  edge1.normalize();
	  var normal1 = Vec2_1.neo(edge1.y, -edge1.x);
	  var offset1 = Vec2_1.dot(normal1, Vec2_1.sub(centroidB, v1));
	  var offset0 = 0.0;
	  var offset2 = 0.0;
	  var convex1 = false;
	  var convex2 = false;

	  // Is there a preceding edge?
	  if (hasVertex0) {
	    var edge0 = Vec2_1.sub(v1, v0);
	    edge0.normalize();
	    var normal0 = Vec2_1.neo(edge0.y, -edge0.x);
	    convex1 = Vec2_1.cross(edge0, edge1) >= 0.0;
	    offset0 = Vec2_1.dot(normal0, centroidB) - Vec2_1.dot(normal0, v0);
	  }

	  // Is there a following edge?
	  if (hasVertex3) {
	    var edge2 = Vec2_1.sub(v3, v2);
	    edge2.normalize();
	    var normal2 = Vec2_1.neo(edge2.y, -edge2.x);
	    convex2 = Vec2_1.cross(edge1, edge2) > 0.0;
	    offset2 = Vec2_1.dot(normal2, centroidB) - Vec2_1.dot(normal2, v2);
	  }

	  var front;
	  var normal = Vec2_1.zero();
	  var lowerLimit = Vec2_1.zero();
	  var upperLimit = Vec2_1.zero();

	  // Determine front or back collision. Determine collision normal limits.
	  if (hasVertex0 && hasVertex3) {
	    if (convex1 && convex2) {
	      front = offset0 >= 0.0 || offset1 >= 0.0 || offset2 >= 0.0;
	      if (front) {
	        normal.set(normal1);
	        lowerLimit.set(normal0);
	        upperLimit.set(normal2);
	      } else {
	        normal.setMul(-1, normal1);
	        lowerLimit.setMul(-1, normal1);
	        upperLimit.setMul(-1, normal1);
	      }
	    } else if (convex1) {
	      front = offset0 >= 0.0 || (offset1 >= 0.0 && offset2 >= 0.0);
	      if (front) {
	        normal.set(normal1);
	        lowerLimit.set(normal0);
	        upperLimit.set(normal1);
	      } else {
	        normal.setMul(-1, normal1);
	        lowerLimit.setMul(-1, normal2);
	        upperLimit.setMul(-1, normal1);
	      }
	    } else if (convex2) {
	      front = offset2 >= 0.0 || (offset0 >= 0.0 && offset1 >= 0.0);
	      if (front) {
	        normal.set(normal1);
	        lowerLimit.set(normal1);
	        upperLimit.set(normal2);
	      } else {
	        normal.setMul(-1, normal1);
	        lowerLimit.setMul(-1, normal1);
	        upperLimit.setMul(-1, normal0);
	      }
	    } else {
	      front = offset0 >= 0.0 && offset1 >= 0.0 && offset2 >= 0.0;
	      if (front) {
	        normal.set(normal1);
	        lowerLimit.set(normal1);
	        upperLimit.set(normal1);
	      } else {
	        normal.setMul(-1, normal1);
	        lowerLimit.setMul(-1, normal2);
	        upperLimit.setMul(-1, normal0);
	      }
	    }
	  } else if (hasVertex0) {
	    if (convex1) {
	      front = offset0 >= 0.0 || offset1 >= 0.0;
	      if (front) {
	        normal.set(normal1);
	        lowerLimit.set(normal0);
	        upperLimit.setMul(-1, normal1);
	      } else {
	        normal.setMul(-1, normal1);
	        lowerLimit.set(normal1);
	        upperLimit.setMul(-1, normal1);
	      }
	    } else {
	      front = offset0 >= 0.0 && offset1 >= 0.0;
	      if (front) {
	        normal.set(normal1);
	        lowerLimit.set(normal1);
	        upperLimit.setMul(-1, normal1);
	      } else {
	        normal.setMul(-1, normal1);
	        lowerLimit.set(normal1);
	        upperLimit.setMul(-1, normal0);
	      }
	    }
	  } else if (hasVertex3) {
	    if (convex2) {
	      front = offset1 >= 0.0 || offset2 >= 0.0;
	      if (front) {
	        normal.set(normal1);
	        lowerLimit.setMul(-1, normal1);
	        upperLimit.set(normal2);
	      } else {
	        normal.setMul(-1, normal1);
	        lowerLimit.setMul(-1, normal1);
	        upperLimit.set(normal1);
	      }
	    } else {
	      front = offset1 >= 0.0 && offset2 >= 0.0;
	      if (front) {
	        normal.set(normal1);
	        lowerLimit.setMul(-1, normal1);
	        upperLimit.set(normal1);
	      } else {
	        normal.setMul(-1, normal1);
	        lowerLimit.setMul(-1, normal2);
	        upperLimit.set(normal1);
	      }
	    }
	  } else {
	    front = offset1 >= 0.0;
	    if (front) {
	      normal.set(normal1);
	      lowerLimit.setMul(-1, normal1);
	      upperLimit.setMul(-1, normal1);
	    } else {
	      normal.setMul(-1, normal1);
	      lowerLimit.set(normal1);
	      upperLimit.set(normal1);
	    }
	  }

	  // Get polygonB in frameA
	  polygonBA.count = polygonB.m_count;
	  for (var i = 0; i < polygonB.m_count; ++i) {
	    polygonBA.vertices[i] = Transform_1.mulVec2(xf, polygonB.m_vertices[i]);
	    polygonBA.normals[i] = Rot_1.mulVec2(xf.q, polygonB.m_normals[i]);
	  }

	  var radius = 2.0 * Settings_1.polygonRadius;

	  manifold.pointCount = 0;

	  { // ComputeEdgeSeparation
	    edgeAxis.type = e_edgeA;
	    edgeAxis.index = front ? 0 : 1;
	    edgeAxis.separation = Infinity;

	    for (var i = 0; i < polygonBA.count; ++i) {
	      var s = Vec2_1.dot(normal, Vec2_1.sub(polygonBA.vertices[i], v1));
	      if (s < edgeAxis.separation) {
	        edgeAxis.separation = s;
	      }
	    }
	  }

	  // If no valid normal can be found than this edge should not collide.
	  if (edgeAxis.type == e_unknown) {
	    return;
	  }

	  if (edgeAxis.separation > radius) {
	    return;
	  }

	  { // ComputePolygonSeparation
	    polygonAxis.type = e_unknown;
	    polygonAxis.index = -1;
	    polygonAxis.separation = -Infinity;

	    var perp = Vec2_1.neo(-normal.y, normal.x);

	    for (var i = 0; i < polygonBA.count; ++i) {
	      var n = Vec2_1.neg(polygonBA.normals[i]);

	      var s1 = Vec2_1.dot(n, Vec2_1.sub(polygonBA.vertices[i], v1));
	      var s2 = Vec2_1.dot(n, Vec2_1.sub(polygonBA.vertices[i], v2));
	      var s = _Math.min(s1, s2);

	      if (s > radius) {
	        // No collision
	        polygonAxis.type = e_edgeB;
	        polygonAxis.index = i;
	        polygonAxis.separation = s;
	        break;
	      }

	      // Adjacency
	      if (Vec2_1.dot(n, perp) >= 0.0) {
	        if (Vec2_1.dot(Vec2_1.sub(n, upperLimit), normal) < -Settings_1.angularSlop) {
	          continue;
	        }
	      } else {
	        if (Vec2_1.dot(Vec2_1.sub(n, lowerLimit), normal) < -Settings_1.angularSlop) {
	          continue;
	        }
	      }

	      if (s > polygonAxis.separation) {
	        polygonAxis.type = e_edgeB;
	        polygonAxis.index = i;
	        polygonAxis.separation = s;
	      }
	    }
	  }

	  if (polygonAxis.type != e_unknown && polygonAxis.separation > radius) {
	    return;
	  }

	  // Use hysteresis for jitter reduction.
	  var k_relativeTol = 0.98;
	  var k_absoluteTol = 0.001;

	  var primaryAxis;
	  if (polygonAxis.type == e_unknown) {
	    primaryAxis = edgeAxis;
	  } else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {
	    primaryAxis = polygonAxis;
	  } else {
	    primaryAxis = edgeAxis;
	  }

	  var ie = [ new Manifold_1.clipVertex(), new Manifold_1.clipVertex() ];

	  if (primaryAxis.type == e_edgeA) {
	    manifold.type = Manifold_1.e_faceA;

	    // Search for the polygon normal that is most anti-parallel to the edge
	    // normal.
	    var bestIndex = 0;
	    var bestValue = Vec2_1.dot(normal, polygonBA.normals[0]);
	    for (var i = 1; i < polygonBA.count; ++i) {
	      var value = Vec2_1.dot(normal, polygonBA.normals[i]);
	      if (value < bestValue) {
	        bestValue = value;
	        bestIndex = i;
	      }
	    }

	    var i1 = bestIndex;
	    var i2 = i1 + 1 < polygonBA.count ? i1 + 1 : 0;

	    ie[0].v = polygonBA.vertices[i1];
	    ie[0].id.cf.indexA = 0;
	    ie[0].id.cf.indexB = i1;
	    ie[0].id.cf.typeA = Manifold_1.e_face;
	    ie[0].id.cf.typeB = Manifold_1.e_vertex;

	    ie[1].v = polygonBA.vertices[i2];
	    ie[1].id.cf.indexA = 0;
	    ie[1].id.cf.indexB = i2;
	    ie[1].id.cf.typeA = Manifold_1.e_face;
	    ie[1].id.cf.typeB = Manifold_1.e_vertex;

	    if (front) {
	      rf.i1 = 0;
	      rf.i2 = 1;
	      rf.v1 = v1;
	      rf.v2 = v2;
	      rf.normal.set(normal1);
	    } else {
	      rf.i1 = 1;
	      rf.i2 = 0;
	      rf.v1 = v2;
	      rf.v2 = v1;
	      rf.normal.setMul(-1, normal1);
	    }
	  } else {
	    manifold.type = Manifold_1.e_faceB;

	    ie[0].v = v1;
	    ie[0].id.cf.indexA = 0;
	    ie[0].id.cf.indexB = primaryAxis.index;
	    ie[0].id.cf.typeA = Manifold_1.e_vertex;
	    ie[0].id.cf.typeB = Manifold_1.e_face;

	    ie[1].v = v2;
	    ie[1].id.cf.indexA = 0;
	    ie[1].id.cf.indexB = primaryAxis.index;
	    ie[1].id.cf.typeA = Manifold_1.e_vertex;
	    ie[1].id.cf.typeB = Manifold_1.e_face;

	    rf.i1 = primaryAxis.index;
	    rf.i2 = rf.i1 + 1 < polygonBA.count ? rf.i1 + 1 : 0;
	    rf.v1 = polygonBA.vertices[rf.i1];
	    rf.v2 = polygonBA.vertices[rf.i2];
	    rf.normal.set(polygonBA.normals[rf.i1]);
	  }

	  rf.sideNormal1.set(rf.normal.y, -rf.normal.x);
	  rf.sideNormal2.setMul(-1, rf.sideNormal1);
	  rf.sideOffset1 = Vec2_1.dot(rf.sideNormal1, rf.v1);
	  rf.sideOffset2 = Vec2_1.dot(rf.sideNormal2, rf.v2);

	  // Clip incident edge against extruded edge1 side edges.
	  var clipPoints1 = [ new Manifold_1.clipVertex(), new Manifold_1.clipVertex() ];
	  var clipPoints2 = [ new Manifold_1.clipVertex(), new Manifold_1.clipVertex() ];

	  var np;

	  // Clip to box side 1
	  np = Manifold_1.clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);

	  if (np < Settings_1.maxManifoldPoints) {
	    return;
	  }

	  // Clip to negative box side 1
	  np = Manifold_1.clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);

	  if (np < Settings_1.maxManifoldPoints) {
	    return;
	  }

	  // Now clipPoints2 contains the clipped points.
	  if (primaryAxis.type == e_edgeA) {
	    manifold.localNormal = Vec2_1.clone(rf.normal);
	    manifold.localPoint = Vec2_1.clone(rf.v1);
	  } else {
	    manifold.localNormal = Vec2_1.clone(polygonB.m_normals[rf.i1]);
	    manifold.localPoint = Vec2_1.clone(polygonB.m_vertices[rf.i1]);
	  }

	  var pointCount = 0;
	  for (var i = 0; i < Settings_1.maxManifoldPoints; ++i) {
	    var separation = Vec2_1.dot(rf.normal, Vec2_1.sub(clipPoints2[i].v, rf.v1));

	    if (separation <= radius) {
	      var cp = manifold.points[pointCount]; // ManifoldPoint

	      if (primaryAxis.type == e_edgeA) {
	        cp.localPoint = Transform_1.mulT(xf, clipPoints2[i].v);
	        cp.id = clipPoints2[i].id;
	      } else {
	        cp.localPoint = clipPoints2[i].v;
	        cp.id.cf.typeA = clipPoints2[i].id.cf.typeB;
	        cp.id.cf.typeB = clipPoints2[i].id.cf.typeA;
	        cp.id.cf.indexA = clipPoints2[i].id.cf.indexB;
	        cp.id.cf.indexB = clipPoints2[i].id.cf.indexA;
	      }

	      ++pointCount;
	    }
	  }

	  manifold.pointCount = pointCount;
	}

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$B = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$B = typeof ASSERT === 'undefined' ? false : ASSERT;

	var DistanceJoint_1 = DistanceJoint;



















	DistanceJoint.TYPE = 'distance-joint';
	Joint_1.TYPES[DistanceJoint.TYPE] = DistanceJoint;

	DistanceJoint._super = Joint_1;
	DistanceJoint.prototype = create(DistanceJoint._super.prototype);

	/**
	 * @typedef {Object} DistanceJointDef
	 *
	 * Distance joint definition. This requires defining an anchor point on both
	 * bodies and the non-zero length of the distance joint. The definition uses
	 * local anchor points so that the initial configuration can violate the
	 * constraint slightly. This helps when saving and loading a game. Warning: Do
	 * not use a zero or short length.
	 * 
	 * @prop {float} frequencyHz The mass-spring-damper frequency in Hertz. A value
	 *       of 0 disables softness.
	 * @prop {float} dampingRatio The damping ratio. 0 = no damping, 1 = critical
	 *       damping.
	 *
	 * @prop {Vec2} def.localAnchorA The local anchor point relative to bodyA's origin.
	 * @prop {Vec2} def.localAnchorB The local anchor point relative to bodyB's origin.
	 * @prop {number} def.length Distance length.
	 */

	var DEFAULTS = {
	  frequencyHz : 0.0,
	  dampingRatio : 0.0
	};

	/**
	 * A distance joint constrains two points on two bodies to remain at a fixed
	 * distance from each other. You can view this as a massless, rigid rod.
	 *
	 * @param {DistanceJointDef} def
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Vec2} anchorA Anchor A in global coordination.
	 * @param {Vec2} anchorB Anchor B in global coordination.
	 */
	function DistanceJoint(def, bodyA, bodyB, anchorA, anchorB) {
	  if (!(this instanceof DistanceJoint)) {
	    return new DistanceJoint(def, bodyA, bodyB, anchorA, anchorB);
	  }

	  // order of constructor arguments is changed in v0.2
	  if (bodyB && anchorA && ('m_type' in anchorA) && ('x' in bodyB) && ('y' in bodyB)) {
	    var temp = bodyB;
	    bodyB = anchorA;
	    anchorA = temp;
	  }

	  def = options(def, DEFAULTS);
	  Joint_1.call(this, def, bodyA, bodyB);
	  bodyA = this.m_bodyA;
	  bodyB = this.m_bodyB;

	  this.m_type = DistanceJoint.TYPE;

	  // Solver shared
	  this.m_localAnchorA = Vec2_1.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2_1.zero());
	  this.m_localAnchorB = Vec2_1.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2_1.zero());
	  this.m_length = _Math.isFinite(def.length) ? def.length :
	    Vec2_1.distance(bodyA.getWorldPoint(this.m_localAnchorA), bodyB.getWorldPoint(this.m_localAnchorB));
	  this.m_frequencyHz = def.frequencyHz;
	  this.m_dampingRatio = def.dampingRatio;
	  this.m_impulse = 0.0;
	  this.m_gamma = 0.0;
	  this.m_bias = 0.0;

	  // Solver temp
	  this.m_u; // Vec2
	  this.m_rA; // Vec2
	  this.m_rB; // Vec2
	  this.m_localCenterA; // Vec2
	  this.m_localCenterB; // Vec2
	  this.m_invMassA;
	  this.m_invMassB;
	  this.m_invIA;
	  this.m_invIB;
	  this.m_mass;

	  // 1-D constrained system
	  // m (v2 - v1) = lambda
	  // v2 + (beta/h) * x1 + gamma * lambda = 0, gamma has units of inverse mass.
	  // x2 = x1 + h * v2

	  // 1-D mass-damper-spring system
	  // m (v2 - v1) + h * d * v2 + h * k *

	  // C = norm(p2 - p1) - L
	  // u = (p2 - p1) / norm(p2 - p1)
	  // Cdot = dot(u, v2 + cross(w2, r2) - v1 - cross(w1, r1))
	  // J = [-u -cross(r1, u) u cross(r2, u)]
	  // K = J * invM * JT
	  // = invMass1 + invI1 * cross(r1, u)^2 + invMass2 + invI2 * cross(r2, u)^2
	}
	DistanceJoint.prototype._serialize = function() {
	  return {
	    type: this.m_type,
	    bodyA: this.m_bodyA,
	    bodyB: this.m_bodyB,
	    collideConnected: this.m_collideConnected,

	    frequencyHz: this.m_frequencyHz,
	    dampingRatio: this.m_dampingRatio,

	    localAnchorA: this.m_localAnchorA,
	    localAnchorB: this.m_localAnchorB,
	    length: this.m_length,

	    impulse: this.m_impulse,
	    gamma: this.m_gamma,
	    bias: this.m_bias,
	  };
	};

	DistanceJoint._deserialize = function(data, world, restore) {
	  data.bodyA = restore(Body_1, data.bodyA, world);
	  data.bodyB = restore(Body_1, data.bodyB, world);
	  var joint = new DistanceJoint(data);
	  return joint;
	};

	/**
	 * @internal
	 */
	DistanceJoint.prototype._setAnchors = function(def) {
	  if (def.anchorA) {
	    this.m_localAnchorA.set(this.m_bodyA.getLocalPoint(def.anchorA));
	  } else if (def.localAnchorA) {
	    this.m_localAnchorA.set(def.localAnchorA);
	  }

	  if (def.anchorB) {
	    this.m_localAnchorB.set(this.m_bodyB.getLocalPoint(def.anchorB));
	  } else if (def.localAnchorB) {
	    this.m_localAnchorB.set(def.localAnchorB);
	  }

	  if (def.length > 0) {
	    this.m_length = +def.length;
	  } else if (def.length < 0) ; else if (def.anchorA || def.anchorA || def.anchorA || def.anchorA) {
	    this.m_length = Vec2_1.distance(
	        this.m_bodyA.getWorldPoint(this.m_localAnchorA),
	        this.m_bodyB.getWorldPoint(this.m_localAnchorB)
	    );
	  }
	};

	/**
	 * The local anchor point relative to bodyA's origin.
	 */
	DistanceJoint.prototype.getLocalAnchorA = function() {
	  return this.m_localAnchorA;
	};

	/**
	 * The local anchor point relative to bodyB's origin.
	 */
	DistanceJoint.prototype.getLocalAnchorB = function() {
	  return this.m_localAnchorB;
	};

	/**
	 * Set/get the natural length. Manipulating the length can lead to non-physical
	 * behavior when the frequency is zero.
	 */
	DistanceJoint.prototype.setLength = function(length) {
	  this.m_length = length;
	};

	DistanceJoint.prototype.getLength = function() {
	  return this.m_length;
	};

	DistanceJoint.prototype.setFrequency = function(hz) {
	  this.m_frequencyHz = hz;
	};

	DistanceJoint.prototype.getFrequency = function() {
	  return this.m_frequencyHz;
	};

	DistanceJoint.prototype.setDampingRatio = function(ratio) {
	  this.m_dampingRatio = ratio;
	};

	DistanceJoint.prototype.getDampingRatio = function() {
	  return this.m_dampingRatio;
	};

	DistanceJoint.prototype.getAnchorA = function() {
	  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
	};

	DistanceJoint.prototype.getAnchorB = function() {
	  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
	};

	DistanceJoint.prototype.getReactionForce = function(inv_dt) {
	  return Vec2_1.mul(this.m_impulse, this.m_u).mul(inv_dt);
	};

	DistanceJoint.prototype.getReactionTorque = function(inv_dt) {
	  return 0.0;
	};

	DistanceJoint.prototype.initVelocityConstraints = function(step) {
	  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
	  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
	  this.m_invMassA = this.m_bodyA.m_invMass;
	  this.m_invMassB = this.m_bodyB.m_invMass;
	  this.m_invIA = this.m_bodyA.m_invI;
	  this.m_invIB = this.m_bodyB.m_invI;

	  var cA = this.m_bodyA.c_position.c;
	  var aA = this.m_bodyA.c_position.a;
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;

	  var cB = this.m_bodyB.c_position.c;
	  var aB = this.m_bodyB.c_position.a;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  var qA = Rot_1.neo(aA);
	  var qB = Rot_1.neo(aB);

	  this.m_rA = Rot_1.mulVec2(qA, Vec2_1.sub(this.m_localAnchorA, this.m_localCenterA));
	  this.m_rB = Rot_1.mulVec2(qB, Vec2_1.sub(this.m_localAnchorB, this.m_localCenterB));
	  this.m_u = Vec2_1.sub(Vec2_1.add(cB, this.m_rB), Vec2_1.add(cA, this.m_rA));

	  // Handle singularity.
	  var length = this.m_u.length();
	  if (length > Settings_1.linearSlop) {
	    this.m_u.mul(1.0 / length);
	  } else {
	    this.m_u.set(0.0, 0.0);
	  }

	  var crAu = Vec2_1.cross(this.m_rA, this.m_u);
	  var crBu = Vec2_1.cross(this.m_rB, this.m_u);
	  var invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB
	      + this.m_invIB * crBu * crBu;

	  // Compute the effective mass matrix.
	  this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;

	  if (this.m_frequencyHz > 0.0) {
	    var C = length - this.m_length;

	    // Frequency
	    var omega = 2.0 * _Math.PI * this.m_frequencyHz;

	    // Damping coefficient
	    var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;

	    // Spring stiffness
	    var k = this.m_mass * omega * omega;

	    // magic formulas
	    var h = step.dt;
	    this.m_gamma = h * (d + h * k);
	    this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;
	    this.m_bias = C * h * k * this.m_gamma;

	    invMass += this.m_gamma;
	    this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
	  } else {
	    this.m_gamma = 0.0;
	    this.m_bias = 0.0;
	  }

	  if (step.warmStarting) {
	    // Scale the impulse to support a variable time step.
	    this.m_impulse *= step.dtRatio;

	    var P = Vec2_1.mul(this.m_impulse, this.m_u);

	    vA.subMul(this.m_invMassA, P);
	    wA -= this.m_invIA * Vec2_1.cross(this.m_rA, P);

	    vB.addMul(this.m_invMassB, P);
	    wB += this.m_invIB * Vec2_1.cross(this.m_rB, P);

	  } else {
	    this.m_impulse = 0.0;
	  }

	  this.m_bodyA.c_velocity.v.set(vA);
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v.set(vB);
	  this.m_bodyB.c_velocity.w = wB;
	};

	DistanceJoint.prototype.solveVelocityConstraints = function(step) {
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  // Cdot = dot(u, v + cross(w, r))
	  var vpA = Vec2_1.add(vA, Vec2_1.cross(wA, this.m_rA));
	  var vpB = Vec2_1.add(vB, Vec2_1.cross(wB, this.m_rB));
	  var Cdot = Vec2_1.dot(this.m_u, vpB) - Vec2_1.dot(this.m_u, vpA);

	  var impulse = -this.m_mass
	      * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
	  this.m_impulse += impulse;

	  var P = Vec2_1.mul(impulse, this.m_u);
	  vA.subMul(this.m_invMassA, P);
	  wA -= this.m_invIA * Vec2_1.cross(this.m_rA, P);
	  vB.addMul(this.m_invMassB, P);
	  wB += this.m_invIB * Vec2_1.cross(this.m_rB, P);

	  this.m_bodyA.c_velocity.v.set(vA);
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v.set(vB);
	  this.m_bodyB.c_velocity.w = wB;
	};

	DistanceJoint.prototype.solvePositionConstraints = function(step) {
	  if (this.m_frequencyHz > 0.0) {
	    // There is no position correction for soft distance constraints.
	    return true;
	  }

	  var cA = this.m_bodyA.c_position.c;
	  var aA = this.m_bodyA.c_position.a;
	  var cB = this.m_bodyB.c_position.c;
	  var aB = this.m_bodyB.c_position.a;

	  var qA = Rot_1.neo(aA);
	  var qB = Rot_1.neo(aB);

	  var rA = Rot_1.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
	  var rB = Rot_1.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
	  var u = Vec2_1.sub(Vec2_1.add(cB, rB), Vec2_1.add(cA, rA));

	  var length = u.normalize();
	  var C = length - this.m_length;
	  C = _Math
	      .clamp(C, -Settings_1.maxLinearCorrection, Settings_1.maxLinearCorrection);

	  var impulse = -this.m_mass * C;
	  var P = Vec2_1.mul(impulse, u);

	  cA.subMul(this.m_invMassA, P);
	  aA -= this.m_invIA * Vec2_1.cross(rA, P);
	  cB.addMul(this.m_invMassB, P);
	  aB += this.m_invIB * Vec2_1.cross(rB, P);

	  this.m_bodyA.c_position.c.set(cA);
	  this.m_bodyA.c_position.a = aA;
	  this.m_bodyB.c_position.c.set(cB);
	  this.m_bodyB.c_position.a = aB;

	  return _Math.abs(C) < Settings_1.linearSlop;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$C = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$C = typeof ASSERT === 'undefined' ? false : ASSERT;

	var FrictionJoint_1 = FrictionJoint;




















	FrictionJoint.TYPE = 'friction-joint';
	Joint_1.TYPES[FrictionJoint.TYPE] = FrictionJoint;

	FrictionJoint._super = Joint_1;
	FrictionJoint.prototype = create(FrictionJoint._super.prototype);

	/**
	 * @typedef {Object} FrictionJointDef
	 *
	 * Friction joint definition.
	 * 
	 * @prop {float} maxForce The maximum friction force in N.
	 * @prop {float} maxTorque The maximum friction torque in N-m.
	 *
	 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
	 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
	 */

	var DEFAULTS$1 = {
	  maxForce : 0.0,
	  maxTorque : 0.0,
	};

	/**
	 * Friction joint. This is used for top-down friction. It provides 2D
	 * translational friction and angular friction.
	 *
	 * @param {FrictionJointDef} def
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Vec2} anchor Anchor in global coordination.
	 */
	function FrictionJoint(def, bodyA, bodyB, anchor) {
	  if (!(this instanceof FrictionJoint)) {
	    return new FrictionJoint(def, bodyA, bodyB, anchor);
	  }

	  def = options(def, DEFAULTS$1);
	  Joint_1.call(this, def, bodyA, bodyB);
	  bodyA = this.m_bodyA;
	  bodyB = this.m_bodyB;

	  this.m_type = FrictionJoint.TYPE;

	  this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2_1.zero();
	  this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2_1.zero();

	  // Solver shared
	  this.m_linearImpulse = Vec2_1.zero();
	  this.m_angularImpulse = 0.0;
	  this.m_maxForce = def.maxForce;
	  this.m_maxTorque = def.maxTorque;

	  // Solver temp
	  this.m_rA; // Vec2
	  this.m_rB; // Vec2
	  this.m_localCenterA; // Vec2
	  this.m_localCenterB; // Vec2
	  this.m_invMassA; // float
	  this.m_invMassB; // float
	  this.m_invIA; // float
	  this.m_invIB; // float
	  this.m_linearMass; // Mat22
	  this.m_angularMass; // float

	  // Point-to-point constraint
	  // Cdot = v2 - v1
	  // = v2 + cross(w2, r2) - v1 - cross(w1, r1)
	  // J = [-I -r1_skew I r2_skew ]
	  // Identity used:
	  // w k % (rx i + ry j) = w * (-ry i + rx j)

	  // Angle constraint
	  // Cdot = w2 - w1
	  // J = [0 0 -1 0 0 1]
	  // K = invI1 + invI2
	}

	FrictionJoint.prototype._serialize = function() {
	  return {
	    type: this.m_type,
	    bodyA: this.m_bodyA,
	    bodyB: this.m_bodyB,
	    collideConnected: this.m_collideConnected,

	    maxForce: this.m_maxForce,
	    maxTorque: this.m_maxTorque,

	    localAnchorA: this.m_localAnchorA,
	    localAnchorB: this.m_localAnchorB,
	  };
	};

	FrictionJoint._deserialize = function(data, world, restore) {
	  data.bodyA = restore(Body_1, data.bodyA, world);
	  data.bodyB = restore(Body_1, data.bodyB, world);
	  var joint = new FrictionJoint(data);
	  return joint;
	};

	/**
	 * The local anchor point relative to bodyA's origin.
	 */
	FrictionJoint.prototype.getLocalAnchorA = function() {
	  return this.m_localAnchorA;
	};

	/**
	 * The local anchor point relative to bodyB's origin.
	 */
	FrictionJoint.prototype.getLocalAnchorB = function() {
	  return this.m_localAnchorB;
	};

	/**
	 * Set the maximum friction force in N.
	 */
	FrictionJoint.prototype.setMaxForce = function(force) {
	  _ASSERT$C && common.assert(_Math.isFinite(force) && force >= 0.0);
	  this.m_maxForce = force;
	};

	/**
	 * Get the maximum friction force in N.
	 */
	FrictionJoint.prototype.getMaxForce = function() {
	  return this.m_maxForce;
	};

	/**
	 * Set the maximum friction torque in N*m.
	 */
	FrictionJoint.prototype.setMaxTorque = function(torque) {
	  _ASSERT$C && common.assert(_Math.isFinite(torque) && torque >= 0.0);
	  this.m_maxTorque = torque;
	};

	/**
	 * Get the maximum friction torque in N*m.
	 */
	FrictionJoint.prototype.getMaxTorque = function() {
	  return this.m_maxTorque;
	};

	FrictionJoint.prototype.getAnchorA = function() {
	  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
	};

	FrictionJoint.prototype.getAnchorB = function() {
	  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
	};

	FrictionJoint.prototype.getReactionForce = function(inv_dt) {
	  return Vec2_1.mul(inv_dt, this.m_linearImpulse);
	};

	FrictionJoint.prototype.getReactionTorque = function(inv_dt) {
	  return inv_dt * this.m_angularImpulse;
	};

	FrictionJoint.prototype.initVelocityConstraints = function(step) {
	  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
	  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
	  this.m_invMassA = this.m_bodyA.m_invMass;
	  this.m_invMassB = this.m_bodyB.m_invMass;
	  this.m_invIA = this.m_bodyA.m_invI;
	  this.m_invIB = this.m_bodyB.m_invI;

	  var aA = this.m_bodyA.c_position.a;
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;

	  var aB = this.m_bodyB.c_position.a;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  var qA = Rot_1.neo(aA), qB = Rot_1.neo(aB);

	  // Compute the effective mass matrix.
	  this.m_rA = Rot_1.mulVec2(qA, Vec2_1.sub(this.m_localAnchorA, this.m_localCenterA));
	  this.m_rB = Rot_1.mulVec2(qB, Vec2_1.sub(this.m_localAnchorB, this.m_localCenterB));

	  // J = [-I -r1_skew I r2_skew]
	  // [ 0 -1 0 1]
	  // r_skew = [-ry; rx]

	  // Matlab
	  // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
	  // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
	  // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]

	  var mA = this.m_invMassA, mB = this.m_invMassB; // float
	  var iA = this.m_invIA, iB = this.m_invIB; // float

	  var K = new Mat22_1();
	  K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y
	      * this.m_rB.y;
	  K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;
	  K.ey.x = K.ex.y;
	  K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x
	      * this.m_rB.x;

	  this.m_linearMass = K.getInverse();

	  this.m_angularMass = iA + iB;
	  if (this.m_angularMass > 0.0) {
	    this.m_angularMass = 1.0 / this.m_angularMass;
	  }

	  if (step.warmStarting) {
	    // Scale impulses to support a variable time step.
	    this.m_linearImpulse.mul(step.dtRatio);
	    this.m_angularImpulse *= step.dtRatio;

	    var P = Vec2_1.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);

	    vA.subMul(mA, P);
	    wA -= iA * (Vec2_1.cross(this.m_rA, P) + this.m_angularImpulse);

	    vB.addMul(mB, P);
	    wB += iB * (Vec2_1.cross(this.m_rB, P) + this.m_angularImpulse);

	  } else {
	    this.m_linearImpulse.setZero();
	    this.m_angularImpulse = 0.0;
	  }

	  this.m_bodyA.c_velocity.v = vA;
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v = vB;
	  this.m_bodyB.c_velocity.w = wB;
	};

	FrictionJoint.prototype.solveVelocityConstraints = function(step) {
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  var mA = this.m_invMassA, mB = this.m_invMassB; // float
	  var iA = this.m_invIA, iB = this.m_invIB; // float

	  var h = step.dt; // float

	  // Solve angular friction
	  {
	    var Cdot = wB - wA; // float
	    var impulse = -this.m_angularMass * Cdot; // float

	    var oldImpulse = this.m_angularImpulse; // float
	    var maxImpulse = h * this.m_maxTorque; // float
	    this.m_angularImpulse = _Math.clamp(this.m_angularImpulse + impulse,
	        -maxImpulse, maxImpulse);
	    impulse = this.m_angularImpulse - oldImpulse;

	    wA -= iA * impulse;
	    wB += iB * impulse;
	  }

	  // Solve linear friction
	  {
	    var Cdot = Vec2_1.sub(Vec2_1.add(vB, Vec2_1.cross(wB, this.m_rB)), Vec2_1.add(vA,
	        Vec2_1.cross(wA, this.m_rA))); // Vec2

	    var impulse = Vec2_1.neg(Mat22_1.mulVec2(this.m_linearMass, Cdot)); // Vec2
	    var oldImpulse = this.m_linearImpulse; // Vec2
	    this.m_linearImpulse.add(impulse);

	    var maxImpulse = h * this.m_maxForce; // float

	    if (this.m_linearImpulse.lengthSquared() > maxImpulse * maxImpulse) {
	      this.m_linearImpulse.normalize();
	      this.m_linearImpulse.mul(maxImpulse);
	    }

	    impulse = Vec2_1.sub(this.m_linearImpulse, oldImpulse);

	    vA.subMul(mA, impulse);
	    wA -= iA * Vec2_1.cross(this.m_rA, impulse);

	    vB.addMul(mB, impulse);
	    wB += iB * Vec2_1.cross(this.m_rB, impulse);
	  }

	  this.m_bodyA.c_velocity.v = vA;
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v = vB;
	  this.m_bodyB.c_velocity.w = wB;
	};

	FrictionJoint.prototype.solvePositionConstraints = function(step) {
	  return true;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$D = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$D = typeof ASSERT === 'undefined' ? false : ASSERT;

	var RevoluteJoint_1 = RevoluteJoint;




















	var inactiveLimit = 0;
	var atLowerLimit = 1;
	var atUpperLimit = 2;
	var equalLimits = 3;

	RevoluteJoint.TYPE = 'revolute-joint';
	Joint_1.TYPES[RevoluteJoint.TYPE] = RevoluteJoint;

	RevoluteJoint._super = Joint_1;
	RevoluteJoint.prototype = create(RevoluteJoint._super.prototype);

	/**
	 * @typedef {Object} RevoluteJointDef
	 *
	 * Revolute joint definition. This requires defining an anchor point where the
	 * bodies are joined. The definition uses local anchor points so that the
	 * initial configuration can violate the constraint slightly. You also need to
	 * specify the initial relative angle for joint limits. This helps when saving
	 * and loading a game.
	 *
	 * The local anchor points are measured from the body's origin rather than the
	 * center of mass because: 1. you might not know where the center of mass will
	 * be. 2. if you add/remove shapes from a body and recompute the mass, the
	 * joints will be broken.
	 *
	 * @prop {bool} enableLimit A flag to enable joint limits.
	 * @prop {bool} enableMotor A flag to enable the joint motor.
	 * @prop {float} lowerAngle The lower angle for the joint limit (radians).
	 * @prop {float} upperAngle The upper angle for the joint limit (radians).
	 * @prop {float} motorSpeed The desired motor speed. Usually in radians per
	 *       second.
	 * @prop {float} maxMotorTorque The maximum motor torque used to achieve the
	 *       desired motor speed. Usually in N-m.
	 *
	 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
	 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
	 * @prop {float} referenceAngle The bodyB angle minus bodyA angle in the
	 *       reference state (radians).
	 */

	var DEFAULTS$2 = {
	  lowerAngle : 0.0,
	  upperAngle : 0.0,
	  maxMotorTorque : 0.0,
	  motorSpeed : 0.0,
	  enableLimit : false,
	  enableMotor : false
	};

	/**
	 * A revolute joint constrains two bodies to share a common point while they are
	 * free to rotate about the point. The relative rotation about the shared point
	 * is the joint angle. You can limit the relative rotation with a joint limit
	 * that specifies a lower and upper angle. You can use a motor to drive the
	 * relative rotation about the shared point. A maximum motor torque is provided
	 * so that infinite forces are not generated.
	 *
	 * @param {RevoluteJointDef} def
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 */
	function RevoluteJoint(def, bodyA, bodyB, anchor) {
	  if (!(this instanceof RevoluteJoint)) {
	    return new RevoluteJoint(def, bodyA, bodyB, anchor);
	  }

	  def = options(def, DEFAULTS$2);
	  Joint_1.call(this, def, bodyA, bodyB);
	  bodyA = this.m_bodyA;
	  bodyB = this.m_bodyB;

	  this.m_type = RevoluteJoint.TYPE;

	  this.m_localAnchorA =  Vec2_1.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2_1.zero());
	  this.m_localAnchorB =  Vec2_1.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2_1.zero());
	  this.m_referenceAngle = _Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();

	  this.m_impulse = Vec3_1();
	  this.m_motorImpulse = 0.0;

	  this.m_lowerAngle = def.lowerAngle;
	  this.m_upperAngle = def.upperAngle;
	  this.m_maxMotorTorque = def.maxMotorTorque;
	  this.m_motorSpeed = def.motorSpeed;
	  this.m_enableLimit = def.enableLimit;
	  this.m_enableMotor = def.enableMotor;

	  // Solver temp
	  this.m_rA; // Vec2
	  this.m_rB; // Vec2
	  this.m_localCenterA; // Vec2
	  this.m_localCenterB; // Vec2
	  this.m_invMassA; // float
	  this.m_invMassB; // float
	  this.m_invIA; // float
	  this.m_invIB; // float
	  // effective mass for point-to-point constraint.
	  this.m_mass = new Mat33_1();
	  // effective mass for motor/limit angular constraint.
	  this.m_motorMass; // float
	  this.m_limitState = inactiveLimit;

	  // Point-to-point constraint
	  // C = p2 - p1
	  // Cdot = v2 - v1
	  // = v2 + cross(w2, r2) - v1 - cross(w1, r1)
	  // J = [-I -r1_skew I r2_skew ]
	  // Identity used:
	  // w k % (rx i + ry j) = w * (-ry i + rx j)

	  // Motor constraint
	  // Cdot = w2 - w1
	  // J = [0 0 -1 0 0 1]
	  // K = invI1 + invI2
	}

	RevoluteJoint.prototype._serialize = function() {
	  return {
	    type: this.m_type,
	    bodyA: this.m_bodyA,
	    bodyB: this.m_bodyB,
	    collideConnected: this.m_collideConnected,

	    lowerAngle: this.m_lowerAngle,
	    upperAngle: this.m_upperAngle,
	    maxMotorTorque: this.m_maxMotorTorque,
	    motorSpeed: this.m_motorSpeed,
	    enableLimit: this.m_enableLimit,
	    enableMotor: this.m_enableMotor,

	    localAnchorA: this.m_localAnchorA,
	    localAnchorB: this.m_localAnchorB,
	    referenceAngle: this.m_referenceAngle,
	  };
	};

	RevoluteJoint._deserialize = function(data, world, restore) {
	  data.bodyA = restore(Body_1, data.bodyA, world);
	  data.bodyB = restore(Body_1, data.bodyB, world);
	  var joint = new RevoluteJoint(data);
	  return joint;
	};

	/**
	 * @internal
	 */
	RevoluteJoint.prototype._setAnchors = function(def) {
	  if (def.anchorA) {
	    this.m_localAnchorA.set(this.m_bodyA.getLocalPoint(def.anchorA));
	  } else if (def.localAnchorA) {
	    this.m_localAnchorA.set(def.localAnchorA);
	  }

	  if (def.anchorB) {
	    this.m_localAnchorB.set(this.m_bodyB.getLocalPoint(def.anchorB));
	  } else if (def.localAnchorB) {
	    this.m_localAnchorB.set(def.localAnchorB);
	  }
	};

	/**
	 * The local anchor point relative to bodyA's origin.
	 */
	RevoluteJoint.prototype.getLocalAnchorA = function() {
	  return this.m_localAnchorA;
	};

	/**
	 * The local anchor point relative to bodyB's origin.
	 */
	RevoluteJoint.prototype.getLocalAnchorB = function() {
	  return this.m_localAnchorB;
	};

	/**
	 * Get the reference angle.
	 */
	RevoluteJoint.prototype.getReferenceAngle = function() {
	  return this.m_referenceAngle;
	};

	/**
	 * Get the current joint angle in radians.
	 */
	RevoluteJoint.prototype.getJointAngle = function() {
	  var bA = this.m_bodyA;
	  var bB = this.m_bodyB;
	  return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
	};

	/**
	 * Get the current joint angle speed in radians per second.
	 */
	RevoluteJoint.prototype.getJointSpeed = function() {
	  var bA = this.m_bodyA;
	  var bB = this.m_bodyB;
	  return bB.m_angularVelocity - bA.m_angularVelocity;
	};

	/**
	 * Is the joint motor enabled?
	 */
	RevoluteJoint.prototype.isMotorEnabled = function() {
	  return this.m_enableMotor;
	};

	/**
	 * Enable/disable the joint motor.
	 */
	RevoluteJoint.prototype.enableMotor = function(flag) {
	  this.m_bodyA.setAwake(true);
	  this.m_bodyB.setAwake(true);
	  this.m_enableMotor = flag;
	};

	/**
	 * Get the current motor torque given the inverse time step. Unit is N*m.
	 */
	RevoluteJoint.prototype.getMotorTorque = function(inv_dt) {
	  return inv_dt * this.m_motorImpulse;
	};

	/**
	 * Set the motor speed in radians per second.
	 */
	RevoluteJoint.prototype.setMotorSpeed = function(speed) {
	  this.m_bodyA.setAwake(true);
	  this.m_bodyB.setAwake(true);
	  this.m_motorSpeed = speed;
	};

	/**
	 * Get the motor speed in radians per second.
	 */
	RevoluteJoint.prototype.getMotorSpeed = function() {
	  return this.m_motorSpeed;
	};

	/**
	 * Set the maximum motor torque, usually in N-m.
	 */
	RevoluteJoint.prototype.setMaxMotorTorque = function(torque) {
	  this.m_bodyA.setAwake(true);
	  this.m_bodyB.setAwake(true);
	  this.m_maxMotorTorque = torque;
	};

	RevoluteJoint.prototype.getMaxMotorTorque = function() {
	  return this.m_maxMotorTorque;
	};

	/**
	 * Is the joint limit enabled?
	 */
	RevoluteJoint.prototype.isLimitEnabled = function() {
	  return this.m_enableLimit;
	};

	/**
	 * Enable/disable the joint limit.
	 */
	RevoluteJoint.prototype.enableLimit = function(flag) {
	  if (flag != this.m_enableLimit) {
	    this.m_bodyA.setAwake(true);
	    this.m_bodyB.setAwake(true);
	    this.m_enableLimit = flag;
	    this.m_impulse.z = 0.0;
	  }
	};

	/**
	 * Get the lower joint limit in radians.
	 */
	RevoluteJoint.prototype.getLowerLimit = function() {
	  return this.m_lowerAngle;
	};

	/**
	 * Get the upper joint limit in radians.
	 */
	RevoluteJoint.prototype.getUpperLimit = function() {
	  return this.m_upperAngle;
	};

	/**
	 * Set the joint limits in radians.
	 */
	RevoluteJoint.prototype.setLimits = function(lower, upper) {
	  _ASSERT$D && common.assert(lower <= upper);

	  if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {
	    this.m_bodyA.setAwake(true);
	    this.m_bodyB.setAwake(true);
	    this.m_impulse.z = 0.0;
	    this.m_lowerAngle = lower;
	    this.m_upperAngle = upper;
	  }
	};

	RevoluteJoint.prototype.getAnchorA = function() {
	  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
	};

	RevoluteJoint.prototype.getAnchorB = function() {
	  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
	};

	/**
	 * Get the reaction force given the inverse time step. Unit is N.
	 */
	RevoluteJoint.prototype.getReactionForce = function(inv_dt) {
	  return Vec2_1.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);
	};

	/**
	 * Get the reaction torque due to the joint limit given the inverse time step.
	 * Unit is N*m.
	 */
	RevoluteJoint.prototype.getReactionTorque = function(inv_dt) {
	  return inv_dt * this.m_impulse.z;
	};

	RevoluteJoint.prototype.initVelocityConstraints = function(step) {
	  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
	  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
	  this.m_invMassA = this.m_bodyA.m_invMass;
	  this.m_invMassB = this.m_bodyB.m_invMass;
	  this.m_invIA = this.m_bodyA.m_invI;
	  this.m_invIB = this.m_bodyB.m_invI;

	  var aA = this.m_bodyA.c_position.a;
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;

	  var aB = this.m_bodyB.c_position.a;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  var qA = Rot_1.neo(aA);
	  var qB = Rot_1.neo(aB);

	  this.m_rA = Rot_1.mulVec2(qA, Vec2_1.sub(this.m_localAnchorA, this.m_localCenterA));
	  this.m_rB = Rot_1.mulVec2(qB, Vec2_1.sub(this.m_localAnchorB, this.m_localCenterB));

	  // J = [-I -r1_skew I r2_skew]
	  // [ 0 -1 0 1]
	  // r_skew = [-ry; rx]

	  // Matlab
	  // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
	  // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
	  // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]

	  var mA = this.m_invMassA;
	  var mB = this.m_invMassB; // float
	  var iA = this.m_invIA;
	  var iB = this.m_invIB; // float

	  var fixedRotation = (iA + iB === 0.0); // bool

	  this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y
	      * this.m_rB.y * iB;
	  this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y
	      * this.m_rB.x * iB;
	  this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
	  this.m_mass.ex.y = this.m_mass.ey.x;
	  this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x
	      * this.m_rB.x * iB;
	  this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
	  this.m_mass.ex.z = this.m_mass.ez.x;
	  this.m_mass.ey.z = this.m_mass.ez.y;
	  this.m_mass.ez.z = iA + iB;

	  this.m_motorMass = iA + iB;
	  if (this.m_motorMass > 0.0) {
	    this.m_motorMass = 1.0 / this.m_motorMass;
	  }

	  if (this.m_enableMotor == false || fixedRotation) {
	    this.m_motorImpulse = 0.0;
	  }

	  if (this.m_enableLimit && fixedRotation == false) {
	    var jointAngle = aB - aA - this.m_referenceAngle; // float

	    if (_Math.abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * Settings_1.angularSlop) {
	      this.m_limitState = equalLimits;

	    } else if (jointAngle <= this.m_lowerAngle) {
	      if (this.m_limitState != atLowerLimit) {
	        this.m_impulse.z = 0.0;
	      }
	      this.m_limitState = atLowerLimit;

	    } else if (jointAngle >= this.m_upperAngle) {
	      if (this.m_limitState != atUpperLimit) {
	        this.m_impulse.z = 0.0;
	      }
	      this.m_limitState = atUpperLimit;

	    } else {
	      this.m_limitState = inactiveLimit;
	      this.m_impulse.z = 0.0;
	    }

	  } else {
	    this.m_limitState = inactiveLimit;
	  }

	  if (step.warmStarting) {
	    // Scale impulses to support a variable time step.
	    this.m_impulse.mul(step.dtRatio);
	    this.m_motorImpulse *= step.dtRatio;

	    var P = Vec2_1.neo(this.m_impulse.x, this.m_impulse.y);

	    vA.subMul(mA, P);
	    wA -= iA * (Vec2_1.cross(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);

	    vB.addMul(mB, P);
	    wB += iB * (Vec2_1.cross(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);

	  } else {
	    this.m_impulse.setZero();
	    this.m_motorImpulse = 0.0;
	  }

	  this.m_bodyA.c_velocity.v = vA;
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v = vB;
	  this.m_bodyB.c_velocity.w = wB;
	};

	RevoluteJoint.prototype.solveVelocityConstraints = function(step) {
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  var mA = this.m_invMassA;
	  var mB = this.m_invMassB; // float
	  var iA = this.m_invIA;
	  var iB = this.m_invIB; // float

	  var fixedRotation = (iA + iB === 0.0); // bool

	  // Solve motor constraint.
	  if (this.m_enableMotor && this.m_limitState != equalLimits
	      && fixedRotation == false) {
	    var Cdot = wB - wA - this.m_motorSpeed; // float
	    var impulse = -this.m_motorMass * Cdot; // float
	    var oldImpulse = this.m_motorImpulse; // float
	    var maxImpulse = step.dt * this.m_maxMotorTorque; // float
	    this.m_motorImpulse = _Math.clamp(this.m_motorImpulse + impulse,
	        -maxImpulse, maxImpulse);
	    impulse = this.m_motorImpulse - oldImpulse;

	    wA -= iA * impulse;
	    wB += iB * impulse;
	  }

	  // Solve limit constraint.
	  if (this.m_enableLimit && this.m_limitState != inactiveLimit
	      && fixedRotation == false) {
	    var Cdot1 = Vec2_1.zero();
	    Cdot1.addCombine(1, vB, 1, Vec2_1.cross(wB, this.m_rB));
	    Cdot1.subCombine(1, vA, 1, Vec2_1.cross(wA, this.m_rA));
	    var Cdot2 = wB - wA; // float
	    var Cdot = Vec3_1(Cdot1.x, Cdot1.y, Cdot2);

	    var impulse = Vec3_1.neg(this.m_mass.solve33(Cdot)); // Vec3

	    if (this.m_limitState == equalLimits) {
	      this.m_impulse.add(impulse);

	    } else if (this.m_limitState == atLowerLimit) {
	      var newImpulse = this.m_impulse.z + impulse.z; // float

	      if (newImpulse < 0.0) {
	        var rhs = Vec2_1.combine(-1, Cdot1, this.m_impulse.z, Vec2_1.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2
	        var reduced = this.m_mass.solve22(rhs); // Vec2
	        impulse.x = reduced.x;
	        impulse.y = reduced.y;
	        impulse.z = -this.m_impulse.z;
	        this.m_impulse.x += reduced.x;
	        this.m_impulse.y += reduced.y;
	        this.m_impulse.z = 0.0;

	      } else {
	        this.m_impulse.add(impulse);
	      }

	    } else if (this.m_limitState == atUpperLimit) {
	      var newImpulse = this.m_impulse.z + impulse.z; // float

	      if (newImpulse > 0.0) {
	        var rhs = Vec2_1.combine(-1, Cdot1, this.m_impulse.z, Vec2_1.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2
	        var reduced = this.m_mass.solve22(rhs); // Vec2
	        impulse.x = reduced.x;
	        impulse.y = reduced.y;
	        impulse.z = -this.m_impulse.z;
	        this.m_impulse.x += reduced.x;
	        this.m_impulse.y += reduced.y;
	        this.m_impulse.z = 0.0;

	      } else {
	        this.m_impulse.add(impulse);
	      }
	    }

	    var P = Vec2_1.neo(impulse.x, impulse.y);

	    vA.subMul(mA, P);
	    wA -= iA * (Vec2_1.cross(this.m_rA, P) + impulse.z);

	    vB.addMul(mB, P);
	    wB += iB * (Vec2_1.cross(this.m_rB, P) + impulse.z);

	  } else {
	    // Solve point-to-point constraint
	    var Cdot = Vec2_1.zero();
	    Cdot.addCombine(1, vB, 1, Vec2_1.cross(wB, this.m_rB));
	    Cdot.subCombine(1, vA, 1, Vec2_1.cross(wA, this.m_rA));
	    var impulse = this.m_mass.solve22(Vec2_1.neg(Cdot)); // Vec2

	    this.m_impulse.x += impulse.x;
	    this.m_impulse.y += impulse.y;

	    vA.subMul(mA, impulse);
	    wA -= iA * Vec2_1.cross(this.m_rA, impulse);

	    vB.addMul(mB, impulse);
	    wB += iB * Vec2_1.cross(this.m_rB, impulse);
	  }

	  this.m_bodyA.c_velocity.v = vA;
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v = vB;
	  this.m_bodyB.c_velocity.w = wB;
	};

	RevoluteJoint.prototype.solvePositionConstraints = function(step) {
	  var cA = this.m_bodyA.c_position.c;
	  var aA = this.m_bodyA.c_position.a;
	  var cB = this.m_bodyB.c_position.c;
	  var aB = this.m_bodyB.c_position.a;

	  var qA = Rot_1.neo(aA);
	  var qB = Rot_1.neo(aB);

	  var angularError = 0.0; // float
	  var positionError = 0.0; // float

	  var fixedRotation = (this.m_invIA + this.m_invIB == 0.0); // bool

	  // Solve angular limit constraint.
	  if (this.m_enableLimit && this.m_limitState != inactiveLimit
	      && fixedRotation == false) {
	    var angle = aB - aA - this.m_referenceAngle; // float
	    var limitImpulse = 0.0; // float

	    if (this.m_limitState == equalLimits) {
	      // Prevent large angular corrections
	      var C = _Math.clamp(angle - this.m_lowerAngle,
	          -Settings_1.maxAngularCorrection, Settings_1.maxAngularCorrection); // float
	      limitImpulse = -this.m_motorMass * C;
	      angularError = _Math.abs(C);

	    } else if (this.m_limitState == atLowerLimit) {
	      var C = angle - this.m_lowerAngle; // float
	      angularError = -C;

	      // Prevent large angular corrections and allow some slop.
	      C = _Math.clamp(C + Settings_1.angularSlop, -Settings_1.maxAngularCorrection,
	          0.0);
	      limitImpulse = -this.m_motorMass * C;

	    } else if (this.m_limitState == atUpperLimit) {
	      var C = angle - this.m_upperAngle; // float
	      angularError = C;

	      // Prevent large angular corrections and allow some slop.
	      C = _Math.clamp(C - Settings_1.angularSlop, 0.0,
	          Settings_1.maxAngularCorrection);
	      limitImpulse = -this.m_motorMass * C;
	    }

	    aA -= this.m_invIA * limitImpulse;
	    aB += this.m_invIB * limitImpulse;
	  }

	  // Solve point-to-point constraint.
	  {
	    qA.set(aA);
	    qB.set(aB);
	    var rA = Rot_1.mulVec2(qA, Vec2_1.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2
	    var rB = Rot_1.mulVec2(qB, Vec2_1.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2

	    var C = Vec2_1.zero();
	    C.addCombine(1, cB, 1, rB);
	    C.subCombine(1, cA, 1, rA);
	    positionError = C.length();

	    var mA = this.m_invMassA;
	    var mB = this.m_invMassB; // float
	    var iA = this.m_invIA;
	    var iB = this.m_invIB; // float

	    var K = new Mat22_1();
	    K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
	    K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
	    K.ey.x = K.ex.y;
	    K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;

	    var impulse = Vec2_1.neg(K.solve(C)); // Vec2

	    cA.subMul(mA, impulse);
	    aA -= iA * Vec2_1.cross(rA, impulse);

	    cB.addMul(mB, impulse);
	    aB += iB * Vec2_1.cross(rB, impulse);
	  }

	  this.m_bodyA.c_position.c.set(cA);
	  this.m_bodyA.c_position.a = aA;
	  this.m_bodyB.c_position.c.set(cB);
	  this.m_bodyB.c_position.a = aB;

	  return positionError <= Settings_1.linearSlop
	      && angularError <= Settings_1.angularSlop;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$E = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$E = typeof ASSERT === 'undefined' ? false : ASSERT;

	var PrismaticJoint_1 = PrismaticJoint;




















	var inactiveLimit$1 = 0;
	var atLowerLimit$1 = 1;
	var atUpperLimit$1 = 2;
	var equalLimits$1 = 3;

	PrismaticJoint.TYPE = 'prismatic-joint';
	Joint_1.TYPES[PrismaticJoint.TYPE] = PrismaticJoint;

	PrismaticJoint._super = Joint_1;
	PrismaticJoint.prototype = create(PrismaticJoint._super.prototype);

	/**
	 * @typedef {Object} PrismaticJointDef
	 *
	 * Prismatic joint definition. This requires defining a line of motion using an
	 * axis and an anchor point. The definition uses local anchor points and a local
	 * axis so that the initial configuration can violate the constraint slightly.
	 * The joint translation is zero when the local anchor points coincide in world
	 * space. Using local anchors and a local axis helps when saving and loading a
	 * game.
	 * 
	 * @prop {boolean} enableLimit Enable/disable the joint limit.
	 * @prop {float} lowerTranslation The lower translation limit, usually in
	 *       meters.
	 * @prop {float} upperTranslation The upper translation limit, usually in
	 *       meters.
	 * @prop {boolean} enableMotor Enable/disable the joint motor.
	 * @prop {float} maxMotorForce The maximum motor torque, usually in N-m.
	 * @prop {float} motorSpeed The desired motor speed in radians per second.
	 *
	 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
	 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
	 * @prop {Vec2} localAxisA The local translation unit axis in bodyA.
	 * @prop {float} referenceAngle The constrained angle between the bodies:
	 *       bodyB_angle - bodyA_angle.
	 */

	var DEFAULTS$3 = {
	  enableLimit : false,
	  lowerTranslation : 0.0,
	  upperTranslation : 0.0,
	  enableMotor : false,
	  maxMotorForce : 0.0,
	  motorSpeed : 0.0
	};

	/**
	 * A prismatic joint. This joint provides one degree of freedom: translation
	 * along an axis fixed in bodyA. Relative rotation is prevented. You can use a
	 * joint limit to restrict the range of motion and a joint motor to drive the
	 * motion or to model joint friction.
	 *
	 * @param {PrismaticJointDef} def
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 */
	function PrismaticJoint(def, bodyA, bodyB, anchor, axis) {
	  if (!(this instanceof PrismaticJoint)) {
	    return new PrismaticJoint(def, bodyA, bodyB, anchor, axis);
	  }

	  def = options(def, DEFAULTS$3);
	  Joint_1.call(this, def, bodyA, bodyB);
	  bodyA = this.m_bodyA;
	  bodyB = this.m_bodyB;

	  this.m_type = PrismaticJoint.TYPE;

	  this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2_1.zero();
	  this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2_1.zero();
	  this.m_localXAxisA = axis ? bodyA.getLocalVector(axis) : def.localAxisA || Vec2_1.neo(1.0, 0.0);
	  this.m_localXAxisA.normalize();
	  this.m_localYAxisA = Vec2_1.cross(1.0, this.m_localXAxisA);
	  this.m_referenceAngle = _Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();

	  this.m_impulse = Vec3_1();
	  this.m_motorMass = 0.0;
	  this.m_motorImpulse = 0.0;

	  this.m_lowerTranslation = def.lowerTranslation;
	  this.m_upperTranslation = def.upperTranslation;
	  this.m_maxMotorForce = def.maxMotorForce;
	  this.m_motorSpeed = def.motorSpeed;
	  this.m_enableLimit = def.enableLimit;
	  this.m_enableMotor = def.enableMotor;
	  this.m_limitState = inactiveLimit$1;

	  this.m_axis = Vec2_1.zero();
	  this.m_perp = Vec2_1.zero();

	  // Solver temp
	  this.m_localCenterA; // Vec2
	  this.m_localCenterB; // Vec2
	  this.m_invMassA; // float
	  this.m_invMassB; // float
	  this.m_invIA; // float
	  this.m_invIB; // float
	  this.m_axis, this.m_perp; // Vec2
	  this.m_s1, this.m_s2; // float
	  this.m_a1, this.m_a2; // float
	  this.m_K = new Mat33_1();
	  this.m_motorMass; // float

	  // Linear constraint (point-to-line)
	  // d = p2 - p1 = x2 + r2 - x1 - r1
	  // C = dot(perp, d)
	  // Cdot = dot(d, cross(w1, perp)) + dot(perp, v2 + cross(w2, r2) - v1 -
	  // cross(w1, r1))
	  // = -dot(perp, v1) - dot(cross(d + r1, perp), w1) + dot(perp, v2) +
	  // dot(cross(r2, perp), v2)
	  // J = [-perp, -cross(d + r1, perp), perp, cross(r2,perp)]
	  //
	  // Angular constraint
	  // C = a2 - a1 + a_initial
	  // Cdot = w2 - w1
	  // J = [0 0 -1 0 0 1]
	  //
	  // K = J * invM * JT
	  //
	  // J = [-a -s1 a s2]
	  // [0 -1 0 1]
	  // a = perp
	  // s1 = cross(d + r1, a) = cross(p2 - x1, a)
	  // s2 = cross(r2, a) = cross(p2 - x2, a)

	  // Motor/Limit linear constraint
	  // C = dot(ax1, d)
	  // Cdot = = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) +
	  // dot(cross(r2, ax1), v2)
	  // J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]

	  // Block Solver
	  // We develop a block solver that includes the joint limit. This makes the
	  // limit stiff (inelastic) even
	  // when the mass has poor distribution (leading to large torques about the
	  // joint anchor points).
	  //
	  // The Jacobian has 3 rows:
	  // J = [-uT -s1 uT s2] // linear
	  // [0 -1 0 1] // angular
	  // [-vT -a1 vT a2] // limit
	  //
	  // u = perp
	  // v = axis
	  // s1 = cross(d + r1, u), s2 = cross(r2, u)
	  // a1 = cross(d + r1, v), a2 = cross(r2, v)

	  // M * (v2 - v1) = JT * df
	  // J * v2 = bias
	  //
	  // v2 = v1 + invM * JT * df
	  // J * (v1 + invM * JT * df) = bias
	  // K * df = bias - J * v1 = -Cdot
	  // K = J * invM * JT
	  // Cdot = J * v1 - bias
	  //
	  // Now solve for f2.
	  // df = f2 - f1
	  // K * (f2 - f1) = -Cdot
	  // f2 = invK * (-Cdot) + f1
	  //
	  // Clamp accumulated limit impulse.
	  // lower: f2(3) = max(f2(3), 0)
	  // upper: f2(3) = min(f2(3), 0)
	  //
	  // Solve for correct f2(1:2)
	  // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:3) * f1
	  // = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:2) * f1(1:2) + K(1:2,3) * f1(3)
	  // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3)) +
	  // K(1:2,1:2) * f1(1:2)
	  // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +
	  // f1(1:2)
	  //
	  // Now compute impulse to be applied:
	  // df = f2 - f1
	}

	PrismaticJoint.prototype._serialize = function() {
	  return {
	    type: this.m_type,
	    bodyA: this.m_bodyA,
	    bodyB: this.m_bodyB,
	    collideConnected: this.m_collideConnected,

	    lowerTranslation: this.m_lowerTranslation,
	    upperTranslation: this.m_upperTranslation,
	    maxMotorForce: this.m_maxMotorForce,
	    motorSpeed: this.m_motorSpeed,
	    enableLimit: this.m_enableLimit,
	    enableMotor: this.m_enableMotor,

	    localAnchorA: this.m_localAnchorA,
	    localAnchorB: this.m_localAnchorB,
	    localAxisA: this.m_localXAxisA,
	    referenceAngle: this.m_referenceAngle,
	  };
	};

	PrismaticJoint._deserialize = function(data, world, restore) {
	  data.bodyA = restore(Body_1, data.bodyA, world);
	  data.bodyB = restore(Body_1, data.bodyB, world);
	  data.localAxisA = Vec2_1(data.localAxisA);
	  var joint = new PrismaticJoint(data);
	  return joint;
	};

	/**
	 * The local anchor point relative to bodyA's origin.
	 */
	PrismaticJoint.prototype.getLocalAnchorA = function() {
	  return this.m_localAnchorA;
	};

	/**
	 * The local anchor point relative to bodyB's origin.
	 */
	PrismaticJoint.prototype.getLocalAnchorB = function() {
	  return this.m_localAnchorB;
	};

	/**
	 * The local joint axis relative to bodyA.
	 */
	PrismaticJoint.prototype.getLocalAxisA = function() {
	  return this.m_localXAxisA;
	};

	/**
	 * Get the reference angle.
	 */
	PrismaticJoint.prototype.getReferenceAngle = function() {
	  return this.m_referenceAngle;
	};

	/**
	 * Get the current joint translation, usually in meters.
	 */
	PrismaticJoint.prototype.getJointTranslation = function() {
	  var pA = this.m_bodyA.getWorldPoint(this.m_localAnchorA);
	  var pB = this.m_bodyB.getWorldPoint(this.m_localAnchorB);
	  var d = Vec2_1.sub(pB, pA);
	  var axis = this.m_bodyA.getWorldVector(this.m_localXAxisA);

	  var translation = Vec2_1.dot(d, axis);
	  return translation;
	};

	/**
	 * Get the current joint translation speed, usually in meters per second.
	 */
	PrismaticJoint.prototype.getJointSpeed = function() {
	  var bA = this.m_bodyA;
	  var bB = this.m_bodyB;

	  var rA = Rot_1.mulVec2(bA.m_xf.q, Vec2_1.sub(this.m_localAnchorA, bA.m_sweep.localCenter)); // Vec2
	  var rB = Rot_1.mulVec2(bB.m_xf.q, Vec2_1.sub(this.m_localAnchorB, bB.m_sweep.localCenter)); // Vec2
	  var p1 = Vec2_1.add(bA.m_sweep.c, rA); // Vec2
	  var p2 = Vec2_1.add(bB.m_sweep.c, rB); // Vec2
	  var d = Vec2_1.sub(p2, p1); // Vec2
	  var axis = Rot_1.mulVec2(bA.m_xf.q, this.m_localXAxisA); // Vec2

	  var vA = bA.m_linearVelocity; // Vec2
	  var vB = bB.m_linearVelocity; // Vec2
	  var wA = bA.m_angularVelocity; // float
	  var wB = bB.m_angularVelocity; // float

	  var speed = Vec2_1.dot(d, Vec2_1.cross(wA, axis))
	      + Vec2_1.dot(axis, Vec2_1.sub(Vec2_1.addCross(vB, wB, rB), Vec2_1.addCross(vA, wA, rA))); // float
	  return speed;
	};

	/**
	 * Is the joint limit enabled?
	 */
	PrismaticJoint.prototype.isLimitEnabled = function() {
	  return this.m_enableLimit;
	};

	/**
	 * Enable/disable the joint limit.
	 */
	PrismaticJoint.prototype.enableLimit = function(flag) {
	  if (flag != this.m_enableLimit) {
	    this.m_bodyA.setAwake(true);
	    this.m_bodyB.setAwake(true);
	    this.m_enableLimit = flag;
	    this.m_impulse.z = 0.0;
	  }
	};

	/**
	 * Get the lower joint limit, usually in meters.
	 */
	PrismaticJoint.prototype.getLowerLimit = function() {
	  return this.m_lowerTranslation;
	};

	/**
	 * Get the upper joint limit, usually in meters.
	 */
	PrismaticJoint.prototype.getUpperLimit = function() {
	  return this.m_upperTranslation;
	};

	/**
	 * Set the joint limits, usually in meters.
	 */
	PrismaticJoint.prototype.setLimits = function(lower, upper) {
	  _ASSERT$E && common.assert(lower <= upper);
	  if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {
	    this.m_bodyA.setAwake(true);
	    this.m_bodyB.setAwake(true);
	    this.m_lowerTranslation = lower;
	    this.m_upperTranslation = upper;
	    this.m_impulse.z = 0.0;
	  }
	};

	/**
	 * Is the joint motor enabled?
	 */
	PrismaticJoint.prototype.isMotorEnabled = function() {
	  return this.m_enableMotor;
	};

	/**
	 * Enable/disable the joint motor.
	 */
	PrismaticJoint.prototype.enableMotor = function(flag) {
	  this.m_bodyA.setAwake(true);
	  this.m_bodyB.setAwake(true);
	  this.m_enableMotor = flag;
	};

	/**
	 * Set the motor speed, usually in meters per second.
	 */
	PrismaticJoint.prototype.setMotorSpeed = function(speed) {
	  this.m_bodyA.setAwake(true);
	  this.m_bodyB.setAwake(true);
	  this.m_motorSpeed = speed;
	};

	/**
	 * Set the maximum motor force, usually in N.
	 */
	PrismaticJoint.prototype.setMaxMotorForce = function(force) {
	  this.m_bodyA.setAwake(true);
	  this.m_bodyB.setAwake(true);
	  this.m_maxMotorForce = force;
	};

	/**
	 * Get the motor speed, usually in meters per second.
	 */
	PrismaticJoint.prototype.getMotorSpeed = function() {
	  return this.m_motorSpeed;
	};

	/**
	 * Get the current motor force given the inverse time step, usually in N.
	 */
	PrismaticJoint.prototype.getMotorForce = function(inv_dt) {
	  return inv_dt * this.m_motorImpulse;
	};

	PrismaticJoint.prototype.getAnchorA = function() {
	  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
	};

	PrismaticJoint.prototype.getAnchorB = function() {
	  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
	};

	PrismaticJoint.prototype.getReactionForce = function(inv_dt) {
	  return Vec2_1.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis).mul(inv_dt);
	};

	PrismaticJoint.prototype.getReactionTorque = function(inv_dt) {
	  return inv_dt * this.m_impulse.y;
	};

	PrismaticJoint.prototype.initVelocityConstraints = function(step) {
	  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
	  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
	  this.m_invMassA = this.m_bodyA.m_invMass;
	  this.m_invMassB = this.m_bodyB.m_invMass;
	  this.m_invIA = this.m_bodyA.m_invI;
	  this.m_invIB = this.m_bodyB.m_invI;

	  var cA = this.m_bodyA.c_position.c;
	  var aA = this.m_bodyA.c_position.a;
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;

	  var cB = this.m_bodyB.c_position.c;
	  var aB = this.m_bodyB.c_position.a;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  var qA = Rot_1.neo(aA);
	  var qB = Rot_1.neo(aB);

	  // Compute the effective masses.
	  var rA = Rot_1.mulVec2(qA, Vec2_1.sub(this.m_localAnchorA, this.m_localCenterA));
	  var rB = Rot_1.mulVec2(qB, Vec2_1.sub(this.m_localAnchorB, this.m_localCenterB));
	  var d = Vec2_1.zero();
	  d.addCombine(1, cB, 1, rB);
	  d.subCombine(1, cA, 1, rA);

	  var mA = this.m_invMassA, mB = this.m_invMassB;
	  var iA = this.m_invIA, iB = this.m_invIB;

	  // Compute motor Jacobian and effective mass.
	  {
	    this.m_axis = Rot_1.mulVec2(qA, this.m_localXAxisA);
	    this.m_a1 = Vec2_1.cross(Vec2_1.add(d, rA), this.m_axis);
	    this.m_a2 = Vec2_1.cross(rB, this.m_axis);

	    this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2
	        * this.m_a2;
	    if (this.m_motorMass > 0.0) {
	      this.m_motorMass = 1.0 / this.m_motorMass;
	    }
	  }

	  // Prismatic constraint.
	  {
	    this.m_perp = Rot_1.mulVec2(qA, this.m_localYAxisA);

	    this.m_s1 = Vec2_1.cross(Vec2_1.add(d, rA), this.m_perp);
	    this.m_s2 = Vec2_1.cross(rB, this.m_perp);

	    var s1test = Vec2_1.cross(rA, this.m_perp);

	    var k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;
	    var k12 = iA * this.m_s1 + iB * this.m_s2;
	    var k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;
	    var k22 = iA + iB;
	    if (k22 == 0.0) {
	      // For bodies with fixed rotation.
	      k22 = 1.0;
	    }
	    var k23 = iA * this.m_a1 + iB * this.m_a2;
	    var k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;

	    this.m_K.ex.set(k11, k12, k13);
	    this.m_K.ey.set(k12, k22, k23);
	    this.m_K.ez.set(k13, k23, k33);
	  }

	  // Compute motor and limit terms.
	  if (this.m_enableLimit) {

	    var jointTranslation = Vec2_1.dot(this.m_axis, d); // float
	    if (_Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * Settings_1.linearSlop) {
	      this.m_limitState = equalLimits$1;

	    } else if (jointTranslation <= this.m_lowerTranslation) {
	      if (this.m_limitState != atLowerLimit$1) {
	        this.m_limitState = atLowerLimit$1;
	        this.m_impulse.z = 0.0;
	      }

	    } else if (jointTranslation >= this.m_upperTranslation) {
	      if (this.m_limitState != atUpperLimit$1) {
	        this.m_limitState = atUpperLimit$1;
	        this.m_impulse.z = 0.0;
	      }

	    } else {
	      this.m_limitState = inactiveLimit$1;
	      this.m_impulse.z = 0.0;
	    }

	  } else {
	    this.m_limitState = inactiveLimit$1;
	    this.m_impulse.z = 0.0;
	  }

	  if (this.m_enableMotor == false) {
	    this.m_motorImpulse = 0.0;
	  }

	  if (step.warmStarting) {
	    // Account for variable time step.
	    this.m_impulse.mul(step.dtRatio);
	    this.m_motorImpulse *= step.dtRatio;

	    var P = Vec2_1.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse
	        + this.m_impulse.z, this.m_axis);
	    var LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y
	        + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
	    var LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y
	        + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;

	    vA.subMul(mA, P);
	    wA -= iA * LA;

	    vB.addMul(mB, P);
	    wB += iB * LB;
	  } else {
	    this.m_impulse.setZero();
	    this.m_motorImpulse = 0.0;
	  }

	  this.m_bodyA.c_velocity.v.set(vA);
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v.set(vB);
	  this.m_bodyB.c_velocity.w = wB;
	};

	PrismaticJoint.prototype.solveVelocityConstraints = function(step) {
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  var mA = this.m_invMassA;
	  var mB = this.m_invMassB;
	  var iA = this.m_invIA;
	  var iB = this.m_invIB;

	  // Solve linear motor constraint.
	  if (this.m_enableMotor && this.m_limitState != equalLimits$1) {
	    var Cdot = Vec2_1.dot(this.m_axis, Vec2_1.sub(vB, vA)) + this.m_a2 * wB
	        - this.m_a1 * wA;
	    var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
	    var oldImpulse = this.m_motorImpulse;
	    var maxImpulse = step.dt * this.m_maxMotorForce;
	    this.m_motorImpulse = _Math.clamp(this.m_motorImpulse + impulse,
	        -maxImpulse, maxImpulse);
	    impulse = this.m_motorImpulse - oldImpulse;

	    var P = Vec2_1.mul(impulse, this.m_axis);
	    var LA = impulse * this.m_a1;
	    var LB = impulse * this.m_a2;

	    vA.subMul(mA, P);
	    wA -= iA * LA;

	    vB.addMul(mB, P);
	    wB += iB * LB;
	  }

	  var Cdot1 = Vec2_1.zero();
	  Cdot1.x += Vec2_1.dot(this.m_perp, vB) + this.m_s2 * wB;
	  Cdot1.x -= Vec2_1.dot(this.m_perp, vA) + this.m_s1 * wA;
	  Cdot1.y = wB - wA;

	  if (this.m_enableLimit && this.m_limitState != inactiveLimit$1) {
	    // Solve prismatic and limit constraint in block form.
	    var Cdot2 = 0;
	    Cdot2 += Vec2_1.dot(this.m_axis, vB) + this.m_a2 * wB;
	    Cdot2 -= Vec2_1.dot(this.m_axis, vA) + this.m_a1 * wA;

	    var Cdot = Vec3_1(Cdot1.x, Cdot1.y, Cdot2);

	    var f1 = Vec3_1(this.m_impulse);
	    var df = this.m_K.solve33(Vec3_1.neg(Cdot)); // Vec3
	    this.m_impulse.add(df);

	    if (this.m_limitState == atLowerLimit$1) {
	      this.m_impulse.z = _Math.max(this.m_impulse.z, 0.0);
	    } else if (this.m_limitState == atUpperLimit$1) {
	      this.m_impulse.z = _Math.min(this.m_impulse.z, 0.0);
	    }

	    // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +
	    // f1(1:2)
	    var b = Vec2_1.combine(-1, Cdot1, -(this.m_impulse.z - f1.z), Vec2_1.neo(this.m_K.ez.x, this.m_K.ez.y)); // Vec2
	    var f2r = Vec2_1.add(this.m_K.solve22(b), Vec2_1.neo(f1.x, f1.y)); // Vec2
	    this.m_impulse.x = f2r.x;
	    this.m_impulse.y = f2r.y;

	    df = Vec3_1.sub(this.m_impulse, f1);

	    var P = Vec2_1.combine(df.x, this.m_perp, df.z, this.m_axis); // Vec2
	    var LA = df.x * this.m_s1 + df.y + df.z * this.m_a1; // float
	    var LB = df.x * this.m_s2 + df.y + df.z * this.m_a2; // float

	    vA.subMul(mA, P);
	    wA -= iA * LA;

	    vB.addMul(mB, P);
	    wB += iB * LB;
	  } else {
	    // Limit is inactive, just solve the prismatic constraint in block form.
	    var df = this.m_K.solve22(Vec2_1.neg(Cdot1)); // Vec2
	    this.m_impulse.x += df.x;
	    this.m_impulse.y += df.y;

	    var P = Vec2_1.mul(df.x, this.m_perp); // Vec2
	    var LA = df.x * this.m_s1 + df.y; // float
	    var LB = df.x * this.m_s2 + df.y; // float

	    vA.subMul(mA, P);
	    wA -= iA * LA;

	    vB.addMul(mB, P);
	    wB += iB * LB;
	  }

	  this.m_bodyA.c_velocity.v = vA;
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v = vB;
	  this.m_bodyB.c_velocity.w = wB;
	};

	PrismaticJoint.prototype.solvePositionConstraints = function(step) {
	  var cA = this.m_bodyA.c_position.c;
	  var aA = this.m_bodyA.c_position.a;
	  var cB = this.m_bodyB.c_position.c;
	  var aB = this.m_bodyB.c_position.a;

	  var qA = Rot_1.neo(aA);
	  var qB = Rot_1.neo(aB);

	  var mA = this.m_invMassA;
	  var mB = this.m_invMassB;
	  var iA = this.m_invIA;
	  var iB = this.m_invIB;

	  // Compute fresh Jacobians
	  var rA = Rot_1.mulVec2(qA, Vec2_1.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2
	  var rB = Rot_1.mulVec2(qB, Vec2_1.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2
	  var d = Vec2_1.sub(Vec2_1.add(cB, rB), Vec2_1.add(cA, rA)); // Vec2

	  var axis = Rot_1.mulVec2(qA, this.m_localXAxisA); // Vec2
	  var a1 = Vec2_1.cross(Vec2_1.add(d, rA), axis); // float
	  var a2 = Vec2_1.cross(rB, axis); // float
	  var perp = Rot_1.mulVec2(qA, this.m_localYAxisA); // Vec2

	  var s1 = Vec2_1.cross(Vec2_1.add(d, rA), perp); // float
	  var s2 = Vec2_1.cross(rB, perp); // float

	  var impulse = Vec3_1();
	  var C1 = Vec2_1.zero(); // Vec2
	  C1.x = Vec2_1.dot(perp, d);
	  C1.y = aB - aA - this.m_referenceAngle;

	  var linearError = _Math.abs(C1.x); // float
	  var angularError = _Math.abs(C1.y); // float

	  var linearSlop = Settings_1.linearSlop;
	  var maxLinearCorrection = Settings_1.maxLinearCorrection;

	  var active = false; // bool
	  var C2 = 0.0; // float
	  if (this.m_enableLimit) {

	    var translation = Vec2_1.dot(axis, d); // float
	    if (_Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * linearSlop) {
	      // Prevent large angular corrections
	      C2 = _Math.clamp(translation, -maxLinearCorrection, maxLinearCorrection);
	      linearError = _Math.max(linearError, _Math.abs(translation));
	      active = true;

	    } else if (translation <= this.m_lowerTranslation) {
	      // Prevent large linear corrections and allow some slop.
	      C2 = _Math.clamp(translation - this.m_lowerTranslation + linearSlop,
	          -maxLinearCorrection, 0.0);
	      linearError = _Math
	          .max(linearError, this.m_lowerTranslation - translation);
	      active = true;

	    } else if (translation >= this.m_upperTranslation) {
	      // Prevent large linear corrections and allow some slop.
	      C2 = _Math.clamp(translation - this.m_upperTranslation - linearSlop, 0.0,
	          maxLinearCorrection);
	      linearError = _Math
	          .max(linearError, translation - this.m_upperTranslation);
	      active = true;
	    }
	  }

	  if (active) {
	    var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float
	    var k12 = iA * s1 + iB * s2; // float
	    var k13 = iA * s1 * a1 + iB * s2 * a2; // float
	    var k22 = iA + iB; // float
	    if (k22 == 0.0) {
	      // For fixed rotation
	      k22 = 1.0;
	    }
	    var k23 = iA * a1 + iB * a2; // float
	    var k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2; // float

	    var K = new Mat33_1();
	    K.ex.set(k11, k12, k13);
	    K.ey.set(k12, k22, k23);
	    K.ez.set(k13, k23, k33);

	    var C = Vec3_1();
	    C.x = C1.x;
	    C.y = C1.y;
	    C.z = C2;

	    impulse = K.solve33(Vec3_1.neg(C));
	  } else {
	    var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float
	    var k12 = iA * s1 + iB * s2; // float
	    var k22 = iA + iB; // float
	    if (k22 == 0.0) {
	      k22 = 1.0;
	    }

	    var K = new Mat22_1();
	    K.ex.set(k11, k12);
	    K.ey.set(k12, k22);

	    var impulse1 = K.solve(Vec2_1.neg(C1)); // Vec2
	    impulse.x = impulse1.x;
	    impulse.y = impulse1.y;
	    impulse.z = 0.0;
	  }

	  var P = Vec2_1.combine(impulse.x, perp, impulse.z, axis); // Vec2
	  var LA = impulse.x * s1 + impulse.y + impulse.z * a1; // float
	  var LB = impulse.x * s2 + impulse.y + impulse.z * a2; // float

	  cA.subMul(mA, P);
	  aA -= iA * LA;
	  cB.addMul(mB, P);
	  aB += iB * LB;

	  this.m_bodyA.c_position.c = cA;
	  this.m_bodyA.c_position.a = aA;
	  this.m_bodyB.c_position.c = cB;
	  this.m_bodyB.c_position.a = aB;

	  return linearError <= Settings_1.linearSlop
	      && angularError <= Settings_1.angularSlop;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$F = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$F = typeof ASSERT === 'undefined' ? false : ASSERT;

	var GearJoint_1 = GearJoint;























	GearJoint.TYPE = 'gear-joint';
	Joint_1.TYPES[GearJoint.TYPE] = GearJoint;

	GearJoint._super = Joint_1;
	GearJoint.prototype = create(GearJoint._super.prototype);

	/**
	 * @typedef {Object} GearJointDef
	 *
	 * Gear joint definition.
	 *
	 * @prop {float} ratio The gear ratio. See GearJoint for explanation.
	 *
	 * @prop {RevoluteJoint|PrismaticJoint} joint1 The first revolute/prismatic
	 *          joint attached to the gear joint.
	 * @prop {PrismaticJoint|RevoluteJoint} joint2 The second prismatic/revolute
	 *          joint attached to the gear joint.
	 */

	var DEFAULTS$4 = {
	  ratio : 1.0
	};

	/**
	 * A gear joint is used to connect two joints together. Either joint can be a
	 * revolute or prismatic joint. You specify a gear ratio to bind the motions
	 * together: coordinate1 + ratio * coordinate2 = constant
	 * 
	 * The ratio can be negative or positive. If one joint is a revolute joint and
	 * the other joint is a prismatic joint, then the ratio will have units of
	 * length or units of 1/length. Warning: You have to manually destroy the gear
	 * joint if joint1 or joint2 is destroyed.
	 * 
	 * This definition requires two existing revolute or prismatic joints (any
	 * combination will work).
	 *
	 * @param {GearJointDef} def
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 */
	function GearJoint(def, bodyA, bodyB, joint1, joint2, ratio) {
	  if (!(this instanceof GearJoint)) {
	    return new GearJoint(def, bodyA, bodyB, joint1, joint2, ratio);
	  }

	  def = options(def, DEFAULTS$4);
	  Joint_1.call(this, def, bodyA, bodyB);
	  bodyA = this.m_bodyA;
	  bodyB = this.m_bodyB;

	  this.m_type = GearJoint.TYPE;

	  _ASSERT$F && common.assert(joint1.m_type === RevoluteJoint_1.TYPE
	      || joint1.m_type === PrismaticJoint_1.TYPE);
	  _ASSERT$F && common.assert(joint2.m_type === RevoluteJoint_1.TYPE
	      || joint2.m_type === PrismaticJoint_1.TYPE);

	  this.m_joint1 = joint1 ? joint1 : def.joint1;
	  this.m_joint2 = joint2 ? joint2 : def.joint2;
	  this.m_ratio = _Math.isFinite(ratio) ? ratio : def.ratio;

	  this.m_type1 = this.m_joint1.getType();
	  this.m_type2 = this.m_joint2.getType();

	  // joint1 connects body A to body C
	  // joint2 connects body B to body D

	  var coordinateA, coordinateB; // float

	  // TODO_ERIN there might be some problem with the joint edges in Joint.

	  this.m_bodyC = this.m_joint1.getBodyA();
	  this.m_bodyA = this.m_joint1.getBodyB();

	  // Get geometry of joint1
	  var xfA = this.m_bodyA.m_xf;
	  var aA = this.m_bodyA.m_sweep.a;
	  var xfC = this.m_bodyC.m_xf;
	  var aC = this.m_bodyC.m_sweep.a;

	  if (this.m_type1 === RevoluteJoint_1.TYPE) {
	    var revolute = this.m_joint1;// RevoluteJoint
	    this.m_localAnchorC = revolute.m_localAnchorA;
	    this.m_localAnchorA = revolute.m_localAnchorB;
	    this.m_referenceAngleA = revolute.m_referenceAngle;
	    this.m_localAxisC = Vec2_1.zero();

	    coordinateA = aA - aC - this.m_referenceAngleA;
	  } else {
	    var prismatic = this.m_joint1; // PrismaticJoint
	    this.m_localAnchorC = prismatic.m_localAnchorA;
	    this.m_localAnchorA = prismatic.m_localAnchorB;
	    this.m_referenceAngleA = prismatic.m_referenceAngle;
	    this.m_localAxisC = prismatic.m_localXAxisA;

	    var pC = this.m_localAnchorC;
	    var pA = Rot_1.mulTVec2(xfC.q, Vec2_1.add(Rot_1.mul(xfA.q, this.m_localAnchorA), Vec2_1.sub(xfA.p, xfC.p)));
	    coordinateA = Vec2_1.dot(pA, this.m_localAxisC) - Vec2_1.dot(pC, this.m_localAxisC);
	  }

	  this.m_bodyD = this.m_joint2.getBodyA();
	  this.m_bodyB = this.m_joint2.getBodyB();

	  // Get geometry of joint2
	  var xfB = this.m_bodyB.m_xf;
	  var aB = this.m_bodyB.m_sweep.a;
	  var xfD = this.m_bodyD.m_xf;
	  var aD = this.m_bodyD.m_sweep.a;

	  if (this.m_type2 === RevoluteJoint_1.TYPE) {
	    var revolute = this.m_joint2; // RevoluteJoint
	    this.m_localAnchorD = revolute.m_localAnchorA;
	    this.m_localAnchorB = revolute.m_localAnchorB;
	    this.m_referenceAngleB = revolute.m_referenceAngle;
	    this.m_localAxisD = Vec2_1.zero();

	    coordinateB = aB - aD - this.m_referenceAngleB;
	  } else {
	    var prismatic = this.m_joint2; // PrismaticJoint
	    this.m_localAnchorD = prismatic.m_localAnchorA;
	    this.m_localAnchorB = prismatic.m_localAnchorB;
	    this.m_referenceAngleB = prismatic.m_referenceAngle;
	    this.m_localAxisD = prismatic.m_localXAxisA;

	    var pD = this.m_localAnchorD;
	    var pB = Rot_1.mulTVec2(xfD.q, Vec2_1.add(Rot_1.mul(xfB.q, this.m_localAnchorB), Vec2_1.sub(xfB.p, xfD.p)));
	    coordinateB = Vec2_1.dot(pB, this.m_localAxisD) - Vec2_1.dot(pD, this.m_localAxisD);
	  }

	  this.m_constant = coordinateA + this.m_ratio * coordinateB;

	  this.m_impulse = 0.0;

	  // Solver temp
	  this.m_lcA, this.m_lcB, this.m_lcC, this.m_lcD; // Vec2
	  this.m_mA, this.m_mB, this.m_mC, this.m_mD; // float
	  this.m_iA, this.m_iB, this.m_iC, this.m_iD; // float
	  this.m_JvAC, this.m_JvBD; // Vec2
	  this.m_JwA, this.m_JwB, this.m_JwC, this.m_JwD; // float
	  this.m_mass; // float

	  // Gear Joint:
	  // C0 = (coordinate1 + ratio * coordinate2)_initial
	  // C = (coordinate1 + ratio * coordinate2) - C0 = 0
	  // J = [J1 ratio * J2]
	  // K = J * invM * JT
	  // = J1 * invM1 * J1T + ratio * ratio * J2 * invM2 * J2T
	  //
	  // Revolute:
	  // coordinate = rotation
	  // Cdot = angularVelocity
	  // J = [0 0 1]
	  // K = J * invM * JT = invI
	  //
	  // Prismatic:
	  // coordinate = dot(p - pg, ug)
	  // Cdot = dot(v + cross(w, r), ug)
	  // J = [ug cross(r, ug)]
	  // K = J * invM * JT = invMass + invI * cross(r, ug)^2
	}
	GearJoint.prototype._serialize = function() {
	  return {
	    type: this.m_type,
	    bodyA: this.m_bodyA,
	    bodyB: this.m_bodyB,
	    collideConnected: this.m_collideConnected,

	    joint1: this.m_joint1,
	    joint2: this.m_joint2,
	    ratio: this.m_ratio,

	    _constant: this.m_constant,
	  };
	};

	GearJoint._deserialize = function(data, world, restore) {
	  data.bodyA = restore(Body_1, data.bodyA, world);
	  data.bodyB = restore(Body_1, data.bodyB, world);
	  data.joint1 = restore(Joint_1, data.joint1, world);
	  data.joint2 = restore(Joint_1, data.joint2, world);
	  var joint = new GearJoint(data);
	  if(data._constant) joint.m_constant = data._constant;
	  return joint;
	};

	/**
	 * Get the first joint.
	 */
	GearJoint.prototype.getJoint1 = function() {
	  return this.m_joint1;
	};

	/**
	 * Get the second joint.
	 */
	GearJoint.prototype.getJoint2 = function() {
	  return this.m_joint2;
	};

	/**
	 * Set/Get the gear ratio.
	 */
	GearJoint.prototype.setRatio = function(ratio) {
	  _ASSERT$F && common.assert(_Math.isFinite(ratio));
	  this.m_ratio = ratio;
	};

	GearJoint.prototype.getRatio = function() {
	  return this.m_ratio;
	};

	GearJoint.prototype.getAnchorA = function() {
	  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
	};

	GearJoint.prototype.getAnchorB = function() {
	  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
	};

	GearJoint.prototype.getReactionForce = function(inv_dt) {
	  return Vec2_1.mul(this.m_impulse, this.m_JvAC).mul(inv_dt);
	};

	GearJoint.prototype.getReactionTorque = function(inv_dt) {
	  var L = this.m_impulse * this.m_JwA; // float
	  return inv_dt * L;
	};

	GearJoint.prototype.initVelocityConstraints = function(step) {
	  this.m_lcA = this.m_bodyA.m_sweep.localCenter;
	  this.m_lcB = this.m_bodyB.m_sweep.localCenter;
	  this.m_lcC = this.m_bodyC.m_sweep.localCenter;
	  this.m_lcD = this.m_bodyD.m_sweep.localCenter;
	  this.m_mA = this.m_bodyA.m_invMass;
	  this.m_mB = this.m_bodyB.m_invMass;
	  this.m_mC = this.m_bodyC.m_invMass;
	  this.m_mD = this.m_bodyD.m_invMass;
	  this.m_iA = this.m_bodyA.m_invI;
	  this.m_iB = this.m_bodyB.m_invI;
	  this.m_iC = this.m_bodyC.m_invI;
	  this.m_iD = this.m_bodyD.m_invI;

	  var aA = this.m_bodyA.c_position.a;
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;

	  var aB = this.m_bodyB.c_position.a;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  var aC = this.m_bodyC.c_position.a;
	  var vC = this.m_bodyC.c_velocity.v;
	  var wC = this.m_bodyC.c_velocity.w;

	  var aD = this.m_bodyD.c_position.a;
	  var vD = this.m_bodyD.c_velocity.v;
	  var wD = this.m_bodyD.c_velocity.w;

	  var qA = Rot_1.neo(aA);
	  var qB = Rot_1.neo(aB);
	  var qC = Rot_1.neo(aC);
	  var qD = Rot_1.neo(aD);

	  this.m_mass = 0.0;

	  if (this.m_type1 == RevoluteJoint_1.TYPE) {
	    this.m_JvAC = Vec2_1.zero();
	    this.m_JwA = 1.0;
	    this.m_JwC = 1.0;
	    this.m_mass += this.m_iA + this.m_iC;
	  } else {
	    var u = Rot_1.mulVec2(qC, this.m_localAxisC); // Vec2
	    var rC = Rot_1.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2
	    var rA = Rot_1.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2
	    this.m_JvAC = u;
	    this.m_JwC = Vec2_1.cross(rC, u);
	    this.m_JwA = Vec2_1.cross(rA, u);
	    this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;
	  }

	  if (this.m_type2 == RevoluteJoint_1.TYPE) {
	    this.m_JvBD = Vec2_1.zero();
	    this.m_JwB = this.m_ratio;
	    this.m_JwD = this.m_ratio;
	    this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
	  } else {
	    var u = Rot_1.mulVec2(qD, this.m_localAxisD); // Vec2
	    var rD = Rot_1.mulSub(qD, this.m_localAnchorD, this.m_lcD); // Vec2
	    var rB = Rot_1.mulSub(qB, this.m_localAnchorB, this.m_lcB); // Vec2
	    this.m_JvBD = Vec2_1.mul(this.m_ratio, u);
	    this.m_JwD = this.m_ratio * Vec2_1.cross(rD, u);
	    this.m_JwB = this.m_ratio * Vec2_1.cross(rB, u);
	    this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;
	  }

	  // Compute effective mass.
	  this.m_mass = this.m_mass > 0.0 ? 1.0 / this.m_mass : 0.0;

	  if (step.warmStarting) {
	    vA.addMul(this.m_mA * this.m_impulse, this.m_JvAC);
	    wA += this.m_iA * this.m_impulse * this.m_JwA;
	    
	    vB.addMul(this.m_mB * this.m_impulse, this.m_JvBD);
	    wB += this.m_iB * this.m_impulse * this.m_JwB;
	    
	    vC.subMul(this.m_mC * this.m_impulse, this.m_JvAC);
	    wC -= this.m_iC * this.m_impulse * this.m_JwC;
	  
	    vD.subMul(this.m_mD * this.m_impulse, this.m_JvBD);
	    wD -= this.m_iD * this.m_impulse * this.m_JwD;

	  } else {
	    this.m_impulse = 0.0;
	  }

	  this.m_bodyA.c_velocity.v.set(vA);
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v.set(vB);
	  this.m_bodyB.c_velocity.w = wB;
	  this.m_bodyC.c_velocity.v.set(vC);
	  this.m_bodyC.c_velocity.w = wC;
	  this.m_bodyD.c_velocity.v.set(vD);
	  this.m_bodyD.c_velocity.w = wD;
	};

	GearJoint.prototype.solveVelocityConstraints = function(step) {
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;
	  var vC = this.m_bodyC.c_velocity.v;
	  var wC = this.m_bodyC.c_velocity.w;
	  var vD = this.m_bodyD.c_velocity.v;
	  var wD = this.m_bodyD.c_velocity.w;

	  var Cdot = Vec2_1.dot(this.m_JvAC, vA) - Vec2_1.dot(this.m_JvAC, vC)
	      + Vec2_1.dot(this.m_JvBD, vB) - Vec2_1.dot(this.m_JvBD, vD); // float
	  Cdot += (this.m_JwA * wA - this.m_JwC * wC)
	      + (this.m_JwB * wB - this.m_JwD * wD);

	  var impulse = -this.m_mass * Cdot; // float
	  this.m_impulse += impulse;

	  vA.addMul(this.m_mA * impulse, this.m_JvAC);
	  wA += this.m_iA * impulse * this.m_JwA;
	  vB.addMul(this.m_mB * impulse, this.m_JvBD);
	  wB += this.m_iB * impulse * this.m_JwB;
	  vC.subMul(this.m_mC * impulse, this.m_JvAC);
	  wC -= this.m_iC * impulse * this.m_JwC;
	  vD.subMul(this.m_mD * impulse, this.m_JvBD);
	  wD -= this.m_iD * impulse * this.m_JwD;

	  this.m_bodyA.c_velocity.v.set(vA);
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v.set(vB);
	  this.m_bodyB.c_velocity.w = wB;
	  this.m_bodyC.c_velocity.v.set(vC);
	  this.m_bodyC.c_velocity.w = wC;
	  this.m_bodyD.c_velocity.v.set(vD);
	  this.m_bodyD.c_velocity.w = wD;
	};

	GearJoint.prototype.solvePositionConstraints = function(step) {
	  var cA = this.m_bodyA.c_position.c;
	  var aA = this.m_bodyA.c_position.a;
	  var cB = this.m_bodyB.c_position.c;
	  var aB = this.m_bodyB.c_position.a;
	  var cC = this.m_bodyC.c_position.c;
	  var aC = this.m_bodyC.c_position.a;
	  var cD = this.m_bodyD.c_position.c;
	  var aD = this.m_bodyD.c_position.a;

	  var qA = Rot_1.neo(aA);
	  var qB = Rot_1.neo(aB);
	  var qC = Rot_1.neo(aC);
	  var qD = Rot_1.neo(aD);

	  var linearError = 0.0; // float

	  var coordinateA, coordinateB; // float

	  var JvAC, JvBD; // Vec2
	  var JwA, JwB, JwC, JwD; // float
	  var mass = 0.0; // float

	  if (this.m_type1 == RevoluteJoint_1.TYPE) {
	    JvAC = Vec2_1.zero();
	    JwA = 1.0;
	    JwC = 1.0;
	    mass += this.m_iA + this.m_iC;

	    coordinateA = aA - aC - this.m_referenceAngleA;
	  } else {
	    var u = Rot_1.mulVec2(qC, this.m_localAxisC); // Vec2
	    var rC = Rot_1.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2
	    var rA = Rot_1.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2
	    JvAC = u;
	    JwC = Vec2_1.cross(rC, u);
	    JwA = Vec2_1.cross(rA, u);
	    mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;

	    var pC = Vec2_1.sub(this.m_localAnchorC, this.m_lcC); // Vec2
	    var pA = Rot_1.mulTVec2(qC, Vec2_1.add(rA, Vec2_1.sub(cA, cC))); // Vec2
	    coordinateA = Vec2_1.dot(Vec2_1.sub(pA, pC), this.m_localAxisC);
	  }

	  if (this.m_type2 == RevoluteJoint_1.TYPE) {
	    JvBD = Vec2_1.zero();
	    JwB = this.m_ratio;
	    JwD = this.m_ratio;
	    mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);

	    coordinateB = aB - aD - this.m_referenceAngleB;
	  } else {
	    var u = Rot_1.mulVec2(qD, this.m_localAxisD);
	    var rD = Rot_1.mulSub(qD, this.m_localAnchorD, this.m_lcD);
	    var rB = Rot_1.mulSub(qB, this.m_localAnchorB, this.m_lcB);
	    JvBD = Vec2_1.mul(this.m_ratio, u);
	    JwD = this.m_ratio * Vec2_1.cross(rD, u);
	    JwB = this.m_ratio * Vec2_1.cross(rB, u);
	    mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD
	        * JwD * JwD + this.m_iB * JwB * JwB;

	    var pD = Vec2_1.sub(this.m_localAnchorD, this.m_lcD); // Vec2
	    var pB = Rot_1.mulTVec2(qD, Vec2_1.add(rB, Vec2_1.sub(cB, cD))); // Vec2
	    coordinateB = Vec2_1.dot(pB, this.m_localAxisD)
	        - Vec2_1.dot(pD, this.m_localAxisD);
	  }

	  var C = (coordinateA + this.m_ratio * coordinateB) - this.m_constant; // float

	  var impulse = 0.0; // float
	  if (mass > 0.0) {
	    impulse = -C / mass;
	  }

	  cA.addMul(this.m_mA * impulse, JvAC);
	  aA += this.m_iA * impulse * JwA;
	  cB.addMul(this.m_mB * impulse, JvBD);
	  aB += this.m_iB * impulse * JwB;
	  cC.subMul(this.m_mC * impulse, JvAC);
	  aC -= this.m_iC * impulse * JwC;
	  cD.subMul(this.m_mD * impulse, JvBD);
	  aD -= this.m_iD * impulse * JwD;

	  this.m_bodyA.c_position.c.set(cA);
	  this.m_bodyA.c_position.a = aA;
	  this.m_bodyB.c_position.c.set(cB);
	  this.m_bodyB.c_position.a = aB;
	  this.m_bodyC.c_position.c.set(cC);
	  this.m_bodyC.c_position.a = aC;
	  this.m_bodyD.c_position.c.set(cD);
	  this.m_bodyD.c_position.a = aD;

	  // TODO_ERIN not implemented
	  return linearError < Settings_1.linearSlop;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$G = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$G = typeof ASSERT === 'undefined' ? false : ASSERT;

	var MotorJoint_1 = MotorJoint;




















	MotorJoint.TYPE = 'motor-joint';
	Joint_1.TYPES[MotorJoint.TYPE] = MotorJoint;

	MotorJoint._super = Joint_1;
	MotorJoint.prototype = create(MotorJoint._super.prototype);

	/**
	 * @typedef {Object} MotorJointDef
	 *
	 * Motor joint definition.
	 * 
	 * @prop {float} angularOffset The bodyB angle minus bodyA angle in radians.
	 * @prop {float} maxForce The maximum motor force in N.
	 * @prop {float} maxTorque The maximum motor torque in N-m.
	 * @prop {float} correctionFactor Position correction factor in the range [0,1].
	 * @prop {Vec2} linearOffset Position of bodyB minus the position of bodyA, in
	 *       bodyA's frame, in meters.
	 */

	var DEFAULTS$5 = {
	  maxForce : 1.0,
	  maxTorque : 1.0,
	  correctionFactor : 0.3
	};

	/**
	 * A motor joint is used to control the relative motion between two bodies. A
	 * typical usage is to control the movement of a dynamic body with respect to
	 * the ground.
	 *
	 * @param {MotorJointDef} def
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 */
	function MotorJoint(def, bodyA, bodyB) {
	  if (!(this instanceof MotorJoint)) {
	    return new MotorJoint(def, bodyA, bodyB);
	  }

	  def = options(def, DEFAULTS$5);
	  Joint_1.call(this, def, bodyA, bodyB);
	  bodyA = this.m_bodyA;
	  bodyB = this.m_bodyB;

	  this.m_type = MotorJoint.TYPE;

	  this.m_linearOffset = def.linearOffset ? def.linearOffset : bodyA.getLocalPoint(bodyB.getPosition());

	  var angleA = bodyA.getAngle();
	  var angleB = bodyB.getAngle();
	  this.m_angularOffset = angleB - angleA;

	  this.m_linearImpulse = Vec2_1.zero();
	  this.m_angularImpulse = 0.0;

	  this.m_maxForce = def.maxForce;
	  this.m_maxTorque = def.maxTorque;
	  this.m_correctionFactor = def.correctionFactor;

	  // Solver temp
	  this.m_rA; // Vec2
	  this.m_rB; // Vec2
	  this.m_localCenterA; // Vec2
	  this.m_localCenterB; // Vec2
	  this.m_linearError; // Vec2
	  this.m_angularError; // float
	  this.m_invMassA; // float
	  this.m_invMassB; // float
	  this.m_invIA; // float
	  this.m_invIB; // float
	  this.m_linearMass; // Mat22
	  this.m_angularMass; // float

	  // Point-to-point constraint
	  // Cdot = v2 - v1
	  // = v2 + cross(w2, r2) - v1 - cross(w1, r1)
	  // J = [-I -r1_skew I r2_skew ]
	  // Identity used:
	  // w k % (rx i + ry j) = w * (-ry i + rx j)

	  // Angle constraint
	  // Cdot = w2 - w1
	  // J = [0 0 -1 0 0 1]
	  // K = invI1 + invI2
	}

	MotorJoint.prototype._serialize = function() {
	  return {
	    type: this.m_type,
	    bodyA: this.m_bodyA,
	    bodyB: this.m_bodyB,
	    collideConnected: this.m_collideConnected,

	    linearOffset: this.m_linearOffset,
	    maxForce: this.m_maxForce,
	    maxTorque: this.m_maxTorque,
	    correctionFactor: this.m_correctionFactor,

	    _angularOffset: this.m_angularOffset,
	  };
	};

	MotorJoint._deserialize = function(data, world, restore) {
	  data.bodyA = restore(Body_1, data.bodyA, world);
	  data.bodyB = restore(Body_1, data.bodyB, world);
	  var joint = new MotorJoint(data);
	  if(data._angularOffset) joint.m_angularOffset = data._angularOffset;
	  return joint;
	};

	/**
	 * Set the maximum friction force in N.
	 */
	MotorJoint.prototype.setMaxForce = function(force) {
	  _ASSERT$G && common.assert(_Math.isFinite(force) && force >= 0.0);
	  this.m_maxForce = force;
	};

	/**
	 * Get the maximum friction force in N.
	 */
	MotorJoint.prototype.getMaxForce = function() {
	  return this.m_maxForce;
	};

	/**
	 * Set the maximum friction torque in N*m.
	 */
	MotorJoint.prototype.setMaxTorque = function(torque) {
	  _ASSERT$G && common.assert(_Math.isFinite(torque) && torque >= 0.0);
	  this.m_maxTorque = torque;
	};

	/**
	 * Get the maximum friction torque in N*m.
	 */
	MotorJoint.prototype.getMaxTorque = function() {
	  return this.m_maxTorque;
	};

	/**
	 * Set the position correction factor in the range [0,1].
	 */
	MotorJoint.prototype.setCorrectionFactor = function(factor) {
	  _ASSERT$G && common.assert(_Math.isFinite(factor) && 0.0 <= factor && factor <= 1.0);
	  this.m_correctionFactor = factor;
	};

	/**
	 * Get the position correction factor in the range [0,1].
	 */
	MotorJoint.prototype.getCorrectionFactor = function() {
	  return this.m_correctionFactor;
	};

	/**
	 * Set/get the target linear offset, in frame A, in meters.
	 */
	MotorJoint.prototype.setLinearOffset = function(linearOffset) {
	  if (linearOffset.x != this.m_linearOffset.x
	      || linearOffset.y != this.m_linearOffset.y) {
	    this.m_bodyA.setAwake(true);
	    this.m_bodyB.setAwake(true);
	    this.m_linearOffset = linearOffset;
	  }
	};

	MotorJoint.prototype.getLinearOffset = function() {
	  return this.m_linearOffset;
	};

	/**
	 * Set/get the target angular offset, in radians.
	 */
	MotorJoint.prototype.setAngularOffset = function(angularOffset) {
	  if (angularOffset != this.m_angularOffset) {
	    this.m_bodyA.setAwake(true);
	    this.m_bodyB.setAwake(true);
	    this.m_angularOffset = angularOffset;
	  }
	};

	MotorJoint.prototype.getAngularOffset = function() {
	  return this.m_angularOffset;
	};

	MotorJoint.prototype.getAnchorA = function() {
	  return this.m_bodyA.getPosition();
	};

	MotorJoint.prototype.getAnchorB = function() {
	  return this.m_bodyB.getPosition();
	};

	MotorJoint.prototype.getReactionForce = function(inv_dt) {
	  return Vec2_1.mul(inv_dt, this.m_linearImpulse);
	};

	MotorJoint.prototype.getReactionTorque = function(inv_dt) {
	  return inv_dt * this.m_angularImpulse;
	};

	MotorJoint.prototype.initVelocityConstraints = function(step) {
	  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
	  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
	  this.m_invMassA = this.m_bodyA.m_invMass;
	  this.m_invMassB = this.m_bodyB.m_invMass;
	  this.m_invIA = this.m_bodyA.m_invI;
	  this.m_invIB = this.m_bodyB.m_invI;

	  var cA = this.m_bodyA.c_position.c;
	  var aA = this.m_bodyA.c_position.a;
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;

	  var cB = this.m_bodyB.c_position.c;
	  var aB = this.m_bodyB.c_position.a;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  var qA = Rot_1.neo(aA), qB = Rot_1.neo(aB);

	  // Compute the effective mass matrix.
	  this.m_rA = Rot_1.mulVec2(qA, Vec2_1.neg(this.m_localCenterA));
	  this.m_rB = Rot_1.mulVec2(qB, Vec2_1.neg(this.m_localCenterB));

	  // J = [-I -r1_skew I r2_skew]
	  // [ 0 -1 0 1]
	  // r_skew = [-ry; rx]

	  // Matlab
	  // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
	  // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
	  // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]

	  var mA = this.m_invMassA;
	  var mB = this.m_invMassB;
	  var iA = this.m_invIA;
	  var iB = this.m_invIB;

	  var K = new Mat22_1();
	  K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y
	      * this.m_rB.y;
	  K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;
	  K.ey.x = K.ex.y;
	  K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x
	      * this.m_rB.x;

	  this.m_linearMass = K.getInverse();

	  this.m_angularMass = iA + iB;
	  if (this.m_angularMass > 0.0) {
	    this.m_angularMass = 1.0 / this.m_angularMass;
	  }

	  this.m_linearError = Vec2_1.zero();
	  this.m_linearError.addCombine(1, cB, 1, this.m_rB);
	  this.m_linearError.subCombine(1, cA, 1, this.m_rA);
	  this.m_linearError.sub(Rot_1.mulVec2(qA, this.m_linearOffset));

	  this.m_angularError = aB - aA - this.m_angularOffset;

	  if (step.warmStarting) {
	    // Scale impulses to support a variable time step.
	    this.m_linearImpulse.mul(step.dtRatio);
	    this.m_angularImpulse *= step.dtRatio;

	    var P = Vec2_1.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);

	    vA.subMul(mA, P);
	    wA -= iA * (Vec2_1.cross(this.m_rA, P) + this.m_angularImpulse);

	    vB.addMul(mB, P);
	    wB += iB * (Vec2_1.cross(this.m_rB, P) + this.m_angularImpulse);

	  } else {
	    this.m_linearImpulse.setZero();
	    this.m_angularImpulse = 0.0;
	  }

	  this.m_bodyA.c_velocity.v = vA;
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v = vB;
	  this.m_bodyB.c_velocity.w = wB;
	};

	MotorJoint.prototype.solveVelocityConstraints = function(step) {
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  var mA = this.m_invMassA, mB = this.m_invMassB;
	  var iA = this.m_invIA, iB = this.m_invIB;

	  var h = step.dt;
	  var inv_h = step.inv_dt;

	  // Solve angular friction
	  {
	    var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;
	    var impulse = -this.m_angularMass * Cdot;

	    var oldImpulse = this.m_angularImpulse;
	    var maxImpulse = h * this.m_maxTorque;
	    this.m_angularImpulse = _Math.clamp(this.m_angularImpulse + impulse,
	        -maxImpulse, maxImpulse);
	    impulse = this.m_angularImpulse - oldImpulse;

	    wA -= iA * impulse;
	    wB += iB * impulse;
	  }

	  // Solve linear friction
	  {
	    var Cdot = Vec2_1.zero();
	    Cdot.addCombine(1, vB, 1, Vec2_1.cross(wB, this.m_rB));
	    Cdot.subCombine(1, vA, 1, Vec2_1.cross(wA, this.m_rA));
	    Cdot.addMul(inv_h * this.m_correctionFactor, this.m_linearError);

	    var impulse = Vec2_1.neg(Mat22_1.mulVec2(this.m_linearMass, Cdot));
	    var oldImpulse = Vec2_1.clone(this.m_linearImpulse);
	    this.m_linearImpulse.add(impulse);

	    var maxImpulse = h * this.m_maxForce;

	    this.m_linearImpulse.clamp(maxImpulse);

	    impulse = Vec2_1.sub(this.m_linearImpulse, oldImpulse);

	    vA.subMul(mA, impulse);
	    wA -= iA * Vec2_1.cross(this.m_rA, impulse);

	    vB.addMul(mB, impulse);
	    wB += iB * Vec2_1.cross(this.m_rB, impulse);
	  }

	  this.m_bodyA.c_velocity.v = vA;
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v = vB;
	  this.m_bodyB.c_velocity.w = wB;
	};

	MotorJoint.prototype.solvePositionConstraints = function(step) {
	  return true;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$H = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$H = typeof ASSERT === 'undefined' ? false : ASSERT;

	var MouseJoint_1 = MouseJoint;



















	MouseJoint.TYPE = 'mouse-joint';
	Joint_1.TYPES[MouseJoint.TYPE] = MouseJoint;

	MouseJoint._super = Joint_1;
	MouseJoint.prototype = create(MouseJoint._super.prototype);

	/**
	 * @typedef {Object} MouseJointDef
	 *
	 * Mouse joint definition. This requires a world target point, tuning
	 * parameters, and the time step.
	 * 
	 * @prop [maxForce = 0.0] The maximum constraint force that can be exerted to
	 *       move the candidate body. Usually you will express as some multiple of
	 *       the weight (multiplier * mass * gravity).
	 * @prop [frequencyHz = 5.0] The response speed.
	 * @prop [dampingRatio = 0.7] The damping ratio. 0 = no damping, 1 = critical
	 *       damping.
	 *
	 * @prop {Vec2} target The initial world target point. This is assumed to
	 *       coincide with the body anchor initially.
	 */

	var DEFAULTS$6 = {
	  maxForce : 0.0,
	  frequencyHz : 5.0,
	  dampingRatio : 0.7
	};

	/**
	 * A mouse joint is used to make a point on a body track a specified world
	 * point. This a soft constraint with a maximum force. This allows the
	 * constraint to stretch and without applying huge forces.
	 * 
	 * NOTE: this joint is not documented in the manual because it was developed to
	 * be used in the testbed. If you want to learn how to use the mouse joint, look
	 * at the testbed.
	 *
	 * @param {MouseJointDef} def
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 */
	function MouseJoint(def, bodyA, bodyB, target) {
	  if (!(this instanceof MouseJoint)) {
	    return new MouseJoint(def, bodyA, bodyB, target);
	  }

	  def = options(def, DEFAULTS$6);
	  Joint_1.call(this, def, bodyA, bodyB);
	  bodyA = this.m_bodyA;
	  bodyB = this.m_bodyB;

	  this.m_type = MouseJoint.TYPE;

	  _ASSERT$H && common.assert(_Math.isFinite(def.maxForce) && def.maxForce >= 0.0);
	  _ASSERT$H && common.assert(_Math.isFinite(def.frequencyHz) && def.frequencyHz >= 0.0);
	  _ASSERT$H && common.assert(_Math.isFinite(def.dampingRatio) && def.dampingRatio >= 0.0);

	  this.m_targetA = target ? Vec2_1.clone(target) : def.target || Vec2_1.zero();
	  this.m_localAnchorB = Transform_1.mulTVec2(bodyB.getTransform(), this.m_targetA);

	  this.m_maxForce = def.maxForce;
	  this.m_impulse = Vec2_1.zero();

	  this.m_frequencyHz = def.frequencyHz;
	  this.m_dampingRatio = def.dampingRatio;

	  this.m_beta = 0.0;
	  this.m_gamma = 0.0;

	  // Solver temp
	  this.m_rB = Vec2_1.zero();
	  this.m_localCenterB = Vec2_1.zero();
	  this.m_invMassB = 0.0;
	  this.m_invIB = 0.0;
	  this.mass = new Mat22_1();
	  this.m_C = Vec2_1.zero();

	  // p = attached point, m = mouse point
	  // C = p - m
	  // Cdot = v
	  // = v + cross(w, r)
	  // J = [I r_skew]
	  // Identity used:
	  // w k % (rx i + ry j) = w * (-ry i + rx j)
	}

	MouseJoint.prototype._serialize = function() {
	  return {
	    type: this.m_type,
	    bodyA: this.m_bodyA,
	    bodyB: this.m_bodyB,
	    collideConnected: this.m_collideConnected,

	    target: this.m_targetA,
	    maxForce: this.m_maxForce,
	    frequencyHz: this.m_frequencyHz,
	    dampingRatio: this.m_dampingRatio,

	    _localAnchorB: this.m_localAnchorB,
	  };
	};

	MouseJoint._deserialize = function(data, world, restore) {
	  data.bodyA = restore(Body_1, data.bodyA, world);
	  data.bodyB = restore(Body_1, data.bodyB, world);
	  data.target = Vec2_1(data.target);
	  var joint = new MouseJoint(data);
	  if(data._localAnchorB) joint.m_localAnchorB = data._localAnchorB;
	  return joint;
	};

	/**
	 * Use this to update the target point.
	 */
	MouseJoint.prototype.setTarget = function(target) {
	  if (this.m_bodyB.isAwake() == false) {
	    this.m_bodyB.setAwake(true);
	  }
	  this.m_targetA = Vec2_1.clone(target);
	};

	MouseJoint.prototype.getTarget = function() {
	  return this.m_targetA;
	};

	/**
	 * Set/get the maximum force in Newtons.
	 */
	MouseJoint.prototype.setMaxForce = function(force) {
	  this.m_maxForce = force;
	};

	MouseJoint.getMaxForce = function() {
	  return this.m_maxForce;
	};

	/**
	 * Set/get the frequency in Hertz.
	 */
	MouseJoint.prototype.setFrequency = function(hz) {
	  this.m_frequencyHz = hz;
	};

	MouseJoint.prototype.getFrequency = function() {
	  return this.m_frequencyHz;
	};

	/**
	 * Set/get the damping ratio (dimensionless).
	 */
	MouseJoint.prototype.setDampingRatio = function(ratio) {
	  this.m_dampingRatio = ratio;
	};

	MouseJoint.prototype.getDampingRatio = function() {
	  return this.m_dampingRatio;
	};

	MouseJoint.prototype.getAnchorA = function() {
	  return Vec2_1.clone(this.m_targetA);
	};

	MouseJoint.prototype.getAnchorB = function() {
	  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
	};

	MouseJoint.prototype.getReactionForce = function(inv_dt) {
	  return Vec2_1.mul(inv_dt, this.m_impulse);
	};

	MouseJoint.prototype.getReactionTorque = function(inv_dt) {
	  return inv_dt * 0.0;
	};

	MouseJoint.prototype.shiftOrigin = function(newOrigin) {
	  this.m_targetA.sub(newOrigin);
	};

	MouseJoint.prototype.initVelocityConstraints = function(step) {
	  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
	  this.m_invMassB = this.m_bodyB.m_invMass;
	  this.m_invIB = this.m_bodyB.m_invI;

	  var position = this.m_bodyB.c_position;
	  var velocity = this.m_bodyB.c_velocity;

	  var cB = position.c;
	  var aB = position.a;
	  var vB = velocity.v;
	  var wB = velocity.w;

	  var qB = Rot_1.neo(aB);

	  var mass = this.m_bodyB.getMass();

	  // Frequency
	  var omega = 2.0 * _Math.PI * this.m_frequencyHz;

	  // Damping coefficient
	  var d = 2.0 * mass * this.m_dampingRatio * omega;

	  // Spring stiffness
	  var k = mass * (omega * omega);

	  // magic formulas
	  // gamma has units of inverse mass.
	  // beta has units of inverse time.
	  var h = step.dt;
	  _ASSERT$H && common.assert(d + h * k > _Math.EPSILON);
	  this.m_gamma = h * (d + h * k);
	  if (this.m_gamma != 0.0) {
	    this.m_gamma = 1.0 / this.m_gamma;
	  }
	  this.m_beta = h * k * this.m_gamma;

	  // Compute the effective mass matrix.
	  this.m_rB = Rot_1.mulVec2(qB, Vec2_1.sub(this.m_localAnchorB, this.m_localCenterB));

	  // K = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) *
	  // invI2 * skew(r2)]
	  // = [1/m1+1/m2 0 ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y
	  // -r1.x*r1.y]
	  // [ 0 1/m1+1/m2] [-r1.x*r1.y r1.x*r1.x] [-r1.x*r1.y r1.x*r1.x]
	  var K = new Mat22_1();
	  K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y
	      + this.m_gamma;
	  K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;
	  K.ey.x = K.ex.y;
	  K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x
	      + this.m_gamma;

	  this.m_mass = K.getInverse();

	  this.m_C.set(cB);
	  this.m_C.addCombine(1, this.m_rB, -1, this.m_targetA);
	  this.m_C.mul(this.m_beta);

	  // Cheat with some damping
	  wB *= 0.98;

	  if (step.warmStarting) {
	    this.m_impulse.mul(step.dtRatio);
	    vB.addMul(this.m_invMassB, this.m_impulse);
	    wB += this.m_invIB * Vec2_1.cross(this.m_rB, this.m_impulse);

	  } else {
	    this.m_impulse.setZero();
	  }

	  velocity.v.set(vB);
	  velocity.w = wB;
	};

	MouseJoint.prototype.solveVelocityConstraints = function(step) {
	  var velocity = this.m_bodyB.c_velocity;
	  var vB = Vec2_1.clone(velocity.v);
	  var wB = velocity.w;

	  // Cdot = v + cross(w, r)

	  var Cdot = Vec2_1.cross(wB, this.m_rB);
	  Cdot.add(vB);

	  Cdot.addCombine(1, this.m_C, this.m_gamma, this.m_impulse);
	  Cdot.neg();

	  var impulse = Mat22_1.mulVec2(this.m_mass, Cdot);

	  var oldImpulse = Vec2_1.clone(this.m_impulse);
	  this.m_impulse.add(impulse);
	  var maxImpulse = step.dt * this.m_maxForce;
	  this.m_impulse.clamp(maxImpulse);
	  impulse = Vec2_1.sub(this.m_impulse, oldImpulse);

	  vB.addMul(this.m_invMassB, impulse);
	  wB += this.m_invIB * Vec2_1.cross(this.m_rB, impulse);

	  velocity.v.set(vB);
	  velocity.w = wB;
	};

	MouseJoint.prototype.solvePositionConstraints = function(step) {
	  return true;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$I = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$I = typeof ASSERT === 'undefined' ? false : ASSERT;

	var PulleyJoint_1 = PulleyJoint;




















	PulleyJoint.TYPE = 'pulley-joint';
	PulleyJoint.MIN_PULLEY_LENGTH = 2.0; // minPulleyLength
	Joint_1.TYPES[PulleyJoint.TYPE] = PulleyJoint;

	PulleyJoint._super = Joint_1;
	PulleyJoint.prototype = create(PulleyJoint._super.prototype);

	/**
	 * @typedef {Object} PulleyJointDef
	 *
	 * Pulley joint definition. This requires two ground anchors, two dynamic body
	 * anchor points, and a pulley ratio.
	 *
	 * @prop {Vec2} groundAnchorA The first ground anchor in world coordinates.
	 *          This point never moves.
	 * @prop {Vec2} groundAnchorB The second ground anchor in world coordinates.
	 *          This point never moves.
	 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
	 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
	 * @prop {float} ratio The pulley ratio, used to simulate a block-and-tackle.
	 * @prop {float} lengthA The reference length for the segment attached to bodyA.
	 * @prop {float} lengthB The reference length for the segment attached to bodyB.
	 */
	var PulleyJointDef = {
	  collideConnected : true
	};

	/**
	 * The pulley joint is connected to two bodies and two fixed ground points. The
	 * pulley supports a ratio such that: length1 + ratio * length2 <= constant
	 * 
	 * Yes, the force transmitted is scaled by the ratio.
	 * 
	 * Warning: the pulley joint can get a bit squirrelly by itself. They often work
	 * better when combined with prismatic joints. You should also cover the the
	 * anchor points with static shapes to prevent one side from going to zero
	 * length.
	 *
	 * @param {PulleyJointDef} def
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 */
	function PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio) {
	  if (!(this instanceof PulleyJoint)) {
	    return new PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio);
	  }

	  def = options(def, PulleyJointDef);
	  Joint_1.call(this, def, bodyA, bodyB);
	  bodyA = this.m_bodyA;
	  bodyB = this.m_bodyB;

	  this.m_type = PulleyJoint.TYPE;
	  this.m_groundAnchorA = groundA ? groundA : def.groundAnchorA || Vec2_1.neo(-1.0, 1.0);
	  this.m_groundAnchorB = groundB ? groundB : def.groundAnchorB || Vec2_1.neo(1.0, 1.0);
	  this.m_localAnchorA = anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2_1.neo(-1.0, 0.0);
	  this.m_localAnchorB = anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2_1.neo(1.0, 0.0);
	  this.m_lengthA = _Math.isFinite(def.lengthA) ? def.lengthA : Vec2_1.distance(anchorA, groundA);
	  this.m_lengthB = _Math.isFinite(def.lengthB) ? def.lengthB : Vec2_1.distance(anchorB, groundB);
	  this.m_ratio = _Math.isFinite(ratio) ? ratio : def.ratio;

	  _ASSERT$I && common.assert(ratio > _Math.EPSILON);

	  this.m_constant = this.m_lengthA + this.m_ratio * this.m_lengthB;

	  this.m_impulse = 0.0;

	  // Solver temp
	  this.m_uA; // Vec2
	  this.m_uB; // Vec2
	  this.m_rA; // Vec2
	  this.m_rB; // Vec2
	  this.m_localCenterA; // Vec2
	  this.m_localCenterB; // Vec2
	  this.m_invMassA; // float
	  this.m_invMassB; // float
	  this.m_invIA; // float
	  this.m_invIB; // float
	  this.m_mass; // float

	  // Pulley:
	  // length1 = norm(p1 - s1)
	  // length2 = norm(p2 - s2)
	  // C0 = (length1 + ratio * length2)_initial
	  // C = C0 - (length1 + ratio * length2)
	  // u1 = (p1 - s1) / norm(p1 - s1)
	  // u2 = (p2 - s2) / norm(p2 - s2)
	  // Cdot = -dot(u1, v1 + cross(w1, r1)) - ratio * dot(u2, v2 + cross(w2, r2))
	  // J = -[u1 cross(r1, u1) ratio * u2 ratio * cross(r2, u2)]
	  // K = J * invM * JT
	  // = invMass1 + invI1 * cross(r1, u1)^2 + ratio^2 * (invMass2 + invI2 *
	  // cross(r2, u2)^2)
	}

	PulleyJoint.prototype._serialize = function() {
	  return {
	    type: this.m_type,
	    bodyA: this.m_bodyA,
	    bodyB: this.m_bodyB,
	    collideConnected: this.m_collideConnected,

	    groundAnchorA: this.m_groundAnchorA,
	    groundAnchorB: this.m_groundAnchorB,
	    localAnchorA: this.m_localAnchorA,
	    localAnchorB: this.m_localAnchorB,
	    lengthA: this.m_lengthA,
	    lengthB: this.m_lengthB,
	    ratio: this.m_ratio,
	  };
	};

	PulleyJoint._deserialize = function(data, world, restore) {
	  data.bodyA = restore(Body_1, data.bodyA, world);
	  data.bodyB = restore(Body_1, data.bodyB, world);
	  var joint = new PulleyJoint(data);
	  return joint;
	};

	/**
	 * Get the first ground anchor.
	 */
	PulleyJoint.prototype.getGroundAnchorA = function() {
	  return this.m_groundAnchorA;
	};

	/**
	 * Get the second ground anchor.
	 */
	PulleyJoint.prototype.getGroundAnchorB = function() {
	  return this.m_groundAnchorB;
	};

	/**
	 * Get the current length of the segment attached to bodyA.
	 */
	PulleyJoint.prototype.getLengthA = function() {
	  return this.m_lengthA;
	};

	/**
	 * Get the current length of the segment attached to bodyB.
	 */
	PulleyJoint.prototype.getLengthB = function() {
	  return this.m_lengthB;
	};

	/**
	 * Get the pulley ratio.
	 */
	PulleyJoint.prototype.getRatio = function() {
	  return this.m_ratio;
	};

	/**
	 * Get the current length of the segment attached to bodyA.
	 */
	PulleyJoint.prototype.getCurrentLengthA = function() {
	  var p = this.m_bodyA.getWorldPoint(this.m_localAnchorA);
	  var s = this.m_groundAnchorA;
	  return Vec2_1.distance(p, s);
	};

	/**
	 * Get the current length of the segment attached to bodyB.
	 */
	PulleyJoint.prototype.getCurrentLengthB = function() {
	  var p = this.m_bodyB.getWorldPoint(this.m_localAnchorB);
	  var s = this.m_groundAnchorB;
	  return Vec2_1.distance(p, s);
	};

	PulleyJoint.prototype.shiftOrigin = function(newOrigin) {
	  this.m_groundAnchorA.sub(newOrigin);
	  this.m_groundAnchorB.sub(newOrigin);
	};

	PulleyJoint.prototype.getAnchorA = function() {
	  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
	};

	PulleyJoint.prototype.getAnchorB = function() {
	  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
	};

	PulleyJoint.prototype.getReactionForce = function(inv_dt) {
	  return Vec2_1.mul(this.m_impulse, this.m_uB).mul(inv_dt);
	};

	PulleyJoint.prototype.getReactionTorque = function(inv_dt) {
	  return 0.0;
	};

	PulleyJoint.prototype.initVelocityConstraints = function(step) {
	  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
	  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
	  this.m_invMassA = this.m_bodyA.m_invMass;
	  this.m_invMassB = this.m_bodyB.m_invMass;
	  this.m_invIA = this.m_bodyA.m_invI;
	  this.m_invIB = this.m_bodyB.m_invI;

	  var cA = this.m_bodyA.c_position.c;
	  var aA = this.m_bodyA.c_position.a;
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;

	  var cB = this.m_bodyB.c_position.c;
	  var aB = this.m_bodyB.c_position.a;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  var qA = Rot_1.neo(aA);
	  var qB = Rot_1.neo(aB);

	  this.m_rA = Rot_1.mulVec2(qA, Vec2_1.sub(this.m_localAnchorA, this.m_localCenterA));
	  this.m_rB = Rot_1.mulVec2(qB, Vec2_1.sub(this.m_localAnchorB, this.m_localCenterB));

	  // Get the pulley axes.
	  this.m_uA = Vec2_1.sub(Vec2_1.add(cA, this.m_rA), this.m_groundAnchorA);
	  this.m_uB = Vec2_1.sub(Vec2_1.add(cB, this.m_rB), this.m_groundAnchorB);

	  var lengthA = this.m_uA.length();
	  var lengthB = this.m_uB.length();

	  if (lengthA > 10.0 * Settings_1.linearSlop) {
	    this.m_uA.mul(1.0 / lengthA);
	  } else {
	    this.m_uA.setZero();
	  }

	  if (lengthB > 10.0 * Settings_1.linearSlop) {
	    this.m_uB.mul(1.0 / lengthB);
	  } else {
	    this.m_uB.setZero();
	  }

	  // Compute effective mass.
	  var ruA = Vec2_1.cross(this.m_rA, this.m_uA); // float
	  var ruB = Vec2_1.cross(this.m_rB, this.m_uB); // float

	  var mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float
	  var mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float

	  this.m_mass = mA + this.m_ratio * this.m_ratio * mB;

	  if (this.m_mass > 0.0) {
	    this.m_mass = 1.0 / this.m_mass;
	  }

	  if (step.warmStarting) {
	    // Scale impulses to support variable time steps.
	    this.m_impulse *= step.dtRatio;

	    // Warm starting.
	    var PA = Vec2_1.mul(-this.m_impulse, this.m_uA);
	    var PB = Vec2_1.mul(-this.m_ratio * this.m_impulse, this.m_uB);

	    vA.addMul(this.m_invMassA, PA);
	    wA += this.m_invIA * Vec2_1.cross(this.m_rA, PA);

	    vB.addMul(this.m_invMassB, PB);
	    wB += this.m_invIB * Vec2_1.cross(this.m_rB, PB);

	  } else {
	    this.m_impulse = 0.0;
	  }

	  this.m_bodyA.c_velocity.v = vA;
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v = vB;
	  this.m_bodyB.c_velocity.w = wB;
	};

	PulleyJoint.prototype.solveVelocityConstraints = function(step) {
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  var vpA = Vec2_1.add(vA, Vec2_1.cross(wA, this.m_rA));
	  var vpB = Vec2_1.add(vB, Vec2_1.cross(wB, this.m_rB));

	  var Cdot = -Vec2_1.dot(this.m_uA, vpA) - this.m_ratio
	      * Vec2_1.dot(this.m_uB, vpB); // float
	  var impulse = -this.m_mass * Cdot; // float
	  this.m_impulse += impulse;

	  var PA = Vec2_1.mul(-impulse, this.m_uA); // Vec2
	  var PB = Vec2_1.mul(-this.m_ratio * impulse, this.m_uB); // Vec2
	  vA.addMul(this.m_invMassA, PA);
	  wA += this.m_invIA * Vec2_1.cross(this.m_rA, PA);
	  vB.addMul(this.m_invMassB, PB);
	  wB += this.m_invIB * Vec2_1.cross(this.m_rB, PB);

	  this.m_bodyA.c_velocity.v = vA;
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v = vB;
	  this.m_bodyB.c_velocity.w = wB;
	};

	PulleyJoint.prototype.solvePositionConstraints = function(step) {
	  var cA = this.m_bodyA.c_position.c;
	  var aA = this.m_bodyA.c_position.a;
	  var cB = this.m_bodyB.c_position.c;
	  var aB = this.m_bodyB.c_position.a;

	  var qA = Rot_1.neo(aA), qB = Rot_1.neo(aB);

	  var rA = Rot_1.mulVec2(qA, Vec2_1.sub(this.m_localAnchorA, this.m_localCenterA));
	  var rB = Rot_1.mulVec2(qB, Vec2_1.sub(this.m_localAnchorB, this.m_localCenterB));

	  // Get the pulley axes.
	  var uA = Vec2_1.sub(Vec2_1.add(cA, this.m_rA), this.m_groundAnchorA);
	  var uB = Vec2_1.sub(Vec2_1.add(cB, this.m_rB), this.m_groundAnchorB);

	  var lengthA = uA.length();
	  var lengthB = uB.length();

	  if (lengthA > 10.0 * Settings_1.linearSlop) {
	    uA.mul(1.0 / lengthA);
	  } else {
	    uA.setZero();
	  }

	  if (lengthB > 10.0 * Settings_1.linearSlop) {
	    uB.mul(1.0 / lengthB);
	  } else {
	    uB.setZero();
	  }

	  // Compute effective mass.
	  var ruA = Vec2_1.cross(rA, uA);
	  var ruB = Vec2_1.cross(rB, uB);

	  var mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float
	  var mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float

	  var mass = mA + this.m_ratio * this.m_ratio * mB; // float

	  if (mass > 0.0) {
	    mass = 1.0 / mass;
	  }

	  var C = this.m_constant - lengthA - this.m_ratio * lengthB; // float
	  var linearError = _Math.abs(C); // float

	  var impulse = -mass * C; // float

	  var PA = Vec2_1.mul(-impulse, uA); // Vec2
	  var PB = Vec2_1.mul(-this.m_ratio * impulse, uB); // Vec2

	  cA.addMul(this.m_invMassA, PA);
	  aA += this.m_invIA * Vec2_1.cross(rA, PA);
	  cB.addMul(this.m_invMassB, PB);
	  aB += this.m_invIB * Vec2_1.cross(rB, PB);

	  this.m_bodyA.c_position.c = cA;
	  this.m_bodyA.c_position.a = aA;
	  this.m_bodyB.c_position.c = cB;
	  this.m_bodyB.c_position.a = aB;

	  return linearError < Settings_1.linearSlop;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$J = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$J = typeof ASSERT === 'undefined' ? false : ASSERT;

	var RopeJoint_1 = RopeJoint;



















	var inactiveLimit$2 = 0;
	var atUpperLimit$2 = 2;

	RopeJoint.TYPE = 'rope-joint';
	Joint_1.TYPES[RopeJoint.TYPE] = RopeJoint;

	RopeJoint._super = Joint_1;
	RopeJoint.prototype = create(RopeJoint._super.prototype);

	/**
	 * @typedef {Object} RopeJointDef
	 *
	 * Rope joint definition. This requires two body anchor points and a maximum
	 * lengths. Note: by default the connected objects will not collide. see
	 * collideConnected in JointDef.
	 *
	 * @prop {float} maxLength The maximum length of the rope. Warning: this must be
	 *       larger than linearSlop or the joint will have no effect.
	 *
	 * @prop {Vec2} def.localAnchorA The local anchor point relative to bodyA's origin.
	 * @prop {Vec2} def.localAnchorB The local anchor point relative to bodyB's origin.
	 */

	var DEFAULTS$7 = {
	  maxLength : 0.0,
	};

	/**
	 * A rope joint enforces a maximum distance between two points on two bodies. It
	 * has no other effect.
	 * 
	 * Warning: if you attempt to change the maximum length during the simulation
	 * you will get some non-physical behavior.
	 * 
	 * A model that would allow you to dynamically modify the length would have some
	 * sponginess, so I chose not to implement it that way. See DistanceJoint if you
	 * want to dynamically control length.
	 *
	 * @param {RopeJointDef} def
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 */
	function RopeJoint(def, bodyA, bodyB, anchor) {
	  if (!(this instanceof RopeJoint)) {
	    return new RopeJoint(def, bodyA, bodyB, anchor);
	  }

	  def = options(def, DEFAULTS$7);
	  Joint_1.call(this, def, bodyA, bodyB);
	  bodyA = this.m_bodyA;
	  bodyB = this.m_bodyB;

	  this.m_type = RopeJoint.TYPE;
	  this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2_1.neo(-1.0, 0.0);
	  this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2_1.neo(1.0, 0.0);

	  this.m_maxLength = def.maxLength;

	  this.m_mass = 0.0;
	  this.m_impulse = 0.0;
	  this.m_length = 0.0;
	  this.m_state = inactiveLimit$2;

	  // Solver temp
	  this.m_u; // Vec2
	  this.m_rA; // Vec2
	  this.m_rB; // Vec2
	  this.m_localCenterA; // Vec2
	  this.m_localCenterB; // Vec2
	  this.m_invMassA; // float
	  this.m_invMassB; // float
	  this.m_invIA; // float
	  this.m_invIB; // float
	  this.m_mass; // float

	  // Limit:
	  // C = norm(pB - pA) - L
	  // u = (pB - pA) / norm(pB - pA)
	  // Cdot = dot(u, vB + cross(wB, rB) - vA - cross(wA, rA))
	  // J = [-u -cross(rA, u) u cross(rB, u)]
	  // K = J * invM * JT
	  // = invMassA + invIA * cross(rA, u)^2 + invMassB + invIB * cross(rB, u)^2
	}
	RopeJoint.prototype._serialize = function() {
	  return {
	    type: this.m_type,
	    bodyA: this.m_bodyA,
	    bodyB: this.m_bodyB,
	    collideConnected: this.m_collideConnected,

	    localAnchorA: this.m_localAnchorA,
	    localAnchorB: this.m_localAnchorB,
	    maxLength: this.m_maxLength,
	  };
	};

	RopeJoint._deserialize = function(data, world, restore) {
	  data.bodyA = restore(Body_1, data.bodyA, world);
	  data.bodyB = restore(Body_1, data.bodyB, world);
	  var joint = new RopeJoint(data);
	  return joint;
	};

	/**
	 * The local anchor point relative to bodyA's origin.
	 */
	RopeJoint.prototype.getLocalAnchorA = function() {
	  return this.m_localAnchorA;
	};

	/**
	 * The local anchor point relative to bodyB's origin.
	 */
	RopeJoint.prototype.getLocalAnchorB = function() {
	  return this.m_localAnchorB;
	};

	/**
	 * Set/Get the maximum length of the rope.
	 */
	RopeJoint.prototype.setMaxLength = function(length) {
	  this.m_maxLength = length;
	};

	RopeJoint.prototype.getMaxLength = function() {
	  return this.m_maxLength;
	};

	RopeJoint.prototype.getLimitState = function() {
	  // TODO LimitState
	  return this.m_state;
	};

	RopeJoint.prototype.getAnchorA = function() {
	  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
	};

	RopeJoint.prototype.getAnchorB = function() {
	  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
	};

	RopeJoint.prototype.getReactionForce = function(inv_dt) {
	  return Vec2_1.mul(this.m_impulse, this.m_u).mul(inv_dt);
	};

	RopeJoint.prototype.getReactionTorque = function(inv_dt) {
	  return 0.0;
	};

	RopeJoint.prototype.initVelocityConstraints = function(step) {
	  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
	  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
	  this.m_invMassA = this.m_bodyA.m_invMass;
	  this.m_invMassB = this.m_bodyB.m_invMass;
	  this.m_invIA = this.m_bodyA.m_invI;
	  this.m_invIB = this.m_bodyB.m_invI;

	  var cA = this.m_bodyA.c_position.c;
	  var aA = this.m_bodyA.c_position.a;
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;

	  var cB = this.m_bodyB.c_position.c;
	  var aB = this.m_bodyB.c_position.a;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  var qA = Rot_1.neo(aA);
	  var qB = Rot_1.neo(aB);

	  this.m_rA = Rot_1.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
	  this.m_rB = Rot_1.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
	  this.m_u = Vec2_1.zero();
	  this.m_u.addCombine(1, cB, 1, this.m_rB);
	  this.m_u.subCombine(1, cA, 1, this.m_rA); // Vec2

	  this.m_length = this.m_u.length();

	  var C = this.m_length - this.m_maxLength; // float
	  if (C > 0.0) {
	    this.m_state = atUpperLimit$2;
	  } else {
	    this.m_state = inactiveLimit$2;
	  }

	  if (this.m_length > Settings_1.linearSlop) {
	    this.m_u.mul(1.0 / this.m_length);
	  } else {
	    this.m_u.setZero();
	    this.m_mass = 0.0;
	    this.m_impulse = 0.0;
	    return;
	  }

	  // Compute effective mass.
	  var crA = Vec2_1.cross(this.m_rA, this.m_u); // float
	  var crB = Vec2_1.cross(this.m_rB, this.m_u); // float
	  var invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB
	      + this.m_invIB * crB * crB; // float

	  this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;

	  if (step.warmStarting) {
	    // Scale the impulse to support a variable time step.
	    this.m_impulse *= step.dtRatio;

	    var P = Vec2_1.mul(this.m_impulse, this.m_u);
	    
	    vA.subMul(this.m_invMassA, P);
	    wA -= this.m_invIA * Vec2_1.cross(this.m_rA, P);
	    
	    vB.addMul(this.m_invMassB, P);
	    wB += this.m_invIB * Vec2_1.cross(this.m_rB, P);
	    
	  } else {
	    this.m_impulse = 0.0;
	  }

	  this.m_bodyA.c_velocity.v.set(vA);
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v.set(vB);
	  this.m_bodyB.c_velocity.w = wB;
	};

	RopeJoint.prototype.solveVelocityConstraints = function(step) {
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  // Cdot = dot(u, v + cross(w, r))
	  var vpA = Vec2_1.addCross(vA, wA, this.m_rA); // Vec2
	  var vpB = Vec2_1.addCross(vB, wB, this.m_rB); // Vec2
	  var C = this.m_length - this.m_maxLength; // float
	  var Cdot = Vec2_1.dot(this.m_u, Vec2_1.sub(vpB, vpA)); // float

	  // Predictive constraint.
	  if (C < 0.0) {
	    Cdot += step.inv_dt * C;
	  }

	  var impulse = -this.m_mass * Cdot; // float
	  var oldImpulse = this.m_impulse; // float
	  this.m_impulse = _Math.min(0.0, this.m_impulse + impulse);
	  impulse = this.m_impulse - oldImpulse;

	  var P = Vec2_1.mul(impulse, this.m_u); // Vec2
	  vA.subMul(this.m_invMassA, P);
	  wA -= this.m_invIA * Vec2_1.cross(this.m_rA, P);
	  vB.addMul(this.m_invMassB, P);
	  wB += this.m_invIB * Vec2_1.cross(this.m_rB, P);

	  this.m_bodyA.c_velocity.v = vA;
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v = vB;
	  this.m_bodyB.c_velocity.w = wB;
	};

	RopeJoint.prototype.solvePositionConstraints = function(step) {
	  var cA = this.m_bodyA.c_position.c; // Vec2
	  var aA = this.m_bodyA.c_position.a; // float
	  var cB = this.m_bodyB.c_position.c; // Vec2
	  var aB = this.m_bodyB.c_position.a; // float

	  var qA = Rot_1.neo(aA);
	  var qB = Rot_1.neo(aB);

	  var rA = Rot_1.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
	  var rB = Rot_1.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
	  var u = Vec2_1.zero();
	  u.addCombine(1, cB, 1, rB);
	  u.subCombine(1, cA, 1, rA); // Vec2

	  var length = u.normalize(); // float
	  var C = length - this.m_maxLength; // float

	  C = _Math.clamp(C, 0.0, Settings_1.maxLinearCorrection);

	  var impulse = -this.m_mass * C; // float
	  var P = Vec2_1.mul(impulse, u); // Vec2

	  cA.subMul(this.m_invMassA, P);
	  aA -= this.m_invIA * Vec2_1.cross(rA, P);
	  cB.addMul(this.m_invMassB, P);
	  aB += this.m_invIB * Vec2_1.cross(rB, P);

	  this.m_bodyA.c_position.c.set(cA);
	  this.m_bodyA.c_position.a = aA;
	  this.m_bodyB.c_position.c.set(cB);
	  this.m_bodyB.c_position.a = aB;

	  return length - this.m_maxLength < Settings_1.linearSlop;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$K = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$K = typeof ASSERT === 'undefined' ? false : ASSERT;

	var WeldJoint_1 = WeldJoint;



















	WeldJoint.TYPE = 'weld-joint';
	Joint_1.TYPES[WeldJoint.TYPE] = WeldJoint;

	WeldJoint._super = Joint_1;
	WeldJoint.prototype = create(WeldJoint._super.prototype);

	/**
	 * @typedef {Object} WeldJointDef
	 *
	 * Weld joint definition. You need to specify local anchor points where they are
	 * attached and the relative body angle. The position of the anchor points is
	 * important for computing the reaction torque.
	 * 
	 * @prop {float} frequencyHz The mass-spring-damper frequency in Hertz. Rotation
	 *       only. Disable softness with a value of 0.
	 * @prop {float} dampingRatio The damping ratio. 0 = no damping, 1 = critical
	 *       damping.
	 *
	 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
	 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
	 * @prop {float} referenceAngle The bodyB angle minus bodyA angle in the
	 *       reference state (radians).
	 */
	var DEFAULTS$8 = {
	  frequencyHz : 0.0,
	  dampingRatio : 0.0,
	};

	/**
	 * A weld joint essentially glues two bodies together. A weld joint may distort
	 * somewhat because the island constraint solver is approximate.
	 *
	 * @param {WeldJointDef} def
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 */
	function WeldJoint(def, bodyA, bodyB, anchor) {
	  if (!(this instanceof WeldJoint)) {
	    return new WeldJoint(def, bodyA, bodyB, anchor);
	  }

	  def = options(def, DEFAULTS$8);
	  Joint_1.call(this, def, bodyA, bodyB);
	  bodyA = this.m_bodyA;
	  bodyB = this.m_bodyB;

	  this.m_type = WeldJoint.TYPE;

	  this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2_1.zero();
	  this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2_1.zero();
	  this.m_referenceAngle = _Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();

	  this.m_frequencyHz = def.frequencyHz;
	  this.m_dampingRatio = def.dampingRatio;

	  this.m_impulse = Vec3_1();

	  this.m_bias = 0.0;
	  this.m_gamma = 0.0;

	  // Solver temp
	  this.m_rA; // Vec2
	  this.m_rB; // Vec2
	  this.m_localCenterA; // Vec2
	  this.m_localCenterB; // Vec2
	  this.m_invMassA; // float
	  this.m_invMassB; // float
	  this.m_invIA; // float
	  this.m_invIB; // float
	  this.m_mass = new Mat33_1();

	  // Point-to-point constraint
	  // C = p2 - p1
	  // Cdot = v2 - v1
	  // / = v2 + cross(w2, r2) - v1 - cross(w1, r1)
	  // J = [-I -r1_skew I r2_skew ]
	  // Identity used:
	  // w k % (rx i + ry j) = w * (-ry i + rx j)

	  // Angle constraint
	  // C = angle2 - angle1 - referenceAngle
	  // Cdot = w2 - w1
	  // J = [0 0 -1 0 0 1]
	  // K = invI1 + invI2
	}

	WeldJoint.prototype._serialize = function() {
	  return {
	    type: this.m_type,
	    bodyA: this.m_bodyA,
	    bodyB: this.m_bodyB,
	    collideConnected: this.m_collideConnected,
	    
	    frequencyHz: this.m_frequencyHz,
	    dampingRatio: this.m_dampingRatio,

	    localAnchorA: this.m_localAnchorA,
	    localAnchorB: this.m_localAnchorB,
	    referenceAngle: this.m_referenceAngle,
	  };
	};

	WeldJoint._deserialize = function(data, world, restore) {
	  data.bodyA = restore(Body_1, data.bodyA, world);
	  data.bodyB = restore(Body_1, data.bodyB, world);
	  var joint = new WeldJoint(data);
	  return joint;
	};

	/**
	 * The local anchor point relative to bodyA's origin.
	 */
	WeldJoint.prototype.getLocalAnchorA = function() {
	  return this.m_localAnchorA;
	};

	/**
	 * The local anchor point relative to bodyB's origin.
	 */
	WeldJoint.prototype.getLocalAnchorB = function() {
	  return this.m_localAnchorB;
	};

	/**
	 * Get the reference angle.
	 */
	WeldJoint.prototype.getReferenceAngle = function() {
	  return this.m_referenceAngle;
	};

	/**
	 * Set/get frequency in Hz.
	 */
	WeldJoint.prototype.setFrequency = function(hz) {
	  this.m_frequencyHz = hz;
	};

	WeldJoint.prototype.getFrequency = function() {
	  return this.m_frequencyHz;
	};

	/**
	 * Set/get damping ratio.
	 */
	WeldJoint.prototype.setDampingRatio = function(ratio) {
	  this.m_dampingRatio = ratio;
	};

	WeldJoint.prototype.getDampingRatio = function() {
	  return this.m_dampingRatio;
	};

	WeldJoint.prototype.getAnchorA = function() {
	  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
	};

	WeldJoint.prototype.getAnchorB = function() {
	  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
	};

	WeldJoint.prototype.getReactionForce = function(inv_dt) {
	  return Vec2_1.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);
	};

	WeldJoint.prototype.getReactionTorque = function(inv_dt) {
	  return inv_dt * this.m_impulse.z;
	};

	WeldJoint.prototype.initVelocityConstraints = function(step) {
	  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
	  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
	  this.m_invMassA = this.m_bodyA.m_invMass;
	  this.m_invMassB = this.m_bodyB.m_invMass;
	  this.m_invIA = this.m_bodyA.m_invI;
	  this.m_invIB = this.m_bodyB.m_invI;

	  var aA = this.m_bodyA.c_position.a;
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;

	  var aB = this.m_bodyB.c_position.a;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  var qA = Rot_1.neo(aA), qB = Rot_1.neo(aB);

	  this.m_rA = Rot_1.mulVec2(qA, Vec2_1.sub(this.m_localAnchorA, this.m_localCenterA));
	  this.m_rB = Rot_1.mulVec2(qB, Vec2_1.sub(this.m_localAnchorB, this.m_localCenterB));

	  // J = [-I -r1_skew I r2_skew]
	  // [ 0 -1 0 1]
	  // r_skew = [-ry; rx]

	  // Matlab
	  // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
	  // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
	  // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]

	  var mA = this.m_invMassA;
	  var mB = this.m_invMassB; // float
	  var iA = this.m_invIA;
	  var iB = this.m_invIB; // float

	  var K = new Mat33_1();
	  K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y
	      * iB;
	  K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
	  K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
	  K.ex.y = K.ey.x;
	  K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x
	      * iB;
	  K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
	  K.ex.z = K.ez.x;
	  K.ey.z = K.ez.y;
	  K.ez.z = iA + iB;

	  if (this.m_frequencyHz > 0.0) {
	    K.getInverse22(this.m_mass);

	    var invM = iA + iB; // float
	    var m = invM > 0.0 ? 1.0 / invM : 0.0; // float

	    var C = aB - aA - this.m_referenceAngle; // float

	    // Frequency
	    var omega = 2.0 * _Math.PI * this.m_frequencyHz; // float

	    // Damping coefficient
	    var d = 2.0 * m * this.m_dampingRatio * omega; // float

	    // Spring stiffness
	    var k = m * omega * omega; // float

	    // magic formulas
	    var h = step.dt; // float
	    this.m_gamma = h * (d + h * k);
	    this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;
	    this.m_bias = C * h * k * this.m_gamma;

	    invM += this.m_gamma;
	    this.m_mass.ez.z = invM != 0.0 ? 1.0 / invM : 0.0;
	  } else if (K.ez.z == 0.0) {
	    K.getInverse22(this.m_mass);
	    this.m_gamma = 0.0;
	    this.m_bias = 0.0;
	  } else {
	    K.getSymInverse33(this.m_mass);
	    this.m_gamma = 0.0;
	    this.m_bias = 0.0;
	  }

	  if (step.warmStarting) {
	    // Scale impulses to support a variable time step.
	    this.m_impulse.mul(step.dtRatio);

	    var P = Vec2_1.neo(this.m_impulse.x, this.m_impulse.y);

	    vA.subMul(mA, P);
	    wA -= iA * (Vec2_1.cross(this.m_rA, P) + this.m_impulse.z);

	    vB.addMul(mB, P);
	    wB += iB * (Vec2_1.cross(this.m_rB, P) + this.m_impulse.z);

	  } else {
	    this.m_impulse.setZero();
	  }

	  this.m_bodyA.c_velocity.v = vA;
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v = vB;
	  this.m_bodyB.c_velocity.w = wB;
	};

	WeldJoint.prototype.solveVelocityConstraints = function(step) {
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  var mA = this.m_invMassA;
	  var mB = this.m_invMassB; // float
	  var iA = this.m_invIA;
	  var iB = this.m_invIB; // float

	  if (this.m_frequencyHz > 0.0) {
	    var Cdot2 = wB - wA; // float

	    var impulse2 = -this.m_mass.ez.z
	        * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z); // float
	    this.m_impulse.z += impulse2;

	    wA -= iA * impulse2;
	    wB += iB * impulse2;

	    var Cdot1 = Vec2_1.zero();
	    Cdot1.addCombine(1, vB, 1, Vec2_1.cross(wB, this.m_rB));
	    Cdot1.subCombine(1, vA, 1, Vec2_1.cross(wA, this.m_rA)); // Vec2

	    var impulse1 = Vec2_1.neg(Mat33_1.mulVec2(this.m_mass, Cdot1)); // Vec2
	    this.m_impulse.x += impulse1.x;
	    this.m_impulse.y += impulse1.y;

	    var P = Vec2_1.clone(impulse1); // Vec2

	    vA.subMul(mA, P);
	    wA -= iA * Vec2_1.cross(this.m_rA, P);

	    vB.addMul(mB, P);
	    wB += iB * Vec2_1.cross(this.m_rB, P);
	  } else {
	    var Cdot1 = Vec2_1.zero();
	    Cdot1.addCombine(1, vB, 1, Vec2_1.cross(wB, this.m_rB));
	    Cdot1.subCombine(1, vA, 1, Vec2_1.cross(wA, this.m_rA)); // Vec2
	    var Cdot2 = wB - wA; // float
	    var Cdot = Vec3_1(Cdot1.x, Cdot1.y, Cdot2); // Vec3

	    var impulse = Vec3_1.neg(Mat33_1.mulVec3(this.m_mass, Cdot)); // Vec3
	    this.m_impulse.add(impulse);

	    var P = Vec2_1.neo(impulse.x, impulse.y);

	    vA.subMul(mA, P);
	    wA -= iA * (Vec2_1.cross(this.m_rA, P) + impulse.z);

	    vB.addMul(mB, P);
	    wB += iB * (Vec2_1.cross(this.m_rB, P) + impulse.z);
	  }

	  this.m_bodyA.c_velocity.v = vA;
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v = vB;
	  this.m_bodyB.c_velocity.w = wB;
	};

	WeldJoint.prototype.solvePositionConstraints = function(step) {
	  var cA = this.m_bodyA.c_position.c;
	  var aA = this.m_bodyA.c_position.a;
	  var cB = this.m_bodyB.c_position.c;
	  var aB = this.m_bodyB.c_position.a;

	  var qA = Rot_1.neo(aA), qB = Rot_1.neo(aB);

	  var mA = this.m_invMassA, mB = this.m_invMassB; // float
	  var iA = this.m_invIA, iB = this.m_invIB; // float

	  var rA = Rot_1.mulVec2(qA, Vec2_1.sub(this.m_localAnchorA, this.m_localCenterA));
	  var rB = Rot_1.mulVec2(qB, Vec2_1.sub(this.m_localAnchorB, this.m_localCenterB));

	  var positionError, angularError; // float

	  var K = new Mat33_1();
	  K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;
	  K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;
	  K.ez.x = -rA.y * iA - rB.y * iB;
	  K.ex.y = K.ey.x;
	  K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;
	  K.ez.y = rA.x * iA + rB.x * iB;
	  K.ex.z = K.ez.x;
	  K.ey.z = K.ez.y;
	  K.ez.z = iA + iB;

	  if (this.m_frequencyHz > 0.0) {
	    var C1 = Vec2_1.zero();
	    C1.addCombine(1, cB, 1, rB);
	    C1.subCombine(1, cA, 1, rA); // Vec2

	    positionError = C1.length();
	    angularError = 0.0;

	    var P = Vec2_1.neg(K.solve22(C1)); // Vec2

	    cA.subMul(mA, P);
	    aA -= iA * Vec2_1.cross(rA, P);

	    cB.addMul(mB, P);
	    aB += iB * Vec2_1.cross(rB, P);
	  } else {
	    var C1 = Vec2_1.zero();
	    C1.addCombine(1, cB, 1, rB);
	    C1.subCombine(1, cA, 1, rA);

	    var C2 = aB - aA - this.m_referenceAngle; // float

	    positionError = C1.length();
	    angularError = _Math.abs(C2);

	    var C = Vec3_1(C1.x, C1.y, C2);

	    var impulse = Vec3_1();
	    if (K.ez.z > 0.0) {
	      impulse = Vec3_1.neg(K.solve33(C));
	    } else {
	      var impulse2 = Vec2_1.neg(K.solve22(C1));
	      impulse.set(impulse2.x, impulse2.y, 0.0);
	    }

	    var P = Vec2_1.neo(impulse.x, impulse.y);

	    cA.subMul(mA, P);
	    aA -= iA * (Vec2_1.cross(rA, P) + impulse.z);

	    cB.addMul(mB, P);
	    aB += iB * (Vec2_1.cross(rB, P) + impulse.z);
	  }

	  this.m_bodyA.c_position.c = cA;
	  this.m_bodyA.c_position.a = aA;
	  this.m_bodyB.c_position.c = cB;
	  this.m_bodyB.c_position.a = aB;

	  return positionError <= Settings_1.linearSlop
	      && angularError <= Settings_1.angularSlop;
	};

	/*
	 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
	 * Copyright (c) 2006-2011 Erin Catto  http://www.box2d.org
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */

	var _DEBUG$L = typeof DEBUG === 'undefined' ? false : DEBUG;
	var _ASSERT$L = typeof ASSERT === 'undefined' ? false : ASSERT;

	var WheelJoint_1 = WheelJoint;



















	WheelJoint.TYPE = 'wheel-joint';
	Joint_1.TYPES[WheelJoint.TYPE] = WheelJoint;

	WheelJoint._super = Joint_1;
	WheelJoint.prototype = create(WheelJoint._super.prototype);

	/**
	 * @typedef {Object} WheelJointDef
	 *
	 * Wheel joint definition. This requires defining a line of motion using an axis
	 * and an anchor point. The definition uses local anchor points and a local axis
	 * so that the initial configuration can violate the constraint slightly. The
	 * joint translation is zero when the local anchor points coincide in world
	 * space. Using local anchors and a local axis helps when saving and loading a
	 * game.
	 *
	 * @prop {boolean} enableMotor Enable/disable the joint motor.
	 * @prop {float} maxMotorTorque The maximum motor torque, usually in N-m.
	 * @prop {float} motorSpeed The desired motor speed in radians per second.
	 * @prop {float} frequencyHz Suspension frequency, zero indicates no suspension.
	 * @prop {float} dampingRatio Suspension damping ratio, one indicates critical
	 *       damping.
	 *
	 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
	 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
	 * @prop {Vec2} localAxisA The local translation axis in bodyA.
	 */
	var DEFAULTS$9 = {
	  enableMotor : false,
	  maxMotorTorque : 0.0,
	  motorSpeed : 0.0,
	  frequencyHz : 2.0,
	  dampingRatio : 0.7,
	};

	/**
	 * A wheel joint. This joint provides two degrees of freedom: translation along
	 * an axis fixed in bodyA and rotation in the plane. In other words, it is a
	 * point to line constraint with a rotational motor and a linear spring/damper.
	 * This joint is designed for vehicle suspensions.
	 *
	 * @param {WheelJointDef} def
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 */
	function WheelJoint(def, bodyA, bodyB, anchor, axis) {
	  if (!(this instanceof WheelJoint)) {
	    return new WheelJoint(def, bodyA, bodyB, anchor, axis);
	  }

	  def = options(def, DEFAULTS$9);
	  Joint_1.call(this, def, bodyA, bodyB);
	  bodyA = this.m_bodyA;
	  bodyB = this.m_bodyB;

	  this.m_type = WheelJoint.TYPE;

	  this.m_localAnchorA = Vec2_1.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2_1.zero());
	  this.m_localAnchorB = Vec2_1.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2_1.zero());
	  this.m_localXAxisA = Vec2_1.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || def.localAxis || Vec2_1.neo(1.0, 0.0));
	  this.m_localYAxisA = Vec2_1.cross(1.0, this.m_localXAxisA);

	  this.m_mass = 0.0;
	  this.m_impulse = 0.0;
	  this.m_motorMass = 0.0;
	  this.m_motorImpulse = 0.0;
	  this.m_springMass = 0.0;
	  this.m_springImpulse = 0.0;

	  this.m_maxMotorTorque = def.maxMotorTorque;
	  this.m_motorSpeed = def.motorSpeed;
	  this.m_enableMotor = def.enableMotor;

	  this.m_frequencyHz = def.frequencyHz;
	  this.m_dampingRatio = def.dampingRatio;

	  this.m_bias = 0.0;
	  this.m_gamma = 0.0;

	  // Solver temp
	  this.m_localCenterA; // Vec2
	  this.m_localCenterB; // Vec2
	  this.m_invMassA; // float
	  this.m_invMassB; // float
	  this.m_invIA; // float
	  this.m_invIB; // float

	  this.m_ax = Vec2_1.zero();
	  this.m_ay = Vec2_1.zero(); // Vec2
	  this.m_sAx;
	  this.m_sBx; // float
	  this.m_sAy;
	  this.m_sBy; // float

	  // Linear constraint (point-to-line)
	  // d = pB - pA = xB + rB - xA - rA
	  // C = dot(ay, d)
	  // Cdot = dot(d, cross(wA, ay)) + dot(ay, vB + cross(wB, rB) - vA - cross(wA,
	  // rA))
	  // = -dot(ay, vA) - dot(cross(d + rA, ay), wA) + dot(ay, vB) + dot(cross(rB,
	  // ay), vB)
	  // J = [-ay, -cross(d + rA, ay), ay, cross(rB, ay)]

	  // Spring linear constraint
	  // C = dot(ax, d)
	  // Cdot = = -dot(ax, vA) - dot(cross(d + rA, ax), wA) + dot(ax, vB) +
	  // dot(cross(rB, ax), vB)
	  // J = [-ax -cross(d+rA, ax) ax cross(rB, ax)]

	  // Motor rotational constraint
	  // Cdot = wB - wA
	  // J = [0 0 -1 0 0 1]
	}

	WheelJoint.prototype._serialize = function() {
	  return {
	    type: this.m_type,
	    bodyA: this.m_bodyA,
	    bodyB: this.m_bodyB,
	    collideConnected: this.m_collideConnected,

	    enableMotor: this.m_enableMotor,
	    maxMotorTorque: this.m_maxMotorTorque,
	    motorSpeed: this.m_motorSpeed,
	    frequencyHz: this.m_frequencyHz,
	    dampingRatio: this.m_dampingRatio,

	    localAnchorA: this.m_localAnchorA,
	    localAnchorB: this.m_localAnchorB,
	    localAxisA: this.m_localXAxisA,
	  };
	};

	WheelJoint._deserialize = function(data, world, restore) {
	  data.bodyA = restore(Body_1, data.bodyA, world);
	  data.bodyB = restore(Body_1, data.bodyB, world);
	  var joint = new WheelJoint(data);
	  return joint;
	};

	/**
	 * @internal
	 */
	WheelJoint.prototype._setAnchors = function(def) {
	  if (def.anchorA) {
	    this.m_localAnchorA.set(this.m_bodyA.getLocalPoint(def.anchorA));
	  } else if (def.localAnchorA) {
	    this.m_localAnchorA.set(def.localAnchorA);
	  }

	  if (def.anchorB) {
	    this.m_localAnchorB.set(this.m_bodyB.getLocalPoint(def.anchorB));
	  } else if (def.localAnchorB) {
	    this.m_localAnchorB.set(def.localAnchorB);
	  }

	  if (def.localAxisA) {
	    this.m_localXAxisA.set(def.localAxisA);
	    this.m_localYAxisA.set(Vec2_1.cross(1.0, def.localAxisA));
	  }
	};

	/**
	 * The local anchor point relative to bodyA's origin.
	 */
	WheelJoint.prototype.getLocalAnchorA = function() {
	  return this.m_localAnchorA;
	};

	/**
	 * The local anchor point relative to bodyB's origin.
	 */
	WheelJoint.prototype.getLocalAnchorB = function() {
	  return this.m_localAnchorB;
	};

	/**
	 * The local joint axis relative to bodyA.
	 */
	WheelJoint.prototype.getLocalAxisA = function() {
	  return this.m_localXAxisA;
	};

	/**
	 * Get the current joint translation, usually in meters.
	 */
	WheelJoint.prototype.getJointTranslation = function() {
	  var bA = this.m_bodyA;
	  var bB = this.m_bodyB;

	  var pA = bA.getWorldPoint(this.m_localAnchorA); // Vec2
	  var pB = bB.getWorldPoint(this.m_localAnchorB); // Vec2
	  var d = Vec2_1.sub(pB, pA); // Vec2
	  var axis = bA.getWorldVector(this.m_localXAxisA); // Vec2

	  var translation = Vec2_1.dot(d, axis); // float
	  return translation;
	};

	/**
	 * Get the current joint translation speed, usually in meters per second.
	 */
	WheelJoint.prototype.getJointSpeed = function() {
	  var wA = this.m_bodyA.m_angularVelocity;
	  var wB = this.m_bodyB.m_angularVelocity;
	  return wB - wA;
	};

	/**
	 * Is the joint motor enabled?
	 */
	WheelJoint.prototype.isMotorEnabled = function() {
	  return this.m_enableMotor;
	};

	/**
	 * Enable/disable the joint motor.
	 */
	WheelJoint.prototype.enableMotor = function(flag) {
	  this.m_bodyA.setAwake(true);
	  this.m_bodyB.setAwake(true);
	  this.m_enableMotor = flag;
	};

	/**
	 * Set the motor speed, usually in radians per second.
	 */
	WheelJoint.prototype.setMotorSpeed = function(speed) {
	  this.m_bodyA.setAwake(true);
	  this.m_bodyB.setAwake(true);
	  this.m_motorSpeed = speed;
	};

	/**
	 * Get the motor speed, usually in radians per second.
	 */
	WheelJoint.prototype.getMotorSpeed = function() {
	  return this.m_motorSpeed;
	};

	/**
	 * Set/Get the maximum motor force, usually in N-m.
	 */
	WheelJoint.prototype.setMaxMotorTorque = function(torque) {
	  this.m_bodyA.setAwake(true);
	  this.m_bodyB.setAwake(true);
	  this.m_maxMotorTorque = torque;
	};

	WheelJoint.prototype.getMaxMotorTorque = function() {
	  return this.m_maxMotorTorque;
	};

	/**
	 * Get the current motor torque given the inverse time step, usually in N-m.
	 */
	WheelJoint.prototype.getMotorTorque = function(inv_dt) {
	  return inv_dt * this.m_motorImpulse;
	};

	/**
	 * Set/Get the spring frequency in hertz. Setting the frequency to zero disables
	 * the spring.
	 */
	WheelJoint.prototype.setSpringFrequencyHz = function(hz) {
	  this.m_frequencyHz = hz;
	};

	WheelJoint.prototype.getSpringFrequencyHz = function() {
	  return this.m_frequencyHz;
	};

	/**
	 * Set/Get the spring damping ratio
	 */
	WheelJoint.prototype.setSpringDampingRatio = function(ratio) {
	  this.m_dampingRatio = ratio;
	};

	WheelJoint.prototype.getSpringDampingRatio = function() {
	  return this.m_dampingRatio;
	};

	WheelJoint.prototype.getAnchorA = function() {
	  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
	};

	WheelJoint.prototype.getAnchorB = function() {
	  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
	};

	WheelJoint.prototype.getReactionForce = function(inv_dt) {
	  return Vec2_1.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax).mul(inv_dt);
	};

	WheelJoint.prototype.getReactionTorque = function(inv_dt) {
	  return inv_dt * this.m_motorImpulse;
	};

	WheelJoint.prototype.initVelocityConstraints = function(step) {
	  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
	  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
	  this.m_invMassA = this.m_bodyA.m_invMass;
	  this.m_invMassB = this.m_bodyB.m_invMass;
	  this.m_invIA = this.m_bodyA.m_invI;
	  this.m_invIB = this.m_bodyB.m_invI;

	  var mA = this.m_invMassA;
	  var mB = this.m_invMassB; // float
	  var iA = this.m_invIA;
	  var iB = this.m_invIB; // float

	  var cA = this.m_bodyA.c_position.c;
	  var aA = this.m_bodyA.c_position.a;
	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;

	  var cB = this.m_bodyB.c_position.c;
	  var aB = this.m_bodyB.c_position.a;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  var qA = Rot_1.neo(aA);
	  var qB = Rot_1.neo(aB);

	  // Compute the effective masses.
	  var rA = Rot_1.mulVec2(qA, Vec2_1.sub(this.m_localAnchorA, this.m_localCenterA));
	  var rB = Rot_1.mulVec2(qB, Vec2_1.sub(this.m_localAnchorB, this.m_localCenterB));
	  var d = Vec2_1.zero();
	  d.addCombine(1, cB, 1, rB);
	  d.subCombine(1, cA, 1, rA); // Vec2

	  // Point to line constraint
	  {
	    this.m_ay = Rot_1.mulVec2(qA, this.m_localYAxisA);
	    this.m_sAy = Vec2_1.cross(Vec2_1.add(d, rA), this.m_ay);
	    this.m_sBy = Vec2_1.cross(rB, this.m_ay);

	    this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy
	        * this.m_sBy;

	    if (this.m_mass > 0.0) {
	      this.m_mass = 1.0 / this.m_mass;
	    }
	  }

	  // Spring constraint
	  this.m_springMass = 0.0;
	  this.m_bias = 0.0;
	  this.m_gamma = 0.0;
	  if (this.m_frequencyHz > 0.0) {
	    this.m_ax = Rot_1.mulVec2(qA, this.m_localXAxisA);
	    this.m_sAx = Vec2_1.cross(Vec2_1.add(d, rA), this.m_ax);
	    this.m_sBx = Vec2_1.cross(rB, this.m_ax);

	    var invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx
	        * this.m_sBx; // float

	    if (invMass > 0.0) {
	      this.m_springMass = 1.0 / invMass;

	      var C = Vec2_1.dot(d, this.m_ax); // float

	      // Frequency
	      var omega = 2.0 * _Math.PI * this.m_frequencyHz; // float

	      // Damping coefficient
	      var d = 2.0 * this.m_springMass * this.m_dampingRatio * omega; // float

	      // Spring stiffness
	      var k = this.m_springMass * omega * omega; // float

	      // magic formulas
	      var h = step.dt; // float
	      this.m_gamma = h * (d + h * k);
	      if (this.m_gamma > 0.0) {
	        this.m_gamma = 1.0 / this.m_gamma;
	      }

	      this.m_bias = C * h * k * this.m_gamma;

	      this.m_springMass = invMass + this.m_gamma;
	      if (this.m_springMass > 0.0) {
	        this.m_springMass = 1.0 / this.m_springMass;
	      }
	    }
	  } else {
	    this.m_springImpulse = 0.0;
	  }

	  // Rotational motor
	  if (this.m_enableMotor) {
	    this.m_motorMass = iA + iB;
	    if (this.m_motorMass > 0.0) {
	      this.m_motorMass = 1.0 / this.m_motorMass;
	    }
	  } else {
	    this.m_motorMass = 0.0;
	    this.m_motorImpulse = 0.0;
	  }

	  if (step.warmStarting) {
	    // Account for variable time step.
	    this.m_impulse *= step.dtRatio;
	    this.m_springImpulse *= step.dtRatio;
	    this.m_motorImpulse *= step.dtRatio;

	    var P = Vec2_1.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax);
	    var LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;
	    var LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;

	    vA.subMul(this.m_invMassA, P);
	    wA -= this.m_invIA * LA;

	    vB.addMul(this.m_invMassB, P);
	    wB += this.m_invIB * LB;

	  } else {
	    this.m_impulse = 0.0;
	    this.m_springImpulse = 0.0;
	    this.m_motorImpulse = 0.0;
	  }

	  this.m_bodyA.c_velocity.v.set(vA);
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v.set(vB);
	  this.m_bodyB.c_velocity.w = wB;
	};

	WheelJoint.prototype.solveVelocityConstraints = function(step) {
	  var mA = this.m_invMassA;
	  var mB = this.m_invMassB; // float
	  var iA = this.m_invIA;
	  var iB = this.m_invIB; // float

	  var vA = this.m_bodyA.c_velocity.v;
	  var wA = this.m_bodyA.c_velocity.w;
	  var vB = this.m_bodyB.c_velocity.v;
	  var wB = this.m_bodyB.c_velocity.w;

	  // Solve spring constraint
	  {
	    var Cdot = Vec2_1.dot(this.m_ax, vB) - Vec2_1.dot(this.m_ax, vA) + this.m_sBx
	        * wB - this.m_sAx * wA; // float
	    var impulse = -this.m_springMass
	        * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse); // float
	    this.m_springImpulse += impulse;

	    var P = Vec2_1.mul(impulse, this.m_ax); // Vec2
	    var LA = impulse * this.m_sAx; // float
	    var LB = impulse * this.m_sBx; // float

	    vA.subMul(mA, P);
	    wA -= iA * LA;

	    vB.addMul(mB, P);
	    wB += iB * LB;
	  }

	  // Solve rotational motor constraint
	  {
	    var Cdot = wB - wA - this.m_motorSpeed; // float
	    var impulse = -this.m_motorMass * Cdot; // float

	    var oldImpulse = this.m_motorImpulse; // float
	    var maxImpulse = step.dt * this.m_maxMotorTorque; // float
	    this.m_motorImpulse = _Math.clamp(this.m_motorImpulse + impulse,
	        -maxImpulse, maxImpulse);
	    impulse = this.m_motorImpulse - oldImpulse;

	    wA -= iA * impulse;
	    wB += iB * impulse;
	  }

	  // Solve point to line constraint
	  {
	    var Cdot = Vec2_1.dot(this.m_ay, vB) - Vec2_1.dot(this.m_ay, vA) + this.m_sBy
	        * wB - this.m_sAy * wA; // float
	    var impulse = -this.m_mass * Cdot; // float
	    this.m_impulse += impulse;

	    var P = Vec2_1.mul(impulse, this.m_ay); // Vec2
	    var LA = impulse * this.m_sAy; // float
	    var LB = impulse * this.m_sBy; // float

	    vA.subMul(mA, P);
	    wA -= iA * LA;

	    vB.addMul(mB, P);
	    wB += iB * LB;
	  }

	  this.m_bodyA.c_velocity.v.set(vA);
	  this.m_bodyA.c_velocity.w = wA;
	  this.m_bodyB.c_velocity.v.set(vB);
	  this.m_bodyB.c_velocity.w = wB;
	};

	WheelJoint.prototype.solvePositionConstraints = function(step) {
	  var cA = this.m_bodyA.c_position.c;
	  var aA = this.m_bodyA.c_position.a;
	  var cB = this.m_bodyB.c_position.c;
	  var aB = this.m_bodyB.c_position.a;

	  var qA = Rot_1.neo(aA);
	  var qB = Rot_1.neo(aB);

	  var rA = Rot_1.mulVec2(qA, Vec2_1.sub(this.m_localAnchorA, this.m_localCenterA));
	  var rB = Rot_1.mulVec2(qB, Vec2_1.sub(this.m_localAnchorB, this.m_localCenterB));
	  var d = Vec2_1.zero();
	  d.addCombine(1, cB, 1, rB);
	  d.subCombine(1, cA, 1, rA);

	  var ay = Rot_1.mulVec2(qA, this.m_localYAxisA);

	  var sAy = Vec2_1.cross(Vec2_1.add(d, rA), ay); // float
	  var sBy = Vec2_1.cross(rB, ay); // float

	  var C = Vec2_1.dot(d, ay); // float

	  var k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy
	      * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy; // float

	  var impulse; // float
	  if (k != 0.0) {
	    impulse = -C / k;
	  } else {
	    impulse = 0.0;
	  }

	  var P = Vec2_1.mul(impulse, ay); // Vec2
	  var LA = impulse * sAy; // float
	  var LB = impulse * sBy; // float

	  cA.subMul(this.m_invMassA, P);
	  aA -= this.m_invIA * LA;
	  cB.addMul(this.m_invMassB, P);
	  aB += this.m_invIB * LB;

	  this.m_bodyA.c_position.c.set(cA);
	  this.m_bodyA.c_position.a = aA;
	  this.m_bodyB.c_position.c.set(cB);
	  this.m_bodyB.c_position.a = aB;

	  return _Math.abs(C) <= Settings_1.linearSlop;
	};

	var lib = createCommonjsModule(function (module, exports) {
	exports.internal = {};

	exports.Serializer = serializer_1;

	exports.Math = _Math;
	exports.Vec2 = Vec2_1;
	exports.Vec3 = Vec3_1;
	exports.Mat22 = Mat22_1;
	exports.Mat33 = Mat33_1;
	exports.Transform = Transform_1;
	exports.Rot = Rot_1;

	exports.AABB = AABB_1;

	exports.Shape = Shape_1;
	exports.Fixture = Fixture_1;
	exports.Body = Body_1;
	exports.Contact = Contact_1;
	exports.Joint = Joint_1;
	exports.World = World_1;

	exports.Circle = CircleShape_1;
	exports.Edge = EdgeShape_1;
	exports.Polygon = PolygonShape_1;
	exports.Chain = ChainShape_1;
	exports.Box = BoxShape_1;



	exports.internal.CollidePolygons = CollidePolygon;



	exports.DistanceJoint = DistanceJoint_1;
	exports.FrictionJoint = FrictionJoint_1;
	exports.GearJoint = GearJoint_1;
	exports.MotorJoint = MotorJoint_1;
	exports.MouseJoint = MouseJoint_1;
	exports.PrismaticJoint = PrismaticJoint_1;
	exports.PulleyJoint = PulleyJoint_1;
	exports.RevoluteJoint = RevoluteJoint_1;
	exports.RopeJoint = RopeJoint_1;
	exports.WeldJoint = WeldJoint_1;
	exports.WheelJoint = WheelJoint_1;

	exports.internal.Sweep = Sweep_1;
	exports.internal.stats = stats;
	exports.internal.Manifold = Manifold_1;
	exports.internal.Distance = Distance_1;
	exports.internal.TimeOfImpact = TimeOfImpact_1;
	exports.internal.DynamicTree = DynamicTree_1;
	exports.internal.Settings = Settings_1;
	});

	// conversion from pixel to meter (1px = 1cm)
	// between rendering engine (p5.js) & physical engine (planck.js)
	const constants = {
	  PX2M: 0.01,
	  THICKNESS: 10,
	};

	const { THICKNESS, PX2M } = constants;

	class Walls {
	  constructor(p, world, canvas) {
	    this.p = p;

	    // add four wall bodies (reference: center of rectangle)
	    const positionTop = lib.Vec2(
	      PX2M * (canvas.width / 2),
	      PX2M * (THICKNESS / 2),
	    );
	    this.wallTop = world.createBody({
	      type: 'static',
	    });
	    this.wallTop.createFixture(
	      lib.Box(
	        PX2M * (canvas.width / 2),
	        PX2M * (THICKNESS / 2),
	        positionTop,
	      ),
	      {
	        density: 1.0,
	        friction: 0.0,
	        userData: 'wall-top',
	      },
	    );

	    const positionBottomLeft = lib.Vec2(
	      PX2M * (canvas.width / 6),
	      PX2M * ((canvas.height + (2 / 3) * canvas.height) / 2),
	    );
	    this.wallBottomLeft = world.createBody({
	      type: 'static',
	    });
	    this.wallBottomLeft.createFixture(
	      lib.Box(
	        PX2M * ((canvas.width / 6) / Math.cos(Math.PI / 4)),
	        PX2M * (THICKNESS / 2),
	        positionBottomLeft,
	        Math.PI / 4,
	      ),
	      {
	        density: 1.0,
	        friction: 0.0,
	        userData: 'wall-bottom-left',
	      },
	    );

	    const positionBottomRight = lib.Vec2(
	      PX2M * ((5 / 6) * canvas.width),
	      PX2M * ((canvas.height + (2 / 3) * canvas.height) / 2),
	    );
	    this.wallBottomRight = world.createBody({
	      type: 'static',
	    });
	    this.wallBottomRight.createFixture(
	      lib.Box(
	        PX2M * ((canvas.width / 6) / Math.cos(-Math.PI / 4)),
	        PX2M * (THICKNESS / 2),
	        positionBottomRight,
	        -Math.PI / 4,
	      ),
	      {
	        density: 1.0,
	        friction: 0.0,
	        userData: 'wall-bottom-right',
	      },
	    );

	    const positionLeft = lib.Vec2(
	      PX2M * (THICKNESS / 2),
	      PX2M * (canvas.height / 3),
	    );
	    this.wallLeft = world.createBody({
	      type: 'static',
	    });
	    this.wallLeft.createFixture(
	      lib.Box(
	        PX2M * (THICKNESS / 2),
	        PX2M * (canvas.height / 3),
	        positionLeft,
	      ),
	      {
	        density: 1.0,
	        friction: 0.0,
	        userData: 'wall-left',
	      },
	    );

	    const positionRight = lib.Vec2(
	      PX2M * (canvas.width - THICKNESS / 2),
	      PX2M * (canvas.height / 3),
	    );
	    this.wallRight = world.createBody({
	      type: 'static',
	    });
	    this.wallRight.createFixture(
	      lib.Box(
	        PX2M * (THICKNESS / 2),
	        PX2M * (canvas.height / 3),
	        positionRight,
	      ),
	      {
	        density: 1.0,
	        friction: 0.0,
	        userData: 'wall-right',
	      },
	    );
	  }

	  draw() {
	    // rectangles at positions of physical walls
	    [
	      this.wallTop,
	      this.wallBottomLeft,
	      this.wallBottomRight,
	      this.wallLeft,
	      this.wallRight,
	    ].forEach((wall, iWall) => {
	      const fixtures = wall.getFixtureList();
	      const [body, shape] = [fixtures.getBody(), fixtures.getShape()];
	      const centroid = {
	        x: (1 / PX2M) * shape.m_centroid.x,
	        y: (1 / PX2M) * shape.m_centroid.y,
	      };
	      const vertices = shape.m_vertices.map((vertex) => ({
	        x: (1 / PX2M) * vertex.x - centroid.x,
	        y: (1 / PX2M) * vertex.y - centroid.y,
	      }));

	      // convert back from meter to pixels
	      this.p.push();
	      this.p.translate(centroid.x, centroid.y);
	      this.p.rotate(body.getAngle());
	      this.p.beginShape();
	      this.p.vertex(vertices[0].x, vertices[0].y);
	      this.p.vertex(vertices[1].x, vertices[1].y);
	      this.p.vertex(vertices[2].x, vertices[2].y);
	      this.p.vertex(vertices[3].x, vertices[3].y);
	      this.p.endShape(this.p.CLOSE);
	      this.p.pop();
	    });
	  }
	}

	const { PX2M: PX2M$1 } = constants;
	const SPEED_MAX = 3.0;

	class Ball {
	  constructor(p, world, x, y) {
	    this.p = p;
	    this.r = 5;

	    // bouncing circle body
	    this.body = world.createDynamicBody({
	      position: lib.Vec2(PX2M$1 * x, PX2M$1 * y),
	      bullet: true,
	    });
	    this.body.createFixture(
	      lib.Circle(PX2M$1 * this.r),
	      {
	        density: 1.0,
	        restitution: 0.1,
	        userData: 'ball',
	      },
	    );
	  }

	  draw() {
	    // convert back from meter to pixels
	    const positionMeter = this.body.getPosition();
	    const positionPixel = {
	      x: (1 / PX2M$1) * positionMeter.x,
	      y: (1 / PX2M$1) * positionMeter.y,
	    };

	    // circle at position of body
	    this.p.push();
	    this.p.fill('#f00');
	    this.p.circle(positionPixel.x, positionPixel.y, this.r * 2);
	    this.p.pop();
	  }

	  limitSpeed() {
	    // limit ball speed when hitting bumper
	    const speedCurrent = this.body.getLinearVelocity();
	    const speedClamped = lib.Vec2(
	      Math.max(Math.min(speedCurrent.x, SPEED_MAX), -SPEED_MAX),
	      Math.max(Math.min(speedCurrent.y, SPEED_MAX), -SPEED_MAX),
	    );

	    this.body.setLinearVelocity(speedClamped);
	  }
	}

	const { THICKNESS: THICKNESS$1, PX2M: PX2M$2 } = constants;

	class Flipper {
	  constructor(p, world, wallLeft, wallRight, canvas) {
	    this.p = p;
	    this.w = canvas.width / 6 - THICKNESS$1;
	    this.h = THICKNESS$1;

	    this.xLeft = canvas.width / 2 - this.w / 2 - THICKNESS$1;
	    this.yLeft = canvas.height - this.h / 2;
	    this.xRight = canvas.width / 2 + this.w / 2 + THICKNESS$1;
	    this.yRight = canvas.height - this.h / 2;

	    // rectangular body for left-flipper
	    this.bodyLeft = world.createDynamicBody();
	    this.bodyLeft.createFixture(
	      lib.Box(
	        PX2M$2 * (this.w / 2),
	        PX2M$2 * (this.h / 2),
	        lib.Vec2(PX2M$2 * this.xLeft, PX2M$2 * this.yLeft),
	      ),
	      {
	        density: 1.0,
	        userData: 'flipper-left',
	      },
	    );

	    // rectangular body for right-flipper
	    this.bodyRight = world.createDynamicBody();
	    this.bodyRight.createFixture(
	      lib.Box(
	        PX2M$2 * (this.w / 2),
	        PX2M$2 * (this.h / 2),
	        lib.Vec2(PX2M$2 * this.xRight, PX2M$2 * this.yRight),
	      ),
	      {
	        density: 1.0,
	        userData: 'flipper-right',
	      },
	    );

	    // hinge joint at end of left-flipper
	    const optionsLeft = {
	      enableMotor: true,
	      motorSpeed: 0.0,
	      maxMotorTorque: 10,
	      enableLimit: true,
	      lowerAngle: -20 * (Math.PI / 180.0),
	      upperAngle: 5 * (Math.PI / 180.0),
	    };
	    this.centerRotationLeft = lib.Vec2(
	      PX2M$2 * (this.xLeft - this.w / 2),
	      PX2M$2 * this.yLeft,
	    );
	    this.jointLeft = lib.RevoluteJoint(optionsLeft, wallLeft, this.bodyLeft,
	      this.centerRotationLeft);
	    world.createJoint(this.jointLeft);

	    // hinge joint at end of right-flipper
	    const optionsRight = {
	      enableMotor: true,
	      motorSpeed: 0.0,
	      maxMotorTorque: 10,
	      enableLimit: true,
	      lowerAngle: -5 * (Math.PI / 180.0),
	      upperAngle: 20 * (Math.PI / 180.0),
	    };
	    this.centerRotationRight = lib.Vec2(
	      PX2M$2 * (this.xRight + this.w / 2),
	      PX2M$2 * this.yRight,
	    );
	    this.jointRight = lib.RevoluteJoint(optionsRight, wallRight, this.bodyRight,
	      this.centerRotationRight);
	    world.createJoint(this.jointRight);
	  }

	  draw() {
	    // rectangles at positions & angles of bodies (convert meters to pixels)
	    this.p.push();
	    this.p.fill('#00f');
	    this.p.translate(
	      (1 / PX2M$2) * this.centerRotationLeft.x,
	      (1 / PX2M$2) * this.centerRotationLeft.y,
	    );
	    this.p.rotate(this.bodyLeft.getAngle());
	    this.p.rect(this.w / 2, 0, this.w, this.h);
	    this.p.pop();

	    this.p.push();
	    this.p.fill('#00f');
	    this.p.translate(
	      (1 / PX2M$2) * this.centerRotationRight.x,
	      (1 / PX2M$2) * this.centerRotationRight.y,
	    );
	    this.p.rotate(this.bodyRight.getAngle());
	    this.p.rect(-this.w / 2, 0, this.w, this.h);
	    this.p.pop();
	  }

	  rotateLeft() {
	    // sets motor speed in radians/second
	    this.jointLeft.setMotorSpeed(-20.0);
	  }

	  resetLeft() {
	    // reset angle on arrow keys release
	    this.jointLeft.setMotorSpeed(20.0);
	  }

	  rotateRight() {
	    this.jointRight.setMotorSpeed(20.0);
	  }

	  resetRight() {
	    this.jointRight.setMotorSpeed(-20.0);
	  }
	}

	const { PX2M: PX2M$3 } = constants;

	class Bumper {
	  constructor(p, world, x, y, label) {
	    this.p = p;
	    this.x = x;
	    this.y = y;
	    this.r = 25;
	    this.color = '#0f0';

	    // static bumper (resitution makes ball bounce)
	    this.body = world.createBody({
	      type: 'static',
	      position: lib.Vec2(PX2M$3 * x, PX2M$3 * y),
	    });
	    this.body.createFixture(
	      lib.Circle(PX2M$3 * this.r),
	      {
	        density: 1.0,
	        friction: 0.0,
	        userData: label,
	        restitution: 1.0,
	      },
	    );
	  }

	  draw() {
	    // convert back from meter to pixels
	    const positionMeter = this.body.getPosition();
	    const positionPixel = {
	      x: (1 / PX2M$3) * positionMeter.x,
	      y: (1 / PX2M$3) * positionMeter.y,
	    };

	    // circle at position of body
	    this.p.push();
	    this.p.fill(this.color);
	    this.p.circle(positionPixel.x, positionPixel.y, this.r * 2);
	    this.p.pop();
	  }

	  collide() {
	    // change bumper color when hit by ball
	    this.color = '#f00';
	  }
	}

	// https://itnext.io/modular-game-worlds-in-phaser-3-tilemaps-4-meet-matter-js-abf4dfa65ca1

	const FPS = 60;
	const canvas = {
	  width: 480,
	  height: 480,
	};

	let world = null;
	let [ball, walls, flipper] = [null, null, null];
	let bumpers = [];

	let score = 0;
	let elementScore = null;
	let isPaused = false;

	// p5 in instance mode using closures
	const sketch = (p) => {
	  p.setup = () => {
	    // draw rect bodies from center
	    p.createCanvas(canvas.width, canvas.height + 20);
	    p.rectMode(p.CENTER);
	    p.angleMode(p.RADIANS);
	    p.frameRate(FPS);

	    // score html element below canvas
	    elementScore = p.createDiv('<b>Score:</b> 0');

	    // set gravity
	    world = new lib.World({
	      gravity: lib.Vec2(0, 10),
	    });

	    // four boundary walls bodies
	    walls = new Walls(p, world, canvas);
	    flipper = new Flipper(p, world, walls.wallBottomLeft, walls.wallBottomRight, canvas);
	    ball = new Ball(p, world, 200, 10);

	    // top & bottom rows of bumers
	    bumpers = [
	      // top row
	      new Bumper(p, world, 100, 100, 'bumper-0'),
	      new Bumper(p, world, 240, 100, 'bumper-1'),
	      new Bumper(p, world, 380, 100, 'bumper-2'),

	      new Bumper(p, world, 170, 180, 'bumper-3'),
	      new Bumper(p, world, 310, 180, 'bumper-4'),
	    ];

	    // collision between ball and bumpers
	    world.on('post-solve', (contact) => {
	      const [fixtureA, fixtureB] = [contact.getFixtureA(), contact.getFixtureB()];
	      const [labelA, labelB] = [fixtureA.getUserData(), fixtureB.getUserData()];
	      const fixtureBall = (labelA === 'ball' && fixtureA) || (labelB === 'ball' && fixtureB);
	      const fixtureBumper = (labelA.startsWith('bumper') && fixtureA) || (labelB.startsWith('bumper') && fixtureB);

	      if (fixtureBall && fixtureBumper) {
	        const labelBumper = fixtureBumper.getUserData();
	        const iBumper = labelBumper.slice(7);
	        const bumper = bumpers[p.int(iBumper)];

	        // flash bumpers color on collision & update score
	        bumper.color = '#f00';
	        setTimeout(() => {
	          bumper.color = '#0f0';

	          score += 1;
	          elementScore.html(`<b>Score:</b> ${score}`);
	        }, 100);

	        // limit ball speed
	        ball.limitSpeed();
	      }
	    });
	  };

	  p.draw = () => {
	    if (isPaused) {
	      return;
	    }

	    // run physical engine
	    world.step(1 / FPS);

	    // draw characters on canvas
	    p.background('#000');
	    walls.draw();
	    flipper.draw();
	    ball.draw();

	    // bumpers
	    bumpers.forEach((bumper) => {
	      bumper.draw();
	    });

	    // rotate flippers with arrow keys (key press below needs multiple presses)
	    if (p.keyIsDown(p.LEFT_ARROW)) {
	      flipper.rotateLeft();
	    } else {
	      flipper.resetLeft();
	    }

	    if (p.keyIsDown(p.RIGHT_ARROW)) {
	      flipper.rotateRight();
	    } else {
	      flipper.resetRight();
	    }
	  };

	  p.keyPressed = () => {
	    // pause game
	    switch (p.keyCode) {
	      case p.ENTER:
	        isPaused = !isPaused;
	        break;
	    }
	  };
	};

	const myp5 = new p5(sketch);

}());
